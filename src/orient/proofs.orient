Proofs:
  ProofOfReplication:
    Graph:
      declare(node_size, integer)
      declare(sector_size, integer)
      declare(nodes, integer)
      nodes = sector_size / node_size
      degree = degree_base + degree_expander
      sector_size_gib = sector_size / gib

      DRG (DRSample) [DRGAssumption]:
        declare(degree_base, integer)
        drg_e = 0.80
        drg_d = 1/4

      ExpanderParents (Chung) [ChungAssumption]:
        declare(degree_expander, integer)

      Layers:
        // declare(layers, integer)
        assume(layers > 0)

    Soundness:
      declare(lambda, integer)
      assume(soundness > 0)
      assume(soundness < 0.5)
      soundness = 1/(2^lambda)

    SpaceGap:
      assume(spacegap > 0)
      assume(spacegap < 0.5)

    Challenges:
      OfflineChallenges:
        // declare(offline_challenges, integer)
        declare(offline_challenges_all, integer)
        assume(offline_challenges > 0)

      OnlineChallenges:
        // declare(online_challenges, integer)
        assume(online_challenges > 0)

    Seal:
      Encoding [KDFTiming]:
        assume(kdf_content > 0)
        assume(encoding_time > 0)
        assume(polling_time > 0)
        kdf_content = degree + 1
        encoding_time = layers * nodes * (kdf_content - 1) * kdf_hash_time * (node_size / kdf_hash_size)
        encoding_time_mins = encoding_time / 60
        malicious_encoding = encoding_time / encoding_amax
        polling_time = malicious_encoding * drg_d

    Commitment (ColumnCommitments) [CRH]:
      commit_size = cid_size
      assume(replica_commit_time > 0)
      replica_commit_time = commit_time * 3 + leaf_time * nodes
      seal_commitments_size = commit_size * 2 // 1 commD, 1 CommR

    ProofGeneration (ColumnCommitments):
      assume(opening_time > 0)
      openings = offline_challenges * opening_per_challenge

      Leaf:
        leaf_constraints =  layers * leaf_hash_constraints
        leaf_circuit_time = layers * leaf_hash_circuit_time
        leaf_time = layers * leaf_hash_time

      Inclusion (MerkleVC) [CRH]:
        // declare(tree_depth, integer)
        tree_depth = (log2(nodes))
        inclusion_circuit_time = tree_depth * merkle_hash_time_circuit
        inclusion_constraints = tree_depth * merkle_hash_constraints
        commit_time = nodes * merkle_hash_time

      SNARK [SNARKAssumptions]:
        comm_d_openings = 1
        comm_d_time = offline_challenges * (comm_d_openings * inclusion_circuit_time)
        comm_d_constraints = offline_challenges * (comm_d_openings * inclusion_constraints)

        comm_r_openings = degree_base
        comm_r_time = offline_challenges * (comm_r_openings * inclusion_circuit_time)
        comm_r_constraints = offline_challenges * (comm_r_openings * inclusion_constraints)

        comm_c_openings = opening_per_challenge
        comm_c_time = offline_challenges * (comm_c_openings * (inclusion_circuit_time + leaf_circuit_time))
        comm_c_constraints = offline_challenges * (comm_c_openings * (inclusion_constraints + leaf_constraints))

        porep_snark_time = comm_d_time + comm_r_time + comm_c_time
        porep_snark_constraints = comm_d_constraints + comm_r_constraints + comm_c_constraints

        porep_snark_partitions = porep_snark_constraints / snark_max_constraints
        porep_snark_proof_size = porep_snark_partitions * snark_single_proof_size

        proofgen_time = porep_snark_time

    Size:
      seal_proof_size = porep_snark_proof_size + seal_commitments_size

    Time:
      seal_time = replica_commit_time + proofgen_time + encoding_time
      parallel_seal_time = (porep_snark_time + commit_time)/cores + encoding_time
      declare(unseal_time) // TODO

    Cost:
      seal_cost = seal_time * (cpu_cost_per_second + memory_cost_per_second)
      declare(unseal_cost) // TODO

  ProofOfReplication (SDR):
    Graph:
      Layers:
        layers = layers_b // TODO max(layers_a, layers_b) + 1
        layers_a = (0.68 - epsilon + delta) / (0.12 - delta)
        layers_b = (log2(1 / (3 * (epsilon - 2 * delta)))) + 0.12 / (0.12 - delta) + 1

    SpaceGap:
      assume(epsilon <= 0.24)
      delta <= epsilon/2
      spacegap = epsilon + 2 * delta

    Challenges:
      OfflineChallenges:
        offline_challenges = (- lambda) / (log2(1 - delta))

      OnlineChallenges:
        online_challenges = (- lambda) / (log2(2 - epsilon - 2 * delta) - 1)

    ProofGeneration (ColumnCommitments):
      opening_per_challenge = degree_base + degree_expander + 1

  ProofOfSpacetime:
    Randomness [RandomBeacon]:
      declare(post_randomness_lookback)

    Parameters:
      declare(proving_period_time)
      declare(max_proving_sectors)

  ProofOfSpacetime (RationalPoSt):
    Parameters:
      post_challenges = online_challenges

    Cost:
      declare(post_proving_cost)

    SNARK:
      post_snark_circuit = online_challenges * inclusion_constraints

    Size:
      post_proof_size = post_snark_proof_size
      post_snark_proof_partitions = 1 // TODO post_snark_circuit / snark_max_constraints
      post_snark_proof_size = post_snark_proof_partitions * snark_single_proof_size
