Assumptions:
  CID [CRH]:
    declare(cid_size, bytes)
    cid_size = 32 + 1 + 1 + 1

  SLE [VRF]:
    declare(vrf_proof_size) // TODO

Primitives:
  declare(var_int, bytes)
  varint = 4
  u64 = 8
  Dimensions:
    Size:
      kib = 1024
      mib = 1024 * kib
      gib = 1024 * mib
      tib = 1024 * gib
      pib = 1024 * tib
      eix = 1024 * pib
    Time:
      year_in_seconds = 365.25 * 24 * 60 * 60

VDFRSA:
  declare(rsa_element, bytes)
  rsa_element = (2048/8)

Blockchain:
  declare(block_time, seconds)
  Address:
    address_size = cid_size

  Block:
    block_framing_size = block_header_size + messages_size + receipts_size

    Messages:
      declare(messages, integer) // TODO
      messages_size = messages * message_size
      messages_root_cid = cid_size

      Message:
        message_size = to_address + from_address + message_nonce + value + gas_price + gas_limit + actor_method
        to_address = address_size
        from_address = address_size

        Nonce:
          declare(message_nonce, bytes) // TODO
          message_nonce = varint

        Value:
          declare(value, bytes)
          value = u64

        Gas:
          declare(gas_price, bytes)
          gas_price = u64
          declare(gas_limit, bytes)
          gas_limit = u64

        ActorMethod:
          declare(actor_method, bytes) // TODO: actor_method what is it? how big is it?
          actor_method = u64

    Receipts:
      declare(receipts, integer) // TODO
      receipts_size = receipts * message_receipt
      message_receipts_cid = cid_size

      Receipt:
        message_receipt = exit_code + return + gas_used
        declare(exit_code, bytes) // TODO
        exit_code = varint
        declare(return, bytes) // TODO
        return = varint
        declare(gas_used, bytes) // TODO
        gas_used = u64

    BlockHeader (EC):
      declare(block_header_size, bytes)
      assume(block_header_size > 0)
      assume(block_header_size < 1024*1024*10) // assume max is 10MB

      block_header_size = block_header_fixed_size + block_header_variable_size
      block_header_fixed_size = miner_address_size + election_proof_size + parent_weight_size + block_height_size + state_root_cid + messages_root_cid + bls_agg_size + message_receipts_cid + timestamp_size + block_sig_size
      block_header_variable_size = tickets_size + parents_cids

      StateTree:
        state_root_cid = cid_size

      Weight:
        declare(parent_weight_size, bytes) // TODO
        parent_weight_size = u64

      Height:
        declare(block_height_size, bytes) // TODO
        block_height_size = u64

      MinerAddress [CID]:
        miner_address_size = address_size

      ElectionProof (VRFBls) [SLE, BLSSig]:
        declare(election_proof_size, bytes) // TODO
        election_proof_size = 64

      // ElectionProof (VRFSecpk) [SLE, Secpk]:
      //   declare(election_proof_size, bytes) // TODO
      //   election_proof_size = 80

      Parents [CID]:
        declare(parents, integer) // TODO
        parents = expected_winning_miners
        parents_cids = parents * cid_size

      BLSSignatures (BLSSigAgg) [BLSSigAgg]:
        declare(bls_agg_size, bytes) // TODO
        bls_agg_size = 96

      Timestamp:
        declare(timestamp_size, integer) // TODO
        timestamp_size = u64

      // BlockSig (BlockSigSecpk):
        declare(block_sig_size, integer) // TODO
      //    block_sig_size = 80

      BlockSig (BlockSigBls):
        declare(block_sig_size, integer) // TODO
        block_sig_size = 96

      Tickets:
        declare(tickets, integer)
        declare(tickets_size, bytes)
        tickets_size = ticket_size * tickets
        ticket_size = election_proof_size + vdf_proof_size + vdf_output_size

SNARK [SNARKAssumptions]:
  declare(snark_single_proof_size, bytes)
  snark_single_proof_size = 192
  snark_max_constraints = 100000000

// VDF (VDFStorageBased):
//   vdf_proof_size = (vdf_snark_circuit / snark_max_constraints) * snark_single_proof_size
//   vdf_output_size = hash_size

VDF (VDFRSA):
  vdf_proof_size = 3 * rsa_element
  vdf_output_size = 0

:proofs.orient

  Consensus [ProofOfReplication, ProofOfSpacetime]:
    declare(expected_winning_miners, integer)
    declare(finality_height, integer)
    Tickets:
      tickets = avg_tickets
      avg_tickets = 1
      min_tickets = 0
      max_tickets = log(one_block_in_ten_years)/log(0.36) + 1 // 0.36^(max_tickets-1) = one_block_in_ten_years
      blocks_in_a_year = (year_in_seconds / block_time) * expected_winning_miners
      blocks_in_ten_years = blocks_in_a_year * 10
      one_block_in_ten_years = 1/blocks_in_ten_years

Mining:
  declare(power_table_lookback)
  declare(slashing_post_time)
  declare(reseal, integer)

  seals_per_sector_per_year = reseal+1
  posts_per_sector_per_year = year_in_seconds / proving_period_seconds
  OnChainFootprint:
    proving_period_seconds = proving_period_hours * 60 * 60
    seals_size_per_sector_per_year = seals_per_sector_per_year * seal_proof_size
    posts_size_per_sector_per_year = posts_per_sector_per_year * post_proof_size
    proofs_size_per_sector_per_year = seals_size_per_sector_per_year + posts_size_per_sector_per_year
    messages_per_sector_per_year = seals_per_sector_per_year + posts_per_sector_per_year
    // assert(proofs_messages_per_year * )

  StorageMarket:
    declare(min_storing_time)
    Deals (OnChainDeals):
      comm_p_size = cid_size
      declare(p_size, 1)
      p_size = (log2(sector_size))
      sector_manifest_size = pieces * comm_p_size + p_size
      max_sector_manifest_hashes = sector_size / min_piece_size


NetworkGoals:
  DataPropagation: // TODO some network assumptions here
    // block_time = ...
    // block_framing_size = ...
    declare(block_propagation_time)
    declare(block_delay)

ScalingRequirements:
  declare(max_storage_network_capacity_year)
  declare(seal_time)
  declare(unseal_time)
  declare(max_network_throughput_year)

  StorageCapacity:
    max_storage_network_capacity_year = 10 * eix
    max_sectors = max_storage_network_capacity_year / sector_size

    max_proofs_size_per_year = proofs_size_per_sector_per_year * max_sectors
    max_proofs_messages_per_year = messages_per_sector_per_year * max_sectors

    proofs_size_per_block = max_proofs_size_per_year / blocks_in_a_year
    proofs_messages_per_block = max_proofs_messages_per_year / blocks_in_a_year

    block_size = block_framing_size + proofs_size_per_block
    messages = proofs_messages_per_block + tx_messages_per_block + actors_messages_per_block // TODO

    // TODO deal

EconomicsRequirements:
  declare(seal_cost)
  declare(unseal_cost)
  declare(year_mining_reward)
  declare(min_hardware_cost)
