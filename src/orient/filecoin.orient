Assumptions:
  CID [CRH]:
    declare(cid_size, bytes)
    cid_size = 32 + 1 + 1 + 1

  SLE [VRF]:
    declare(vrf_proof_size) // TODO

Primitives:
  declare(var_int, bytes)
  varint = 4
  u64 = 8
  Dimensions:
    Size:
      kib = 1024
      mib = 1024 * kib
      gib = 1024 * mib
      tib = 1024 * gib
      pib = 1024 * tib
      eix = 1024 * pib
    Time:
      year_in_seconds = 365.25 * 24 * 60 * 60

VDFRSA:
  declare(rsa_element, bytes)
  rsa_element = (2048/8)

:blockchain.orient

SNARK [SNARKAssumptions]:
  declare(snark_single_proof_size, bytes)
  snark_single_proof_size = 192
  snark_max_constraints = 100000000

// VDF (VDFStorageBased):
//   vdf_proof_size = (vdf_snark_circuit / snark_max_constraints) * snark_single_proof_size
//   vdf_output_size = hash_size

VDF (VDFRSA):
  vdf_proof_size = 3 * rsa_element
  vdf_output_size = 0

:proofs.orient

  Consensus [ProofOfReplication, ProofOfSpacetime]:
    declare(expected_winning_miners, integer)
    declare(finality_height, integer)
    Tickets:
      tickets = avg_tickets
      avg_tickets = 1
      min_tickets = 0
      max_tickets = log(one_block_in_ten_years)/log(0.36) + 1 // 0.36^(max_tickets-1) = one_block_in_ten_years
      blocks_in_a_year = (year_in_seconds / block_time) * expected_winning_miners
      blocks_in_ten_years = blocks_in_a_year * 10
      one_block_in_ten_years = 1/blocks_in_ten_years

Mining:
  declare(power_table_lookback)
  declare(slashing_post_time)
  declare(reseal, integer)

  seals_per_sector_per_year = reseal+1
  posts_per_sector_per_year = year_in_seconds / proving_period_seconds
  OnChainFootprint:
    proving_period_seconds = proving_period_hours * 60 * 60
    seals_size_per_sector_per_year = seals_per_sector_per_year * seal_proof_size
    posts_size_per_sector_per_year = posts_per_sector_per_year * post_proof_size
    proofs_size_per_sector_per_year = seals_size_per_sector_per_year + posts_size_per_sector_per_year
    messages_per_sector_per_year = seals_per_sector_per_year + posts_per_sector_per_year
    // assert(proofs_messages_per_year * )

  StorageMarket:
    declare(min_storing_time)
    Deals (OnChainDeals):
      comm_p_size = cid_size
      declare(p_size, 1)
      p_size = (log2(sector_size))
      sector_manifest_size = pieces * comm_p_size + p_size
      max_sector_manifest_hashes = sector_size / min_piece_size


NetworkGoals:
  DataPropagation: // TODO some network assumptions here
    // block_time = ...
    // block_framing_size = ...
    declare(block_propagation_time)
    declare(block_delay)

ScalingRequirements:
  declare(max_storage_network_capacity_year)
  declare(seal_time)
  declare(unseal_time)
  declare(max_network_throughput_year)

  StorageCapacity:
    max_storage_network_capacity_year = 10 * eix
    max_sectors = max_storage_network_capacity_year / sector_size

    max_proofs_size_per_year = proofs_size_per_sector_per_year * max_sectors
    max_proofs_messages_per_year = messages_per_sector_per_year * max_sectors

    proofs_size_per_block = max_proofs_size_per_year / blocks_in_a_year
    proofs_messages_per_block = max_proofs_messages_per_year / blocks_in_a_year

    block_size = block_framing_size + proofs_size_per_block
    messages = proofs_messages_per_block + tx_messages_per_block + actors_messages_per_block // TODO

    // TODO deal

EconomicsRequirements:
  declare(seal_cost)
  declare(unseal_cost)
  declare(year_mining_reward)
  declare(min_hardware_cost)
