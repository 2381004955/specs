<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>filproofs - Filecoin Storage Proofs | Filecoin Spec</title>



<link rel="stylesheet" href="../../../../book.min.80d177ba9eeab42f747930aec886ccdf593ccbbd4ea5800f45db583ed39a4aed.css">
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=EB+Garamond" />


<link rel="icon" href="../../../../favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="../../../../docs/libraries/filcrypto/filproofs/index.xml" title="Filecoin Spec" />

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="./gumshoe.polyfills.min.js"></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../../../css/syntax.css">
<link href="../../../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../../../mermaid/mermaid.js"></script>
<script src="../../../../spec.js"></script>

</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href=""><span>Filecoin Spec</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2flibraries\2f filcrypto\2f filproofs\2f "] {
      color: #0b3a53;
  }
  </style>


  <div id="menu-toc">

  <div>
    
    <input id="menu-detail-slider" type="range" onchange="onMenuDetailChange();"
      min="1" value="3" max="5" step="1" />

    <span id="menu-detail-slider-label">3</span>
  </div>

  
  
  <ul class="menu-item-section depth-0">
  
      <li>
      
        











<a href="../../../../#intro" class="menu-item depth-1">
    
    
    <strong>
    
        Introduction
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="../../../../#intro__arch" class="menu-item depth-2">
    
    
        Architecture Diagrams
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#intro__concepts" class="menu-item depth-2">
    
    
        Key Concepts
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#intro__filecoin_vm" class="menu-item depth-2">
    
    
        Filecoin VM
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#intro__process" class="menu-item depth-2">
    
    
        Process
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#intro__process__about" class="menu-item depth-3">
    
    
        About
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#intro__process__fip" class="menu-item depth-3">
    
    
        FIPs
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#intro__process__contributing" class="menu-item depth-3">
    
    
        Contributing
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#intro__process__related_resources" class="menu-item depth-3">
    
    
        Related Resources
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#intro__process__related_resources__research_portal" class="menu-item depth-4">
    
    
        Research portal
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#intro__process__related_resources__network_tooling" class="menu-item depth-4">
    
    
        Network tooling
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#intro__process__related_resources__testing" class="menu-item depth-4">
    
    
        Testing and implementation compliance
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#intro__changelog" class="menu-item depth-2">
    
    
        Change Log
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#intro__system" class="menu-item depth-2">
    
    
        System Decomposition
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#intro__system__why_systems" class="menu-item depth-3">
    
    
        What are Systems?
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#intro__system__impl_systems" class="menu-item depth-3">
    
    
        Implementing Systems
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="../../../../#systems" class="menu-item depth-1">
    
    
    <strong>
    
        Systems
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes" class="menu-item depth-2">
    ⚙️
    
        <strong>Filecoin Nodes</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types" class="menu-item depth-3">
    
    
        Node Types
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types__node" class="menu-item depth-4">
    
    
        Node Interface
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types__node_types" class="menu-item depth-4">
    
    
        Examples
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types__verifier_node" class="menu-item depth-4">
    
    
        Chain Verifier Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types__client_node" class="menu-item depth-4">
    
    
        Client Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types__storage_miner_node" class="menu-item depth-4">
    
    
        Storage Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types__retrieval_miner_node" class="menu-item depth-4">
    
    
        Retrieval Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__node_types__relayer_node" class="menu-item depth-4">
    
    
        Relayer Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_nodes__repository" class="menu-item depth-3">
    
    
        Repository
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_nodes__repository__config" class="menu-item depth-4">
    
    
        Config
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__repository__key" class="menu-item depth-4">
    
    
        KeyStore &amp; user keys
    
</a>



<ul class="menu-item-section depth-4">

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_nodes__repository__ipldstore" class="menu-item depth-4">
    
    
        IpldStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__repository__usage" class="menu-item depth-4">
    
    
        Usage in Systems
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__network" class="menu-item depth-3">
    
    
        Network Interface
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__clock" class="menu-item depth-3">
    
    
        Clock
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_nodes__key_store" class="menu-item depth-3">
    
    
        Key Store
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_files" class="menu-item depth-2">
    📑
    
        <strong>Files &amp; Data</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="../../../../#systems__filecoin_files__file" class="menu-item depth-3">
    
    
        File
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_files__file__filestore" class="menu-item depth-4">
    
    
        FileStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_files__piece" class="menu-item depth-3">
    
    
        Piece
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_files__piece__piece_store" class="menu-item depth-4">
    
    
        PieceStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_files__data_transfer" class="menu-item depth-3">
    
    
        Data Transfer
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_vm" class="menu-item depth-2">
    💻
    
        <strong>Virtual Machine</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_vm__actor" class="menu-item depth-3">
    
    
        Actor
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_vm__actor__address" class="menu-item depth-4">
    
    
        Address
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_vm__state_tree" class="menu-item depth-3">
    
    
        State Tree
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_vm__message" class="menu-item depth-3">
    
    
        Message
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_vm__runtime" class="menu-item depth-3">
    
    
        Runtime
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_vm__runtime__exitcode" class="menu-item depth-4">
    
    
        Exit Codes
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_vm__runtime__gascost" class="menu-item depth-4">
    
    
        Gas Costs
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_vm__sysactors" class="menu-item depth-3">
    
    
        System Actors
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_vm__sysactors__init_actor" class="menu-item depth-4">
    
    
        InitActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_vm__sysactors__cron_actor" class="menu-item depth-4">
    
    
        CronActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_vm__sysactors__account_actor" class="menu-item depth-4">
    
    
        AccountActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_vm__sysactors__reward_actor" class="menu-item depth-4">
    
    
        RewardActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_vm__interpreter" class="menu-item depth-3">
    
    
        Interpreter
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain" class="menu-item depth-2">
    📦
    
        <strong>Blockchain</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__struct" class="menu-item depth-3">
    
    
        Blocks
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__struct__block" class="menu-item depth-4">
    
    
        Block
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__struct__tipset" class="menu-item depth-4">
    
    
        Tipset
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__struct__chain" class="menu-item depth-4">
    
    
        Chain
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__struct__chain_manager" class="menu-item depth-4">
    
    
        Chain Manager
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__struct__block_producer" class="menu-item depth-4">
    
    
        Block Producer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__message_pool" class="menu-item depth-3">
    
    
        Message Pool
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__message_pool__message_syncer" class="menu-item depth-4">
    
    
        Message Syncer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__message_pool__message_storage" class="menu-item depth-4">
    
    
        Message Storage
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_blockchain__chainsync" class="menu-item depth-3">
    
    
        ChainSync
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__storage_power_consensus" class="menu-item depth-3">
    
    
        Storage Power Consensus
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor" class="menu-item depth-4">
    
    
        Storage Power Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_token" class="menu-item depth-2">
    📀
    
        <strong>Token</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_token__wallets" class="menu-item depth-3">
    
    
        Wallet
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_token__payments" class="menu-item depth-3">
    
    
        Payments
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_token__payment_channels" class="menu-item depth-3">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_token__payment_channels__payment_channel_actor" class="menu-item depth-4">
    
    
        Payment Channel Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_token__multisig" class="menu-item depth-3">
    
    
        Multisig Wallet
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_token__multisig__multisig_actor" class="menu-item depth-4">
    
    
        Multisig Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_mining" class="menu-item depth-2">
    ⛏
    
        <strong>Storage Mining</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_mining__storage_mining" class="menu-item depth-3">
    
    
        Storage Miner
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__storage_mining__mining_cycle" class="menu-item depth-4">
    
    
        Storage Mining Cycle
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__storage_mining__storage_miner_actor" class="menu-item depth-4">
    
    
        Storage Miner Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__sector" class="menu-item depth-3">
    
    
        Sector
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__sector__sectorset" class="menu-item depth-4">
    
    
        Sector Set
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__sector__sealing" class="menu-item depth-4">
    
    
        Sector Sealing
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__sector_index" class="menu-item depth-3">
    
    
        Sector Index
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__sector_index__sector_builder" class="menu-item depth-4">
    
    
        Sector Builder
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__sector_index__sector_store" class="menu-item depth-4">
    
    
        SectorStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_mining__storage_proving" class="menu-item depth-3">
    
    
        Storage Proving
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_mining__storage_proving__sealer" class="menu-item depth-4">
    
    
        Sector Sealer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_mining__storage_proving__poster" class="menu-item depth-4">
    
    
        Sector Poster
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_markets" class="menu-item depth-2">
    ⚖️
    
        <strong>Market</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#systems__filecoin_markets__order" class="menu-item depth-3">
    
    
        Orders
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_markets__deal" class="menu-item depth-3">
    
    
        Deals
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_markets__storage_market" class="menu-item depth-3">
    
    
        Storage Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__storage_market__storage_market_actor" class="menu-item depth-4">
    
    
        Storage Market Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__storage_market__storage_provider" class="menu-item depth-4">
    
    
        Storage Provider
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__storage_market__storage_client" class="menu-item depth-4">
    
    
        Storage Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__storage_market__faults" class="menu-item depth-4">
    
    
        Faults
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#systems__filecoin_markets__retrieval_market" class="menu-item depth-3">
    
    
        Retrieval Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__retrieval_market__retrieval_peer_resolver" class="menu-item depth-4">
    
    
        Retrieval Peer Resolver
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__retrieval_market__retrieval_protocols" class="menu-item depth-4">
    
    
        Retrieval Protocols
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__retrieval_market__retrieval_client" class="menu-item depth-4">
    
    
        Retrieval Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#systems__filecoin_markets__retrieval_market__retrieval_provider" class="menu-item depth-4">
    
    
        Retrieval Provider (Miner)
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        










  


<a href="../../../../#libraries" class="menu-item depth-1">
    
    
    <strong>
    
        Libraries
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
    </li>

    <li>
    
      











<a href="../../../../#libraries__fcs" class="menu-item depth-2">
    
    
        FCS
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__ipld" class="menu-item depth-2">
    
    
        IPLD
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#libraries__ipld__cid" class="menu-item depth-3">
    
    
        CID
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#libraries__ipld__datamodel" class="menu-item depth-3">
    
    
        Data Model
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__ipld__selectors" class="menu-item depth-3">
    
    
        Selectors
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__ipld__graphstore" class="menu-item depth-3">
    
    
        GraphStore
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__libp2p" class="menu-item depth-2">
    
    
        libp2p
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="../../../../#libraries__libp2p__gossipsub" class="menu-item depth-3">
    
    
        gossipsub
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__libp2p__kad_dht" class="menu-item depth-3">
    
    
        kad-dht
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__libp2p__fil_libp2p_nodes" class="menu-item depth-3">
    
    
        fil-libp2p Nodes
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__ipfs" class="menu-item depth-2">
    
    
        IPFS
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="../../../../#libraries__ipfs__bitswap" class="menu-item depth-3">
    
    
        BitSwap
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#libraries__ipfs__graphsync" class="menu-item depth-3">
    
    
        GraphSync
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#libraries__ipfs__unixfs" class="menu-item depth-3">
    
    
        UnixFS
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="../../../../#libraries__multiformats" class="menu-item depth-2">
    
    
        Multiformats
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="../../../../#algorithms" class="menu-item depth-1">
    
    
    <strong>
    
        Algorithms
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="../../../../#algorithms__expected_consensus" class="menu-item depth-2">
    
    
        Expected Consensus
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__porep" class="menu-item depth-2">
    
    
        Proof-of-Replication
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="../../../../#algorithms__porep__stacked_drg" class="menu-item depth-3">
    
    
        Stacked DRG PoRep
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__porep__porep_commitments" class="menu-item depth-3">
    
    
        PoRep Commitments
    
</a>




    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__porep__stacked_drg_circuit" class="menu-item depth-3">
    
    
        
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__post" class="menu-item depth-2">
    
    
        Proof-of-Spacetime
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="../../../../#algorithms__post__election_post" class="menu-item depth-3">
    
    
        Election PoSt
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__post__proof_of_spacetime_parameters" class="menu-item depth-3">
    
    
        PoSt Parameters
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__payment_channels" class="menu-item depth-2">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__block_sync" class="menu-item depth-2">
    
    
        BlockSync
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__gossip_sub" class="menu-item depth-2">
    
    
        GossipSub
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#algorithms__crypto" class="menu-item depth-2">
    
    
        Cryptographic Primitives
    
</a>




    
    </li>

    <li>
    
      










  


<a href="../../../../#algorithms__cryptoecon" class="menu-item depth-2">
    
    
        Cryptoecon
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="../../../../#listings" class="menu-item depth-1">
    
    
    <strong>
    
        Listings
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="../../../../#listings__actors" class="menu-item depth-2">
    
    
        Filecoin VM Actors
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#listings__data_structures" class="menu-item depth-2">
    
    
        Data Structures
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#listings__system_map" class="menu-item depth-2">
    
    
        Components
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#listings__libp2p_protocols" class="menu-item depth-2">
    
    
        libp2p Protocols
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="../../../../#listings__libp2p_protocols__data_transfer_protocol" class="menu-item depth-3">
    
    
        Data Transfer Protocol
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="../../../../#glossary" class="menu-item depth-1">
    
    
    <strong>
    
        Glossary
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

</ul>


      
      </li>
  
      <li>
      
        











<a href="../../../../#appendix" class="menu-item depth-1">
    
    
    <strong>
    
        Appendix
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="../../../../#appendix__sharray" class="menu-item depth-2">
    
    
        Sharded IPLD Array
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#appendix__address" class="menu-item depth-2">
    
    
        Address
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="../../../../#appendix__orient" class="menu-item depth-2">
    
    
        Filecoin Parameters
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
  </ul>
  
</div>










</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>filproofs - Filecoin Storage Proofs</strong>
</header>

      
<article class="markdown">


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>

<span class="kd">type</span> <span class="nx">SectorInfo</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">SectorID</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">FilecoinProofsSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sealVerifyInfo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">sectorIndex</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>

<span class="kd">type</span> <span class="nx">WinStackedDRGLayers</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGNodeSize</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGNodes</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGWindowCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGPartitions</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGChallenges</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGWindowChallenges</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGLeafChallengeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGChallengeRangeSize</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">DRGDepth</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGFraction</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGDegree</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">DRGSeed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGNodeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphNodeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelKeys</span> <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelRounds</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelHashFunction</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">Blake2S</span>
    <span class="nx">SHA256</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">ChungExpanderAlpha</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ChungExpanderBeta</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphDegree</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphSeed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGNodeSize</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">SealAlgorithmArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">AlgorithmWideSetupArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// trusted setup output parameters go here
</span><span class="c1"></span>        <span class="c1">// updates to public parameters go here
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nx">SealSetupArtifacts</span>

    <span class="c1">// ProveArtifacts or
</span><span class="c1"></span>    <span class="nx">ChallengeArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// inputs into prove() go here
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nx">VerifyArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// inputs into verify() go here
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// per-sector setup artifacts go here
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealSetupArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CommD</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommR</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
    <span class="nx">CommC</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommQ</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommRLast</span>          <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommDTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommCTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommQTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommRLastTreePath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">Seed</span>               <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span>
    <span class="nx">KeyLayers</span>          <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
    <span class="nx">Replica</span>            <span class="nx">Bytes</span>  <span class="c1">// This is what we challenge in PoSt. It will be regenerated just in time. Should probably be removed from here.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">EllipticCurve</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">FieldModulus</span> <span class="o">&amp;</span><span class="nx">util</span><span class="p">.</span><span class="nx">BigInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">WinStackedDRG</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Layers</span>                  <span class="nx">WinStackedDRGLayers</span>
    <span class="nx">NodeSize</span>                <span class="nx">WinStackedDRGNodeSize</span>
    <span class="nx">Nodes</span>                   <span class="nx">WinStackedDRGNodes</span>
    <span class="nx">WindowCount</span>             <span class="nx">WinStackedDRGWindowCount</span>
    <span class="nx">Partitions</span>              <span class="nx">WinStackedDRGPartitions</span>
    <span class="nx">Challenges</span>              <span class="nx">WinStackedDRGChallenges</span>
    <span class="nx">WindowChallenges</span>        <span class="nx">WinStackedDRGWindowChallenges</span>
    <span class="nx">LeafChallengeCount</span>      <span class="nx">WinStackedDRGLeafChallengeCount</span>
    <span class="nx">ChallengeRangeSize</span>      <span class="nx">WinStackedDRGChallengeRangeSize</span>
    <span class="nx">Algorithm</span>               <span class="kd">struct</span> <span class="p">{}</span>
    <span class="nx">DRGCfg</span>
    <span class="nx">ExpanderGraphCfg</span>
    <span class="nx">WindowDRGCfg</span>            <span class="nx">DRGCfg</span>
    <span class="nx">WindowExpanderGraphCfg</span>  <span class="nx">ExpanderGraphCfg</span>
    <span class="c1">// invariant: DRGCfg.Nodes == ExpanderGraphCfg.Nodes
</span><span class="c1"></span>    <span class="nx">Curve</span>                   <span class="nx">EllipticCurve</span>
    <span class="nx">Cfg</span>                     <span class="nx">SDRCfg</span>

    <span class="nf">Drg</span><span class="p">()</span>                   <span class="nx">DRG</span>
    <span class="nf">Expander</span><span class="p">()</span>              <span class="nx">ExpanderGraph</span>

    <span class="nf">WindowDrg</span><span class="p">()</span>             <span class="nx">DRG</span>
    <span class="nf">WindowExpander</span><span class="p">()</span>        <span class="nx">ExpanderGraph</span>

    <span class="nf">Seal</span><span class="p">(</span>
        <span class="nx">sid</span>         <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
        <span class="nx">data</span>        <span class="nx">Bytes</span>
        <span class="nx">randomness</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span>
    <span class="p">)</span> <span class="nx">SealSetupArtifacts</span>
    <span class="nf">CreateSealProof</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
        <span class="nx">aux</span>            <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
    <span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span>
    <span class="nf">CreatePrivateSealProof</span><span class="p">(</span>
        <span class="nx">randomness</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
        <span class="nx">aux</span>         <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
    <span class="p">)</span> <span class="nx">PrivateOfflineProof</span>

    <span class="nf">CreateOfflineCircuitProof</span><span class="p">(</span>
        <span class="nx">challengeProofs</span>  <span class="p">[</span><span class="nx">OfflineWindowProof</span><span class="p">]</span>
        <span class="nx">aux</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
    <span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span>
    <span class="nf">VerifyPrivateSealProof</span><span class="p">(</span>
        <span class="nx">privateProof</span>  <span class="p">[</span><span class="nx">OfflineWindowProof</span><span class="p">]</span>
        <span class="nx">sealSeeds</span>     <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">]</span>
        <span class="nx">randomness</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
        <span class="nx">commD</span>         <span class="nx">Commitment</span>
        <span class="nx">commR</span>         <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
    <span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">GenerateElectionPoStCandidates</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">eligibleSectors</span>  <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span>
        <span class="nx">candidateCount</span>   <span class="kt">int</span>
        <span class="nx">sectorStore</span>      <span class="nx">sectorIndex</span><span class="p">.</span><span class="nx">SectorStore</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="nf">CreateElectionPoStProof</span><span class="p">(</span><span class="nx">privateProofs</span> <span class="p">[</span><span class="nx">PrivatePoStProof</span><span class="p">])</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span>
    <span class="nf">VerifyElectionPoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">GenerateSurprisePoStCandidates</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">eligibleSectors</span>  <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span>
        <span class="nx">candidateCount</span>   <span class="kt">int</span>
        <span class="nx">sectorStore</span>      <span class="nx">sectorIndex</span><span class="p">.</span><span class="nx">SectorStore</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="nf">CreateSurprisePoStProof</span><span class="p">(</span><span class="nx">privateProofs</span> <span class="p">[</span><span class="nx">PrivatePoStProof</span><span class="p">])</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span>
    <span class="nf">VerifySurprisePoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">CreatePrivatePoStProof</span><span class="p">(</span>
        <span class="nx">candidateProofs</span>  <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">]</span>
        <span class="nx">challengeSeed</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">aux</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span>
    <span class="p">)</span> <span class="nx">PrivatePoStProof</span>
    <span class="nf">VerifyPrivatePoStProof</span><span class="p">(</span>
        <span class="nx">privateProof</span>  <span class="nx">PrivatePoStProof</span>
        <span class="nx">candidates</span>    <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
        <span class="nx">commRLast</span>     <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SDRCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealCfg</span>          <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg</span>
    <span class="nx">ElectionPoStCfg</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCfg</span>
    <span class="nx">SurprisePoStCfg</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCfg</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DRGCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Depth</span>     <span class="nx">DRGDepth</span>  <span class="c1">// D
</span><span class="c1"></span>        <span class="nx">Fraction</span>  <span class="nx">DRGFraction</span>  <span class="c1">// E
</span><span class="c1"></span>
        <span class="nx">ParentsAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
            <span class="nx">DRSample</span>
        <span class="p">}</span>

        <span class="nx">RNGAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
            <span class="nx">ChaCha20</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">Degree</span> <span class="nx">DRGDegree</span>
    <span class="nx">Seed</span> <span class="nx">DRGSeed</span>
    <span class="nx">Nodes</span> <span class="nx">DRGNodeCount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DRG</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>         <span class="nx">DRGCfg</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">UInt</span><span class="p">)</span>  <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ExpanderGraphCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span> <span class="nx">union</span> <span class="p">{</span>
        <span class="nx">ChungExpanderAlgorithm</span>
    <span class="p">}</span>

    <span class="nx">Degree</span>  <span class="nx">ExpanderGraphDegree</span>
    <span class="nx">Seed</span>    <span class="nx">ExpanderGraphSeed</span>
    <span class="nx">Nodes</span>   <span class="nx">ExpanderGraphNodeCount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ExpanderGraph</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>         <span class="nx">ExpanderGraphCfg</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">UInt</span><span class="p">)</span>  <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ChungExpanderAlgorithm</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Alpha</span>  <span class="nx">ChungExpanderAlpha</span>
    <span class="nx">Beta</span>   <span class="nx">ChungExpanderBeta</span>
    <span class="nx">PermutationAlgorithm</span> <span class="nx">union</span> <span class="p">{</span>
        <span class="nx">Feistel</span>
    <span class="p">}</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Feistel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Keys</span>          <span class="nx">ChungExpanderPermutationFeistelKeys</span>
    <span class="nx">Rounds</span>        <span class="nx">ChungExpanderPermutationFeistelRounds</span>
    <span class="nx">HashFunction</span>  <span class="nx">ChungExpanderPermutationFeistelHashFunction</span>
    <span class="nf">Permute</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">n</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MerkleTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">InclusionProof</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="nx">index</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// TODO: Needs to be generic over hash.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">InclusionProof</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">()</span>       <span class="nx">Bytes</span>
    <span class="nf">LeafIndex</span><span class="p">()</span>  <span class="nx">UInt</span>
    <span class="nf">Root</span><span class="p">()</span>       <span class="nx">Commitment</span>
    <span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">filproofs</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>

	<span class="s">&#34;encoding/binary&#34;</span>
	<span class="nx">big</span> <span class="s">&#34;math/big&#34;</span>

	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

	<span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>

	<span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>

	<span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>

	<span class="nx">sector_index</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">SHA256Hash</span> <span class="nx">Bytes32</span>
<span class="kd">type</span> <span class="nx">PedersenHash</span> <span class="nx">Bytes32</span>
<span class="kd">type</span> <span class="nx">Bytes32</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="kd">type</span> <span class="nx">UInt</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">PieceInfo</span> <span class="p">=</span> <span class="o">*</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo_I</span>
<span class="kd">type</span> <span class="nx">Label</span> <span class="nx">Bytes32</span>
<span class="kd">type</span> <span class="nx">Commitment</span> <span class="p">=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>

<span class="kd">const</span> <span class="nx">WRAPPER_LAYER_WINDOW_INDEX</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="kd">func</span> <span class="nf">WinSDRParams</span><span class="p">(</span><span class="nx">cfg</span> <span class="nx">SDRCfg</span><span class="p">)</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span> <span class="p">{</span>
	<span class="c1">// TODO: Bridge constants with orient model.
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">LAYERS</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="kd">const</span> <span class="nx">NODE_SIZE</span> <span class="p">=</span> <span class="mi">32</span>
	<span class="kd">const</span> <span class="nx">OFFLINE_CHALLENGES</span> <span class="p">=</span> <span class="mi">6666</span>
	<span class="kd">const</span> <span class="nx">OFFLINE_WINDOW_CHALLENGES</span> <span class="p">=</span> <span class="mi">1111</span>
	<span class="kd">const</span> <span class="nx">POST_LEAF_CHALLENGE_COUNT</span> <span class="p">=</span> <span class="mi">66</span>
	<span class="kd">const</span> <span class="nx">POST_CHALLENGE_RANGE_SIZE</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="kd">const</span> <span class="nx">FEISTEL_ROUNDS</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="kd">var</span> <span class="nx">FEISTEL_KEYS</span> <span class="p">=</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="nx">UInt</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">FIELD_MODULUS</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="c1">// https://github.com/zkcrypto/pairing/blob/master/src/bls12_381/fr.rs#L4
</span><span class="c1"></span>	<span class="nx">FIELD_MODULUS</span><span class="p">.</span><span class="nf">SetString</span><span class="p">(</span><span class="s">&#34;52435875175126190479447740508185965837690552500527637822603658699938581184513&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">cfg</span><span class="p">.</span><span class="nf">SealCfg</span><span class="p">().</span><span class="nf">SectorSize</span><span class="p">()</span> <span class="o">/</span> <span class="nx">NODE_SIZE</span><span class="p">)</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">WinStackedDRG_I</span><span class="p">{</span>
		<span class="nx">Layers_</span><span class="p">:</span>             <span class="nf">WinStackedDRGLayers</span><span class="p">(</span><span class="nx">LAYERS</span><span class="p">),</span>
		<span class="nx">Challenges_</span><span class="p">:</span>         <span class="nf">WinStackedDRGChallenges</span><span class="p">(</span><span class="nx">OFFLINE_CHALLENGES</span><span class="p">),</span>
		<span class="nx">WindowChallenges_</span><span class="p">:</span>   <span class="nf">WinStackedDRGWindowChallenges</span><span class="p">(</span><span class="nx">OFFLINE_WINDOW_CHALLENGES</span><span class="p">),</span>
		<span class="nx">LeafChallengeCount_</span><span class="p">:</span> <span class="nf">WinStackedDRGLeafChallengeCount</span><span class="p">(</span><span class="nx">POST_LEAF_CHALLENGE_COUNT</span><span class="p">),</span>
		<span class="nx">ChallengeRangeSize_</span><span class="p">:</span> <span class="nf">WinStackedDRGChallengeRangeSize</span><span class="p">(</span><span class="nx">POST_CHALLENGE_RANGE_SIZE</span><span class="p">),</span>
		<span class="nx">NodeSize_</span><span class="p">:</span>           <span class="nf">WinStackedDRGNodeSize</span><span class="p">(</span><span class="nx">NODE_SIZE</span><span class="p">),</span>
		<span class="nx">Nodes_</span><span class="p">:</span>              <span class="nf">WinStackedDRGNodes</span><span class="p">(</span><span class="nx">nodes</span><span class="p">),</span>
		<span class="nx">Algorithm_</span><span class="p">:</span>          <span class="o">&amp;</span><span class="nx">WinStackedDRG_Algorithm_I</span><span class="p">{},</span>
		<span class="nx">DRGCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">DRGCfg_I</span><span class="p">{</span>
			<span class="nx">Algorithm_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">DRGCfg_Algorithm_I</span><span class="p">{</span>
				<span class="nx">ParentsAlgorithm_</span><span class="p">:</span> <span class="nx">DRGCfg_Algorithm_ParentsAlgorithm_DRSample</span><span class="p">,</span>
				<span class="nx">RNGAlgorithm_</span><span class="p">:</span>     <span class="nx">DRGCfg_Algorithm_RNGAlgorithm_ChaCha20</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="nx">Degree_</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
			<span class="nx">Nodes_</span><span class="p">:</span>  <span class="nf">DRGNodeCount</span><span class="p">(</span><span class="nx">nodes</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="nx">ExpanderGraphCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">ExpanderGraphCfg_I</span><span class="p">{</span>
			<span class="nx">Algorithm_</span><span class="p">:</span> <span class="nf">ExpanderGraphCfg_Algorithm_Make_ChungExpanderAlgorithm</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">{</span>
					<span class="nx">PermutationAlgorithm_</span><span class="p">:</span> <span class="nf">ChungExpanderAlgorithm_PermutationAlgorithm_Make_Feistel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Feistel_I</span><span class="p">{</span>
						<span class="nx">Keys_</span><span class="p">:</span>         <span class="nx">FEISTEL_KEYS</span><span class="p">[:],</span>
						<span class="nx">Rounds_</span><span class="p">:</span>       <span class="nx">FEISTEL_ROUNDS</span><span class="p">,</span>
						<span class="nx">HashFunction_</span><span class="p">:</span> <span class="nx">ChungExpanderPermutationFeistelHashFunction_SHA256</span><span class="p">,</span>
					<span class="p">}),</span>
				<span class="p">}),</span>
			<span class="nx">Degree_</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
			<span class="nx">Nodes_</span><span class="p">:</span>  <span class="nf">ExpanderGraphNodeCount</span><span class="p">(</span><span class="nx">nodes</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="nx">WindowDRGCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">DRGCfg_I</span><span class="p">{</span>
			<span class="nx">Algorithm_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">DRGCfg_Algorithm_I</span><span class="p">{</span>
				<span class="nx">ParentsAlgorithm_</span><span class="p">:</span> <span class="nx">DRGCfg_Algorithm_ParentsAlgorithm_DRSample</span><span class="p">,</span>
				<span class="nx">RNGAlgorithm_</span><span class="p">:</span>     <span class="nx">DRGCfg_Algorithm_RNGAlgorithm_ChaCha20</span><span class="p">,</span>
			<span class="p">},</span>
			<span class="nx">Degree_</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nx">Nodes_</span><span class="p">:</span>  <span class="nf">DRGNodeCount</span><span class="p">(</span><span class="nx">nodes</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="nx">WindowExpanderGraphCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">ExpanderGraphCfg_I</span><span class="p">{</span>
			<span class="nx">Algorithm_</span><span class="p">:</span> <span class="nf">ExpanderGraphCfg_Algorithm_Make_ChungExpanderAlgorithm</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">{</span>
					<span class="nx">PermutationAlgorithm_</span><span class="p">:</span> <span class="nf">ChungExpanderAlgorithm_PermutationAlgorithm_Make_Feistel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Feistel_I</span><span class="p">{</span>
						<span class="nx">Keys_</span><span class="p">:</span>         <span class="nx">FEISTEL_KEYS</span><span class="p">[:],</span>
						<span class="nx">Rounds_</span><span class="p">:</span>       <span class="nx">FEISTEL_ROUNDS</span><span class="p">,</span>
						<span class="nx">HashFunction_</span><span class="p">:</span> <span class="nx">ChungExpanderPermutationFeistelHashFunction_SHA256</span><span class="p">,</span>
					<span class="p">}),</span>
				<span class="p">}),</span>
			<span class="nx">Degree_</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
			<span class="nx">Nodes_</span><span class="p">:</span>  <span class="nf">ExpanderGraphNodeCount</span><span class="p">(</span><span class="nx">nodes</span><span class="p">),</span>
		<span class="p">},</span>

		<span class="nx">Curve_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">EllipticCurve_I</span><span class="p">{</span>
			<span class="nx">FieldModulus_</span><span class="p">:</span> <span class="o">*</span><span class="nx">FIELD_MODULUS</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="nx">Cfg_</span><span class="p">:</span> <span class="nx">cfg</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">Drg</span><span class="p">()</span> <span class="o">*</span><span class="nx">DRG_I</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">DRG_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">DRGCfg</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">Expander</span><span class="p">()</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ExpanderGraph_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">ExpanderGraphCfg</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">WindowDrg</span><span class="p">()</span> <span class="o">*</span><span class="nx">DRG_I</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">DRG_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowDRGCfg</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">WindowExpander</span><span class="p">()</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ExpanderGraph_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowExpanderGraphCfg</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">config</span> <span class="o">:=</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Config</span><span class="p">()</span>
	<span class="nx">degree</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nf">Degree</span><span class="p">())</span>
	<span class="k">return</span> <span class="nf">DRGAlgorithmComputeParents</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nf">Algorithm</span><span class="p">().</span><span class="nf">ParentsAlgorithm</span><span class="p">(),</span> <span class="nx">degree</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// TODO: Verify this. Both the port from impl and the algorithm.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DRGAlgorithmComputeParents</span><span class="p">(</span><span class="nx">alg</span> <span class="nx">DRGCfg_Algorithm_ParentsAlgorithm</span><span class="p">,</span> <span class="nx">degree</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">alg</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">DRGCfg_Algorithm_ParentsAlgorithm_DRSample</span><span class="p">:</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">node</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">node</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

		<span class="nx">m</span> <span class="o">:=</span> <span class="nx">degree</span> <span class="o">-</span> <span class="mi">1</span>

		<span class="kd">var</span> <span class="nx">k</span> <span class="nx">UInt</span>
		<span class="k">for</span> <span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">logi</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Log2</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">m</span><span class="p">))))</span>
			<span class="c1">// FIXME: Make RNG parameterizable and specify it.
</span><span class="c1"></span>			<span class="nx">j</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">logi</span><span class="p">)</span>
			<span class="nx">jj</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">node</span><span class="o">*</span><span class="nx">m</span><span class="o">+</span><span class="nx">k</span><span class="p">),</span> <span class="nb">float64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
			<span class="nx">backDist</span> <span class="o">:=</span> <span class="nf">randInRange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">jj</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			<span class="nx">out</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">node</span><span class="o">*</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">backDist</span><span class="p">)</span> <span class="o">/</span> <span class="nx">m</span>

			<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">parents</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;DRG algorithm not supported: %v&#34;</span><span class="p">,</span> <span class="nx">alg</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">randInRange</span><span class="p">(</span><span class="nx">lowInclusive</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">highExclusive</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="c1">// NOTE: current implementation uses a more sophisticated method for repeated sampling within a range.
</span><span class="c1"></span>	<span class="c1">// We need to converge on and fully specify the actual method, since this must be deterministic.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">highExclusive</span><span class="o">-</span><span class="nx">lowInclusive</span><span class="p">)</span> <span class="o">+</span> <span class="nx">lowInclusive</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">exp</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Degree</span><span class="p">()</span>

	<span class="c1">// TODO: How do we handle choice of algorithm generically?
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Algorithm</span><span class="p">().</span><span class="nf">As_ChungExpanderAlgorithm</span><span class="p">().</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Nodes</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chung</span> <span class="o">*</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="nx">UInt</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="nx">UInt</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">parent</span> <span class="o">:=</span> <span class="nx">chung</span><span class="p">.</span><span class="nf">_ithParent</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">)</span>
		<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">parents</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chung</span> <span class="o">*</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">)</span> <span class="nf">_ithParent</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">degree</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="c1">// ithParent generates one of d parents of node.
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">degree</span><span class="p">)</span>

	<span class="c1">// This is done by operating on permutations of a set with d elements per node.
</span><span class="c1"></span>	<span class="nx">setSize</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">nodes</span><span class="p">)</span> <span class="o">*</span> <span class="nx">d</span>

	<span class="c1">// There are d ways of mapping each node into the set, and we choose the ith.
</span><span class="c1"></span>	<span class="c1">// Note that we can project the element back to the original node: element / d == node.
</span><span class="c1"></span>	<span class="nx">element</span> <span class="o">:=</span> <span class="nx">node</span><span class="o">*</span><span class="nx">d</span> <span class="o">+</span> <span class="nx">i</span>

	<span class="c1">// Permutations of the d elements corresponding to each node yield d new elements,
</span><span class="c1"></span>	<span class="nx">permuted</span> <span class="o">:=</span> <span class="nx">chung</span><span class="p">.</span><span class="nf">PermutationAlgorithm</span><span class="p">().</span><span class="nf">As_Feistel</span><span class="p">().</span><span class="nf">Permute</span><span class="p">(</span><span class="nx">setSize</span><span class="p">,</span> <span class="nx">element</span><span class="p">)</span>

	<span class="c1">// each of which can be projected back to a node.
</span><span class="c1"></span>	<span class="nx">projected</span> <span class="o">:=</span> <span class="nx">permuted</span> <span class="o">/</span> <span class="nx">d</span>

	<span class="c1">// We have selected the ith such parent of node.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">projected</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Feistel_I</span><span class="p">)</span> <span class="nf">Permute</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="c1">// Call into feistel.go.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">Seal</span><span class="p">(</span><span class="nx">sid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">)</span> <span class="nx">SealSetupArtifacts</span> <span class="p">{</span>
	<span class="nx">windowCount</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowCount</span><span class="p">())</span>
	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">())</span>
	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Nodes</span><span class="p">())</span>
	<span class="nx">curveModulus</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Curve</span><span class="p">().</span><span class="nf">FieldModulus</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">windowData</span> <span class="p">[][]</span><span class="kt">byte</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nx">windowData</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">windowData</span><span class="p">,</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">:(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">])</span>
	<span class="p">}</span>

	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">windowData</span><span class="p">)</span> <span class="o">==</span> <span class="nx">windowCount</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">windowKeyLayers</span> <span class="p">[][]</span><span class="kt">byte</span>
	<span class="kd">var</span> <span class="nx">finalWindowKeyLayer</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="nx">commD</span><span class="p">,</span> <span class="nx">commDTreePath</span> <span class="o">:=</span> <span class="nf">ComputeDataCommitment</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">sealSeed</span> <span class="o">:=</span> <span class="nf">computeSealSeed</span><span class="p">(</span><span class="nx">sid</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nx">commD</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">windowCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">keyLayers</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_generateWindowKey</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sid</span><span class="p">,</span> <span class="nx">commD</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">)</span>

		<span class="nx">lastIndex</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">windowKeyLayers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">windowKeyLayers</span><span class="p">,</span> <span class="nx">keyLayers</span><span class="p">[:</span><span class="nx">lastIndex</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">finalWindowKeyLayer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">finalWindowKeyLayer</span><span class="p">,</span> <span class="nx">keyLayers</span><span class="p">[</span><span class="nx">lastIndex</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">qLayer</span> <span class="o">:=</span> <span class="nf">encodeDataInPlace</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">finalWindowKeyLayer</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">curveModulus</span><span class="p">)</span>
	<span class="c1">// NOTE: qLayer and data are now the same, and qLayer is introduced here for descriptive clarity only.
</span><span class="c1"></span>
	<span class="nx">replica</span> <span class="o">:=</span> <span class="nf">labelLayer</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Drg</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Expander</span><span class="p">(),</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">WRAPPER_LAYER_WINDOW_INDEX</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">qLayer</span><span class="p">)</span>

	<span class="nx">commC</span><span class="p">,</span> <span class="nx">commQ</span><span class="p">,</span> <span class="nx">commRLast</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">commCTreePath</span><span class="p">,</span> <span class="nx">commQTreePath</span><span class="p">,</span> <span class="nx">commRLastTreePath</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">GenerateCommitments</span><span class="p">(</span><span class="nx">replica</span><span class="p">,</span> <span class="nx">windowKeyLayers</span><span class="p">,</span> <span class="nx">qLayer</span><span class="p">)</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">SealSetupArtifacts_I</span><span class="p">{</span>
		<span class="nx">CommD_</span><span class="p">:</span>             <span class="nf">Commitment</span><span class="p">(</span><span class="nx">commD</span><span class="p">),</span>
		<span class="nx">CommR_</span><span class="p">:</span>             <span class="nf">SealedSectorCID</span><span class="p">(</span><span class="nx">commR</span><span class="p">),</span>
		<span class="nx">CommC_</span><span class="p">:</span>             <span class="nf">Commitment</span><span class="p">(</span><span class="nx">commC</span><span class="p">),</span>
		<span class="nx">CommQ_</span><span class="p">:</span>             <span class="nf">Commitment</span><span class="p">(</span><span class="nx">commQ</span><span class="p">),</span>
		<span class="nx">CommRLast_</span><span class="p">:</span>         <span class="nf">Commitment</span><span class="p">(</span><span class="nx">commRLast</span><span class="p">),</span>
		<span class="nx">CommDTreePath_</span><span class="p">:</span>     <span class="nx">commDTreePath</span><span class="p">,</span>
		<span class="nx">CommCTreePath_</span><span class="p">:</span>     <span class="nx">commCTreePath</span><span class="p">,</span>
		<span class="nx">CommQTreePath_</span><span class="p">:</span>     <span class="nx">commQTreePath</span><span class="p">,</span>
		<span class="nx">CommRLastTreePath_</span><span class="p">:</span> <span class="nx">commRLastTreePath</span><span class="p">,</span>
		<span class="nx">Seed_</span><span class="p">:</span>              <span class="nx">sealSeed</span><span class="p">,</span>
		<span class="nx">KeyLayers_</span><span class="p">:</span>         <span class="nx">windowKeyLayers</span><span class="p">,</span>
		<span class="nx">Replica_</span><span class="p">:</span>           <span class="nx">replica</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">_generateWindowKey</span><span class="p">(</span><span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">windowIndex</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">commD</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">())</span>
	<span class="nx">curveModulus</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Curve</span><span class="p">().</span><span class="nf">FieldModulus</span><span class="p">()</span>
	<span class="nx">layers</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Layers</span><span class="p">())</span>

	<span class="nx">keyLayers</span> <span class="o">:=</span> <span class="nf">generateSDRKeyLayers</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowDrg</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowExpander</span><span class="p">(),</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">windowIndex</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">layers</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">curveModulus</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">keyLayers</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">GenerateCommitments</span><span class="p">(</span><span class="nx">replica</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">windowKeyLayers</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">qLayer</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">commC</span> <span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">commQ</span> <span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">commRLast</span> <span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">commR</span> <span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">commCTreePath</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="nx">commQTreePath</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">,</span> <span class="nx">commRLastTreePath</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">commC</span><span class="p">,</span> <span class="nx">commCTreePath</span> <span class="p">=</span> <span class="nf">computeCommC</span><span class="p">(</span><span class="nx">windowKeyLayers</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">()))</span>
	<span class="nx">commQ</span><span class="p">,</span> <span class="nx">commQTreePath</span> <span class="p">=</span> <span class="nf">computeCommQ</span><span class="p">(</span><span class="nx">qLayer</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">()))</span>
	<span class="nx">commRLast</span><span class="p">,</span> <span class="nx">commRLastTreePath</span> <span class="p">=</span> <span class="nf">BuildTree_PedersenHash</span><span class="p">(</span><span class="nx">replica</span><span class="p">)</span>
	<span class="nx">commR</span> <span class="p">=</span> <span class="nf">TernaryHash_PedersenHash</span><span class="p">(</span><span class="nx">commC</span><span class="p">,</span> <span class="nx">commQ</span><span class="p">,</span> <span class="nx">commRLast</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">commC</span><span class="p">,</span> <span class="nx">commQ</span><span class="p">,</span> <span class="nx">commRLast</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">commCTreePath</span><span class="p">,</span> <span class="nx">commQTreePath</span><span class="p">,</span> <span class="nx">commRLastTreePath</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getProverID</span><span class="p">(</span><span class="nx">minerID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">MinerID</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">computeSealSeed</span><span class="p">(</span><span class="nx">sid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">,</span> <span class="nx">commD</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span> <span class="p">{</span>
	<span class="nx">proverId</span> <span class="o">:=</span> <span class="nf">getProverID</span><span class="p">(</span><span class="nx">sid</span><span class="p">.</span><span class="nf">MinerID</span><span class="p">())</span>
	<span class="nx">sectorNumber</span> <span class="o">:=</span> <span class="nx">sid</span><span class="p">.</span><span class="nf">Number</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">proverId</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">bigEndianBytesFromUInt</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">sectorNumber</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">randomness</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">Commitment_UnsealedSectorCID</span><span class="p">(</span><span class="nx">commD</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

	<span class="nx">sealSeed</span> <span class="o">:=</span> <span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">SealSeed</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateSDRKeyLayers</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">window</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">layers</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">modulus</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">keyLayers</span> <span class="p">[][]</span><span class="kt">byte</span>
	<span class="kd">var</span> <span class="nx">prevLayer</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">layers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">currentLayer</span> <span class="o">:=</span> <span class="nf">labelLayer</span><span class="p">(</span><span class="nx">drg</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">window</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">prevLayer</span><span class="p">)</span>
		<span class="nx">keyLayers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">,</span> <span class="nx">currentLayer</span><span class="p">)</span>
		<span class="nx">prevLayer</span> <span class="p">=</span> <span class="nx">currentLayer</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">keyLayers</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">labelLayer</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">window</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">prevLayer</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">nodes</span> <span class="o">*</span> <span class="nx">nodeSize</span>
	<span class="nx">labels</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nodes</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="nx">Label</span>

		<span class="c1">// The first node of every layer has no DRG Parents.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">start</span> <span class="o">:=</span> <span class="nx">parent</span> <span class="o">*</span> <span class="nx">nodeSize</span>
				<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">start</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// The first layer has no expander parents.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">prevLayer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">start</span> <span class="o">:=</span> <span class="nx">parent</span> <span class="o">*</span> <span class="nx">nodeSize</span>
				<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">prevLayer</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">start</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">label</span> <span class="o">:=</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">window</span><span class="p">,</span> <span class="nx">parents</span><span class="p">)</span>
		<span class="nx">labels</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">labels</span><span class="p">,</span> <span class="nx">label</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">labels</span>
<span class="p">}</span>

<span class="c1">// Encodes data in-place, mutating it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">encodeDataInPlace</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Key and data must be same length.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nf">encodeNode</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">modulus</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">data</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">node</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">window</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">dependencies</span> <span class="p">[]</span><span class="nx">Label</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nx">sealSeed</span>

	<span class="k">if</span> <span class="nx">window</span> <span class="o">!=</span> <span class="nx">WRAPPER_LAYER_WINDOW_INDEX</span> <span class="p">{</span>
		<span class="nx">windowBytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
		<span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">PutUint64</span><span class="p">(</span><span class="nx">windowBytes</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">window</span><span class="p">))</span>

		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">windowBytes</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">nodeBytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">PutUint64</span><span class="p">(</span><span class="nx">nodeBytes</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span>

	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">nodeBytes</span><span class="o">...</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dependency</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dependencies</span> <span class="p">{</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">dependency</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">deriveLabel</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deriveLabel</span><span class="p">(</span><span class="nx">elements</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">trimToFr32</span><span class="p">(</span><span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">elements</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computeCommC</span><span class="p">(</span><span class="nx">keyLayers</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">leaves</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

	<span class="c1">// For each node in the graph,
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">start</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leaves</span><span class="p">);</span> <span class="nx">start</span> <span class="o">+=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">nodeSize</span>

		<span class="kd">var</span> <span class="nx">column</span> <span class="p">[]</span><span class="nx">Label</span>
		<span class="c1">// Concatenate that node&#39;s label at each layer, in order, into a column.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">label</span> <span class="o">:=</span> <span class="nx">keyLayers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">]</span>
			<span class="nx">column</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">column</span><span class="p">,</span> <span class="nx">label</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// And hash that column to create the leaf of a new tree.
</span><span class="c1"></span>		<span class="nx">hashed</span> <span class="o">:=</span> <span class="nf">hashColumn</span><span class="p">(</span><span class="nx">column</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">leaves</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">],</span> <span class="nx">hashed</span><span class="p">[:])</span>
	<span class="p">}</span>

	<span class="c1">// Return the root of and path to the column tree.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">BuildTree_PedersenHash</span><span class="p">(</span><span class="nx">leaves</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computeCommQ</span><span class="p">(</span><span class="nx">layerBytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">leaves</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">layerBytes</span><span class="p">)</span><span class="o">/</span><span class="nx">nodeSize</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leaves</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">leaves</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">leaves</span><span class="p">,</span> <span class="nx">layerBytes</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">:(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">BuildTree_PedersenHash</span><span class="p">(</span><span class="nx">leaves</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">hashColumn</span><span class="p">(</span><span class="nx">column</span> <span class="p">[]</span><span class="nx">Label</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">label</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">column</span> <span class="p">{</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">label</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">HashBytes_PedersenHash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreateSealProof</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span> <span class="p">{</span>
	<span class="nx">privateProof</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">CreatePrivateSealProof</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>

	<span class="c1">// Sanity check: newly-created proofs must pass verification.
</span><span class="c1"></span>	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">VerifyPrivateSealProof</span><span class="p">(</span><span class="nx">privateProof</span><span class="p">,</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">Seed</span><span class="p">(),</span> <span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">CommD</span><span class="p">(),</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">CommR</span><span class="p">()))</span>

	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">CreateOfflineCircuitProof</span><span class="p">(</span><span class="nx">privateProof</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreatePrivateSealProof</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="p">(</span><span class="nx">privateProof</span> <span class="nx">PrivateOfflineProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sealSeed</span> <span class="o">:=</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">Seed</span><span class="p">()</span>
	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">())</span>
	<span class="nx">wrapperChallenges</span><span class="p">,</span> <span class="nx">windowChallenges</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_generateOfflineChallenges</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Challenges</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowChallenges</span><span class="p">())</span>

	<span class="nx">dataTree</span> <span class="o">:=</span> <span class="nf">LoadMerkleTree</span><span class="p">(</span><span class="nx">aux</span><span class="p">.</span><span class="nf">CommDTreePath</span><span class="p">())</span>
	<span class="nx">columnTree</span> <span class="o">:=</span> <span class="nf">LoadMerkleTree</span><span class="p">(</span><span class="nx">aux</span><span class="p">.</span><span class="nf">CommCTreePath</span><span class="p">())</span>
	<span class="nx">replicaTree</span> <span class="o">:=</span> <span class="nf">LoadMerkleTree</span><span class="p">(</span><span class="nx">aux</span><span class="p">.</span><span class="nf">PersistentAux</span><span class="p">().</span><span class="nf">CommRLastTreePath</span><span class="p">())</span>
	<span class="nx">qTree</span> <span class="o">:=</span> <span class="nf">LoadMerkleTree</span><span class="p">(</span><span class="nx">aux</span><span class="p">.</span><span class="nf">CommQTreePath</span><span class="p">())</span>

	<span class="nx">windows</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowCount</span><span class="p">())</span>
	<span class="nx">windowSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Cfg</span><span class="p">().</span><span class="nf">SealCfg</span><span class="p">().</span><span class="nf">SectorSize</span><span class="p">())</span> <span class="o">/</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowCount</span><span class="p">()))</span>

	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">windowChallenges</span> <span class="p">{</span>
		<span class="nx">columnProofs</span> <span class="o">:=</span> <span class="nf">createColumnProofs</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowDrg</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowExpander</span><span class="p">(),</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">columnTree</span><span class="p">,</span> <span class="nx">aux</span><span class="p">,</span> <span class="nx">windows</span><span class="p">,</span> <span class="nx">windowSize</span><span class="p">)</span>
		<span class="nx">privateProof</span><span class="p">.</span><span class="nx">ColumnProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">privateProof</span><span class="p">.</span><span class="nx">ColumnProofs</span><span class="p">,</span> <span class="nx">columnProofs</span><span class="o">...</span><span class="p">)</span>

		<span class="nx">windowProof</span> <span class="o">:=</span> <span class="nf">createWindowProof</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowDrg</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowExpander</span><span class="p">(),</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">dataTree</span><span class="p">,</span> <span class="nx">columnTree</span><span class="p">,</span> <span class="nx">qTree</span><span class="p">,</span> <span class="nx">aux</span><span class="p">,</span> <span class="nx">windows</span><span class="p">,</span> <span class="nx">windowSize</span><span class="p">)</span>
		<span class="nx">privateProof</span><span class="p">.</span><span class="nx">WindowProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">privateProof</span><span class="p">.</span><span class="nx">WindowProofs</span><span class="p">,</span> <span class="nx">windowProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">wrapperChallenges</span> <span class="p">{</span>
		<span class="nx">wrapperProof</span> <span class="o">:=</span> <span class="nf">createWrapperProof</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Drg</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Expander</span><span class="p">(),</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">qTree</span><span class="p">,</span> <span class="nx">replicaTree</span><span class="p">,</span> <span class="nx">aux</span><span class="p">,</span> <span class="nx">windows</span><span class="p">,</span> <span class="nx">windowSize</span><span class="p">)</span>
		<span class="nx">privateProof</span><span class="p">.</span><span class="nx">WrapperProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">privateProof</span><span class="p">.</span><span class="nx">WrapperProofs</span><span class="p">,</span> <span class="nx">wrapperProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">privateProof</span>
<span class="p">}</span>

<span class="c1">// Verify a private proof.
</span><span class="c1">// NOTE: Verification of a private proof is exactly the computation we will prove we have performed in a zk-SNARK.
</span><span class="c1">// If we can verifiably prove that we have performed the verification of a private proof, then we need not reveal the proof itself.
</span><span class="c1">// Since the zk-SNARK circuit proof is much smaller than the private proof, this allows us to save space on the chain (at the cost of increased computation to generate the zk-SNARK proof).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">VerifyPrivateSealProof</span><span class="p">(</span><span class="nx">privateProof</span> <span class="nx">PrivateOfflineProof</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span><span class="p">,</span> <span class="nx">commD</span> <span class="nx">Commitment</span><span class="p">,</span> <span class="nx">commR</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">())</span>
	<span class="nx">windowCount</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowCount</span><span class="p">())</span>
	<span class="nx">windowSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Cfg</span><span class="p">().</span><span class="nf">SealCfg</span><span class="p">().</span><span class="nf">SectorSize</span><span class="p">())</span> <span class="o">/</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowCount</span><span class="p">()))</span> <span class="c1">// TOOD: Make this a function.
</span><span class="c1"></span>	<span class="nx">layers</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Layers</span><span class="p">())</span>
	<span class="nx">curveModulus</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Curve</span><span class="p">().</span><span class="nf">FieldModulus</span><span class="p">()</span>
	<span class="nx">windowChallenges</span><span class="p">,</span> <span class="nx">wrapperChallenges</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_generateOfflineChallenges</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Challenges</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowChallenges</span><span class="p">())</span>

	<span class="nx">windowProofs</span> <span class="o">:=</span> <span class="nx">privateProof</span><span class="p">.</span><span class="nx">WindowProofs</span>
	<span class="nx">columnProofs</span> <span class="o">:=</span> <span class="nx">privateProof</span><span class="p">.</span><span class="nx">ColumnProofs</span>
	<span class="nx">wrapperProofs</span> <span class="o">:=</span> <span class="nx">privateProof</span><span class="p">.</span><span class="nx">WrapperProofs</span>

	<span class="c1">// commC, commQ, and commRLast must be the same for all challenge proofs, so we can arbitrarily verify against the first.
</span><span class="c1"></span>	<span class="nx">firstColumnProof</span> <span class="o">:=</span> <span class="nx">columnProofs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">firstWrapperProof</span> <span class="o">:=</span> <span class="nx">wrapperProofs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="nx">commC</span> <span class="o">:=</span> <span class="nx">firstColumnProof</span><span class="p">.</span><span class="nx">InclusionProof</span><span class="p">.</span><span class="nf">Root</span><span class="p">()</span>
	<span class="nx">commQ</span> <span class="o">:=</span> <span class="nx">firstWrapperProof</span><span class="p">.</span><span class="nx">QLayerProofs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">Root</span><span class="p">()</span>
	<span class="nx">commRLast</span> <span class="o">:=</span> <span class="nx">firstWrapperProof</span><span class="p">.</span><span class="nx">ReplicaProof</span><span class="p">.</span><span class="nf">Root</span><span class="p">()</span>

	<span class="nx">windowDrgParentCount</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowDRGCfg</span><span class="p">().</span><span class="nf">Degree</span><span class="p">())</span>
	<span class="nx">windowExpanderParentCount</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowDRGCfg</span><span class="p">().</span><span class="nf">Degree</span><span class="p">())</span>
	<span class="nx">wrapperExpanderParentCount</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">ExpanderGraphCfg</span><span class="p">().</span><span class="nf">Degree</span><span class="p">())</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">challenge</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">windowChallenges</span> <span class="p">{</span>
		<span class="c1">// Verify one OfflineSDRChallengeProof.
</span><span class="c1"></span>		<span class="nx">windowProof</span> <span class="o">:=</span> <span class="nx">windowProofs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">dataProof</span> <span class="o">:=</span> <span class="nx">windowProof</span><span class="p">.</span><span class="nx">DataProof</span>
		<span class="nx">qLayerProof</span> <span class="o">:=</span> <span class="nx">windowProof</span><span class="p">.</span><span class="nx">QLayerProof</span>

		<span class="c1">// Verify column proofs and that they represent the right columns.
</span><span class="c1"></span>		<span class="nx">columnElements</span> <span class="o">:=</span> <span class="nf">getColumnElements</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Drg</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Expander</span><span class="p">(),</span> <span class="nx">challenge</span><span class="p">)</span>

		<span class="c1">// Check column openings.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">columnElement</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnElements</span> <span class="p">{</span>
			<span class="nx">columnProof</span> <span class="o">:=</span> <span class="nx">columnProofs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

			<span class="c1">// The provided column proofs must correspond to the expected columns.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">!</span><span class="nx">columnProof</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">commC</span><span class="p">,</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">columnElement</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Check labeling.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">windowCount</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">layer</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">layer</span> <span class="p">&lt;</span> <span class="nx">layers</span><span class="p">;</span> <span class="nx">layer</span><span class="o">++</span> <span class="p">{</span>
				<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="nx">Label</span>

				<span class="c1">// First column proof is the challenge.
</span><span class="c1"></span>				<span class="c1">// Then the DRG parents.
</span><span class="c1"></span>				<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">drgParentProof</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnProofs</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="nx">windowDrgParentCount</span><span class="p">]</span> <span class="p">{</span>
					<span class="nx">parent</span> <span class="o">:=</span> <span class="nx">drgParentProof</span><span class="p">.</span><span class="nx">Column</span><span class="p">[</span><span class="nx">layer</span><span class="p">]</span>
					<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="c1">// And the expander parents, if not the first layer.
</span><span class="c1"></span>				<span class="k">if</span> <span class="nx">layer</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
					<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">expanderParentProof</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnProofs</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="nx">windowDrgParentCount</span> <span class="p">:</span> <span class="mi">1</span><span class="o">+</span><span class="nx">windowExpanderParentCount</span><span class="p">]</span> <span class="p">{</span>
						<span class="nx">parent</span> <span class="o">:=</span> <span class="nx">expanderParentProof</span><span class="p">.</span><span class="nx">Column</span><span class="p">[</span><span class="nx">layer</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
						<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="nx">calculatedLabel</span> <span class="o">:=</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">parents</span><span class="p">)</span>

				<span class="k">if</span> <span class="nx">layer</span> <span class="o">==</span> <span class="nx">layers</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
					<span class="c1">// Last layer includes encoding.
</span><span class="c1"></span>					<span class="nx">dataNode</span> <span class="o">:=</span> <span class="nx">dataProof</span><span class="p">.</span><span class="nf">Leaf</span><span class="p">()</span>
					<span class="nx">qLayerNode</span> <span class="o">:=</span> <span class="nx">qLayerProof</span><span class="p">.</span><span class="nf">Leaf</span><span class="p">()</span>

					<span class="k">if</span> <span class="p">!</span><span class="nx">dataProof</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">commD</span><span class="p">,</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">windowSize</span><span class="o">*</span><span class="nx">w</span><span class="p">)</span><span class="o">+</span><span class="nx">challenge</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">return</span> <span class="kc">false</span>
					<span class="p">}</span>

					<span class="nx">encodedNode</span> <span class="o">:=</span> <span class="nf">encodeNode</span><span class="p">(</span><span class="nx">dataNode</span><span class="p">,</span> <span class="nx">calculatedLabel</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">curveModulus</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>

					<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">encodedNode</span><span class="p">,</span> <span class="nx">qLayerNode</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">return</span> <span class="kc">false</span>
					<span class="p">}</span>

				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="nx">providedLabel</span> <span class="o">:=</span> <span class="nx">columnProofs</span><span class="p">[</span><span class="nx">columnElements</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="nx">Column</span><span class="p">[</span><span class="nx">layer</span><span class="p">]</span>

					<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">calculatedLabel</span><span class="p">,</span> <span class="nx">providedLabel</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">return</span> <span class="kc">false</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">challenge</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">wrapperChallenges</span> <span class="p">{</span>
		<span class="nx">wrapperProof</span> <span class="o">:=</span> <span class="nx">wrapperProofs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">replicaProof</span> <span class="o">:=</span> <span class="nx">wrapperProof</span><span class="p">.</span><span class="nx">ReplicaProof</span>
		<span class="nx">qLayerProofs</span> <span class="o">:=</span> <span class="nx">wrapperProof</span><span class="p">.</span><span class="nx">QLayerProofs</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">replicaProof</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">commRLast</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="nx">Label</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">wrapperExpanderParentCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">parent</span> <span class="o">:=</span> <span class="nx">qLayerProofs</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nf">Leaf</span><span class="p">()</span>
			<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">label</span> <span class="o">:=</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">windowCount</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">parents</span><span class="p">)</span>
		<span class="nx">replicaNode</span> <span class="o">:=</span> <span class="nx">replicaProof</span><span class="p">.</span><span class="nf">Leaf</span><span class="p">()</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">label</span><span class="p">,</span> <span class="nx">replicaNode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">commRCalculated</span> <span class="o">:=</span> <span class="nf">TernaryHash_PedersenHash</span><span class="p">(</span><span class="nx">commC</span><span class="p">,</span> <span class="nx">commQ</span><span class="p">,</span> <span class="nx">commRLast</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">commRCalculated</span><span class="p">,</span> <span class="nf">AsBytes_SealedSectorCID</span><span class="p">(</span><span class="nx">commR</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createColumnProofs</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">columnTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span> <span class="p">{</span>
	<span class="nx">columnElements</span> <span class="o">:=</span> <span class="nf">getColumnElements</span><span class="p">(</span><span class="nx">drg</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">columnProofs</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnElements</span> <span class="p">{</span>
		<span class="nx">chall</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>

		<span class="nx">columnProof</span> <span class="o">:=</span> <span class="nf">createColumnProof</span><span class="p">(</span><span class="nx">chall</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">windows</span><span class="p">,</span> <span class="nx">windowSize</span><span class="p">,</span> <span class="nx">columnTree</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>
		<span class="nx">columnProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnProofs</span><span class="p">,</span> <span class="nx">columnProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">columnProofs</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createWindowProof</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">dataTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">columnTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">qLayerTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">proof</span> <span class="nx">OfflineWindowProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">columnElements</span> <span class="o">:=</span> <span class="nf">getColumnElements</span><span class="p">(</span><span class="nx">drg</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">columnProofs</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnElements</span> <span class="p">{</span>
		<span class="nx">chall</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>

		<span class="nx">columnProof</span> <span class="o">:=</span> <span class="nf">createColumnProof</span><span class="p">(</span><span class="nx">chall</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">windows</span><span class="p">,</span> <span class="nx">windowSize</span><span class="p">,</span> <span class="nx">columnTree</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>
		<span class="nx">columnProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnProofs</span><span class="p">,</span> <span class="nx">columnProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">dataProof</span> <span class="o">:=</span> <span class="nx">dataTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>
	<span class="nx">qLayerProof</span> <span class="o">:=</span> <span class="nx">qLayerTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>

	<span class="nx">proof</span> <span class="p">=</span> <span class="nx">OfflineWindowProof</span><span class="p">{</span>
		<span class="nx">DataProof</span><span class="p">:</span>   <span class="nx">dataProof</span><span class="p">,</span>
		<span class="nx">QLayerProof</span><span class="p">:</span> <span class="nx">qLayerProof</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">proof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createWrapperProof</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">qTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">replicaTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">proof</span> <span class="nx">OfflineWrapperProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">proof</span><span class="p">.</span><span class="nx">ReplicaProof</span> <span class="p">=</span> <span class="nx">replicaTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>

	<span class="nx">parents</span> <span class="o">:=</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parents</span> <span class="p">{</span>
		<span class="nx">proof</span><span class="p">.</span><span class="nx">QLayerProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">proof</span><span class="p">.</span><span class="nx">QLayerProofs</span><span class="p">,</span> <span class="nx">qTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">parent</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">proof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getColumnElements</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">(</span><span class="nx">columnElements</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">columnElements</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createColumnProof</span><span class="p">(</span><span class="nx">c</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">columnTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="p">(</span><span class="nx">columnProof</span> <span class="nx">SDRColumnProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">layers</span> <span class="o">:=</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">KeyLayers</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">column</span> <span class="p">[]</span><span class="nx">Label</span>

	<span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">windows</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">layers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">start</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">windowSize</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
			<span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nodeSize</span><span class="p">)</span>
			<span class="nx">column</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">column</span><span class="p">,</span> <span class="nx">layers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">columnProof</span> <span class="p">=</span> <span class="nx">SDRColumnProof</span><span class="p">{</span>
		<span class="nx">Column</span><span class="p">:</span>         <span class="nx">column</span><span class="p">,</span>
		<span class="nx">InclusionProof</span><span class="p">:</span> <span class="nx">columnTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">columnProof</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PrivateOfflineProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ColumnProofs</span>  <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="nx">WindowProofs</span>  <span class="p">[]</span><span class="nx">OfflineWindowProof</span>
	<span class="nx">WrapperProofs</span> <span class="p">[]</span><span class="nx">OfflineWrapperProof</span>
<span class="p">}</span>

<span class="c1">// // Column proofs for all windows.
</span><span class="c1">// type OfflineWindowColumnProof struct {
</span><span class="c1">// 	ColumnProofs []SDRColumnProof
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">OfflineWindowProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// TODO: these proofs need to depend on hash function.
</span><span class="c1"></span>	<span class="nx">DataProof</span>   <span class="nx">InclusionProof</span> <span class="c1">// SHA256
</span><span class="c1"></span>	<span class="nx">QLayerProof</span> <span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OfflineWrapperProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ReplicaProof</span> <span class="nx">InclusionProof</span> <span class="c1">// Pedersen
</span><span class="c1"></span>	<span class="nx">QLayerProofs</span> <span class="p">[]</span><span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">Leaf</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">LeafIndex</span><span class="p">()</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">Root</span><span class="p">()</span> <span class="nx">Commitment</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">MerkleTree_I</span><span class="p">)</span> <span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">InclusionProof</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">MerkleTree_I</span><span class="p">)</span> <span class="nf">Leaf</span><span class="p">(</span><span class="nx">index</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LoadMerkleTree</span><span class="p">(</span><span class="nx">path</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="nx">MerkleTree</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// FIXME: need to verify proof length of private inclusion proofs.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SDRColumnProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Column</span>         <span class="p">[]</span><span class="nx">Label</span>
	<span class="nx">InclusionProof</span> <span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">proof</span> <span class="o">*</span><span class="nx">SDRColumnProof</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nf">hashColumn</span><span class="p">(</span><span class="nx">proof</span><span class="p">.</span><span class="nx">Column</span><span class="p">),</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">InclusionProof</span><span class="p">.</span><span class="nf">Leaf</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">InclusionProof</span><span class="p">.</span><span class="nf">LeafIndex</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">challenge</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">InclusionProof</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreateOfflineCircuitProof</span><span class="p">(</span><span class="nx">proof</span> <span class="nx">PrivateOfflineProof</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span> <span class="p">{</span>
	<span class="c1">// partitions := sdr.Partitions()
</span><span class="c1"></span>	<span class="c1">// publicInputs := GeneratePublicInputs()
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">_generateOfflineChallenges</span><span class="p">(</span><span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span><span class="p">,</span> <span class="nx">wrapperChallengeCount</span> <span class="nx">WinStackedDRGChallenges</span><span class="p">,</span> <span class="nx">windowChallengeCount</span> <span class="nx">WinStackedDRGWindowChallenges</span><span class="p">)</span> <span class="p">(</span><span class="nx">windowChallenges</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">,</span> <span class="nx">wrapperChallenges</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">wrapperChallenges</span> <span class="p">=</span> <span class="nf">generateOfflineChallenges</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Nodes</span><span class="p">()),</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">wrapperChallengeCount</span><span class="p">))</span>
	<span class="nx">windowChallenges</span> <span class="p">=</span> <span class="nf">generateOfflineChallenges</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowDRGCfg</span><span class="p">().</span><span class="nf">Nodes</span><span class="p">()),</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">windowChallengeCount</span><span class="p">))</span>

	<span class="k">return</span> <span class="nx">windowChallenges</span><span class="p">,</span> <span class="nx">wrapperChallenges</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateOfflineChallenges</span><span class="p">(</span><span class="nx">challengeRange</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span><span class="p">,</span> <span class="nx">challengeCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">challenges</span> <span class="p">[]</span><span class="nx">UInt</span>
	<span class="nx">challengeRangeSize</span> <span class="o">:=</span> <span class="nx">challengeRange</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Never challenge the first node.
</span><span class="c1"></span>	<span class="nx">challengeModulus</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">challengeModulus</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">challengeRangeSize</span><span class="p">))</span>

	<span class="c1">// Maybe factor this into a separate function, since the logic is the same...
</span><span class="c1"></span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">challengeCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">[]</span><span class="kt">byte</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">sealSeed</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">randomness</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">littleEndianBytesFromInt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

		<span class="nx">hash</span> <span class="o">:=</span> <span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
		<span class="nx">bigChallenge</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
		<span class="nx">bigChallenge</span> <span class="p">=</span> <span class="nx">bigChallenge</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">bigChallenge</span><span class="p">,</span> <span class="nx">challengeModulus</span><span class="p">)</span>

		<span class="c1">// Sectors nodes must be 64-bit addressable, always a safe assumption.
</span><span class="c1"></span>		<span class="nx">challenge</span> <span class="o">:=</span> <span class="nx">bigChallenge</span><span class="p">.</span><span class="nf">Uint64</span><span class="p">()</span>
		<span class="nx">challenge</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Never challenge the first node.
</span><span class="c1"></span>		<span class="nx">challenges</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">challenges</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">challenges</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">encodeNode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="c1">// TODO: Make this a method of WinStackedDRG.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">addEncode</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">modulus</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addEncode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>

	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">k</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

	<span class="nx">sum</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">modulus</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">littleEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Seal Verification
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">onChain</span> <span class="o">:=</span> <span class="nx">sv</span><span class="p">.</span><span class="nf">OnChain</span><span class="p">()</span>
	<span class="nx">sealProof</span> <span class="o">:=</span> <span class="nx">onChain</span><span class="p">.</span><span class="nf">Proof</span><span class="p">()</span>
	<span class="nx">commR</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">SealedSectorCID</span><span class="p">(</span><span class="nx">onChain</span><span class="p">.</span><span class="nf">SealedCID</span><span class="p">())</span>
	<span class="nx">commD</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nx">sv</span><span class="p">.</span><span class="nf">UnsealedCID</span><span class="p">())</span>
	<span class="nx">sealSeed</span> <span class="o">:=</span> <span class="nf">computeSealSeed</span><span class="p">(</span><span class="nx">sv</span><span class="p">.</span><span class="nf">SectorID</span><span class="p">(),</span> <span class="nx">sv</span><span class="p">.</span><span class="nf">Randomness</span><span class="p">(),</span> <span class="nx">commD</span><span class="p">)</span>

	<span class="nx">wrapperChallenges</span><span class="p">,</span> <span class="nx">windowChallenges</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_generateOfflineChallenges</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">sv</span><span class="p">.</span><span class="nf">InteractiveRandomness</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Challenges</span><span class="p">(),</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">WindowChallenges</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_verifyOfflineCircuitProof</span><span class="p">(</span><span class="nx">commD</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">windowChallenges</span><span class="p">,</span> <span class="nx">wrapperChallenges</span><span class="p">,</span> <span class="nx">sealProof</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeUnsealedSectorCIDFromPieceInfos</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">pieceInfos</span> <span class="p">[]</span><span class="nx">PieceInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsealedCID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rootPieceInfo</span> <span class="o">:=</span> <span class="nf">computeRootPieceInfo</span><span class="p">(</span><span class="nx">pieceInfos</span><span class="p">)</span>
	<span class="nx">rootSize</span> <span class="o">:=</span> <span class="nx">rootPieceInfo</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">rootSize</span> <span class="o">!=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">unsealedCID</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Wrong sector size.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nf">AsBytes_PieceCID</span><span class="p">(</span><span class="nx">rootPieceInfo</span><span class="p">.</span><span class="nf">PieceCID</span><span class="p">())),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="c1">// commD := rootPieceInfo.CommP()
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">computeRootPieceInfo</span><span class="p">(</span><span class="nx">pieceInfos</span> <span class="p">[]</span><span class="nx">PieceInfo</span><span class="p">)</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
	<span class="c1">// Construct root PieceInfo by (shift-reduce) parsing the constituent PieceInfo array.
</span><span class="c1"></span>	<span class="c1">// Later pieces must always be joined with equal-sized predecessors to create a new root twice their size.
</span><span class="c1"></span>	<span class="c1">// So if a piece is larger than the current root (top of stack), add padding until it is not.
</span><span class="c1"></span>	<span class="c1">// If a piece is smaller than the root, let it be the new root (top of stack) until reduced to a replacement that can be joined
</span><span class="c1"></span>	<span class="c1">// with the previous.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="nx">PieceInfo</span>

	<span class="nx">shift</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="nx">PieceInfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">peek</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">peek2</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">pop</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">reduce1</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">peek</span><span class="p">().</span><span class="nf">Size</span><span class="p">()</span> <span class="o">==</span> <span class="nf">peek2</span><span class="p">().</span><span class="nf">Size</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">right</span> <span class="o">:=</span> <span class="nf">pop</span><span class="p">()</span>
			<span class="nx">left</span> <span class="o">:=</span> <span class="nf">pop</span><span class="p">()</span>
			<span class="nx">joined</span> <span class="o">:=</span> <span class="nf">joinPieceInfos</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
			<span class="nf">shift</span><span class="p">(</span><span class="nx">joined</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">reduce</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nf">reduce1</span><span class="p">()</span> <span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">shiftReduce</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="nx">PieceInfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">shift</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="nf">reduce</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Prime the pump with first pieceInfo.
</span><span class="c1"></span>	<span class="nf">shift</span><span class="p">(</span><span class="nx">pieceInfos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

	<span class="c1">// Consume the remainder.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pieceInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pieceInfos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="c1">// TODO: Assert that pieceInfo.Size() is a power of 2.
</span><span class="c1"></span>
		<span class="c1">// Add padding until top of stack is large enough to receive current pieceInfo.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">peek</span><span class="p">().</span><span class="nf">Size</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">pieceInfo</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="p">{</span>
			<span class="nf">shiftReduce</span><span class="p">(</span><span class="nf">zeroPadding</span><span class="p">(</span><span class="nf">peek</span><span class="p">().</span><span class="nf">Size</span><span class="p">()))</span>
		<span class="p">}</span>

		<span class="c1">// Add the current piece.
</span><span class="c1"></span>		<span class="nf">shiftReduce</span><span class="p">(</span><span class="nx">pieceInfo</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Add any necessary final padding.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nf">shiftReduce</span><span class="p">(</span><span class="nf">zeroPadding</span><span class="p">(</span><span class="nf">peek</span><span class="p">().</span><span class="nf">Size</span><span class="p">()))</span>
	<span class="p">}</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">pop</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">zeroPadding</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo_I</span><span class="p">{</span>
		<span class="nx">Size_</span><span class="p">:</span> <span class="nx">size</span><span class="p">,</span>
		<span class="c1">// CommP_: FIXME: Implement.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">joinPieceInfos</span><span class="p">(</span><span class="nx">left</span> <span class="nx">PieceInfo</span><span class="p">,</span> <span class="nx">right</span> <span class="nx">PieceInfo</span><span class="p">)</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">==</span> <span class="nx">right</span><span class="p">.</span><span class="nf">Size</span><span class="p">())</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo_I</span><span class="p">{</span>
		<span class="nx">Size_</span><span class="p">:</span>     <span class="nx">left</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">+</span> <span class="nx">right</span><span class="p">.</span><span class="nf">Size</span><span class="p">(),</span>
		<span class="nx">PieceCID_</span><span class="p">:</span> <span class="nx">piece</span><span class="p">.</span><span class="nf">PieceCID</span><span class="p">(</span><span class="nf">BinaryHash_SHA256Hash</span><span class="p">(</span><span class="nf">AsBytes_PieceCID</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nf">PieceCID</span><span class="p">()),</span> <span class="nf">AsBytes_PieceCID</span><span class="p">(</span><span class="nx">right</span><span class="p">.</span><span class="nf">PieceCID</span><span class="p">()))),</span> <span class="c1">// FIXME: make this whole function generic?
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">_verifyOfflineCircuitProof</span><span class="p">(</span><span class="nx">commD</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">commR</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">windowChallenges</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">,</span> <span class="nx">wrapperChallenges</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">,</span> <span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">//publicInputs := GeneratePublicInputs()
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// PoSt
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">_getChallengedSectors</span><span class="p">(</span><span class="nx">sectorIDs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">sectors</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">candidateCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sector</span> <span class="o">:=</span> <span class="nf">generateSectorChallenge</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sectorIDs</span><span class="p">)</span>
		<span class="nx">sectors</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sectors</span><span class="p">,</span> <span class="nx">sector</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">sectors</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateSectorChallenge</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorIDs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">(</span><span class="nx">sector</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nf">littleEndianBytesFromInt</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nf">SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
	<span class="nx">sectorChallenge</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>

	<span class="nx">challengeModulus</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">challengeModulus</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">sectorIDs</span><span class="p">)))</span>

	<span class="nx">sectorIndex</span> <span class="o">:=</span> <span class="nx">sectorChallenge</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">sectorChallenge</span><span class="p">,</span> <span class="nx">challengeModulus</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">sectorIDs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nx">sectorIndex</span><span class="p">.</span><span class="nf">Uint64</span><span class="p">())]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateLeafChallenge</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">sectorChallengeIndex</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">leafChallengeIndex</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">challengeRangeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nf">littleEndianBytesFromUInt</span><span class="p">(</span><span class="nx">sectorChallengeIndex</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">littleEndianBytesFromInt</span><span class="p">(</span><span class="nx">leafChallengeIndex</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nf">SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
	<span class="nx">bigHash</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>

	<span class="nx">challengeSpaceSize</span> <span class="o">:=</span> <span class="nx">nodes</span> <span class="o">/</span> <span class="nx">challengeRangeSize</span>
	<span class="nx">challengeModulus</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">challengeModulus</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">challengeSpaceSize</span><span class="p">))</span>

	<span class="nx">leafChallenge</span> <span class="o">:=</span> <span class="nx">bigHash</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">bigHash</span><span class="p">,</span> <span class="nx">challengeModulus</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">leafChallenge</span><span class="p">.</span><span class="nf">Uint64</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateCandidate</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span><span class="p">,</span> <span class="nx">sectorID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">sectorChallengeIndex</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">leafChallengeCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">challengeRangeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span> <span class="p">{</span>
	<span class="nx">treePath</span> <span class="o">:=</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">CommRLastTreePath</span><span class="p">()</span>
	<span class="nx">tree</span> <span class="o">:=</span> <span class="nf">LoadMerkleTree</span><span class="p">(</span><span class="nx">treePath</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="kd">var</span> <span class="nx">inclusionProofs</span> <span class="p">[]</span><span class="nx">InclusionProof</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">leafChallengeCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">leafChallenge</span> <span class="o">:=</span> <span class="nf">generateLeafChallenge</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nx">sectorChallengeIndex</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">challengeRangeSize</span><span class="p">)</span>

		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">challengeRangeSize</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">leafIndex</span> <span class="o">:=</span> <span class="nx">leafChallenge</span> <span class="o">+</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>
			<span class="nx">data</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">tree</span><span class="p">.</span><span class="nf">Leaf</span><span class="p">(</span><span class="nx">leafIndex</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
			<span class="nx">inclusionProof</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">leafIndex</span><span class="p">)</span>
			<span class="nx">inclusionProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">inclusionProofs</span><span class="p">,</span> <span class="nx">inclusionProof</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">partialTicket</span> <span class="o">:=</span> <span class="nf">computePartialTicket</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nx">sectorID</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

	<span class="nx">privateProof</span> <span class="o">:=</span> <span class="nx">InternalPrivateCandidateProof</span><span class="p">{</span>
		<span class="nx">InclusionProofs</span><span class="p">:</span> <span class="nx">inclusionProofs</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">candidate</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate_I</span><span class="p">{</span>
		<span class="nx">PartialTicket_</span><span class="p">:</span>  <span class="nx">partialTicket</span><span class="p">,</span>
		<span class="nx">PrivateProof_</span><span class="p">:</span>   <span class="nx">privateProof</span><span class="p">.</span><span class="nf">externalize</span><span class="p">(),</span>
		<span class="nx">SectorID_</span><span class="p">:</span>       <span class="nx">sectorID</span><span class="p">,</span>
		<span class="nx">ChallengeIndex_</span><span class="p">:</span> <span class="nx">sectorChallengeIndex</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">candidate</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computePartialTicket</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">sectorID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PartialTicket</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nx">randomness</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">getProverID</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">.</span><span class="nf">MinerID</span><span class="p">())</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">littleEndianBytesFromUInt</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">.</span><span class="nf">Number</span><span class="p">()),</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">data</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">partialTicket</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">PartialTicket</span><span class="p">(</span><span class="nf">HashBytes_PedersenHash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">))</span>

	<span class="k">return</span> <span class="nx">partialTicket</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">_generatePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sector_index</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">)</span> <span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Nodes</span><span class="p">())</span>
	<span class="nx">leafChallengeCount</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">LeafChallengeCount</span><span class="p">())</span>
	<span class="nx">challengeRangeSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">ChallengeRangeSize</span><span class="p">())</span>
	<span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_getChallengedSectors</span><span class="p">(</span><span class="nx">eligibleSectors</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">eligibleSectors</span><span class="p">,</span> <span class="nx">candidateCount</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sectorID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">challengedSectors</span> <span class="p">{</span>
		<span class="nx">proofAux</span> <span class="o">:=</span> <span class="nx">sectorStore</span><span class="p">.</span><span class="nf">GetSectorPersistentProofAux</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">)</span>

		<span class="nx">candidate</span> <span class="o">:=</span> <span class="nf">generateCandidate</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">proofAux</span><span class="p">,</span> <span class="nx">sectorID</span><span class="p">,</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span> <span class="nx">leafChallengeCount</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">challengeRangeSize</span><span class="p">)</span>

		<span class="nx">candidates</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">candidates</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">candidates</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreatePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="nx">privateProof</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">CreatePrivatePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">)</span>

	<span class="c1">// var candidates []sector.PoStCandidate // FIXME
</span><span class="c1"></span>
	<span class="c1">// Hmmmmm: we cannot perform this santiy check without the sectorIDs. Should we require them just for that purpose or perform the check earlier?
</span><span class="c1"></span>	<span class="c1">// Sanity check: newly-created proofs must pass verification.
</span><span class="c1"></span>	<span class="c1">//util.Assert(sdr.VerifyPrivatePoStProof(privateProof, candidates, sectorIDs, sectorCommitments))
</span><span class="c1"></span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">CreatePoStCircuitProof</span><span class="p">(</span><span class="nx">privateProof</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PrivatePoStProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ChallengeSeed</span>   <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span>
	<span class="nx">CandidateProofs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreatePrivatePoStProof</span><span class="p">(</span><span class="nx">candidateProofs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="nx">PrivatePoStProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PrivatePoStProof</span><span class="p">{</span>
		<span class="nx">ChallengeSeed</span><span class="p">:</span>   <span class="nx">challengeSeed</span><span class="p">,</span>
		<span class="nx">CandidateProofs</span><span class="p">:</span> <span class="nx">candidateProofs</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InternalPrivateCandidateProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">InclusionProofs</span> <span class="p">[]</span><span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="c1">// This exists because we need to pass private proofs out of filproofs for winner selection.
</span><span class="c1">// Actually implementing it would (will?) be tedious, since it means doing the same for InclusionProofs.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">InternalPrivateCandidateProof</span><span class="p">)</span> <span class="nf">externalize</span><span class="p">()</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// This is the inverse of InternalPrivateCandidateProof.externalize and equally tedious.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newInternalPrivateProof</span><span class="p">(</span><span class="nx">externalPrivateProof</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">)</span> <span class="nx">InternalPrivateCandidateProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">InternalPrivateCandidateProof</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">VerifyInternalPrivateCandidateProof</span><span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">InternalPrivateCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">candidate</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">,</span> <span class="nx">commRLast</span> <span class="nx">Commitment</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">candidate</span><span class="p">.</span><span class="nf">PrivateProof</span><span class="p">()</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Nodes</span><span class="p">())</span>
	<span class="nx">challengeRangeSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">ChallengeRangeSize</span><span class="p">())</span>

	<span class="nx">sectorID</span> <span class="o">:=</span> <span class="nx">candidate</span><span class="p">.</span><span class="nf">SectorID</span><span class="p">()</span>
	<span class="nx">claimedPartialTicket</span> <span class="o">:=</span> <span class="nx">candidate</span><span class="p">.</span><span class="nf">PartialTicket</span><span class="p">()</span>

	<span class="nx">allInclusionProofs</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">InclusionProofs</span>

	<span class="kd">var</span> <span class="nx">ticketData</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">allInclusionProofs</span> <span class="p">{</span>
		<span class="nx">ticketData</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ticketData</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Leaf</span><span class="p">()</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Check partial ticket
</span><span class="c1"></span>	<span class="nx">calculatedTicket</span> <span class="o">:=</span> <span class="nf">computePartialTicket</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">sectorID</span><span class="p">,</span> <span class="nx">ticketData</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">calculatedTicket</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">claimedPartialTicket</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="kt">byte</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">claimedPartialTicket</span> <span class="p">{</span>
		<span class="k">if</span> <span class="kt">byte</span> <span class="o">!=</span> <span class="nx">calculatedTicket</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Helper to get InclusionProofs sequentially.
</span><span class="c1"></span>	<span class="nx">next</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">InclusionProof</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">allInclusionProofs</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="nx">proof</span> <span class="o">:=</span> <span class="nx">allInclusionProofs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="nx">allInclusionProofs</span> <span class="p">=</span> <span class="nx">allInclusionProofs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="k">return</span> <span class="nx">proof</span>
	<span class="p">}</span>

	<span class="c1">// Check all inclusion proofs.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">LeafChallengeCount</span><span class="p">());</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">leafChallenge</span> <span class="o">:=</span> <span class="nf">generateLeafChallenge</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">.</span><span class="nf">ChallengeIndex</span><span class="p">(),</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">challengeRangeSize</span><span class="p">)</span>
		<span class="k">for</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="p">&lt;</span> <span class="nx">challengeRangeSize</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">leafIndex</span> <span class="o">:=</span> <span class="nx">leafChallenge</span> <span class="o">+</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span>
			<span class="nx">proof</span> <span class="o">:=</span> <span class="nf">next</span><span class="p">()</span>
			<span class="k">if</span> <span class="nx">proof</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="c1">// All required inclusion proofs must be provided.
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">proof</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">commRLast</span><span class="p">,</span> <span class="nx">leafIndex</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">VerifyPrivatePoStProof</span><span class="p">(</span><span class="nx">privateProof</span> <span class="nx">PrivatePoStProof</span><span class="p">,</span> <span class="nx">candidates</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">,</span> <span class="nx">sectorIDs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">sectorCommitments</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorCommitments</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// This is safe by construction.
</span><span class="c1"></span>	<span class="nx">challengeSeed</span> <span class="o">:=</span> <span class="nx">privateProof</span><span class="p">.</span><span class="nx">ChallengeSeed</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">privateProof</span><span class="p">.</span><span class="nx">CandidateProofs</span> <span class="p">{</span>
		<span class="nx">proof</span> <span class="o">:=</span> <span class="nf">newInternalPrivateProof</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>

		<span class="nx">candidate</span> <span class="o">:=</span> <span class="nx">candidates</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
		<span class="nx">ci</span> <span class="o">:=</span> <span class="nx">candidate</span><span class="p">.</span><span class="nf">ChallengeIndex</span><span class="p">()</span>
		<span class="nx">expectedSectorID</span> <span class="o">:=</span> <span class="nx">sectorIDs</span><span class="p">[</span><span class="nx">ci</span><span class="p">]</span>

		<span class="nx">challengedSectorID</span> <span class="o">:=</span> <span class="nf">generateSectorChallenge</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sectorIDs</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">expectedSectorID</span> <span class="o">!=</span> <span class="nx">challengedSectorID</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>

		<span class="nx">commRLast</span> <span class="o">:=</span> <span class="nx">sectorCommitments</span><span class="p">[</span><span class="nx">expectedSectorID</span><span class="p">]</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">VerifyInternalPrivateCandidateProof</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">proof</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">,</span> <span class="nx">commRLast</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreatePoStCircuitProof</span><span class="p">(</span><span class="nx">privateProof</span> <span class="nx">PrivatePoStProof</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">_verifyPoStProof</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// commT := sv.CommT()
</span><span class="c1"></span>	<span class="c1">// candidates := sv.Candidates()
</span><span class="c1"></span>	<span class="c1">// randomness := sv.Randomness()
</span><span class="c1"></span>	<span class="c1">// postProof := sv.OnChain.Proof()
</span><span class="c1"></span>
	<span class="c1">// Verify circuit proof.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Election PoSt
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">GenerateElectionPoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sector_index</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">)</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_generatePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">eligibleSectors</span><span class="p">,</span> <span class="nx">candidateCount</span><span class="p">,</span> <span class="nx">sectorStore</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreateElectionPoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">CreatePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">VerifyElectionPoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_verifyPoStProof</span><span class="p">(</span><span class="nx">sv</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Surprise PoSt
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">GenerateSurprisePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sector_index</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">)</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCandidate</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_generatePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">eligibleSectors</span><span class="p">,</span> <span class="nx">candidateCount</span><span class="p">,</span> <span class="nx">sectorStore</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">CreateSurprisePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">CreatePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">WinStackedDRG_I</span><span class="p">)</span> <span class="nf">VerifySurprisePoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_verifyPoStProof</span><span class="p">(</span><span class="nx">sv</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">/// Generic Hashing and Merkle Tree generation
</span><span class="c1"></span>
<span class="c1">/// Binary hash compression.
</span><span class="c1">// BinaryHash&lt;T&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BinaryHash_T</span><span class="p">(</span><span class="nx">left</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">HashBytes_T</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TernaryHash_T</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">c</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nb">append</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="o">...</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">HashBytes_T</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// BinaryHash&lt;PedersenHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BinaryHash_PedersenHash</span><span class="p">(</span><span class="nx">left</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PedersenHash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TernaryHash_PedersenHash</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">c</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PedersenHash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// BinaryHash&lt;SHA256Hash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BinaryHash_SHA256Hash</span><span class="p">(</span><span class="nx">left</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">SHA256Hash</span> <span class="p">{</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">SHA256Hash</span><span class="p">{}</span>
	<span class="k">return</span> <span class="nf">trimToFr32</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">TernaryHash_SHA256Hash</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">c</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">SHA256Hash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">SHA256Hash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="c1">/// Digest
</span><span class="c1">// HashBytes&lt;T&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HashBytes_T</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// HashBytes&lt;PedersenHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HashBytes_PedersenHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PedersenHash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// HashBytes&lt;SHA256Hash.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">SHA256Hash</span> <span class="p">{</span>
	<span class="c1">// Digest is truncated to 254 bits.
</span><span class="c1"></span>	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">SHA256Hash</span><span class="p">{}</span>

	<span class="k">return</span> <span class="nx">result</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">DigestSize_T</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unspecialized&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DigestSize_PedersenHash</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">32</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DigestSize_SHA256Hash</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">32</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">/// Binary Merkle-tree generation
</span><span class="c1"></span>
<span class="c1">// BuildTree&lt;T&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BuildTree_T</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Plan: define this in terms of BinaryHash_T, then copy-paste changes into T-specific specializations, for now.
</span><span class="c1"></span>
	<span class="c1">// Nodes are always the digest size so data cannot be compressed to digest for storage.
</span><span class="c1"></span>	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nf">DigestSize_T</span><span class="p">()</span>

	<span class="c1">// TODO: Fail if len(dat) is not a power of 2 and a multiple of the node size.
</span><span class="c1"></span>
	<span class="nx">rows</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span>

	<span class="k">for</span> <span class="nx">row</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{};</span> <span class="nb">len</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">nodeSize</span><span class="p">;</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">nodeSize</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">]</span>
			<span class="nx">right</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">]</span>

			<span class="nx">hashed</span> <span class="o">:=</span> <span class="nf">BinaryHash_T</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>

			<span class="nx">row</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nf">AsBytes_T</span><span class="p">(</span><span class="nx">hashed</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">rows</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rows</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Last row is the root
</span><span class="c1"></span>	<span class="nx">root</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">rows</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;math failed us&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">filePath</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span> <span class="c1">// TODO: dump tree to file.
</span><span class="c1"></span>	<span class="c1">// NOTE: merkle tree file layout is illustrative, not prescriptive.
</span><span class="c1"></span>
	<span class="c1">// TODO: Check above more carefully. It&#39;s just an untested sketch for the moment.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">fromBytes_T</span><span class="p">(</span><span class="nx">root</span><span class="p">),</span> <span class="nx">filePath</span>
<span class="p">}</span>

<span class="c1">// BuildTree&lt;PedersenHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BuildTree_PedersenHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PedersenHash</span><span class="p">{},</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span> <span class="c1">// FIXME
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">//  BuildTree&lt;SHA256Hash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">BuildTree_SHA256Hash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">SHA256Hash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span> <span class="c1">// FIXME
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="c1">// Destructively trim data so most significant two bits of last byte are 0.
</span><span class="c1">// This ensure data interpreted as little-endian will not exceed a field with 254-bit capacity.
</span><span class="c1">// NOTE: 254 bits is the capacity of BLS12-381, but other curves with ~32-byte field elements
</span><span class="c1">// may have a different capacity. (Example: BLS12-377 has a capacity of 252 bits.)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">trimToFr32</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span>
	<span class="nx">data</span><span class="p">[</span><span class="mi">31</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x3f</span> <span class="c1">// 0x3f = 0b0011_1111
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">data</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nx">h</span> <span class="nx">SHA256Hash</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SealedSectorCID</span><span class="p">(</span><span class="nx">h</span> <span class="nx">PedersenHash</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Commitment_UnsealedSectorCID</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">)</span> <span class="nx">Commitment</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Commitment_SealedSectorCID</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">)</span> <span class="nx">Commitment</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeDataCommitment</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: make hash parameterizable
</span><span class="c1"></span>	<span class="nx">hash</span><span class="p">,</span> <span class="nx">path</span> <span class="o">:=</span> <span class="nf">BuildTree_SHA256Hash</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nx">hash</span><span class="p">),</span> <span class="nx">path</span>
<span class="p">}</span>

<span class="c1">// Compute CommP or CommD.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ComputeUnsealedSectorCID</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: check that len(data) &gt; minimum piece size and is a power of 2.
</span><span class="c1"></span>	<span class="nx">hash</span><span class="p">,</span> <span class="nx">treePath</span> <span class="o">:=</span> <span class="nf">BuildTree_SHA256Hash</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nx">hash</span><span class="p">),</span> <span class="nx">treePath</span>
<span class="p">}</span>

<span class="c1">// Utilities
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nx">bytes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">bytes</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">bytes</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">bytes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="nf">reverse</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">SetBytes</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bigIntFromBigEndianBytes</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">SetBytes</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// size is number of bytes to return
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">littleEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">z</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">bytes</span> <span class="o">:=</span> <span class="nx">z</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="nx">size</span><span class="p">]</span>
	<span class="nf">reverse</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">bytes</span>
<span class="p">}</span>

<span class="c1">// size is number of bytes to return
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">bigEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">z</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">z</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="nx">size</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">littleEndianBytesFromInt</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">z</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">z</span><span class="p">.</span><span class="nf">SetInt64</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="k">return</span> <span class="nf">littleEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bigEndianBytesFromInt</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">z</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">z</span><span class="p">.</span><span class="nf">SetInt64</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="k">return</span> <span class="nf">bigEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">littleEndianBytesFromUInt</span><span class="p">(</span><span class="nx">n</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">z</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">z</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="k">return</span> <span class="nf">littleEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bigEndianBytesFromUInt</span><span class="p">(</span><span class="nx">n</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">z</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">z</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">n</span><span class="p">))</span>
	<span class="k">return</span> <span class="nf">bigEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AsBytes_T</span><span class="p">(</span><span class="nx">t</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unimplemented for T&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AsBytes_UnsealedSectorCID</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unimplemented for UnsealedSectorCID&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AsBytes_SealedSectorCID</span><span class="p">(</span><span class="nx">CID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unimplemented for SealedSectorCID&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AsBytes_PieceCID</span><span class="p">(</span><span class="nx">CID</span> <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unimplemented for PieceCID&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">fromBytes_T</span><span class="p">(</span><span class="nx">_</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unimplemented for T&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">isPow2</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">n</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span><span class="o">&amp;</span><span class="p">(</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// FIXME: This does not belong in filproofs, and no effort is being made to ensure it has any particular properties.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RandomInt</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Randomness</span><span class="p">,</span> <span class="nx">nonce</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">limit</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="nx">nonceBytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">PutUint64</span><span class="p">(</span><span class="nx">nonceBytes</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">nonce</span><span class="p">))</span>
	<span class="nx">input</span> <span class="o">:=</span> <span class="nx">randomness</span>
	<span class="nx">input</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">nonceBytes</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">ranHash</span> <span class="o">:=</span> <span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">input</span><span class="p">[:])</span>
	<span class="nx">hashInt</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">ranHash</span><span class="p">)</span>
	<span class="nx">num</span> <span class="o">:=</span> <span class="nx">hashInt</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">hashInt</span><span class="p">,</span> <span class="nx">limit</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">num</span>
<span class="p">}</span>
</code></pre></div>





</article>

      

      
    </div>

    
  



  </main>

  
  
</body>

</html>
