<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Actors
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2f actors\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/proofs/">Proofs</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/networking/">Network</a>

<ul>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/network-protocols/">Specific Protocols</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><strong>Proofs</strong></p>

<ul>
<li><a href="../../docs/zigzag-circuit/">ZigZag</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Actors
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="filecoin-state-machine-actors">Filecoin State Machine Actors</h1>

<p>Any implementations of the Filecoin actors must be exactly byte for byte compatible with the go-filecoin actor implementations. The pseudocode below tries to capture the important logic, but capturing all the detail would require embedding exactly the code from go-filecoin, so for now, its simply informative pseudocode. The algorithms below are correct, and all implementations much match it (including go-filecoin), but details omitted from here should be looked for in the go-filecoin code.</p>

<p>This spec describes a set of actors that operate within the <a href="../state-machine">Filecoin State Machine</a>. All types are defined in <a href="../data-structures#basic-type-encodings">the basic type encoding spec</a>.</p>

<h2 id="actor-state">Actor State</h2>

<p>These below used <code>kindeded</code> representation, as the type can be inferred from the context, in which
they are used (<code>Actor</code> or <code>UnsignedMessage</code>).</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ActorState union <span class="o">{</span>
    <span class="p">|</span> InitActorState
    <span class="p">|</span> AccountActorState
    <span class="p">|</span> StorageMarketActorState
    <span class="p">|</span> StorageMinerActorState
    <span class="p">|</span> PaymentChannelBrokerActorState
    <span class="p">|</span> MultisigActorState
<span class="o">}</span> representation kinded

<span class="nb">type</span> ActorMethod union <span class="o">{</span>
    <span class="p">|</span> InitActorMethod
    <span class="p">|</span> AccountActorMethod
    <span class="p">|</span> StorageMarketActorMethod
    <span class="p">|</span> StorageMinerActorMethod
    <span class="p">|</span> PaymentChannelBrokerActorMethod
    <span class="p">|</span> MultisigActorMethod
<span class="o">}</span> representation kinded</code></pre></div>
<h2 id="system-actors">System Actors</h2>

<p>Some state machine actors are &lsquo;system&rsquo; actors that get instantiated in the genesis block, and have their IDs allocated at that point.</p>

<table>
<thead>
<tr>
<th>ID</th>
<th>Actor</th>
<th>Name</th>
</tr>
</thead>

<tbody>
<tr>
<td>0</td>
<td>InitActor</td>
<td>Network Init</td>
</tr>

<tr>
<td>1</td>
<td>AccountActor</td>
<td>Network Treasury</td>
</tr>

<tr>
<td>2</td>
<td>StorageMarketActor</td>
<td>Filecoin Storage Market</td>
</tr>

<tr>
<td>99</td>
<td>AccountActor</td>
<td>Burnt Funds</td>
</tr>
</tbody>
</table>

<h2 id="built-in-actors">Built In Actors</h2>

<h3 id="init-actor">Init Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;init&quot;&gt;</code></li>
</ul>

<p>The init actor is responsible for creating new actors on the filecoin network. This is a built-in actor and cannot be replicated. In the future, this actor will be responsible for loading new code into the system (for user programmable actors). ID allocation for user instantiated actors starts at 100. This means that <code>NextID</code> will initially be set to 100.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> InitActorState struct <span class="o">{</span>
    addressMap <span class="o">{</span>Address:ID<span class="o">}</span>&lt;Hamt&gt;
    nextId UInt
<span class="o">}</span>

<span class="nb">type</span> InitActorMethod union <span class="o">{</span>
    <span class="p">|</span> InitConstructor <span class="m">0</span>
    <span class="p">|</span> Exec <span class="m">1</span>
    <span class="p">|</span> GetIdForAddress <span class="m">2</span>
<span class="o">}</span> representation keyed</code></pre></div>
<h4 id="constructor"><code>Constructor</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> InitConstructor struct <span class="o">{</span>
<span class="o">}</span></code></pre></div>
<p><strong>Algorithm</strong></p>

<h4 id="exec"><code>Exec</code></h4>

<p>This method is the core of the <code>Init Actor</code>. It handles instantiating new actors and assigning them their IDs.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Exec struct <span class="o">{</span>
    <span class="c1">## Reference to the location at which the code of the actor to create is stored.</span>
    code <span class="p">&amp;</span>Code
    <span class="c1">## Parameters passed to the constructor of the actor.</span>
    params ActorMethod
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">code</span> <span class="o">&amp;</span><span class="nx">Code</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">ActorMethod</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="c1">// Get the actor ID for this actor.
</span><span class="c1"></span>    <span class="nx">actorID</span> <span class="p">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">NextID</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">NextID</span><span class="o">++</span>

    <span class="c1">// Make sure that only the actors defined in the spec can be launched.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">IsBuiltinActor</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch actor instance that is not a builtin actor&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Ensure that singeltons can be only launched once.
</span><span class="c1"></span>    <span class="c1">// TODO: do we want to enforce this? If so how should actors be marked as such?
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">IsSingletonActor</span><span class="p">(</span><span class="nx">code</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch another actor of this type&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// This generates a unique address for this actor that is stable across message
</span><span class="c1"></span>    <span class="c1">// reordering
</span><span class="c1"></span>    <span class="c1">// TODO: where do `creator` and `nonce` come from?
</span><span class="c1"></span>    <span class="nx">addr</span> <span class="o">:=</span> <span class="nx">VM</span><span class="p">.</span><span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span><span class="p">,</span> <span class="nx">nonce</span><span class="p">)</span>

    <span class="c1">// Set up the actor itself
</span><span class="c1"></span>    <span class="nx">actor</span> <span class="o">:=</span> <span class="nx">Actor</span><span class="p">{</span>
        <span class="nx">Code</span><span class="p">:</span>    <span class="nx">code</span><span class="p">,</span>
        <span class="nx">Balance</span><span class="p">:</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
        <span class="nx">Head</span><span class="p">:</span>    <span class="kc">nil</span><span class="p">,</span>
        <span class="nx">Nonce</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1">// The call to the actors constructor will set up the initial state
</span><span class="c1"></span>    <span class="c1">// from the given parameters, setting `actor.Head` to a new value when successfull.
</span><span class="c1"></span>    <span class="c1">// TODO: can constructors fail?
</span><span class="c1"></span>    <span class="nx">actor</span><span class="p">.</span><span class="nf">Constructor</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span>

    <span class="nx">VM</span><span class="p">.</span><span class="nx">GlobalState</span><span class="p">.</span><span class="nf">Set</span><span class="p">(</span><span class="nx">actorID</span><span class="p">,</span> <span class="nx">actor</span><span class="p">)</span>

    <span class="c1">// Store the mapping of address to actor ID.
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actorID</span>

    <span class="k">return</span> <span class="nx">addr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IsSingletonActor</span><span class="p">(</span><span class="nx">code</span> <span class="nx">Cid</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">code</span> <span class="o">==</span> <span class="nx">StorageMarketActor</span> <span class="o">||</span> <span class="nx">code</span> <span class="o">==</span> <span class="nx">InitActor</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// TODO: find a better home for this logic
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">VM</span> <span class="nx">VM</span><span class="p">)</span> <span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">nonce</span> <span class="nx">Integer</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">NewActorAddress</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="nx">creator</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">nonce</span><span class="p">.</span><span class="nf">BigEndianBytes</span><span class="p">()))</span>
<span class="p">}</span></code></pre></div>
<h4 id="getidforaddress"><code>GetIdForAddress</code></h4>

<p>This method allows for fetching the corresponding ID of a given Address</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">GetIdForAddress</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">addr</span> <span class="nx">Address</span>
<span class="p">}</span> <span class="nx">representation</span> <span class="nx">tuple</span></code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetIdForAddress</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
    <span class="nx">id</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">id</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">Fault</span><span class="p">(</span><span class="s">&#34;unknown address&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">id</span>
<span class="p">}</span></code></pre></div>
<h3 id="account-actor">Account Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;account&quot;&gt;</code></li>
</ul>

<p>The Account actor is the actor used for normal keypair backed accounts on the filecoin network.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> AccountActorState struct <span class="o">{</span>
    address Address
<span class="o">}</span>

<span class="nb">type</span> AccountActorMethod union <span class="o">{</span>
    <span class="p">|</span> AccountConstructor <span class="m">0</span>
    <span class="p">|</span> GetAddress <span class="m">1</span>
<span class="o">}</span> representation keyed

<span class="nb">type</span> AccountConstructor struct <span class="o">{</span>
<span class="o">}</span></code></pre></div>
<h4 id="getaddress"><code>GetAddress</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetAddress struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetAddress</span><span class="p">()</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">address</span>
<span class="p">}</span></code></pre></div>
<h3 id="storage-market-actor">Storage Market Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;smarket&quot;&gt;</code></li>
</ul>

<p>The storage market actor is the central point for the Filecoin storage market. It is responsible for registering new miners to the system, and maintaining the power table. The Filecoin storage market is a singleton that lives at a specific well-known address.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMarketActorState struct <span class="o">{</span>
    miners <span class="o">{</span>Address:Null<span class="o">}</span>&lt;Hamt&gt;
    totalStorage BytesAmount
<span class="o">}</span>

<span class="nb">type</span> StorageMarketActorMethod union <span class="o">{</span>
    <span class="p">|</span> StorageMarketConstructor <span class="m">0</span>
    <span class="p">|</span> CreateStorageMiner <span class="m">1</span>
    <span class="p">|</span> SlashConsensusFault <span class="m">2</span>
    <span class="p">|</span> UpdateStorage <span class="m">3</span>
    <span class="p">|</span> GetTotalStorage <span class="m">4</span>
    <span class="p">|</span> PowerLookup <span class="m">5</span>
    <span class="p">|</span> IsMiner <span class="m">6</span>
<span class="o">}</span> representation keyed</code></pre></div>
<h4 id="constructor-1"><code>Constructor</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMarketConstructor struct <span class="o">{</span>
<span class="o">}</span></code></pre></div>
<p><strong>Algorithm</strong></p>

<h4 id="createstorageminer"><code>CreateStorageMiner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> CreateStorageMiner struct <span class="o">{</span>
    worker Address
    sectorSize BytesAmount
    peerId PeerId
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CreateStorageMiner</span><span class="p">(</span><span class="nx">worker</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">SupportedSectorSize</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Unsupported sector size&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">newminer</span> <span class="o">:=</span> <span class="nx">InitActor</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">MinerActorCodeCid</span><span class="p">,</span> <span class="nf">EncodeParams</span><span class="p">(</span><span class="nx">pubkey</span><span class="p">,</span> <span class="nx">pledge</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">pid</span><span class="p">))</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">newminer</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">newminer</span>
<span class="p">}</span></code></pre></div>
<h4 id="slashconsensusfault"><code>SlashConsensusFault</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SlashConsensusFault struct <span class="o">{</span>
    block1 <span class="p">&amp;</span>Block
    block2 <span class="p">&amp;</span>Block
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">shouldSlash</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span> <span class="nx">BlockHeader</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// First slashing condition, blocks have the same ticket round
</span><span class="c1"></span>    <span class="k">if</span> <span class="nf">sameTicketRound</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="c1">// Second slashing condition, miner ignored own block when mining
</span><span class="c1"></span>    <span class="c1">// Case A: block2 could have been in block1&#39;s parent set but is not
</span><span class="c1"></span>    <span class="nx">block1ParentTipSet</span> <span class="o">:=</span> <span class="nf">parentOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">block1Parent</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block1ParentTipSet</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="nx">block2</span><span class="p">.</span><span class="nx">Height</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block1ParentTipSet</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="o">==</span> <span class="nx">block2</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="c1">// Case B: block1 could have been in block2&#39;s parent set but is not
</span><span class="c1"></span>    <span class="nx">block2ParentTipSet</span> <span class="o">:=</span> <span class="nf">parentOf</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">block2Parent</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block2ParentTipSet</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="nx">block1</span><span class="p">.</span><span class="nx">Height</span> <span class="o">&amp;&amp;</span>
        <span class="nx">block2ParentTipSet</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="o">==</span> <span class="nx">block1</span><span class="p">.</span><span class="nx">ParentCids</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SlashConsensusFault</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span> <span class="nx">BlockHeader</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">block1</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="o">||</span> <span class="p">!</span><span class="nf">ValidSignature</span><span class="p">(</span><span class="nx">block2</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid blocks&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span> <span class="o">!=</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;blocks must be from the same miner&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// see the &#34;Consensus Faults&#34; section of the faults spec (faults.md)
</span><span class="c1"></span>    <span class="c1">// for details on these slashing conditions.
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">shouldSlash</span><span class="p">(</span><span class="nx">block1</span><span class="p">,</span> <span class="nx">block2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;blocks do not prove a slashable offense&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">miner</span> <span class="o">:=</span> <span class="nf">AuthorOf</span><span class="p">(</span><span class="nx">block1</span><span class="p">)</span>

    <span class="c1">// TODO: Some of the slashed collateral should be paid to the slasher
</span><span class="c1"></span>
    <span class="c1">// Burn all of the miners collateral
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nf">BurnCollateral</span><span class="p">()</span>

    <span class="c1">// Remove the miner from the list of network miners
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
    <span class="nx">self</span><span class="p">.</span><span class="nf">UpdateStorage</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Power</span><span class="p">)</span>

    <span class="c1">// Now delete the miner (maybe this is a bit harsh, but i&#39;m okay with it for now)
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nf">SelfDestruct</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="updatestorage"><code>UpdateStorage</code></h4>

<p>UpdateStorage is used to update the global power table.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> UpdateStorage struct <span class="o">{</span>
    delta BytesAmount
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">delta</span> <span class="nx">BytesAmount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;update storage must only be called by a miner actor&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">TotalStorage</span> <span class="o">+=</span> <span class="nx">delta</span>
<span class="p">}</span></code></pre></div>
<h4 id="gettotalstorage"><code>GetTotalStorage</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetTotalStorage struct <span class="o">{</span>

<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetTotalStorage</span><span class="p">()</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">TotalStorage</span>
<span class="p">}</span></code></pre></div>
<h4 id="powerlookup"><code>PowerLookup</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PowerLookup struct <span class="o">{</span>
    miner Address
<span class="o">}</span> representation tuple
<span class="sb">````</span>

**Algorithm**

<span class="sb">```</span>go
func PowerLookup<span class="o">(</span>miner Address<span class="o">)</span> BytesAmount <span class="o">{</span>
    <span class="k">if</span> !self.Miners.Has<span class="o">(</span>miner<span class="o">)</span> <span class="o">{</span>
        Fatal<span class="o">(</span><span class="s2">&#34;miner not registered with storage market&#34;</span><span class="o">)</span>
    <span class="o">}</span>

    mact :<span class="o">=</span> LoadMinerActor<span class="o">(</span>miner<span class="o">)</span>

    <span class="k">return</span> mact.GetPower<span class="o">()</span>
<span class="o">}</span></code></pre></div>
<h4 id="isminer"><code>IsMiner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> IsMiner struct <span class="o">{</span>
    addr Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">IsMiner</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Miners</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h2 id="storage-miner-actor">Storage Miner Actor</h2>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;sminer&quot;&gt;</code></li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMinerActorState struct <span class="o">{</span>
    <span class="c1">## Account that owns this miner.</span>
    <span class="c1">## - Income and returned collateral are paid to this address.</span>
    <span class="c1">## - This address is also allowed to change the worker address for the miner.</span>
    owner Address

    <span class="c1">## Worker account for this miner.</span>
    <span class="c1">## This will be the key that is used to sign blocks created by this miner, and</span>
    <span class="c1">## sign messages sent on behalf of this miner to commit sectors, submit PoSts, and</span>
    <span class="c1">## other day to day miner activities.</span>
    worker Address

    <span class="c1">## Libp2p identity that should be used when connecting to this miner.</span>
    peerId PeerId

    <span class="c1">## Amount of space in each sector committed to the network by this miner.</span>
    sectorSize BytesAmount

    <span class="c1">## Collateral currently committed to live storage.</span>
    activeCollateral TokenAmount

    <span class="c1">## Collateral that is waiting to be withdrawn.</span>
    dePledgedCollateral TokenAmount

    <span class="c1">## Time at which the depledged collateral may be withdrawn.</span>
    dePledgeTime BlockHeight

    <span class="c1">## All sectors this miner has committed.</span>
    sectors SectorSet

    <span class="c1">## Sectors this miner is currently mining. It is only updated</span>
    <span class="c1">## when a PoSt is submitted (not as each new sector commitment is added).</span>
    provingSet SectorSet

    <span class="c1">## Sectors reported during the last PoSt submission as being &#39;done&#39;. The collateral</span>
    <span class="c1">## for them is still being held until the next PoSt submission in case early sector</span>
    <span class="c1">## removal penalization is needed.</span>
    nextDoneSet SectorSet

    <span class="c1">## Deals this miner has been slashed for since the last post submission.</span>
    arbitratedDeals CidSet

    <span class="c1">## Amount of power this miner has.</span>
    power UInt
<span class="o">}</span>

<span class="nb">type</span> StorageMinerActorMethod union <span class="o">{</span>
    <span class="p">|</span> StorageMinerConstructor <span class="m">0</span>
    <span class="p">|</span> CommitSector <span class="m">1</span>
    <span class="p">|</span> SubmitPost <span class="m">2</span>
    <span class="p">|</span> IncreasePledge <span class="m">3</span>
    <span class="p">|</span> SlashStorageFault <span class="m">4</span>
    <span class="p">|</span> GetCurrentProvingSet <span class="m">5</span>
    <span class="p">|</span> ArbitrateDeal <span class="m">6</span>
    <span class="p">|</span> DePledge <span class="m">7</span>
    <span class="p">|</span> GetOwner <span class="m">8</span>
    <span class="p">|</span> GetWorkerAddr <span class="m">9</span>
    <span class="p">|</span> GetPower <span class="m">10</span>
    <span class="p">|</span> GetPeerID <span class="m">11</span>
    <span class="p">|</span> GetSectorSize <span class="m">12</span>
    <span class="p">|</span> UpdatePeerID <span class="m">13</span>
    <span class="p">|</span> ChangeWorker <span class="m">14</span>
<span class="o">}</span> representation keyed</code></pre></div>
<h4 id="constructor-2"><code>Constructor</code></h4>

<p>Along with the call, the actor must be created with exactly enough filecoin for the collateral necessary for the pledge.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> StorageMinerConstructor struct <span class="o">{</span>
    worker Address
    sectorSize BytesAmount
    peerId PeerId
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">StorageMinerActor</span><span class="p">(</span><span class="nx">worker</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">pid</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">Owner</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nx">From</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">Worker</span> <span class="p">=</span> <span class="nx">worker</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">PeerID</span> <span class="p">=</span> <span class="nx">pid</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span> <span class="p">=</span> <span class="nx">sectorSize</span>
<span class="p">}</span></code></pre></div>
<h4 id="commitsector"><code>CommitSector</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> CommitSector struct <span class="o">{</span>
    sectorId SectorID
    commD Bytes
    commR Bytes
    commRStar Bytes
    proof SealProof
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>

<div class="notices todo" >TODO: ValidatePoRep, EnsureSectorIsUnique, CollateralForSector, Commitment</div>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">CommitSector</span><span class="p">(</span><span class="nx">sectorID</span> <span class="nx">SectorID</span><span class="p">,</span> <span class="nx">commD</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">commRStar</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">SealProof</span><span class="p">)</span> <span class="nx">SectorID</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">miner</span><span class="p">.</span><span class="nf">ValidatePoRep</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">comm</span><span class="p">,</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Worker</span><span class="p">,</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;bad proof!&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// make sure the miner isnt trying to submit a pre-existing sector
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">miner</span><span class="p">.</span><span class="nf">EnsureSectorIsUnique</span><span class="p">(</span><span class="nx">comm</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;sector already committed!&#34;</span><span class="p">)</span>
    <span class="p">}</span>

  <span class="c1">// Power of the miner after adding this sector
</span><span class="c1"></span>  <span class="nx">futurePower</span> <span class="p">=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">power</span> <span class="o">+</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span>
  <span class="nx">collateralRequired</span> <span class="p">=</span> <span class="nf">CollateralForPower</span><span class="p">(</span><span class="nx">futurePower</span><span class="p">)</span>

  <span class="k">if</span> <span class="nx">collateralRequired</span> <span class="p">&gt;</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">MyBalance</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not enough collateral&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// ensure that the miner cannot commit more sectors than can be proved with a single PoSt
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="nx">POST_SECTORS_COUNT</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;too many sectors&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nx">ActiveCollateral</span> <span class="o">+=</span> <span class="nx">coll</span>

    <span class="c1">// Note: There must exist a unique index in the miner&#39;s sector set for each
</span><span class="c1"></span>    <span class="c1">// sector ID. The `faults`, `recovered`, and `done` parameters of the
</span><span class="c1"></span>    <span class="c1">// SubmitPoSt method express indices into this sector set.
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">commD</span><span class="p">)</span>

    <span class="c1">// if miner is not mining, start their proving period now
</span><span class="c1"></span>    <span class="c1">// Note: As written here, every miners first PoSt will only be over one sector.
</span><span class="c1"></span>    <span class="c1">// We could set up a &#39;grace period&#39; for starting mining that would allow miners
</span><span class="c1"></span>    <span class="c1">// to submit several sectors for their first proving period. Alternatively, we
</span><span class="c1"></span>    <span class="c1">// could simply make the &#39;CommitSector&#39; call take multiple sectors at a time.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Note: Proving period is a function of sector size; small sectors take less
</span><span class="c1"></span>    <span class="c1">// time to prove than large sectors do. Sector size is selected when pledging.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingSet</span> <span class="p">=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span>
        <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="p">=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="o">+</span> <span class="nf">ProvingPeriodDuration</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CollateralForPower</span><span class="p">(</span><span class="nx">power</span> <span class="nx">BytesAmount</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
  <span class="nx">availableFil</span> <span class="p">=</span> <span class="nx">FakeGlobalMethods</span><span class="p">.</span><span class="nf">GetAvailableFil</span><span class="p">()</span>
  <span class="nx">totalNetworkPower</span> <span class="p">=</span> <span class="nx">StorageMinerActor</span><span class="p">.</span><span class="nf">GetTotalStorage</span><span class="p">()</span>
  <span class="nx">numMiners</span> <span class="p">=</span> <span class="nx">StorageMarket</span><span class="p">.</span><span class="nf">GetMinerCount</span><span class="p">()</span>
  <span class="nx">powerCollateral</span> <span class="p">=</span> <span class="nx">availableFil</span> <span class="o">*</span> <span class="nx">NetworkConstants</span><span class="p">.</span><span class="nx">POWER_COLLATERAL_PROPORTION</span> <span class="o">*</span> <span class="nx">power</span> <span class="o">/</span> <span class="nx">totalNetworkPower</span>
  <span class="nx">perCapitaCollateral</span> <span class="p">=</span> <span class="nx">availableFil</span> <span class="o">*</span> <span class="nx">NetworkConstants</span><span class="p">.</span><span class="nx">PER_CAPITA_COLLATERAL_PROPORTION</span> <span class="o">/</span> <span class="nx">numMiners</span>
  <span class="nx">collateralRequired</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nx">minerPowerCollateral</span> <span class="o">+</span> <span class="nx">minerPerCapitaCollateral</span><span class="p">)</span>
  <span class="k">return</span> <span class="nx">collateralRequired</span>
<span class="p">}</span></code></pre></div>
<h4 id="submitpost"><code>SubmitPoSt</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SubmitPost struct <span class="o">{</span>
    proofs <span class="o">[</span>PoStProof<span class="o">]</span>
    faults <span class="o">[</span>FaultSet<span class="o">]</span>
    recovered Bitfield
    <span class="k">done</span> Bitfield
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>

<div class="notices todo" >TODO: ValidateFaultSets, GenerationAttackTime, ComputeLateFee</div>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SubmitPost</span><span class="p">(</span><span class="nx">proofs</span> <span class="nx">PoStProof</span><span class="p">,</span> <span class="nx">faults</span> <span class="p">[]</span><span class="nx">FaultSet</span><span class="p">,</span> <span class="nx">recovered</span> <span class="nx">BitField</span><span class="p">,</span> <span class="nx">done</span> <span class="nx">BitField</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Worker</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized to submit post for miner&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// ensure recovered is a subset of the combined fault sets, and that done
</span><span class="c1"></span>    <span class="c1">// does not intersect with either, and that all sets only reference sectors
</span><span class="c1"></span>    <span class="c1">// that currently exist
</span><span class="c1"></span>    <span class="nx">allFaults</span> <span class="p">=</span> <span class="nf">AggregateBitfields</span><span class="p">(</span><span class="nx">faults</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">miner</span><span class="p">.</span><span class="nf">ValidateFaultSets</span><span class="p">(</span><span class="nx">faults</span><span class="p">,</span> <span class="nx">recovered</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;fault sets invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>


    <span class="kd">var</span> <span class="nx">feesRequired</span> <span class="nx">TokenAmount</span>

    <span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span><span class="o">+</span><span class="nf">GenerationAttackTime</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// TODO: determine what exactly happens here. Is the miner permanently banned?
</span><span class="c1"></span>        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Post submission too late&#34;</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="p">{</span>
        <span class="nx">feesRequired</span> <span class="o">+=</span> <span class="nf">ComputeLateFee</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">Power</span><span class="p">,</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span><span class="o">-</span><span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">feesRequired</span> <span class="o">+=</span> <span class="nf">ComputeTemporarySectorFailureFee</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">recovered</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span> <span class="p">&lt;</span> <span class="nx">feesRequired</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not enough funds to pay post submission fees&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// we want to ensure that the miner can submit more fees than required, just in case
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span> <span class="p">&gt;</span> <span class="nx">feesRequired</span> <span class="p">{</span>
        <span class="nf">Refund</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Value</span> <span class="o">-</span> <span class="nx">feesRequired</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">!</span><span class="nf">CheckPostProof</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">proof</span><span class="p">,</span> <span class="nx">faults</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;proof invalid&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// combine all the fault set bitfields, and subtract out the recovered
</span><span class="c1"></span>    <span class="c1">// ones to get the set of sectors permanently lost
</span><span class="c1"></span>    <span class="nx">permLostSet</span> <span class="p">=</span> <span class="nx">allFaults</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">recovered</span><span class="p">)</span>

    <span class="c1">// adjust collateral for &#39;done&#39; sectors
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nx">ActiveCollateral</span> <span class="o">-=</span> <span class="nf">CollateralForSectors</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">NextDoneSet</span><span class="p">)</span>

    <span class="c1">// penalize collateral for lost sectors
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nx">ActiveCollateral</span> <span class="o">-=</span> <span class="nf">CollateralForSectors</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">permLostSet</span><span class="p">)</span>

    <span class="c1">// burn funds for fees and collateral penalization
</span><span class="c1"></span>    <span class="nf">BurnFunds</span><span class="p">(</span><span class="nx">miner</span><span class="p">,</span> <span class="nf">CollateralForSectors</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">permLostSet</span><span class="p">)</span><span class="o">+</span><span class="nx">feesRequired</span><span class="p">)</span>

    <span class="c1">// update sector sets and proving set
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span>
    <span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">permLostSet</span><span class="p">)</span>

    <span class="c1">// update miner power to the amount of data actually proved during
</span><span class="c1"></span>    <span class="c1">// the last proving period.
</span><span class="c1"></span>    <span class="nx">oldPower</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Power</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nx">Power</span> <span class="p">=</span> <span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">-</span> <span class="nx">allFaults</span><span class="p">.</span><span class="nf">Count</span><span class="p">())</span> <span class="o">*</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="nx">StorageMarket</span><span class="p">.</span><span class="nf">UpdateStorage</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">Power</span> <span class="o">-</span> <span class="nx">oldPower</span><span class="p">)</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingSet</span> <span class="p">=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Sectors</span>

    <span class="c1">// NEEDS REVIEW: early submission of PoSts may give the miner extra time for
</span><span class="c1"></span>    <span class="c1">// their next PoSt, which could compound. Does the beacon reseeding for Posts
</span><span class="c1"></span>    <span class="c1">// address this well enough?
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="p">=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">+</span> <span class="nf">ProvingPeriodDuration</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">)</span>

    <span class="c1">// update next done set
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nx">NextDoneSet</span> <span class="p">=</span> <span class="nx">done</span>
    <span class="nx">miner</span><span class="p">.</span><span class="nx">ArbitratedDeals</span><span class="p">.</span><span class="nf">Clear</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ValidateFaultSets</span><span class="p">(</span><span class="nx">faults</span> <span class="p">[]</span><span class="nx">FaultSet</span><span class="p">,</span> <span class="nx">recovered</span><span class="p">,</span> <span class="nx">done</span> <span class="nx">BitField</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">aggregate</span> <span class="nx">BitField</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">fs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">faults</span> <span class="p">{</span>
        <span class="nx">aggregate</span> <span class="p">=</span> <span class="nx">aggregate</span><span class="p">.</span><span class="nf">Union</span><span class="p">(</span><span class="nx">fs</span><span class="p">.</span><span class="nx">BitField</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// all sectors marked recovered must have actually failed
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">recovered</span><span class="p">.</span><span class="nf">IsSubsetOf</span><span class="p">(</span><span class="nx">aggregate</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="c1">// the done set cannot intersect with the aggregated faults
</span><span class="c1"></span>    <span class="c1">// you can&#39;t mark a fault as &#39;done&#39;
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">aggregate</span><span class="p">.</span><span class="nf">Intersects</span><span class="p">(</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">aggregate</span><span class="p">.</span><span class="nf">Bits</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">miner</span><span class="p">.</span><span class="nf">HasSectorByID</span><span class="p">(</span><span class="nx">bit</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">bit</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">done</span><span class="p">.</span><span class="nf">Bits</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">miner</span><span class="p">.</span><span class="nf">HasSectorByID</span><span class="p">(</span><span class="nx">bit</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ProvingPeriodDuration</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">Integer</span> <span class="p">{</span>
    <span class="c1">// TODO: eventually, this needs to be different for different sector sizes
</span><span class="c1"></span>    <span class="c1">// The research team should give us concrete numbers
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1">// number of blocks in one day
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeLateFee</span><span class="p">(</span><span class="nx">power</span> <span class="nx">Integer</span><span class="p">,</span> <span class="nx">blocksLate</span> <span class="nx">Integer</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">4</span> <span class="c1">// TODO: real collateral calculation, obviously
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeTemporarySectorFailureFee</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">Integer</span><span class="p">)</span> <span class="nx">TokenAmount</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">4</span> <span class="c1">// TODO: something tells me that 4 might not work in all situations. probably should find a better way to compute this
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h4 id="slashstoragefault"><code>SlashStorageFault</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="c1">## TODO:</span>
<span class="nb">type</span> IncreasePledge struct <span class="o">{</span>

<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>

<div class="notices todo" >TODO</div>

<h4 id="slashstoragefault-1"><code>SlashStorageFault</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SlashStorageFault struct <span class="o">{</span>
    miner Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SlashStorageFault</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">SlashedAt</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner already slashed&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span><span class="o">+</span><span class="nf">GenerationAttackTime</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner is not yet tardy&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">.</span><span class="nf">Size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;miner is inactive&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Strip miner of their power
</span><span class="c1"></span>    <span class="nx">StorageMarketActor</span><span class="p">.</span><span class="nf">UpdateStorage</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Power</span><span class="p">)</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">Power</span> <span class="p">=</span> <span class="mi">0</span>

    <span class="c1">// TODO: make this less hand wavey
</span><span class="c1"></span>    <span class="nf">BurnCollateral</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">ConsensusCollateral</span><span class="p">)</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">SlashedAt</span> <span class="p">=</span> <span class="nx">CurrentBlockHeight</span>
<span class="p">}</span></code></pre></div>
<h4 id="getcurrentprovingset"><code>GetCurrentProvingSet</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetCurrentProvingSet struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetCurrentProvingSet</span><span class="p">()</span> <span class="p">[][]</span><span class="kt">byte</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ProvingSet</span>
<span class="p">}</span></code></pre></div>
<div class="notices note" ><strong>Note</strong>: this is unlikely to ever be called on-chain, and will be a very large amount of data. We should reconsider the need for a list of all sector commitments (maybe fixing with accumulators?)</div>

<h4 id="arbitratedeal"><code>ArbitrateDeal</code></h4>

<p>This may be called by anyone to penalize a miner for dropping the data of a deal they committed to before the deal expires. Note: in order to call this, the caller must have the signed deal between the client and the miner in question, this would require out of band communication of this information from the client to acquire.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ArbitrateDeal struct <span class="o">{</span>
    deal Deal
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AbitrateDeal</span><span class="p">(</span><span class="nx">d</span> <span class="nx">Deal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid signature on deal&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">CurrentBlockHeight</span> <span class="p">&lt;</span> <span class="nx">d</span><span class="p">.</span><span class="nx">StartTime</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Deal not yet started&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">Expiry</span> <span class="p">&lt;</span> <span class="nx">CurrentBlockHeight</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Deal is expired&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">NextDoneSet</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">PieceCommitment</span><span class="p">.</span><span class="nx">Sector</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Deal agreement not broken, or arbitration too late&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">ArbitratedDeals</span><span class="p">.</span><span class="nf">Has</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">PieceRef</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot slash miner twice for same deal&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">pledge</span><span class="p">,</span> <span class="nx">storage</span> <span class="o">:=</span> <span class="nf">CollateralForDeal</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>

    <span class="c1">// burn the pledge collateral
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nf">BurnFunds</span><span class="p">(</span><span class="nx">pledge</span><span class="p">)</span>

    <span class="c1">// pay the client the storage collateral
</span><span class="c1"></span>    <span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">ClientAddr</span><span class="p">,</span> <span class="nx">storage</span><span class="p">)</span>

    <span class="c1">// make sure the miner can&#39;t be slashed twice for this deal
</span><span class="c1"></span>    <span class="nx">self</span><span class="p">.</span><span class="nx">ArbitratedDeals</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">PieceRef</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<div class="notices todo" ><strong>TODO(scaling)</strong>: This method, as currently designed, must be called once per sector. If a miner agrees to store 1TB (1000 sectors) for a particular client, and loses all that data, the client must then call this method 1000 times, which will be really expensive.</div>

<h4 id="depledge"><code>DePledge</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> DePledge struct <span class="o">{</span>
    amount TokenAmount
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">DePledge</span><span class="p">(</span><span class="nx">amt</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Worker</span> <span class="o">&amp;&amp;</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">Owner</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Not authorized to call DePledge&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">&gt;</span> <span class="nx">CurrentBlockHeight</span> <span class="p">{</span>
            <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;too early to withdraw collateral&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nf">TransferFunds</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">Owner</span><span class="p">,</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">DePledgedCollateral</span><span class="p">)</span>
        <span class="nx">miner</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">miner</span><span class="p">.</span><span class="nx">DePledgedCollateral</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="k">return</span>
    <span class="p">}</span>

  <span class="nx">collateralRequired</span> <span class="p">=</span> <span class="nf">CollateralForPower</span><span class="p">(</span><span class="nx">miner</span><span class="p">.</span><span class="nx">power</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">amt</span> <span class="o">+</span> <span class="nx">collateralRequired</span> <span class="p">&gt;</span> <span class="nx">vm</span><span class="p">.</span><span class="nf">MyBalance</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Not enough free collateral to withdraw that much&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nx">DePledgedCollateral</span> <span class="p">=</span> <span class="nx">amt</span>
    <span class="nx">miner</span><span class="p">.</span><span class="nx">DePledgeTime</span> <span class="p">=</span> <span class="nx">CurrentBlockHeight</span> <span class="o">+</span> <span class="nx">DePledgeCooldown</span>
<span class="p">}</span></code></pre></div>
<h4 id="getowner"><code>GetOwner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetOwner struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetOwner</span><span class="p">()</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Owner</span>
<span class="p">}</span></code></pre></div>
<h4 id="getworkeraddr"><code>GetWorkerAddr</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetWorkerAddr struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetWorkerAddr</span><span class="p">()</span> <span class="nx">Address</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Worker</span>
<span class="p">}</span></code></pre></div>
<h4 id="getpower"><code>GetPower</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetPower struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetPower</span><span class="p">()</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Power</span>
<span class="p">}</span></code></pre></div>
<h4 id="getpeerid"><code>GetPeerID</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetPeerID struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetPeerID</span><span class="p">()</span> <span class="nx">PeerID</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">PeerID</span>
<span class="p">}</span></code></pre></div>
<h4 id="getsectorsize"><code>GetSectorSize</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> GetSectorSize struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">GetSectorSize</span><span class="p">()</span> <span class="nx">BytesAmount</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">SectorSize</span>
<span class="p">}</span></code></pre></div>
<h4 id="updatepeerid"><code>UpdatePeerID</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> UpdatePeerID struct <span class="o">{</span>
    peerId PeerId
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">UpdatePeerID</span><span class="p">(</span><span class="nx">pid</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Worker</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;only the mine worker may update the peer ID&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">PeerID</span> <span class="p">=</span> <span class="nx">pid</span>
<span class="p">}</span></code></pre></div>
<h4 id="changeworker"><code>ChangeWorker</code></h4>

<p>Changes the worker address. Note that since Sector Commitments take the miners worker key as an input, any sectors sealed with the old key but not yet submitted to the chain will be invalid. All future sectors must be sealed with the new worker key.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ChangeWorker struct <span class="o">{</span>
    addr Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChangeWorker</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Owner</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;only the owner can change the worker address&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Worker</span> <span class="p">=</span> <span class="nx">addr</span>
<span class="p">}</span></code></pre></div>
<h3 id="payment-channel-broker-actor">Payment Channel Broker Actor</h3>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> PaymentChannelBrokerActorState struct <span class="o">{</span>
<span class="o">}</span>

<span class="nb">type</span> PaymentChannelBrokerActorMethod union <span class="o">{</span>

<span class="o">}</span> representation keyed</code></pre></div>
<p>TODO</p>

<h3 id="multisig-account-actor">Multisig Account Actor</h3>

<ul>
<li><strong>Code Cid</strong>: <code>&lt;codec:raw&gt;&lt;mhType:identity&gt;&lt;&quot;multisig&quot;&gt;</code></li>
</ul>

<p>A basic multisig account actor. Allows sending of messages like a normal account actor, but with the requirement of M of N parties agreeing to the operation. Completed and/or cancelled operations stick around in the actors state until explicitly cleared out. Proposers may cancel transactions they propose, or transactions by proposers who are no longer approved signers.</p>

<p>Self modification methods (add/remove signer, change requirement) are called by
doing a multisig transaction invoking the desired method on the contract itself. This means the &lsquo;signature
threshold&rsquo; logic only needs to be implemented once, in one place.</p>

<p>The <a href="#init-actor">init actor</a> is used to create new instances of the multisig.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> MultisigActorState struct <span class="o">{</span>
    signers <span class="o">[</span>Address<span class="o">]</span>
    required UInt
    nextTxId UInt
    transactions <span class="o">{</span>UInt:Transaction<span class="o">}</span>
<span class="o">}</span>

<span class="nb">type</span> MultisigActorMethod union <span class="o">{</span>
    <span class="p">|</span> MultisigConstructor <span class="m">0</span>
    <span class="p">|</span> Propose <span class="m">1</span>
    <span class="p">|</span> Approve <span class="m">2</span>
    <span class="p">|</span> Cancel <span class="m">3</span>
    <span class="p">|</span> ClearCompleted <span class="m">4</span>
    <span class="p">|</span> AddSigner <span class="m">5</span>
    <span class="p">|</span> RemoveSigner <span class="m">6</span>
    <span class="p">|</span> SwapSigner <span class="m">7</span>
    <span class="p">|</span> ChangeRequirement <span class="m">8</span>
<span class="o">}</span> representation keyed

<span class="nb">type</span> Transaction struct <span class="o">{</span>
    created UInt
    txID UInt
    to Address
    value TokenAmount
    method <span class="p">&amp;</span>ActorMethod
    approved <span class="o">[</span>Address<span class="o">]</span>
    completed Bool
    canceled Bool
<span class="o">}</span></code></pre></div>
<h4 id="constructor-3"><code>Constructor</code></h4>

<p>This method sets up the initial state for the multisig account</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> MultisigConstructor struct <span class="o">{</span>
    <span class="c1">## The addresses that will be the signatories of this wallet.</span>
    signers <span class="o">[</span>Address<span class="o">]</span>
    <span class="c1">## The number of signatories required to perform a transaction.</span>
    required UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Multisig</span><span class="p">(</span><span class="nx">signers</span> <span class="p">[</span><span class="nx">Address</span><span class="p">],</span> <span class="nx">required</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span> <span class="p">=</span> <span class="nx">signers</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">=</span> <span class="nx">required</span>
<span class="p">}</span></code></pre></div>
<h4 id="propose"><code>Propose</code></h4>

<p>Propose is used to propose a new transaction to be sent by this multisig. The proposer must be a signer, and the proposal also serves as implicit approval from the proposer. If only a single signature is required, then the transaction is executed immediately.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Propose struct <span class="o">{</span>
    <span class="c1">## The address of the target of the proposed transaction.</span>
    to Address
    <span class="c1">## The amount of funds to send with the proposed transaction.</span>
    value TokenAmount
    <span class="c1">## The method and parameters that will be invoked on the proposed transactions target.</span>
    method <span class="p">&amp;</span>ActorMethod
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Propose</span><span class="p">(</span><span class="nx">to</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">String</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">txid</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">NextTxID</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">NextTxID</span><span class="o">++</span>

    <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">Transaction</span><span class="p">{</span>
        <span class="nx">TxID</span><span class="p">:</span>     <span class="nx">txid</span><span class="p">,</span>
        <span class="nx">To</span><span class="p">:</span>       <span class="nx">to</span><span class="p">,</span>
        <span class="nx">Value</span><span class="p">:</span>    <span class="nx">value</span><span class="p">,</span>
        <span class="nx">Method</span><span class="p">:</span>   <span class="nx">method</span><span class="p">,</span>
        <span class="nx">Params</span><span class="p">:</span>   <span class="nx">params</span><span class="p">,</span>
        <span class="nx">Approved</span><span class="p">:</span> <span class="p">[]</span><span class="nx">Address</span><span class="p">{</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>

    <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nx">vm</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Params</span><span class="p">)</span>
        <span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">txid</span>
<span class="p">}</span></code></pre></div>
<h4 id="approve"><code>Approve</code></h4>

<p>Approve is called by a signer to approve a given transaction. If their approval pushes the approvals for this transaction over the threshold, the transaction is executed.</p>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Approve struct <span class="o">{</span>
    <span class="c1">## The ID of the transaction to approve.</span>
    txid UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Approve</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nf">getTransaction</span><span class="p">(</span><span class="nx">txid</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction already completed&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction canceled&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">signer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">signer</span> <span class="o">==</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="p">{</span>
            <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;already signed this message&#34;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">{</span>
        <span class="nf">Send</span><span class="p">(</span><span class="nx">tx</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Params</span><span class="p">)</span>
        <span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="cancel"><code>Cancel</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Cancel struct <span class="o">{</span>
    txid UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Cancel</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nf">getTransaction</span><span class="p">(</span><span class="nx">txid</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Complete</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot cancel completed transaction&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;transaction already canceled&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">proposer</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Approved</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nx">proposer</span> <span class="o">!=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">&amp;&amp;</span> <span class="nf">isSigner</span><span class="p">(</span><span class="nx">proposer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot cancel another signers transaction&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">=</span> <span class="kc">true</span>
<span class="p">}</span></code></pre></div>
<h4 id="clearcompleted"><code>ClearCompleted</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ClearCompleted struct <span class="o">{</span>
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ClearCompleted</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">From</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;not authorized&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="nx">tx</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Completed</span> <span class="o">||</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Canceled</span> <span class="p">{</span>
            <span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">tx</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="addsigner"><code>AddSigner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> AddSigner struct <span class="o">{</span>
    signer Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">AddSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;add signer must be called by wallet itself&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;new address is already a signer&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="removesigner"><code>RemoveSigner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> RemoveSigner struct <span class="o">{</span>
    signer Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">RemoveSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;remove signer must be called by wallet itself&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;given address was not a signer&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">signer</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="swapsigner"><code>SwapSigner</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> SwapSigner struct <span class="o">{</span>
    old Address
    new Address
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SwapSigner</span><span class="p">(</span><span class="nx">old</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;swap signer must be called by wallet itself&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;given old address was not a signer&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nf">isSigner</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;given new address was already a signer&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">new</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="changerequirement"><code>ChangeRequirement</code></h4>

<p><strong>Parameters</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ChangeRequirement struct <span class="o">{</span>
    requirement UInt
<span class="o">}</span> representation tuple</code></pre></div>
<p><strong>Algorithm</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChangeRequirement</span><span class="p">(</span><span class="nx">req</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">From</span> <span class="o">!=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;change requirement must be called by wallet itself&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">req</span> <span class="p">&lt;</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;requirement must be at least 1&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">self</span><span class="p">.</span><span class="nx">Required</span> <span class="p">=</span> <span class="nx">req</span>
<span class="p">}</span></code></pre></div>
<h2 id="helper-methods">Helper Methods</h2>

<p>The various helper methods called above are defined here.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">isSigner</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">signer</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Signers</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">a</span> <span class="o">==</span> <span class="nx">signer</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">getTransaction</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">Transaction</span> <span class="p">{</span>
    <span class="nx">tx</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Transactions</span><span class="p">[</span><span class="nx">txid</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;no such transaction&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">tx</span>
<span class="p">}</span></code></pre></div>
</article>

      
<div class="align-center book-git-footer justify-between">
  
  <div>
    
    <a href="https://github.com/filecoin-project/specs/commit/9dcf16da57ae5577304bbf442808d35563add0aa" title='Last modified May 11, 2019 by dignifiedquire' target="_blank" rel="noopener">
      <img src="../../svg/code-merge.svg" alt="Changed" /> May 11, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/actors.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#filecoin-state-machine-actors">Filecoin State Machine Actors</a>
<ul>
<li><a href="#actor-state">Actor State</a></li>
<li><a href="#system-actors">System Actors</a></li>
<li><a href="#built-in-actors">Built In Actors</a>
<ul>
<li><a href="#init-actor">Init Actor</a>
<ul>
<li><a href="#constructor"><code>Constructor</code></a></li>
<li><a href="#exec"><code>Exec</code></a></li>
<li><a href="#getidforaddress"><code>GetIdForAddress</code></a></li>
</ul></li>
<li><a href="#account-actor">Account Actor</a>
<ul>
<li><a href="#getaddress"><code>GetAddress</code></a></li>
</ul></li>
<li><a href="#storage-market-actor">Storage Market Actor</a>
<ul>
<li><a href="#constructor-1"><code>Constructor</code></a></li>
<li><a href="#createstorageminer"><code>CreateStorageMiner</code></a></li>
<li><a href="#slashconsensusfault"><code>SlashConsensusFault</code></a></li>
<li><a href="#updatestorage"><code>UpdateStorage</code></a></li>
<li><a href="#gettotalstorage"><code>GetTotalStorage</code></a></li>
<li><a href="#powerlookup"><code>PowerLookup</code></a></li>
<li><a href="#isminer"><code>IsMiner</code></a></li>
</ul></li>
</ul></li>
<li><a href="#storage-miner-actor">Storage Miner Actor</a>
<ul>
<li>
<ul>
<li><a href="#constructor-2"><code>Constructor</code></a></li>
<li><a href="#commitsector"><code>CommitSector</code></a></li>
<li><a href="#submitpost"><code>SubmitPoSt</code></a></li>
<li><a href="#slashstoragefault"><code>SlashStorageFault</code></a></li>
<li><a href="#slashstoragefault-1"><code>SlashStorageFault</code></a></li>
<li><a href="#getcurrentprovingset"><code>GetCurrentProvingSet</code></a></li>
<li><a href="#arbitratedeal"><code>ArbitrateDeal</code></a></li>
<li><a href="#depledge"><code>DePledge</code></a></li>
<li><a href="#getowner"><code>GetOwner</code></a></li>
<li><a href="#getworkeraddr"><code>GetWorkerAddr</code></a></li>
<li><a href="#getpower"><code>GetPower</code></a></li>
<li><a href="#getpeerid"><code>GetPeerID</code></a></li>
<li><a href="#getsectorsize"><code>GetSectorSize</code></a></li>
<li><a href="#updatepeerid"><code>UpdatePeerID</code></a></li>
<li><a href="#changeworker"><code>ChangeWorker</code></a></li>
</ul></li>
<li><a href="#payment-channel-broker-actor">Payment Channel Broker Actor</a></li>
<li><a href="#multisig-account-actor">Multisig Account Actor</a>
<ul>
<li><a href="#constructor-3"><code>Constructor</code></a></li>
<li><a href="#propose"><code>Propose</code></a></li>
<li><a href="#approve"><code>Approve</code></a></li>
<li><a href="#cancel"><code>Cancel</code></a></li>
<li><a href="#clearcompleted"><code>ClearCompleted</code></a></li>
<li><a href="#addsigner"><code>AddSigner</code></a></li>
<li><a href="#removesigner"><code>RemoveSigner</code></a></li>
<li><a href="#swapsigner"><code>SwapSigner</code></a></li>
<li><a href="#changerequirement"><code>ChangeRequirement</code></a></li>
</ul></li>
</ul></li>
<li><a href="#helper-methods">Helper Methods</a></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
