<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Proofs
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.8ed296f7d0513f1357d39495dfefb38ccd496a6be349c5e1e3aea0248d053f46.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fproofs\2f "] {
      color: #0b3a53;
  }
  </style>

<ul>
<li><a href="../../"><strong>Overview</strong></a></li>
<li><strong>Core</strong>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography</li>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/proofs/">Proofs</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
<li><a href="../../docs/network-protocols/">Network</a></li>
<li><a href="../../docs/bootstrap/">Bootstrapping</a></li>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/sync/">Chain Sync</a></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a></li>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
<li><a href="../../docs/operation/">Node Operation</a></li>
</ul></li>
<li><a href="../../docs/actors/"><strong>Actors</strong></a>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul></li>
<li><a href="../../docs/client/"><strong>Client</strong></a></li>
<li><strong>Proofs</strong>

<ul>
<li><a href="../../docs/drgporep-circuit/">DrgPoRep</a></li>
<li><a href="../../docs/zigzag-circuit/">ZigZag</a></li>
</ul></li>
<li><a href="../../docs/definitions/"><strong>Glossary</strong></a></li>
<li><strong>Spec</strong>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Proofs
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="filecoin-proofs">Filecoin Proofs</h1>

<p>The Filecoin protocol requires a means of generating and verifying the following cryptographic proofs:</p>

<ul>
<li><strong><em>Proof of Replication</em></strong> proves that a unique copy of a given <strong><em>sector</em></strong> has been created. The <code>Seal</code> operation creates this unique copy and generates a corresponding <strong><em>Proof of Replication</em></strong>.</li>
<li><strong><em>Proof of Space-Time</em></strong> proves that an arbitrary number of <strong><em>sealed sectors</em></strong> existed over a specified period of time in their own dedicated storage — as opposed to being generated on-the-fly at proof time.</li>
<li><strong><em>Piece Inclusion Proof</em></strong> proves that a given <strong><em>piece</em></strong> is contained within a specified <strong><em>sealed sector</em></strong>.</li>
<li><strong><em>Proof of Retrievability</em></strong> is a merkle proof that a given challenged leaf is present in an extant <strong><em>sealed
sector</em></strong>.</li>
</ul>

<p>Throughout this document, the following definitions are used:</p>

<ul>
<li><strong><em>sector:</em></strong> a fixed-size block of data of <code>SECTOR_SIZE</code> bytes.

<ul>
<li><strong><em>piece:</em></strong> a block of data of at most <code>SECTOR_SIZE</code> bytes.</li>
</ul></li>
<li><strong><em>original data:</em></strong> the concatenation of a <strong><em>sector&rsquo;s</em></strong> constitutent pieces, all <strong><em>piece padding</em></strong>, and any <strong><em>terminal padding</em></strong>.</li>
<li><strong><em>unsealed sector:</em></strong> a concrete representation (on disk or in memory) of a sector&rsquo;s <strong><em>original data</em></strong>.</li>
<li><strong><em>sealed sector:</em></strong> a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an <strong><em>unsealed sector</em></strong>.</li>
<li><strong><em>piece padding:</em></strong> a block of zero or more &lsquo;zero bytes&rsquo; inserted between <strong><em>pieces</em></strong> to ensure they are positioned within the containing <strong><em>sector</em></strong> in a way compatible with the <strong><em>Piece Inclusion Proof</em></strong>.</li>
<li><strong><em>terminal padding:</em></strong> a block of zero or more &lsquo;zero bytes&rsquo; inserted after a <strong><em>sector&rsquo;s</em></strong> final piece, ensuring that the length of the <strong><em>original data</em></strong> is <code>SECTOR_BYTES</code>.</li>
<li><strong><em>preprocessing:</em></strong> a transformation applied to an <strong><em>unsealed sector</em></strong> as the first stage of sealing and which may increase the size of the data.</li>
<li><strong><em>preprocessed data:</em></strong> the result of <strong><em>preprocessing</em></strong> the <strong><em>original data</em></strong>.</li>
<li><strong><em>preprocessed sector:</em></strong> a concrete representation (on disk or in memory) of a <strong><em>sector&rsquo;s</em></strong> <strong><em>preprocessed data</em></strong>.</li>
<li><strong><em>SNARK proof:</em></strong> a block of bytes which proves that the creator is in possession of a satisfying assignment to a quadratic arithmetic program (<strong><em>circuit</em></strong>).</li>
<li><strong><em>merkle inclusion proof:</em></strong> a proof (whose format is unspecified here) that a given leaf block is contained within a merkle tree whose root is the <strong><em>commitment</em></strong> associated with the proof.</li>
<li><strong><em>commitment:</em></strong> an opaque block of data to which a prover &lsquo;commits&rsquo;, enabling subsequent proofs which cannot be validly constructed unless the <strong><em>commitment</em></strong> itself was validly constructed. For example: the output of a suitable pseudorandom collision-resistant hash function may serve as a <strong><em>commitment</em></strong> to the data which is the preimage of that hash. Publication of the <strong><em>commitment</em></strong> proves that the creator was in possession of the preimage at the time the <strong><em>commitment</em></strong> was generated.</li>
<li><strong><em>prover:</em></strong> the party who generates a proof.</li>
<li><strong><em>verifier:</em></strong> the party who verifies a proof generated by a <strong><em>prover</em></strong>.</li>
<li><strong><em>sectors count:</em></strong> the number of sectors over which a proof-of-spacetime is performed (<code>POST_SECTORS_COUNT</code>).</li>
</ul>

<h2 id="proof-of-replication">Proof of Replication</h2>

<p><strong><em>Proof of Replication</em></strong> generates a unique copy (<strong><em>sealed sector</em></strong>) of a <strong><em>sector&rsquo;s</em></strong> <strong><em>original data</em></strong>, a <strong><em>SNARK proof</em></strong>, and a set of <strong><em>commitments</em></strong> identifying the <strong><em>sealed sector</em></strong> and linking it to the corresponding <strong><em>unsealed sector</em></strong>.</p>

<h2 id="seal">Seal</h2>

<p><code>Seal</code> has the side effect of generating a <strong><em>sealed sector</em></strong> from an <strong><em>unsealed sector</em></strong>,  and returns identifying <strong><em>commitments</em></strong> and a <strong><em>SNARK proof</em></strong>. The proof returned is a <strong><em>SNARK proofs</em></strong>.</p>

<p>The commitments are used to verify that the correct <strong><em>original data</em></strong> was sealed, and that the correct <strong><em>sealed data</em></strong> is the subject of later <strong><em>Proofs of Space-Time</em></strong>, proving that this data is being stored continuously.</p>

<p><code>Seal</code> operates by performing a slow encoding of the <strong><em>unsealed sector</em></strong> — such that it is infeasible for a dishonest prover to computationally regenerate the <strong><em>sealed sector</em></strong> quickly enough to satisfy subsequent required <strong><em>Proofs of Space-Time</em></strong> — thus ensuring that the <strong><em>sealed sector</em></strong> remains manifest as a unique, concrete representation of the <strong><em>original data</em></strong>.</p>

<pre><code>Seal
 (
  // request represents a request to seal a sector.
  proverID       [31]byte,    // uniquely identifies miner
  sealedAccess   string,      // identifier providing access to sealed sector-access
  sectorID       [31]byte,    // uniquely identifies sector
  storage        SectorStore, // used to manipulate sectors
  unsealedAccess string       // identifier providing access to unsealed sector-access
 ) err Error | (
  // response contains the commitments resulting from a successful Seal().
  commD          [32]byte,                       // data commitment: merkle root of original data
  commR          [32]byte,                       // replica commitment: merkle root of replicated data [will be removed in future iteration]
  commRStar      [32]byte,                       // a hash of intermediate layers
  proof          []byte, 
 )

</code></pre>

<h3 id="verifyseal">VerifySeal</h3>

<p><code>VerifySeal</code> is the functional counterpart to <code>Seal</code>&rsquo;s proof component. It takes all of <code>Seal's</code> outputs, along with those of Seal&rsquo;s inputs which are required to uniquely identify the created <strong><em>sealed sector</em></strong>. This allows a <strong><em>verifier</em></strong> to determine whether a given proof is valid.  All inputs are required because verification requires sufficient context to determine not only that a proof is <em>valid</em> but also that the proof indeed corresponds to what it purports to prove.</p>

<pre><code>
VerifySeal
 (
  // request represents a request to verify the output of a Seal() operation.
  commD     [32]byte,                       // returned from Seal
  commR     [32]byte,                       // returned from Seal [will be removed in future iteration] 
  commRStar [32]byte,                       // returned from Seal
  proof     []byte,                         // returned from Seal
  proverID  [31]byte,                       // uniquely identifies miner
  sectorID  [31]byte,                       // uniquely identifies sector
) err Error | 
  IsValid bool                              // true iff the provided proof-of-replication os valid

</code></pre>

<h3 id="unseal">Unseal</h3>

<p><code>Unseal</code> is the counterpart to <code>Seal</code>&rsquo;s encoding side-effect. It reverses the &lsquo;slow encoding&rsquo; and creates an <strong><em>unsealed sector</em></strong> from a <strong><em>sealed sector</em></strong> as a special case of its more general function. In general, it allows extraction of a range of bytes (specified in terms of the layout of the <strong><em>original data</em></strong>).</p>

<pre><code>Unseal
 (
  // request represents a request to unseal a sector.
  numBytes      uint64,      // number of bytes to unseal (corresponds to contents of unsealed sector-file)
  outputAccess  string,      // identifier providing access to write unsealed file-bytes
  proverID      [31]byte,    // uniquely identifies miner
  sealedAccess  string,      // identifier providing access to sealed sector-file
  sectorID      [31]byte,    // uniquely identifies sector
  startOffset   uint64,      // zero-based byte offset in original, unsealed sector-file
  storage       SectorStore  // used to manipulate sectors
 ) err Error |
  NumBytesWritten uint64     // the number of bytes unsealed (and written) by Unseal()
</code></pre>

<h3 id="security-notes">Security Notes</h3>

<h4 id="guaranteeing-sector-uniqueness">Guaranteeing sector uniqueness</h4>

<p>Every sealed sector is unique, even if the unsealed data is identical. This prevents a malicious miner from storing the same sector twice without dedicating twice the amount of storage, or two malicious miners pretending to store the same sector, but only storing one copy. Sector uniqueness is guaranteed by having unique <code>proverId</code> and <code>sectorId</code>. Each miner has a unique <code>proverID</code>, and each sector has a unique <code>sectorID</code>within that miner&rsquo;s sectors. Taken together, <code>proverID</code> and <code>sectorID</code> are globally unique . Both the <code>proverId</code> and the <code>sectorId</code> are used to encode the sealed data.</p>

<p>The Filecoin node verifies that the correct <code>proverId</code> and <code>sectorId</code> is used when verifying the proof.</p>

<hr />

<h2 id="proof-of-space-time">Proof of Space-Time</h2>

<p><strong>NOTE:</strong> <strong><em>Proof of Space-Time</em></strong> is in transition. Current implementations are mocked, and the final design has not been implemented. Consumers may refer to the below for reference, but nothing should be implemented until the spec is updated and synchronized with what will be the canonical construction.</p>

<h3 id="generatepost">GeneratePost</h3>

<p><code>GeneratePoSt</code> generates a <strong><em>Proof of Space-Time</em></strong> over <code>POST_SECTORS_COUNT</code> <strong><em>sealed sectors</em></strong> — identified by their <code>commR</code> commitments. This is accomplished by performing a series of merkle inclusion proofs (<strong><em>Proofs of Retrievability</em></strong>). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo-randomly, based on the provided <code>challengeSeed</code>. At each time step, a number of <strong><em>Proofs of Retrievability</em></strong> are performed. The result of each such set of <strong><em>Proofs of Retrievability</em></strong> is used to seed challenge generation for another iteration. Repeated and necessarily sequential generation of these <strong><em>Proofs of Retrievability</em></strong> proves that the claimed <strong><em>sealed sectors</em></strong> existed during the time required to generate them.</p>

<p>Since many <strong><em>sealed sectors</em></strong> may be proved at once, it may be the case that one or more <strong><em>sealed sectors</em></strong> has been lost, damaged, or otherwise become impossible to validly prove. In this case, a fault is recorded and returned in an array of faults. This allows provers to selectively default on individual <strong><em>sealed sector</em></strong> proofs while still providing a verifiable proof of their aggregate <strong><em>Proof of Space-Time</em></strong> claims.</p>

<pre><code>GeneratePoSt
 (
  // request represents a request to generate a proof-of-spacetime.
  commRs         [POST_SECTORS_COUNT][32]byte,  // the commR commitments corresponding to the sealed sectors to prove
  challengeSeed  [32]byte,    // a pseudo-random value to be used in challenge generation
) err Error | (
  // response contains PoST proof and any faults that may have occurred.
  faults        []uint64,    // faults encountered while proving (by index of associated commR in the input) 
  proof         []byte
)
</code></pre>

<h3 id="verifypost">VerifyPoSt</h3>

<p><code>VerifyPoSt</code> is the functional counterpart to <code>GeneratePoSt</code>. It takes all of <code>GeneratePoSt</code>&rsquo;s output, along with those of <code>GeneratePost</code>&rsquo;s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.</p>

<pre><code>VerifyPoSt
 (
  // request represents a request to generate verify a proof-of-spacetime.
  commRs        [POST_SECTORS_COUNT][32]byte,        // the commRs provided to GeneratePoSt
  challengeSeed [32]byte,
  faults        []uint64
  proof         []byte,            // SNARK proof returned by GeneratePoSt 
 ) err Error | 
  isValid bool                     // true iff the provided Proof of Space-Time is valid
</code></pre>

<hr />

<h2 id="piece-inclusion-proof">Piece Inclusion Proof</h2>

<h3 id="pieceinclusionproof">PieceInclusionProof</h3>

<p>A <code>PieceInclusionProof</code> contains a merkle inclusion proof for the first and last node
of a piece. This ensures all &lsquo;edge&rsquo; hashes necessary to generate a complete merkle
tree are available.</p>

<p>Depending on the position of the nodes, not every hash provided will actually be needed.
As a space optimization, and at the cost of greater complexity in the encoding, &lsquo;interior&rsquo; nodes
of either path may be omitted –– provided that the implementation <code>InclusionProof</code> allows for this omission.</p>

<pre><code>struct PieceInclusionProof {
    FirstNodeProof  InclusionProof,
    LastNodeProof   InclusionProof,
}
</code></pre>

<h3 id="generatepieceinclusionproofs">GeneratePieceInclusionProofs</h3>

<p><code>GeneratePieceInclusionProofs</code> takes a merkle tree and a slice of piece lengths, and returns
a vector of <code>PieceInclusionProofs</code> corresponding to the pieces. This assumes that the first
piece begins at offset 0, and that each piece begins directly after the previous piece ends.
For this method to work, the piece data used to validate pieces will need to be padded as necessary,
and pieces will need to be aligned (to 128-byte chunks due to details of <strong><em>preprocessing</em></strong>) when written.</p>

<pre><code>GeneratePieceInclusionProofs
 (
  Tree MerkleTree,
  PieceLengths uint,
 ) []PieceInclusionProof
</code></pre>

<p><code>GeneratePieceInclusionProof</code> takes a merkle tree and the index positions of the first and last nodes
of the piece whose inclusion should be proved. It returns a corresponding <code>PieceInclusionProof</code>.
For the resulting proof to be valid, first_node must be &lt;= last_node.</p>

<pre><code>GeneratePieceInclusionProof
 (
  tree       MerkleTree,
  firstNode  uint,
  lastNode   uint,
 ) err Error | proof PieceInclusionProof
</code></pre>

<p><code>VerifyPieceInclusionProof</code> takes a merkle root and (pre-processed) piece data.
Iff it returns true, then <code>PieceInclusionProof</code> indeed proves that piece&rsquo;s
bytes were included in the merkle tree corresponding to root — and at the
position encoded in the proof.</p>

<pre><code>VerifyPieceInclusionProof
 (
  proof PieceInclusionProof,
  root  [32]byte,
  piece []byte
 ) err Error | IsValid bool // true iff the provided PieceInclusionProof is valid.
</code></pre>

</article>

      
<div class="align-center book-git-footer justify-between">
  
  <div>
    
    <a href="https://github.com/filecoin-project/specs/commit/9dcf16da57ae5577304bbf442808d35563add0aa" title='Last modified May 11, 2019 by dignifiedquire' target="_blank" rel="noopener">
      <img src="../../svg/code-merge.svg" alt="Changed" /> May 11, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/proofs.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#filecoin-proofs">Filecoin Proofs</a>
<ul>
<li><a href="#proof-of-replication">Proof of Replication</a></li>
<li><a href="#seal">Seal</a>
<ul>
<li><a href="#verifyseal">VerifySeal</a></li>
<li><a href="#unseal">Unseal</a></li>
<li><a href="#security-notes">Security Notes</a>
<ul>
<li><a href="#guaranteeing-sector-uniqueness">Guaranteeing sector uniqueness</a></li>
</ul></li>
</ul></li>
<li><a href="#proof-of-space-time">Proof of Space-Time</a>
<ul>
<li><a href="#generatepost">GeneratePost</a></li>
<li><a href="#verifypost">VerifyPoSt</a></li>
</ul></li>
<li><a href="#piece-inclusion-proof">Piece Inclusion Proof</a>
<ul>
<li><a href="#pieceinclusionproof">PieceInclusionProof</a></li>
<li><a href="#generatepieceinclusionproofs">GeneratePieceInclusionProofs</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
