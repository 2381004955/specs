<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Sync
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.a2c4f2c7363d7e4899b90033b962e5b296ac9e565ec3f1283651eb747746487a.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fsync\2f "] {
      color: #0b3a53;
  }
  </style>

<ul>
<li><a href="../../"><strong>Overview</strong></a></li>
<li><strong>Core</strong>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography</li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/proofs/">Proofs</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
<li><a href="../../docs/network-protocols/">Network</a></li>
<li><a href="../../docs/bootstrap/">Bootstrapping</a></li>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/sync/">Chain Sync</a></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a></li>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
<li><a href="../../docs/operation/">Node Operation</a></li>
</ul></li>
<li><a href="../../docs/actors/"><strong>Actors</strong></a>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul></li>
<li><a href="../../docs/client/"><strong>Client</strong></a></li>
<li><strong>Proofs</strong>

<ul>
<li><a href="../../docs/drgporep-circuit/">DrgPoRep</a></li>
<li><a href="../../docs/zigzag-circuit/">ZigZag</a></li>
</ul></li>
<li><a href="../../docs/definitions/"><strong>Glossary</strong></a></li>
<li><strong>Spec</strong>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Sync
  
</strong>
</header>

      
<article class="markdown">

<h1 id="chain-syncing">Chain Syncing</h1>

<p>This spec describes the Filecoin sync protocol, for related systems, see:</p>

<ul>
<li><a href="./bootstrap.md">Bootstrapping</a> which describes how a node builds a peer set in the first place.</li>
<li><a href="./network-protocols.md">Network Protocols</a> on how Filecoin nodes can communicate with each other, with for instance, an <a href="./network-protocols.md#hello-handshake">initial handshake</a>, or <a href="./network-protocols.md#blocksync">block syncing</a>.</li>
<li><a href="./operation.md">Operation</a> on various operations a functional Filecoin node needs to run, like <a href="./operation.md#dht-for-peer-routing.md">DHT routing</a>.</li>
</ul>

<h2 id="what-is-chain-syncing-in-filecoin">What is chain syncing in Filecoin?</h2>

<p>Chain syncing is the process a filecoin node runs to sync its internal chain state with new blocks from the network and new blocks it itself has mined.  A node syncs in two distinct modes: <code>syncing</code> and <code>caught up</code>.  Chain syncing updates both local storage of chain data and the head of the current heaviest observed chain.</p>

<p>&lsquo;Syncing&rsquo; mode and &lsquo;Caught up&rsquo; mode are two distinct processes. &lsquo;Syncing&rsquo; mode, or &lsquo;the initial sync&rsquo; is a process that is triggered when a node is far enough behind the rest of the network. This process terminates once the nodes &lsquo;head&rsquo; is    sufficiently far ahead. Once &lsquo;syncing&rsquo; is complete, the &lsquo;caught up&rsquo; sync process begins. This process keeps the node up to date with the rest of the network, and terminates only when the node is shut down.</p>

<h2 id="interface">Interface</h2>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Syncer</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// The heaviest known TipSet in the network.
</span><span class="c1"></span>	<span class="nx">head</span> <span class="nx">TipSet</span>

	<span class="c1">// The interface for accessing and putting TipSets into local storage
</span><span class="c1"></span>	<span class="nx">store</span> <span class="nx">ChainStore</span>

	<span class="c1">// The known genesis TipSet
</span><span class="c1"></span>	<span class="nx">genesis</span> <span class="nx">TipSet</span>

	<span class="c1">// the current mode the syncer is in
</span><span class="c1"></span>	<span class="nx">syncMode</span> <span class="nx">SyncMode</span>

	<span class="c1">// TipSets known to be invalid
</span><span class="c1"></span>	<span class="nx">bad</span> <span class="nx">BadTipSetCache</span>
    
  <span class="c1">// handle to the block sync service
</span><span class="c1"></span>  <span class="nx">bsync</span> <span class="nx">BlockSync</span>
    
  <span class="c1">//peer set
</span><span class="c1"></span>  <span class="nx">peerSet</span> <span class="p">[]</span><span class="nx">PeerID</span>
    
  <span class="c1">// peer heads
</span><span class="c1"></span>  <span class="c1">// Note: clear cache on disconnects
</span><span class="c1"></span>  <span class="nx">peerHeads</span> <span class="kd">map</span><span class="p">[</span><span class="nx">PeerID</span><span class="p">][]</span><span class="nx">Cid</span>
  
  <span class="nx">trustedPeers</span> <span class="p">[]</span><span class="nx">PeerID</span>
  <span class="nx">trustedHeads</span> <span class="kd">map</span><span class="p">[</span><span class="nx">PeerId</span><span class="p">][]</span><span class="nx">Cid</span>  
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">BootstrapPeerThreshold</span> <span class="p">=</span> <span class="mi">25</span>
<span class="kd">const</span> <span class="nx">DupThreshold</span> <span class="p">=</span> <span class="mi">10</span></code></pre></div>
<h2 id="general-operation">General Operation</h2>

<p>Whenever a node hears about a new head, it will sync to it as warranted. <code>InformNewHead()</code> is called both during bootstrapping and as peers send across new blocks.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// InformNewHead informs the syncer about a new potential TipSet
</span><span class="c1">// This should be called when connecting to new peers, and additionally
</span><span class="c1">// when receiving new blocks from the network
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">syncer</span> <span class="o">*</span><span class="nx">Syncer</span><span class="p">)</span> <span class="nf">InformNewHead</span><span class="p">(</span><span class="nx">from</span> <span class="nx">PeerID</span><span class="p">,</span> <span class="nx">head</span> <span class="nx">TipSet</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">syncMode</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">Bootstrap</span><span class="p">:</span>
    <span class="c1">// InformNewHead will only get called during PeerSetExpansion during bootstrapping
</span><span class="c1"></span>		<span class="k">go</span> <span class="nf">SyncBootstrap</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">CaughtUp</span><span class="p">:</span>
		<span class="k">go</span> <span class="nx">syncer</span><span class="p">.</span><span class="nf">SyncCaughtUp</span><span class="p">(</span><span class="nx">blk</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// SyncBootstrap is used to synchronise your chain when first joining
</span><span class="c1">// the network, or when rejoining after significant downtime.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">syncer</span> <span class="o">*</span><span class="nx">Syncer</span><span class="p">)</span> <span class="nf">SyncBootstrap</span><span class="p">(</span><span class="kt">bool</span> <span class="nx">expanding</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">syncer</span><span class="p">.</span><span class="nx">syncLock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">syncLock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">if</span> <span class="nx">expanding</span> <span class="o">&amp;&amp;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">syncer</span><span class="p">.</span><span class="nx">peerHeads</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">BootstrapPeerThreshold</span> <span class="p">{</span>
        <span class="c1">// not enough peers to sync yet...
</span><span class="c1"></span>        <span class="k">return</span>
    <span class="p">}</span>
  
  	<span class="nx">syncPeers</span> <span class="o">:=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">peerSet</span>
  	<span class="nx">syncHeads</span> <span class="o">:=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">peerHeads</span>
  	<span class="k">if</span> <span class="p">(!</span><span class="nx">expanding</span><span class="p">)</span> <span class="p">{</span>
    		<span class="nx">syncPeers</span> <span class="p">=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">trustedPeers</span>
      	<span class="nx">syncHeads</span> <span class="p">=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">trustedHeads</span>
  	<span class="p">}</span>
  	<span class="c1">// Will now get heaviest head from all the heads from our Peerset
</span><span class="c1"></span>    <span class="nx">selectedHead</span> <span class="o">:=</span> <span class="nf">selectHead</span><span class="p">(</span><span class="nx">syncer</span><span class="p">.</span><span class="nx">peerHeads</span><span class="p">)</span>
    
    <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">selectedHead</span>
    <span class="kd">var</span> <span class="nx">blockSet</span> <span class="nx">BlockSet</span>
    <span class="k">for</span> <span class="nx">head</span><span class="p">.</span><span class="nf">Height</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// NB: GetBlocks validates that the blocks are in-fact the ones we
</span><span class="c1"></span>        <span class="c1">// requested, and that they are correctly linked to each other. It does
</span><span class="c1"></span>        <span class="c1">// not validate any state transitions
</span><span class="c1"></span>        <span class="nx">blks</span> <span class="o">:=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">bsync</span><span class="p">.</span><span class="nf">GetBlocks</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="nx">RequestWidth</span><span class="p">)</span>
        <span class="nx">blockSet</span><span class="p">.</span><span class="nf">Insert</span><span class="p">(</span><span class="nx">blks</span><span class="p">)</span>
            
        <span class="nx">head</span> <span class="p">=</span> <span class="nx">blks</span><span class="p">.</span><span class="nf">Last</span><span class="p">().</span><span class="nf">Parents</span><span class="p">()</span>
    <span class="p">}</span>
        
    <span class="c1">// Fetch all the messages for all the blocks in this chain
</span><span class="c1"></span>    <span class="c1">// There are many ways to make this more efficient. For now, do the dumb thing
</span><span class="c1"></span>    <span class="nx">blockSet</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="nx">Block</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// FetchMessages should use bitswap to fetch any messages we don&#39;t have locally
</span><span class="c1"></span>        <span class="nf">FetchMessages</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
    <span class="p">})</span>
  
  	<span class="c1">// Ensure that the selectedHead has the right genesis block
</span><span class="c1"></span>  	<span class="c1">// Should be checked for trusted nodes in InitialConnect() and for
</span><span class="c1"></span>  	<span class="c1">// all others in addPeerToSet(), but we leave details up to impl.
</span><span class="c1"></span>  	<span class="nx">selectedGenesis</span> <span class="o">:=</span> <span class="nx">blockSet</span><span class="p">.</span><span class="nf">GetByHeight</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	  <span class="nf">assert</span><span class="p">(</span><span class="nx">selectedGenesis</span> <span class="o">==</span> <span class="nx">genesis</span><span class="p">,</span> <span class="s">&#34;State failure: trying to sync to wrong chain&#34;</span><span class="p">)</span>
    
    <span class="c1">// Now, to validate some state transitions
</span><span class="c1"></span>    <span class="nx">base</span> <span class="o">:=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">genesis</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">selectedHead</span><span class="p">.</span><span class="nf">Height</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">next</span> <span class="o">:=</span> <span class="nx">blockSet</span><span class="p">.</span><span class="nf">GetByHeight</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateTransition</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// TODO: do something productive here...
</span><span class="c1"></span>            <span class="nf">Error</span><span class="p">(</span><span class="s">&#34;invalid state transition&#34;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nx">blockSet</span><span class="p">.</span><span class="nf">PersistTo</span><span class="p">(</span><span class="nx">syncer</span><span class="p">.</span><span class="nx">store</span><span class="p">)</span>
    <span class="nx">syncer</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">bset</span><span class="p">.</span><span class="nf">Head</span><span class="p">()</span>
    <span class="nx">syncer</span><span class="p">.</span><span class="nx">syncMode</span> <span class="p">=</span> <span class="nx">CaughtUp</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">selectHead</span><span class="p">(</span><span class="nx">heads</span> <span class="kd">map</span><span class="p">[</span><span class="nx">PeerID</span><span class="p">]</span><span class="nx">TipSet</span><span class="p">)</span> <span class="nx">TipSet</span> <span class="p">{</span>
    <span class="nx">headsArr</span> <span class="o">:=</span> <span class="nf">toArray</span><span class="p">(</span><span class="nx">heads</span><span class="p">)</span>
    <span class="nx">sel</span> <span class="o">:=</span> <span class="nx">headsArr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">headsArr</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">cur</span> <span class="o">:=</span> <span class="nx">headsArr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">IsAncestorOf</span><span class="p">(</span><span class="nx">sel</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">sel</span><span class="p">.</span><span class="nf">IsAncestorOf</span><span class="p">(</span><span class="nx">cur</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">sel</span> <span class="p">=</span> <span class="nx">cur</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        
        <span class="nx">nca</span> <span class="o">:=</span> <span class="nf">NearestCommonAncestor</span><span class="p">(</span><span class="nx">cur</span><span class="p">,</span> <span class="nx">sel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">sel</span><span class="p">.</span><span class="nf">Height</span><span class="p">()</span> <span class="o">-</span> <span class="nx">nca</span><span class="p">.</span><span class="nf">Height</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">ForkLengthThreshold</span> <span class="p">{</span>
        	<span class="c1">// TODO: handle this better than refusing to sync
</span><span class="c1"></span>        	<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Conflict exists in heads set&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="nx">cur</span><span class="p">.</span><span class="nf">Weight</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">sel</span><span class="p">.</span><span class="nf">Weight</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">sel</span> <span class="p">=</span> <span class="nx">cur</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">sel</span>
<span class="p">}</span>

<span class="c1">// SyncCaughtUp is used to stay in sync once caught up to
</span><span class="c1">// the rest of the network.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">syncer</span> <span class="o">*</span><span class="nx">Syncer</span><span class="p">)</span> <span class="nf">SyncCaughtUp</span><span class="p">(</span><span class="nx">maybeHead</span> <span class="nx">TipSet</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">chain</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nf">collectChainCaughtUp</span><span class="p">(</span><span class="nx">maybeHead</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// possibleTs enumerates possible tipsets that are the union
</span><span class="c1"></span>	<span class="c1">// of tipsets from the chain and the store
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ts</span> <span class="o">:=</span> <span class="k">range</span> <span class="nf">possibleTs</span><span class="p">(</span><span class="nx">chain</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">consensus</span><span class="p">.</span><span class="nf">Validate</span><span class="p">(</span><span class="nx">ts</span><span class="p">,</span> <span class="nx">store</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">err</span>
		<span class="p">}</span>
		<span class="nx">syncer</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">PutTipSet</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">consenus</span><span class="p">.</span><span class="nf">Weight</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">consensus</span><span class="p">.</span><span class="nf">Weight</span><span class="p">(</span><span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">syncer</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">ts</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">syncer</span> <span class="o">*</span><span class="nx">Syncer</span><span class="p">)</span> <span class="nf">collectChainCaughtUp</span><span class="p">(</span><span class="nx">maybeHead</span> <span class="nx">TipSet</span><span class="p">)</span> <span class="p">(</span><span class="nx">Chain</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// fetch TipSet and messages via bitswap
</span><span class="c1"></span>	<span class="nx">ts</span> <span class="o">:=</span> <span class="nf">tipsetFromCidOverNet</span><span class="p">(</span><span class="nx">newHead</span><span class="p">)</span> 

	<span class="kd">var</span> <span class="nx">chain</span> <span class="nx">Chain</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">consensus</span><span class="p">.</span><span class="nf">Punctual</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">syncer</span><span class="p">.</span><span class="nx">bad</span><span class="p">.</span><span class="nf">InvalidateChain</span><span class="p">(</span><span class="nx">chain</span><span class="p">)</span>
			<span class="nx">syncer</span><span class="p">.</span><span class="nx">bad</span><span class="p">.</span><span class="nf">InvalidateTipSet</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;TipSet forks too far back from head&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">chain</span><span class="p">.</span><span class="nf">InsertFront</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span>

		<span class="k">if</span> <span class="nx">syncer</span><span class="p">.</span><span class="nx">store</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">ts</span><span class="p">)</span> <span class="p">{</span> 
			<span class="c1">// Store has record of this TipSet.
</span><span class="c1"></span>			<span class="k">return</span> <span class="nx">chain</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">parent</span> <span class="o">:=</span> <span class="nx">ts</span><span class="p">.</span><span class="nf">ParentCid</span><span class="p">()</span>
		<span class="nx">ts</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">tipsetFromCidOverNet</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h2 id="syncing-mode">Syncing Mode</h2>

<p>A filecoin node syncs in <code>syncing</code> mode when entering the network for the first time, or after being separated for a sufficiently long period of time.  The exact period of time comes from the consensus protocol (TODO specify more concretely, for example how does this relate to the consensus.Punctual method?).</p>

<p>During <code>syncing</code> mode a node learns about the newest head of the blockchain through the secure bootstrapping protocol. The syncing protocol then syncs the block headers for that entire chain, and validates their linking. It then fetches all the messages for the chain, and checks all the state transitions between the blocks and that the blocks were correctly created.  If validation passes the node&rsquo;s head is updated to the head TipSet received from bootstrapping.</p>

<p>In this mode of operation a filecoin node should not mine or send messages as it will not be able to successfully generate heaviest blocks or reference the correct state of the chain to verify that messages will execute as expected.</p>

<p>(TODO: should include discussion of a <code>Load()</code> call to make use of existing chain data on a node during &ldquo;re-awakening&rdquo; case of <code>syncing</code> mode.)</p>

<h2 id="caught-up-mode">Caught Up Mode</h2>

<p>A filecoin node syncs in <code>caught up</code> mode after completing <code>syncing</code> mode. A node stays in this mode until it is shut down. New block cids are gossiped from the network through the hello protocol or the network&rsquo;s <a href="data-propagation.md#block-propagation">block pubsub protocol</a>. A node also obtains new block cids coming from its own successfully mined blocks.  These cids are input to the <code>caught up</code> syncing protocol.  If these cids belong to a TipSet already in the store then they are already synced and the syncing protocol finishes.  If not the syncing protocol resolves the TipSet corresponding to the input cids.  It checks that this TipSet is not in its badTipSet cache, and that this TipSet is not too far back in the chain using the consensus <code>Punctual</code> method.  It then resolves the parent TipSet by reading off the parent cids in the header of any block of the TipSet.  The above procedure repeats until either an error is found or the store contains the next TipSet.  In the case of an error bad TipSets and their children not already in the bad TipSet cache are added to the cache before the call to <code>collectTipSetCaughtUp</code> returns.</p>

<p>After collecting a chain up to an ancestor TipSet that was previously synced to the store the syncing protocol checks each TipSet of the new chain for validity one by one.  When the filecoin network runs Expected Consensus, or any other multiple parents consensus protocol, the syncing protocol must consider not only the TipSets in the new chain but also possible new-heaviest TipSets that are the union of TipSets in the new chain and TipSets already in the store.  In the case of Expected Consensus there is at most one such TipSet: the TipSet made up of the union of the first new TipSet in the new chain being synced and the largest TipSet with the same parents kept in the store.</p>

<p>To sync new TipSets the <code>caught up</code> syncing protocol first runs a consensus validation check on the TipSet.  If any TipSet is invalid the syncing protocol finishes.  If a TipSet is valid the syncer adds the TipSet to the chain store.  The syncing protocol then checks whether the TipSet is heavier than the current head using the consensus weighting rules.  If it is heavier the chain updates the state of the node to account for the new heaviest TipSet.</p>

<h2 id="maintaining-a-fresh-peer-set">Maintaining a fresh Peer Set</h2>

<p>Syncing depends on the validity of a node&rsquo;s peer set. In order to ensure that the peer set remains representative of the network&rsquo;s state after bootstrap, a node should replace peers as peers disconnect. (TODO in future: cycle through peers on regular basis).</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// triggered when a peer disconnects
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">syncer</span> <span class="o">*</span><span class="nx">Syncer</span><span class="p">)</span> <span class="nf">replacePeer</span><span class="p">(</span><span class="nx">peer</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">delete</span><span class="p">(</span><span class="nx">syncer</span><span class="p">.</span><span class="nx">PeerSet</span><span class="p">,</span> <span class="nx">peer</span><span class="p">)</span>
    <span class="nb">delete</span><span class="p">(</span><span class="nx">syncer</span><span class="p">.</span><span class="nx">PeerHeads</span><span class="p">,</span> <span class="nx">peer</span><span class="p">)</span>
            
  	<span class="nx">newPeer</span> <span class="o">:=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nf">getRandomPeer</span><span class="p">()</span>
  	<span class="c1">// addPeerToSet will validate this peer (i.e. check it has right genesis, etc.)
</span><span class="c1"></span>  	<span class="nx">while</span> <span class="p">!</span><span class="nx">syncer</span><span class="p">.</span><span class="nf">addPeerToSet</span><span class="p">(</span><span class="nx">newPeer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">newPeer</span> <span class="p">=</span> <span class="nx">syncer</span><span class="p">.</span><span class="nf">getRandomPeer</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">ownID</span><span class="p">)</span>
  	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">syncer</span> <span class="o">*</span><span class="nx">Syncer</span><span class="p">)</span> <span class="nf">getRandomPeer</span><span class="p">(</span><span class="nx">from</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="nx">newPeer</span> <span class="nx">PeerID</span> <span class="p">{</span>
  	<span class="nx">wantedPeer</span> <span class="o">:=</span> <span class="nf">generateRandomNodeID</span><span class="p">()</span>
    <span class="c1">// libp2p&#39;s GetClosestPeers gets back k nearest peers, ordered
</span><span class="c1"></span>    <span class="nx">peers</span> <span class="o">:=</span> <span class="nx">dht</span><span class="p">.</span><span class="nf">GetClosestPeers</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">wantedPeer</span><span class="p">)</span>
	  <span class="c1">// We only use the nearest to get a good random peer
</span><span class="c1"></span>    <span class="nx">newPeer</span> <span class="o">:=</span> <span class="nx">peers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">return</span> <span class="nx">newPeer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">syncer</span> <span class="o">*</span><span class="nx">Syncer</span><span class="p">)</span> <span class="nf">addPeerToSet</span><span class="p">(</span><span class="nx">newPeer</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  	<span class="c1">// verify new peer to check whether to include in peerSet
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nx">peerSet</span><span class="p">.</span><span class="nf">contains</span><span class="p">(</span><span class="nx">newPeer</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">peerChain</span> <span class="o">:=</span> <span class="nf">sayHello</span><span class="p">(</span><span class="nx">newPeer</span><span class="p">)</span>
      
      <span class="k">if</span> <span class="nx">peerChain</span><span class="p">.</span><span class="nx">GenesisHash</span> <span class="o">==</span> <span class="nx">GENESIS</span> <span class="o">||</span> <span class="nx">trustedPeer</span><span class="p">.</span><span class="nf">isAncestorOf</span><span class="p">(</span><span class="nx">newPeer</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span><span class="p">.</span><span class="nx">peerSet</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">peerSet</span><span class="p">,</span> <span class="nx">newPeer</span><span class="p">)</span>
        <span class="nx">s</span><span class="p">.</span><span class="nf">InformNewHead</span><span class="p">(</span><span class="nx">newPeer</span><span class="p">,</span> <span class="nx">trustedChain</span><span class="p">.</span><span class="nx">HeaviestTipSet</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">true</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span></code></pre></div>
<h1 id="dependencies">Dependencies</h1>

<p>Things that affect the chain syncing protocol.</p>

<p><strong>Consensus protocol</strong>
- The consensus protocol should define a punctual function: <code>func Punctual([]TipSet chain) bool</code>. <code>Punctual(chain) == true</code> when a provided chain does not fork from the node&rsquo;s view of the current best chain &lsquo;too far in the past&rsquo;, and false otherwise.
- The fork selection rule.  This includes the weighting function.  As part of this in the context of EC the syncer must consider TipSets that are the union of independently propagated TipSets.</p>

<p><strong>Chain storage</strong></p>

<ul>
<li>The current chain syncing protocol requires that the chain store never stores an invalid TipSet.</li>
</ul>

<h1 id="open-questions">Open Questions</h1>

<ul>
<li>Secure bootstrapping in <code>syncing</code> mode</li>
<li>How do we handle the lag between the initial head bootstrapped in <code>syncing</code> mode and the network head once the first <code>SyncBootstrap</code> call is complete?  Likely we&rsquo;ll need multiple <code>SyncBootstrap</code> calls.  Should they be parallelized?</li>
<li>The properties of the chain store implementation have significant impact on the design of the syncing protocol and the syncing protocol&rsquo;s resistance to Denial Of Service (DOS) attacks.  For example if the chain store naively keeps all blocks in storage nodes are more vulnerable to running out of space.  As another example the syncer assumes that the store always contains a punctual ancestor of the heaviest chain. Should the spec grow to include properties of chain storage so that the syncing protocol can guarantee a level of DOS resistance?  Should chain storage be completely up to the implementation?  Should the chain storage spec be a part of the syncing protocol?<br /></li>
</ul>
</article>

      
<div class="align-center book-git-footer justify-end">
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/content/docs/sync.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#chain-syncing">Chain Syncing</a>
<ul>
<li><a href="#what-is-chain-syncing-in-filecoin">What is chain syncing in Filecoin?</a></li>
<li><a href="#interface">Interface</a></li>
<li><a href="#general-operation">General Operation</a></li>
<li><a href="#syncing-mode">Syncing Mode</a></li>
<li><a href="#caught-up-mode">Caught Up Mode</a></li>
<li><a href="#maintaining-a-fresh-peer-set">Maintaining a fresh Peer Set</a></li>
</ul></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#open-questions">Open Questions</a></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
