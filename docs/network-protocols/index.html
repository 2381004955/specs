<!DOCTYPE html>




<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  
    
    Network Protocols
  
 | Filecoin Spec</title>



<link rel="stylesheet" href="../../book.min.23e4d1e3709b51090814a78569072de166323089d7e859dbabb823c874bdc20d.css">


<link rel="icon" href="../../favicon.png" type="image/x-icon">


<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="../../css/syntax.css">
<link href="../../mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="../../mermaid/mermaid.js"></script>

</head>

<body>
  <input type="checkbox" style="display: none" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav role="navigation">
<h2 class="book-brand">
  <a href="https://filecoin-project.github.io/specs/">Filecoin Spec</a>
</h2>



    
  
  
  

  <style>
  nav ul a[href$="\2f docs\2fnetwork-protocols\2f "] {
      color: #0b3a53;
  }
  </style>

<p><a href="../../"><strong>Overview</strong></a></p>

<p><strong>Core</strong></p>

<ul>
<li><a href="../../docs/data-structures/">Data Structures</a></li>
<li>Cryptography

<ul>
<li><a href="../../docs/address/">Address</a></li>
<li><a href="../../docs/signatures/">Signatures</a></li>
<li><a href="../../docs/proofs/">Proofs</a></li>
<li><a href="../../docs/validation/">Block Validation</a></li>
</ul></li>
<li><a href="../../docs/network-protocols/">Network</a>

<ul>
<li><a href="../../docs/bootstrap/">Bootstrapping</a></li>
<li><a href="../../docs/data-propagation/">Data Propagation</a></li>
<li><a href="../../docs/sync/">Chain Sync</a></li>
</ul></li>
<li><a href="../../docs/expected-consensus/">Expected Consensus</a></li>
<li><a href="../../docs/state-machine/">State Machine</a>

<ul>
<li><a href="../../docs/local-storage/">Local Storage</a></li>
</ul></li>
<li><a href="../../docs/operation/">Node Operation</a></li>
</ul>

<p><a href="../../docs/actors/"><strong>Actors</strong></a></p>

<ul>
<li><a href="../../docs/mining/">Mining</a></li>
<li><a href="../../docs/storage-market/">Storage Market</a></li>
<li><a href="../../docs/retrieval-market/">Retrieval Market</a></li>
<li><a href="../../docs/payments/">Payments</a></li>
<li><a href="../../docs/faults/">Faults</a></li>
</ul>

<p><strong>Proofs</strong></p>

<ul>
<li><a href="../../docs/zigzag-circuit/">ZigZag</a></li>
</ul>

<p><a href="../../docs/definitions/"><strong>Glossary</strong></a></p>

<p><strong>Spec</strong></p>

<ul>
<li><a href="../../docs/style/">Style</a></li>
<li><a href="../../docs/process/">Process</a></li>
</ul>





</nav>


  
<script>
(function() {
  var menu = document.querySelector('aside.book-menu nav')
  addEventListener('beforeunload', function(event) {
    localStorage.setItem('menu.scrollTop', menu.scrollTop)
  });
  menu.scrollTop = localStorage.getItem('menu.scrollTop')
})()
</script>



    </aside>

    <div class="book-page">
      <header class="align-center justify-between book-header">
  <label for="menu-control">
    <img src="../../svg/menu.svg" alt="Menu" />
  </label>
  <strong>
  
    
    Network Protocols
  
</strong>
</header>

      
<article class="markdown">
  

<h1 id="filecoin-network-protocols">Filecoin Network Protocols</h1>

<p>All filecoin network protocols are implemented as libp2p protocols. This document will assume that all data is communicated between peers on a libp2p stream.</p>

<h2 id="cbor-rpc">CBOR RPC</h2>

<p>Filecoin uses many pre-existing protocols from ipfs and libp2p, and also implements several new protocols of its own. For these Filecoin specific protocols, we will use the CBOR RPC protocol format, defined below.</p>

<p>This format consists of series of <a href="https://tools.ietf.org/html/rfc7049">CBOR</a> serialized objects. Whenever a filecoin protocol says &ldquo;send X&rdquo;, it means &ldquo;cbor serialize the object X, then write the serialized bytes&rdquo;.</p>

<h2 id="hello-handshake">Hello Handshake</h2>

<ul>
<li><strong>Name</strong>: Hello</li>
<li><strong>Protocol ID</strong>: <code>/fil/hello/1.0.0</code></li>
</ul>

<p>Note: Implementations should limit the maximum number of bytes read during the <code>ReadCborRPC</code>Â call. We suggest 1MB as a sane limit.</p>

<h1 id="hello-handshake-1">Hello Handshake</h1>

<blockquote>
<p>The Hello protocol is used when two filecoin nodes initially connect to eachother in order to determine information about the other node.</p>
</blockquote>

<p>Whenever a node gets a new connection, it opens a new stream on that connection and &ldquo;says hello&rdquo;. This is done by crafting a <code>HelloMessage</code>, sending it to the other peer using CBOR RPC and finally, closing the stream.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">HelloMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">HeaviestTipSet</span>       <span class="p">[]</span><span class="nx">Cid</span>
    <span class="nx">HeaviestTipSetWeight</span> <span class="kt">uint64</span>
    <span class="nx">GenesisHash</span>          <span class="nx">Cid</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SayHello</span><span class="p">(</span><span class="nx">p</span> <span class="nx">PeerID</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nf">OpenStream</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
    <span class="nx">mes</span> <span class="o">:=</span> <span class="nf">GetHelloMessage</span><span class="p">()</span>
    <span class="nf">WriteCborRPC</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">mes</span><span class="p">)</span>
    <span class="nx">s</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<p>Upon receiving a &ldquo;hello&rdquo; stream from another node, you should read off the CBOR RPC message, and then check that the genesis hash matches you genesis hash. If it does not, that node is not part of your network, and should probably be disconnected from. Next, the <code>HeaviestTipSet</code>, claimed <code>HeaviestTipSetWeight</code>, and peerID of the other node should be passed to the chain sync subsystem.</p>

<h2 id="storage-deal">Storage Deal</h2>

<ul>
<li><strong>Name</strong>: Storage Deal</li>
<li><strong>Protocol ID</strong>: <code>/fil/storage/mk/1.0.0</code></li>
</ul>

<blockquote>
<p>The storage deal protocol is used by any client to store data with a storage miner.</p>
</blockquote>

<p>The protocol starts with storage client (which in this case may be a normal storage client, or a broker). It is assumed that the client has their data already prepared into a <code>piece</code> prior to executing this protocol. For more details on initial data processing, see <a href="../client-data">client data</a>.</p>

<p>First the client sends a <code>SignedStorageDealProposal</code> to the storage miner:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Commitment</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">type</span> <span class="nx">StorageDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// PieceRef is the hash of the data in native structure. This will be used for
</span><span class="c1"></span>    <span class="c1">// certifying the data transfer
</span><span class="c1"></span>    <span class="nx">PieceRef</span> <span class="nx">Cid</span>

    <span class="c1">// SerializationMode specifies how the graph referenced by &#39;PieceRef&#39; gets transformed
</span><span class="c1"></span>    <span class="c1">// into the data that will be packed into a sector.
</span><span class="c1"></span>    <span class="nx">SerializationMode</span> <span class="kt">string</span>

    <span class="c1">// CommP is the data hashed in a form that is compatible with the proofs system
</span><span class="c1"></span>    <span class="c1">// TODO: this *could* possibly be combined with the PieceRef
</span><span class="c1"></span>    <span class="nx">CommP</span> <span class="nx">Commitment</span>

    <span class="nx">Size</span> <span class="nx">NumBytes</span>

    <span class="nx">TotalPrice</span> <span class="nx">TokenAmount</span>

    <span class="c1">// Duration is how long the file should be stored for
</span><span class="c1"></span>    <span class="nx">Duration</span> <span class="nx">NumBlocks</span>

    <span class="c1">// PaymentRef is a reference to the mechanism that the proposer
</span><span class="c1"></span>    <span class="c1">// will use to pay the miner. It should be verifiable by the
</span><span class="c1"></span>    <span class="c1">// miner using on-chain information.
</span><span class="c1"></span>    <span class="nx">Payment</span> <span class="nx">PaymentInfo</span>

    <span class="c1">// MinerAddress is the address of the storage miner in the deal proposal
</span><span class="c1"></span>    <span class="nx">MinerAddress</span> <span class="nx">Address</span>

    <span class="nx">ClientAddress</span> <span class="nx">Address</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SignedStorageDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>    
    <span class="nx">Proposal</span> <span class="nx">StorageDealProposal</span>

    <span class="c1">// Signature over the cbor encoded StorageDealProposal signed by client
</span><span class="c1"></span>    <span class="nx">Signature</span> <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PaymentInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// PayChActor is the address of the payment channel actor
</span><span class="c1"></span>    <span class="c1">// that will be used to facilitate payments
</span><span class="c1"></span>    <span class="nx">PayChActor</span> <span class="nx">Address</span>

    <span class="c1">// Payer is the address of the owner of the payment channel
</span><span class="c1"></span>    <span class="nx">Payer</span> <span class="nx">Address</span>

    <span class="c1">// Channel is the ID of the specific channel the client will
</span><span class="c1"></span>    <span class="c1">// use to pay the miner. It must already have sufficient funds locked up
</span><span class="c1"></span>    <span class="nx">Channel</span> <span class="nx">ChannelID</span>

    <span class="c1">// ChannelMsgCid is the B58 encoded CID of the message used to create the
</span><span class="c1"></span>    <span class="c1">// channel. Adding the message cid allows the miner to wait until the
</span><span class="c1"></span>    <span class="c1">// channel is accepted on chain.
</span><span class="c1"></span>    <span class="nx">ChannelMsgCid</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

    <span class="c1">// Vouchers is a set of payments from the client to the miner that can be
</span><span class="c1"></span>    <span class="c1">// cashed out contingent on the agreed upon data being provably within a
</span><span class="c1"></span>    <span class="c1">// live sector in the miners control on-chain
</span><span class="c1"></span>    <span class="nx">Vouchers</span> <span class="p">[]</span><span class="nx">PaymentVouchers</span>
<span class="p">}</span></code></pre></div>
<h3 id="deal-state-values">Deal State Values</h3>

<p>Legal values for <code>DealState</code> are as follows:</p>

<table>
<thead>
<tr>
<th>State</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Unset</td>
<td><code>0</code></td>
<td>This implies a programmer error and should never appear in an actual message.</td>
</tr>

<tr>
<td>Unknown</td>
<td><code>1</code></td>
<td>Signifies an unknown negotiation.</td>
</tr>

<tr>
<td>Rejected</td>
<td><code>2</code></td>
<td>The deal was rejected for some reason.</td>
</tr>

<tr>
<td>Accepted</td>
<td><code>3</code></td>
<td>The deal was accepted but hasn&rsquo;t yet started.</td>
</tr>

<tr>
<td>Started</td>
<td><code>4</code></td>
<td>Tthe deal has started and the transfer is in progress.</td>
</tr>

<tr>
<td>Failed</td>
<td><code>5</code></td>
<td>The deal has failed for some reason.</td>
</tr>

<tr>
<td>Staged</td>
<td><code>6</code></td>
<td>The data has been received and staged into a sector, but is not sealed yet.</td>
</tr>

<tr>
<td>Complete</td>
<td><code>7</code></td>
<td>Deal is complete, and the sector that the deal is contained in has been sealed and its commitment posted on chain.</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">SendStorageProposal</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">Address</span><span class="p">,</span> <span class="nx">file</span> <span class="nx">Cid</span><span class="p">,</span> <span class="nx">duration</span> <span class="nx">NumBlocks</span><span class="p">,</span> <span class="nx">price</span> <span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">IsMiner</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;given address was not a miner&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Get a PoRep friendly commitment from the file
</span><span class="c1"></span>    <span class="nx">commitment</span><span class="p">,</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nf">ProcessRef</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>

    <span class="c1">// Get a handle on the payment system to be used to pay this miner
</span><span class="c1"></span>    <span class="c1">// Most likely, this grabs an existing payment channel, or creates
</span><span class="c1"></span>    <span class="c1">// a new one
</span><span class="c1"></span>    <span class="nx">payments</span> <span class="o">:=</span> <span class="nf">PaymentSysToMiner</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>

    <span class="nx">payInfo</span> <span class="o">:=</span> <span class="nx">payments</span><span class="p">.</span><span class="nf">CreatePaymentInfo</span><span class="p">(</span><span class="nx">storageStart</span><span class="p">,</span> <span class="nx">duration</span><span class="p">,</span> <span class="nx">price</span><span class="o">*</span><span class="nx">size</span><span class="p">)</span>

    <span class="nx">prop</span> <span class="o">:=</span> <span class="nx">StorageDealProposal</span><span class="p">{</span>
        <span class="nx">PieceRef</span><span class="p">:</span>      <span class="nx">file</span><span class="p">,</span>
        <span class="nx">CommP</span><span class="p">:</span> <span class="nx">commitment</span><span class="p">,</span>
        <span class="nx">TotalPrice</span><span class="p">:</span>    <span class="nx">price</span> <span class="o">*</span> <span class="nx">size</span><span class="p">,</span> <span class="c1">// Maybe just leave this to the payment info?
</span><span class="c1"></span>        <span class="nx">Duration</span><span class="p">:</span>      <span class="nx">duration</span><span class="p">,</span>
        <span class="nx">Size</span><span class="p">:</span>          <span class="nx">size</span><span class="p">,</span>
        <span class="nx">Payment</span><span class="p">:</span>       <span class="nx">payInfo</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nx">client</span><span class="p">.</span><span class="nf">SignProposal</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span>

    <span class="nx">peerid</span> <span class="o">:=</span> <span class="nx">lookup</span><span class="p">.</span><span class="nf">ByMinerAddress</span><span class="p">(</span><span class="nx">miner</span><span class="p">)</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="nf">NewStream</span><span class="p">(</span><span class="nx">peerid</span><span class="p">,</span> <span class="nx">MakeStorageDealProtocolID</span><span class="p">)</span>

    <span class="c1">// Send the proposal over
</span><span class="c1"></span>    <span class="nx">CborRpc</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">prop</span><span class="p">)</span>

    <span class="c1">// Read the response...
</span><span class="c1"></span>    <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">CborRpc</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

    <span class="k">switch</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">State</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">Accepted</span><span class="p">:</span>
        <span class="c1">// Yay! the miner accepted our deal, prepare to send them the file, and then check back
</span><span class="c1"></span>        <span class="c1">// later to see how its going
</span><span class="c1"></span>    <span class="k">case</span> <span class="nx">Rejected</span><span class="p">:</span>
        <span class="c1">// oh no, our deal was rejected.
</span><span class="c1"></span>        <span class="c1">// practically, we should consider whether or not to close our payment channel
</span><span class="c1"></span>        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Deal rejected, reason: &#34;</span><span class="p">,</span> <span class="nx">resp</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="c1">// unexpected response state...
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<div class="notices todo" ><strong>TODO</strong>: possibly also include a starting block height here, to indicate when this deal may be started (implying you could select a value in the future). After the first response, both parties will have signed agreeing that the deal started at that point. This could possibly be used to challenge either party in the event of a stall. This starting block height also gives the miner time to seal and post the commitment on chain. Otherwise a weird condition exists where a client could immediately slash a miner for not having their data stored.</div>

<p>The miner then decides whether or not to accept the deal, and sends back a SignedStorageDealResponse:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StorageDealResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">State</span> <span class="nx">DealState</span>

    <span class="c1">// Message is an optional message to add context to any given response
</span><span class="c1"></span>    <span class="nx">Message</span> <span class="kt">string</span>

    <span class="c1">// ProposalCid is the cid of the StorageDealProposal object this response is for
</span><span class="c1"></span>    <span class="nx">ProposalCid</span> <span class="nx">Cid</span>

    <span class="c1">// PieceInclusionProof is a collection of information needed to convince the client that
</span><span class="c1"></span>    <span class="c1">// the miner has sealed the data into a sector.
</span><span class="c1"></span>    <span class="c1">// Note: the miner doesnt necessarily have to have committed the sector at this point
</span><span class="c1"></span>    <span class="c1">// they just need to have staged it into a sector, and be committed to putting it at
</span><span class="c1"></span>    <span class="c1">// that place in the sector.
</span><span class="c1"></span>    <span class="nx">PieceInclusionProof</span> <span class="nx">PieceInclusionProof</span>

    <span class="c1">// SectorCommitMsg is the Cid of the message that was sent to submit
</span><span class="c1"></span>    <span class="c1">// the sector containing this data to the chain.
</span><span class="c1"></span>    <span class="nx">SectorCommitMsg</span> <span class="nx">Cid</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SignedStorageDealResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Response</span> <span class="nx">StorageDealResponse</span>

    <span class="c1">// Signature is a signature from the miner over the cbor encoded response
</span><span class="c1"></span>    <span class="nx">Signature</span> <span class="nx">Signature</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">HandleStorageDealProposal</span><span class="p">(</span><span class="nx">s</span> <span class="nx">Stream</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">prop</span> <span class="o">:=</span> <span class="nx">CborRpc</span><span class="p">.</span><span class="nf">Read</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateInput</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;client sent invalid proposal&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">accept</span><span class="p">,</span> <span class="nx">reason</span> <span class="o">:=</span> <span class="nx">MinerPolicy</span><span class="p">.</span><span class="nf">ShouldAccept</span><span class="p">(</span><span class="nx">prop</span><span class="p">);</span> <span class="p">!</span><span class="nx">accept</span> <span class="p">{</span>
        <span class="nx">CborRpc</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">StorageDealResponse</span><span class="p">{</span>
            <span class="nx">State</span><span class="p">:</span>   <span class="nx">Rejected</span><span class="p">,</span>
            <span class="nx">Message</span><span class="p">:</span> <span class="nx">reason</span><span class="p">,</span>
        <span class="p">})</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c1">// Alright, we&#39;re accepting
</span><span class="c1"></span>    <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">StorageDealResponse</span><span class="p">{</span>
        <span class="nx">State</span><span class="p">:</span>    <span class="nx">Accepted</span><span class="p">,</span>
        <span class="nx">Proposal</span><span class="p">:</span> <span class="nx">prop</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(),</span>
    <span class="p">}</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nf">SetDealState</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>

    <span class="c1">// Make sure we are ready to receive the file (however it may come)
</span><span class="c1"></span>    <span class="c1">// TODO: potentially add in something to the protocol to allow
</span><span class="c1"></span>    <span class="c1">// clients to signal how the file will be transferred
</span><span class="c1"></span>    <span class="nx">miner</span><span class="p">.</span><span class="nf">RegisterInboundFileTransfer</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span>

    <span class="nx">CborRpc</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ValidateInput</span><span class="p">(</span><span class="nx">prop</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Note: Maybe this is unnecessary, and the payment info being valid suffices?
</span><span class="c1"></span>    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidateSignature</span><span class="p">(</span><span class="nx">prop</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">ClientAddress</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid signature from client&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">!</span><span class="nf">IsExistingAccount</span><span class="p">(</span><span class="nx">prop</span><span class="p">.</span><span class="nx">ClientAddress</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;proposal came from a fake account&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidatePaymentInfo</span><span class="p">(</span><span class="nx">prop</span><span class="p">.</span><span class="nx">Payment</span><span class="p">,</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">Duration</span><span class="p">,</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">Size</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;propsal had invalid payment information&#34;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>If <code>response.State</code> is <code>Accepted</code> then the client should proceed to transfer the data in question to the storage miner. This operation happens out of band from this protocol, and can be a simple bitswap transfer at first. Support for other more &lsquo;exotic&rsquo; &lsquo;protocols&rsquo; such as mailing hard drives is an explicit goal.</p>

<p>Next, when the miner receives all the data and validates it, they set the <code>DealState</code> to <code>Staged</code>. When the sector gets sealed, and the commitment is posted on chain, the state gets set to <code>Complete</code> and the deals <code>PieceInclusionProof</code> field should be set to the appropriate values.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">OnDataReceived</span><span class="p">(</span><span class="nx">prop</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">!</span><span class="nf">ValidatePieceTranslation</span><span class="p">(</span><span class="nx">prop</span><span class="p">.</span><span class="nx">PieceRef</span><span class="p">,</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">SerializationMode</span><span class="p">,</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">CommP</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">StorageDealResponse</span><span class="p">{</span>
            <span class="nx">State</span><span class="p">:</span>    <span class="nx">Rejected</span><span class="p">,</span>
            <span class="nx">Proposal</span><span class="p">:</span> <span class="nx">prop</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(),</span>
            <span class="nx">Message</span><span class="p">:</span>  <span class="s">&#34;CommP was invalid, reconstructed data did not match&#34;</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="nx">miner</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
        <span class="nx">miner</span><span class="p">.</span><span class="nf">SetDealState</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c1">// TODO: is CommP actually needed? How does it tie in?
</span><span class="c1"></span>    <span class="nx">SectorBuilder</span><span class="p">.</span><span class="nf">AddPiece</span><span class="p">(</span><span class="nx">prop</span><span class="p">.</span><span class="nx">PieceRef</span><span class="p">,</span> <span class="nx">prop</span><span class="p">.</span><span class="nx">SerializationMode</span><span class="p">)</span>
<span class="p">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">OnSectorPacked</span><span class="p">(</span><span class="nx">prop</span> <span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">pieceConf</span> <span class="nx">PieceCommitment</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">resp</span> <span class="o">:=</span> <span class="nx">StorageDealResponse</span><span class="p">{</span>
        <span class="nx">State</span><span class="p">:</span>             <span class="nx">Staged</span><span class="p">,</span>
        <span class="nx">Proposal</span><span class="p">:</span>          <span class="nx">prop</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(),</span>
        <span class="nx">PieceInclusionProof</span><span class="p">:</span> <span class="nx">pieceConf</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
    <span class="nx">miner</span><span class="p">.</span><span class="nf">SetDealState</span><span class="p">(</span><span class="nx">resp</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Once the deal makes it to the <code>Staged</code> state, the client should be able to query and get the <code>PieceInclusionProof</code> that they need to verify that the miner is indeed storing their data.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">OnSectorSealed</span><span class="p">(</span><span class="nx">prop</span> <span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">msgcid</span> <span class="nx">Cid</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">curState</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">GetDealState</span><span class="p">(</span><span class="nx">prop</span><span class="p">)</span>
    <span class="nx">nstate</span> <span class="o">:=</span> <span class="nx">StorageDealResponse</span><span class="p">{</span>
        <span class="nx">State</span><span class="p">:</span>             <span class="nx">Complete</span><span class="p">,</span>
        <span class="nx">Proposal</span><span class="p">:</span>          <span class="nx">prop</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(),</span>
        <span class="nx">PieceInclusionProof</span><span class="p">:</span> <span class="nx">curState</span><span class="p">.</span><span class="nx">PieceInclusionProof</span><span class="p">,</span>
        <span class="nx">SectorCommitMsg</span><span class="p">:</span>   <span class="nx">msgcid</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="nx">miner</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">nstate</span><span class="p">)</span>
    <span class="nx">miner</span><span class="p">.</span><span class="nf">SetDealState</span><span class="p">(</span><span class="nx">nstate</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h3 id="query">Query</h3>

<p>Here we describe a basic protocol for querying the current state of a given storage deal. In the future we may want something more complex that is able to multiplex waiting for notifications about a large set of deals over a single stream simultaneously. Upgrading to that from this should be relatively simple, so for now, we do the simple thing.</p>

<p>The libp2p protocol ID for this protocol is <code>/fil/storage/qry/1.0.0</code></p>

<p>At any point, the client in this flow may query the miner for the state of a given proposal. To query, they send a &lsquo;StorageDealQuery&rsquo; that looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StorageDealQuery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ProposalCid is the cid of the proposal for the deal that we are querying
</span><span class="c1"></span>    <span class="c1">// the state of
</span><span class="c1"></span>    <span class="nx">ProposalCid</span> <span class="o">*</span><span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

    <span class="nx">BaseState</span> <span class="nx">DealState</span>
<span class="p">}</span></code></pre></div>
<p>If <code>BaseState</code> is <code>Unset</code> or a terminal state (<code>Complete</code>, <code>Rejected</code>, or <code>Failed</code>) then the current state of the deal in question is returned. If the <code>BaseState</code> is different than the current state of the deal, the current state of the deal is also returned immediately. In the case that the <code>BaseState</code> matches the current state of the deal, then the stream is held open until the state changes, at which point the new state of the deal is returned.</p>

<h2 id="retrieve-piece-for-free">Retrieve Piece for Free</h2>

<ul>
<li><strong>Name</strong>: Retrieve Piece for Free</li>
<li><strong>Protocol ID</strong>: <code>/fil/retrieval/free/0.0.0</code></li>
</ul>

<blockquote>
<p>The Retrieve Piece for Free protocol is used to coordinate the transfer of a piece from miner to client at no cost to the client.</p>
</blockquote>

<p>The client initiates the protocol by opening a libp2p stream to the miner. To find and connect to the miner, the <a href="../lookup-service">address lookup service</a> should be used. Once connected, the client must send the miner a <code>RetrievePieceRequest</code> message using the <a href="#CBOR-RPC">CBOR RPC</a> protocol format.</p>

<p>The <code>RetrievePieceRequest</code> is specified as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RetrievePieceRequest</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// `PieceRef` identifies a piece of user data, typically received from the
</span><span class="c1"></span>    <span class="c1">// client while consummating a storage deal.
</span><span class="c1"></span>    <span class="nx">PieceRef</span> <span class="o">*</span><span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
<span class="p">}</span></code></pre></div>
<p>When the miner receives the request, it responds with a <code>RetrievePieceResponse</code> message indicating that it has accepted or rejected the request.</p>

<p>The <code>RetrievePieceResponse</code> message is specified as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RetrievePieceResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// `Status` communicates the miner&#39;s willingness to send a piece back to a
</span><span class="c1"></span>    <span class="c1">// client. The value of the `Status` field must be one of: `Failure` or
</span><span class="c1"></span>    <span class="c1">// `Success`.
</span><span class="c1"></span>    <span class="nx">Status</span> <span class="nx">RetrievePieceStatus</span>

    <span class="c1">// If `Status` is `Failure`, `ErrorMessage` should contain a string
</span><span class="c1"></span>    <span class="c1">// explaining the cause for the rejection.
</span><span class="c1"></span>    <span class="nx">ErrorMessage</span> <span class="kt">string</span>
<span class="p">}</span></code></pre></div>
<p>Legal values for <code>RetrievePieceStatus</code> are as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// Unset implies a programmer error. This value should never appear in an
</span><span class="c1"></span>    <span class="c1">// actual message.
</span><span class="c1"></span>    <span class="nx">Unset</span> <span class="p">=</span> <span class="nf">RetrievePieceStatus</span><span class="p">(</span><span class="kc">iota</span><span class="p">)</span>

    <span class="c1">// Failure indicates that the piece can not be retrieved from the miner.
</span><span class="c1"></span>    <span class="nx">Failure</span>

    <span class="c1">// Success means that the piece can be retrieved from the miner.
</span><span class="c1"></span>    <span class="nx">Success</span>
<span class="p">)</span></code></pre></div>
<p>If the miner does not accept the request, it sends a <code>RetrievePieceResponse</code> with the <code>Status</code> field set to <code>Failure</code>. The miner should set the <code>ErrorMessage</code> field to indicate a reason for the request being rejected.</p>

<p>If the miner accepts the request, it sends a <code>RetrievePieceResponse</code> with the <code>Status</code> field set to <code>Success</code>. The miner then sends the client ordered <code>RetrievePieceChunk</code> messages until all of the piece&rsquo;s data has been transferred, at which point the miner closes the stream.</p>

<p>Note: The client must be able to reconstruct a piece by concatenating the <code>Data</code>-bytes in the order that they were received.</p>

<p>Note: The miner divides the piece in to chunks containing a maximum of <code>256 &lt;&lt; 8</code> bytes due to a limitation in our software which caps the size of CBOR-encoded messages at <code>256 &lt;&lt; 10</code> bytes.</p>

<p>The <code>RetrievePieceChunk</code> message is specified as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">RetrievePieceChunk</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The `Data` field contains a chunk of a piece. The length of `Data` must
</span><span class="c1"></span>    <span class="c1">// be &gt; 0.
</span><span class="c1"></span>    <span class="nx">Data</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span></code></pre></div>
<div class="notices todo" ><strong>TODO</strong>: document the query deal interaction</div>

<h2 id="blocksync">BlockSync</h2>

<p>The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol with a protocol ID of <code>/fil/sync/blk/0.0.1</code>. It uses CBOR-RPC.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BlockSyncRequest</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The TipSet being synced from
</span><span class="c1"></span>    <span class="nx">Start</span>         <span class="p">[]</span><span class="nx">Cid</span>
    <span class="c1">// How many tipsets to sync
</span><span class="c1"></span>    <span class="nx">RequestLength</span> <span class="kt">uint64</span>
    <span class="c1">// Query options
</span><span class="c1"></span>    <span class="nx">Options</span> <span class="kt">uint64</span>
<span class="p">}</span></code></pre></div>
<p>The request requests a chain of a given length by the hash of its highest block. The <code>Options</code> allow the requester to specify whether or not blocks and messages to be included.</p>

<table>
<thead>
<tr>
<th>bit</th>
<th>option</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>0</code></td>
<td>Blocks</td>
<td>Include blocks if set</td>
</tr>

<tr>
<td><code>1</code></td>
<td>Messages</td>
<td>Include messages if set</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BlockSyncResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Chain</span> <span class="p">[]</span><span class="nx">TipSetBundle</span>
    <span class="nx">Status</span>  <span class="kt">uint</span>
    <span class="nx">Message</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TipSetBundle</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">Blocks</span> <span class="p">[]</span><span class="nx">Blocks</span>
  <span class="nx">Messages</span> <span class="p">[]</span><span class="nx">Message</span>
  <span class="nx">MsgIncludes</span> <span class="p">[][]</span><span class="kt">int</span>
<span class="p">}</span></code></pre></div>
<p>The response contains the requested chain in reverse iteration order. Each item in the <code>Chain</code> array contains the blocks for that tipset if the <code>Blocks</code> option bit in the request was set, and if the <code>Messages</code> bit was set, the messages across all blocks in that tipset. The <code>MsgIncludes</code> array contains one array of integers for each block in the <code>Blocks</code> array. Each of the arrays in <code>MsgIncludes</code> contains a list of indexes of messages from the <code>Messages</code> array that are in each <code>Block</code> in the blocks array.</p>

<h3 id="example">Example</h3>

<p>The TipSetBundle</p>

<pre><code>Blocks: [b0, b1]
Messages: [mA, mB, mC, mD]
MsgIncludes: [[0, 1, 3], [1, 2, 0]]
</code></pre>

<p>corresponds to:</p>

<pre><code>Block 'b0': [mA, mB, mD]
Block 'b1': [mB, mC, mA]
</code></pre>

<h3 id="error-codes">Error Codes</h3>

<table>
<thead>
<tr>
<th>Name</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>Success</td>
<td><code>0</code></td>
<td>All is well.</td>
</tr>

<tr>
<td>PartialResponse</td>
<td><code>101</code></td>
<td>Sent back fewer blocks than requested.</td>
</tr>

<tr>
<td>BlockNotFound</td>
<td><code>201</code></td>
<td>Request.Start not found</td>
</tr>

<tr>
<td>GoAway</td>
<td><code>202</code></td>
<td>Requester is making too many requests.</td>
</tr>

<tr>
<td>InternalError</td>
<td><code>203</code></td>
<td>Internal error occured.</td>
</tr>
</tbody>
</table>

</article>

      
<div class="align-center book-git-footer justify-between">
  
  <div>
    
    <a href="https://github.com/filecoin-project/specs/commit/9dcf16da57ae5577304bbf442808d35563add0aa" title='Last modified May 11, 2019 by dignifiedquire' target="_blank" rel="noopener">
      <img src="../../svg/code-merge.svg" alt="Changed" /> May 11, 2019
    </a>
  </div>
  
  
  <div>
    <a href="https://github.com/filecoin-project/specs/edit/master/network-protocols.md" target="_blank" rel="noopener">
      <img src="../../svg/code-fork.svg" alt="Edit" /> Edit this page
    </a>
  </div>
  
</div>


      
    </div>

    
  
  
  <aside class="book-toc fixed">
    <nav id="TableOfContents">
<ul>
<li><a href="#filecoin-network-protocols">Filecoin Network Protocols</a>
<ul>
<li><a href="#cbor-rpc">CBOR RPC</a></li>
<li><a href="#hello-handshake">Hello Handshake</a></li>
</ul></li>
<li><a href="#hello-handshake-1">Hello Handshake</a>
<ul>
<li><a href="#storage-deal">Storage Deal</a>
<ul>
<li><a href="#deal-state-values">Deal State Values</a></li>
<li><a href="#query">Query</a></li>
</ul></li>
<li><a href="#retrieve-piece-for-free">Retrieve Piece for Free</a></li>
<li><a href="#blocksync">BlockSync</a>
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#error-codes">Error Codes</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </aside>



  </main>
  
  
  
</body>

</html>
