<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Filecoin Specification on Filecoin Spec</title>
    <link>/</link>
    <description>Recent content in Filecoin Specification on Filecoin Spec</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>/docs/algorithms/porep/stacked_drg_circuit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/stacked_drg_circuit/</guid>
      <description>Stacked DRG: Offline PoRep Circuit Spec Stacked DRG Overview Stacked DRG PoRep is based on layering DRG graphs LAYERS times. The data represented in each DRG layer is a labeling based on previously labeled nodes. The final labeled layer is the SDR key, and the &amp;lsquo;final layer&amp;rsquo; of replication the replica, an encoding of the original data using the generated key.
 ReplicaId is a unique replica identifier (see the Filecoin Proofs spec for details).</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_market_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_market_actor_old/</guid>
      <description>Storage Market Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;smarket&amp;quot;&amp;gt;  The storage market actor is the central point for the Filecoin storage market. It is responsible for registering new miners to the system, and maintaining the power table. The Filecoin storage market is a singleton that lives at a specific well-known address.
type StorageMarketActorState struct { miners {Address:Null}&amp;lt;Hamt&amp;gt; totalStorage BytesAmount } Methods    Name Method ID     StorageMarketConstructor 1   CreateStorageMiner 2   SlashConsensusFault 3   UpdateStorage 4   GetTotalStorage 5   PowerLookup 6   IsMiner 7   StorageCollateralForSize 8    Constructor Parameters</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor_old/</guid>
      <description>Storage Miner Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;sminer&amp;quot;&amp;gt;
type StorageMinerActorState struct { ## contains mostly static info about this miner info &amp;amp;MinerInfo ## Collateral that is waiting to be withdrawn. dePledgedCollateral TokenAmount ## Time at which the depledged collateral may be withdrawn. dePledgeTime BlockHeight ## All sectors this miner has committed. sectors &amp;amp;SectorSet ## Sectors this miner is currently mining. It is only updated ## when a PoSt is submitted (not as each new sector commitment is added).</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_token/multisig/multisig_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/multisig/multisig_actor_old/</guid>
      <description>Multisig Account Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;multisig&amp;quot;&amp;gt;  A basic multisig account actor. Allows sending of messages like a normal account actor, but with the requirement of M of N parties agreeing to the operation. Completed and/or cancelled operations stick around in the actors state until explicitly cleared out. Proposers may cancel transactions they propose, or transactions by proposers who are no longer approved signers.
Self modification methods (add/remove signer, change requirement) are called by doing a multisig transaction invoking the desired method on the contract itself.</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_token/payment_channels/payment_channel_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/payment_channels/payment_channel_actor_old/</guid>
      <description>Payment Channel Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;paych&amp;quot;&amp;gt;  The payment channel actor manages the on-chain state of a point to point payment channel.
type PaymentChannel struct { from Address to Address toSend TokenAmount closingAt UInt minCloseHeight UInt laneStates {UInt:LaneState} } representation tuple type SignedVoucher struct { TimeLock BlockHeight SecretPreimage Bytes Extra ModVerifyParams Lane Uint Nonce Uint Merges []Merge Amount TokenAmount MinCloseHeight Uint Signature Signature } type ModVerifyParams struct { Actor Address Method Uint Data Bytes } type Merge struct { Lane Uint Nonce Uint } type LaneState struct { Closed bool Redeemed TokenAmount Nonce Uint } type PaymentChannelMethod union { | PaymentChannelConstructor 0 | UpdateChannelState 1 | Close 2 | Collect 3 } representation keyed Methods    Name Method ID     Constructor 1   UpdateChannelState 2   Close 3   Collect 4    Constructor Parameters</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_vm/sysactors/account_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/account_actor_old/</guid>
      <description>Account Actor  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;account&amp;quot;&amp;gt;  The Account actor is the actor used for normal keypair backed accounts on the filecoin network.
type AccountActorState struct { address Address } Methods    Name Method ID     AccountConstructor 1   GetAddress 2    type AccountConstructor struct { }  GetAddress Parameters
type GetAddress struct { } representation tuple Algorithm
func GetAddress() Address { return self.</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_vm/sysactors/init_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/init_actor_old/</guid>
      <description>Init Actor  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;init&amp;quot;&amp;gt;  The init actor is responsible for creating new actors on the filecoin network. This is a built-in actor and cannot be replicated. In the future, this actor will be responsible for loading new code into the system (for user programmable actors). ID allocation for user instantiated actors starts at 100. This means that NextID will initially be set to 100.
type InitActorState struct { addressMap {Address:ID}&amp;lt;Hamt&amp;gt; nextId UInt } Methods    Name Method ID     Constructor 1   Exec 2   GetIdForAddress 3    Constructor Parameters</description>
    </item>
    
    <item>
      <title>About this specification</title>
      <link>/docs/intro/process/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/about/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>AccountActor</title>
      <link>/docs/systems/filecoin_vm/sysactors/account_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/account_actor/</guid>
      <description>(You can see the old AccountActor here )
import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&amp;#34; import filcrypto &amp;#34;github.com/filecoin-project/specs/algorithms/crypto&amp;#34; import vmr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&amp;#34; type AccountActorCode struct { VerifySignature(rt vmr.Runtime, sig filcrypto.Signature) InvocOutput } type AccountActorState struct { // normal keypair backed accounts  Address addr.Address }  package sysactors import filcrypto &amp;#34;github.com/filecoin-project/specs/algorithms/crypto&amp;#34; import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&amp;#34; import exitcode &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&amp;#34; import vmr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&amp;#34; import ipld &amp;#34;github.com/filecoin-project/specs/libraries/ipld&amp;#34; //////////////////////////////////////////////////////////////////////////////// // Boilerplate ////////////////////////////////////////////////////////////////////////////////  func (a *AccountActorCode_I) State(rt Runtime) (vmr.ActorStateHandle, AccountActorState) { h := rt.</description>
    </item>
    
    <item>
      <title>Address</title>
      <link>/docs/appendix/address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/address/</guid>
      <description>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</description>
    </item>
    
    <item>
      <title>Architecture Diagrams</title>
      <link>/docs/intro/arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/arch/</guid>
      <description>Filecoin Systems function statusIndicatorsShow() { var $uls = document.querySelectorAll(&#39;.statusIcon&#39;) $uls.forEach(function (el) { el.classList.remove(&#39;hidden&#39;) }) return false; // stop click event } function statusIndicatorsHide() { var $uls = document.querySelectorAll(&#39;.statusIcon&#39;) $uls.forEach(function (el) { el.classList.add(&#39;hidden&#39;) }) return false; // stop click event }  Status Legend:
 🛑 Bare - Very incomplete at this time.  Implementors: This is far from ready for you.  ⚠️ Rough &amp;ndash; work in progress, heavy changes coming, as we put in place key functionality.</description>
    </item>
    
    <item>
      <title>BitSwap</title>
      <link>/docs/libraries/ipfs/bitswap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/bitswap/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Block Reception</title>
      <link>/docs/algorithms/block_reception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/block_reception/</guid>
      <description>func (g *BlockValidationGraph_I) ConsiderBlock(block Block) { panic(&amp;ldquo;TODO&amp;rdquo;) // g.UnconnectedBlocks.AddBlock(block) // g.tryConnectBlockToFringe(block) }
func (g *BlockValidationGraph_I) tryConnectBlockToFringe(block Block) { panic(&amp;ldquo;TODO&amp;rdquo;)
// try to connect the block, and then try connecting its descendents. // // this algorithm should be breadth-first because we need to process the fringe // in order. Depth-first search may consider blocks whose parents are still // yet to be added // blocks := Queue &amp;lt; Block &amp;gt; // blocks.</description>
    </item>
    
    <item>
      <title>BlockSync</title>
      <link>/docs/algorithms/block_sync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/block_sync/</guid>
      <description>Name: Block Sync Protocol ID: /fil/sync/blk/0.0.1  The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol.
The request requests a chain of a given length by the hash of its highest block. The Options allow the requester to specify whether or not blocks and messages to be included.
The response contains the requested chain in reverse iteration order.</description>
    </item>
    
    <item>
      <title>Chain Verifier Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/verifier_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/verifier_node/</guid>
      <description>type ChainVerifierNode interface { FilecoinNode systems.Blockchain }  </description>
    </item>
    
    <item>
      <title>CIDs - Content IDentifiers</title>
      <link>/docs/libraries/ipld/cid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/cid/</guid>
      <description> type BytesKey string // so that we can use it in go maps  type CID BytesKey // TODO: remove util.  </description>
    </item>
    
    <item>
      <title>Client Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/client_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/client_node/</guid>
      <description>type ClientNode struct { FilecoinNode systems.Blockchain markets.StorageMarketClient markets.RetrievalMarketClient markets.MarketOrderBook markets.DataTransfers }  </description>
    </item>
    
    <item>
      <title>Components</title>
      <link>/docs/listings/system_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/system_map/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Contributing to the Filecoin spec</title>
      <link>/docs/intro/process/contributing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/contributing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>CronActor</title>
      <link>/docs/systems/filecoin_vm/sysactors/cron_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/cron_actor/</guid>
      <description>import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&amp;#34; import vmr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&amp;#34; type CronActorState struct { // Cron has no internal state } type CronActorCode struct { // actors is a set of actors to call during EpochTick.  // This can be done a bunch of ways. We do it this way here to make it easy to add  // a handler to Cron elsewhere in the spec code. How to do this is implementation  // specific.</description>
    </item>
    
    <item>
      <title>Data Model</title>
      <link>/docs/libraries/ipld/datamodel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/datamodel/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Data Structures</title>
      <link>/docs/listings/data_structures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/data_structures/</guid>
      <description>Address An address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. An address encodes information about:
 Network this address belongs to Type of data the address contains The data itself Checksum (depending on the type of address)  For more detail, see the full address spec.
Block A block header contains information relevant to a particular point in time over which the network may achieve consensus.</description>
    </item>
    
    <item>
      <title>Data Transfer Protocol</title>
      <link>/docs/listings/libp2p_protocols/data_transfer_protocol/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/libp2p_protocols/data_transfer_protocol/</guid>
      <description> Name: Data Transfer Protocol Protocol ID: /fil/data-transfer/0.0.1  Message Protobuf
 message DataTransferMessage { message Request { int32 transferID = 1 bool isPull = 2 bytes voucher = 3 bytes pieceID = 4 bytes selector = 5 bool isPartial = 6 bool isCancel = 7 } message Response { int32 transferID = 1 boolean accepted = 2 } bool isResponse = 1 Request request = 2 Response response = 3 }  </description>
    </item>
    
    <item>
      <title>Election PoSt</title>
      <link>/docs/algorithms/post/election_post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/post/election_post/</guid>
      <description>This document describes Election-PoSt, the Proof-of-Spacetime used in Filecoin.
High Level API Election PoSt couples the PoSt process with block production, meaning that in order to produce a block, the miner must produce a valid PoSt proof (snark output). Specifically, a subset of non-faulted sectors the miner is storing (i.e. eligible sectors) allows them to attempt a leader election using a ChallengeTicket any of which could yield a valid ElectionProof.</description>
    </item>
    
    <item>
      <title>Examples</title>
      <link>/docs/systems/filecoin_nodes/node_types/node_types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/node_types/</guid>
      <description>There are many kinds of Filecoin Nodes &amp;hellip;
This section should contain:
 what all nodes must have, and why examples of using different systems  </description>
    </item>
    
    <item>
      <title>Faults</title>
      <link>/docs/systems/filecoin_markets/storage_market/faults/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/faults/</guid>
      <description>There are two main categories of faults in the Filecoin network.
 ConsensusFaults StorageDealFaults  ConsensusFaults are faults that impact network consensus and StorageDealFaults are faults where data in a StorageDeal is not maintained by the providers pursuant to deal terms.
 is slashed for ConsensusFaults and Storage Deal Collateral for StorageDealFaults.
Any misbehavior may result in more than one fault thus lead to slashing on both collaterals. For example, missing a PoStProof will incur a penalty on both PledgeCollateral and StorageDealCollateral given it impacts both a given StorageDeal and power derived from the sector commitments in Storage Power Consensus.</description>
    </item>
    
    <item>
      <title>FIL Wallet</title>
      <link>/docs/systems/filecoin_token/wallets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/wallets/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Filecoin libp2p Nodes</title>
      <link>/docs/libraries/libp2p/fil_libp2p_nodes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/fil_libp2p_nodes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/orient/</guid>
      <description>All Parameters    Parameter Type Value Description     ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.   ALL-POST-MESSAGES-PER-YEAR  122557560.0    ALL-SEAL-MESSAGES-PER-YEAR  335544320    ALL-SEAL-SIZE-PER-YEAR  335544320    AVG-POSTS-MESSAGES-PER-BLOCK  11.650845    AVG-PROOFS-MESSAGES-PER-BLOCK  43.</description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/orient/</guid>
      <description>(asdf:load-system :orient) (in-package orient.lang)  #&amp;lt;PACKAGE &amp;#34;ORIENT.LANG&amp;#34;&amp;gt;  (defparameter *filecoin* (get-system &amp;#34;../orient/filecoin.orient&amp;#34;)) (defparameter *input* (interface:get-json-relation-list &amp;#34;../orient/params.json&amp;#34;)) (defparameter *multi-input* (interface:get-json-relation-list &amp;#34;../orient/multi-params.json&amp;#34;))  *MULTI-INPUT*  All Parameters  (let ((result-tuple (extract (solve-for *filecoin* &amp;#39;() *input*)))) (org-present-tuple result-tuple *filecoin*))     Parameter Type Value Description   ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.</description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/content/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/appendix/orient/</guid>
      <description>All Parameters    Parameter Type Value Description     ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.   ALL-POST-MESSAGES-PER-YEAR  122557560.0    ALL-SEAL-MESSAGES-PER-YEAR  335544320    ALL-SEAL-SIZE-PER-YEAR  335544320    AVG-POSTS-MESSAGES-PER-BLOCK  11.650845    AVG-PROOFS-MESSAGES-PER-BLOCK  43.</description>
    </item>
    
    <item>
      <title>Filecoin VM</title>
      <link>/docs/intro/filecoin_vm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/filecoin_vm/</guid>
      <description>The majority of Filecoin&amp;rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &amp;lsquo;chain&amp;rsquo; of blocks is the correct one. Each block contains a series of state transitions called messages, and a checkpoint of the current global state after the application of those messages.
The global state here consists of a set of actors, each with their own private state.</description>
    </item>
    
    <item>
      <title>Filecoin VM Actors</title>
      <link>/docs/listings/actors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/actors/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>FileStore - Local Storage for Files</title>
      <link>/docs/systems/filecoin_files/file/filestore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_files/file/filestore/</guid>
      <description>The FileStore is an abstraction used to refer to any underlying system or device that Filecoin will store its data to. It is based on Unix filesystem semantics, and includes the notion of Paths. This abstraction is here in order to make sure Filecoin implementations make it easy for end-users to replace the underlying storage system with whatever suits their needs. The simplest version of FileStore is just the host operating system&amp;rsquo;s file system.</description>
    </item>
    
    <item>
      <title>FIPs - Filecoin Improvement Proposals</title>
      <link>/docs/intro/process/fip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/fip/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>GossipSub</title>
      <link>/docs/algorithms/gossip_sub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/gossip_sub/</guid>
      <description>Messages and block headers along side the message references are propagated using the gossipsub libp2p pubsub router. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be syntactically validated before being propagated further.
Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it. This allows any node to fetch missing pieces (e.</description>
    </item>
    
    <item>
      <title>Gossipsub for broadcasts</title>
      <link>/docs/libraries/libp2p/gossipsub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/gossipsub/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GraphStore - IPLD Data Storage</title>
      <link>/docs/libraries/ipld/graphstore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/graphstore/</guid>
      <description> // imported as ipld.Store type GraphStore struct { Get(cid CID) (Object, error) Put(o Object) (CID, error) }  </description>
    </item>
    
    <item>
      <title>GraphSync</title>
      <link>/docs/libraries/ipfs/graphsync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/graphsync/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Implementing Systems</title>
      <link>/docs/intro/system/impl_systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/system/impl_systems/</guid>
      <description>System Requirements In order to make it easier to decouple functionality into systems, the Filecoin Protocol assumes a set of functionality available to all systems. This functionality can be achieved by implementations in a variety of ways, and should take the guidance here as a recommendation (SHOULD).
All Systems, as defined in this document, require the following:
 Repository:  Local IpldStore. Some amount of persistent local storage for data structures (small structured objects).</description>
    </item>
    
    <item>
      <title>InitActor</title>
      <link>/docs/systems/filecoin_vm/sysactors/init_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/sysactors/init_actor/</guid>
      <description>(You can see the old InitActor here )
import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&amp;#34; import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&amp;#34; import vmr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&amp;#34; type InitActorState struct { // responsible for create new actors  AddressMap {addr.Address: addr.ActorID} IDMap {addr.ActorID: addr.Address} NextID addr.ActorID _assignNextID() addr.ActorID } type InitActorCode struct { Constructor(r vmr.Runtime) Exec(r vmr.Runtime, code actor.CodeID, params actor.MethodParams) addr.Address GetActorIDForAddress(r vmr.Runtime, address addr.Address) addr.ActorID } type ActorExecAddressSeed struct { creator addr.Address toplevelCallSeqNum actor.CallSeqNum internalCallSeqNum actor.CallSeqNum }  package sysactors import addr &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Kademlia DHT for Peer Routing</title>
      <link>/docs/libraries/libp2p/kad_dht/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/kad_dht/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Key Concepts</title>
      <link>/docs/intro/concepts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/concepts/</guid>
      <description>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:
 Data structures are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).
 Functions are computational procedures that do not depend on external state (i.e., mathematical functions, or programming language functions that do not refer to global variables).
 Components are sets of functionality that are intended to be represented as single software units in the implementation structure.</description>
    </item>
    
    <item>
      <title>Message Storage</title>
      <link>/docs/systems/filecoin_blockchain/message_pool/message_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/message_pool/message_storage/</guid>
      <description> TODO:
 give sample algorithm for miner message selection in block production (to avoid dups) give sample algorithm for message storage caching/purging policies.  </description>
    </item>
    
    <item>
      <title>Message Syncer</title>
      <link>/docs/systems/filecoin_blockchain/message_pool/message_syncer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/message_pool/message_syncer/</guid>
      <description>TODO:
 explain message syncer works include the message syncer code  Message Propagation Messages are propagated over the libp2p pubsub channel /fil/messages. On this channel, every serialised SignedMessage is announced.
Upon receiving the message, its validity must be checked: the signature must be valid, and the account in question must have enough funds to cover the actions specified. If the message is not valid it should be dropped and must not be forwarded.</description>
    </item>
    
    <item>
      <title>Mining Scheduler</title>
      <link>/docs/systems/filecoin_mining/storage_mining/mining_scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/mining_scheduler/</guid>
      <description>import poster &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&amp;#34; import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&amp;#34; import mining &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining&amp;#34; // import storage_indexer &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_indexer&amp;#34;  type MiningScheduler struct { getStagedSectors() sector.SectorSet getSealedSectors() sector.SealedSectorSet getFaultySectors() sector.SectorSet getRepairedSectors() sector.SectorSet // same as completedSectors/doneSectors  getExpiredSectors() sector.SectorSet ProducePost(sectors sector.SectorSet) poster.PoStSubmission VerifyPost(sectors sector.SectorSet) poster.PoStSubmission ReportFaults( actor &amp;amp;StorageMinerActorCode ) bool RemoveSectors(remove sector.SectorSet) bool DePledge( amount actor.TokenAmount ) bool // receives from sector storage subsystem  SealedSector( sealedSector mining.SealedSector ) bool AddSector( pledge actor.</description>
    </item>
    
    <item>
      <title>Multisig Actor</title>
      <link>/docs/systems/filecoin_token/multisig/multisig_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/multisig/multisig_actor/</guid>
      <description>(You can see the old Multisig Actor here )
import address &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&amp;#34; import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&amp;#34; type TxSeqNo UVarint type NumRequired UVarint type EpochDuration UVarint type Epoch UVarint type MultisigActor struct { signers [address.Address] required NumRequired nextTxId TxSeqNo initialBalance actor.TokenAmount startingBlock Epoch unlockDuration EpochDuration // transactions {TxSeqNo: Transaction} // TODO Transaction type does not exist  Construct( signers [address.Address] required NumRequired unlockDuration EpochDuration ) Propose( to address.Address value actor.TokenAmount method string params Bytes ) TxSeqNo Approve(txid TxSeqNo) Cancel(txid TxSeqNo) ClearCompleted() AddSigner(signer address.</description>
    </item>
    
    <item>
      <title>Network tooling</title>
      <link>/docs/intro/process/related_resources/network_tooling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/network_tooling/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Node Interface</title>
      <link>/docs/systems/filecoin_nodes/node_types/node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/node/</guid>
      <description>Something&#39;s not right. The filecoin_node.id file was not found.</description>
    </item>
    
    <item>
      <title>Payment Channel Actor</title>
      <link>/docs/systems/filecoin_token/payment_channels/payment_channel_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/payment_channels/payment_channel_actor/</guid>
      <description>(You can see the old Payment Channel Actor here )
type Voucher struct {} type VouchersApprovalResponse struct {} type PieceInclusionProof struct {} type PaymentChannelActor struct { RedeemVoucherWithApproval(voucher Voucher) RedeemVoucherWithPIP(voucher Voucher, pip PieceInclusionProof) }  </description>
    </item>
    
    <item>
      <title>Payment Channels</title>
      <link>/docs/algorithms/payment_channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/payment_channels/</guid>
      <description>Payment Channels In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.
The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &amp;ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Payments</title>
      <link>/docs/systems/filecoin_token/payments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/payments/</guid>
      <description></description>
    </item>
    
    <item>
      <title>PieceStore - storing and indexing pieces</title>
      <link>/docs/systems/filecoin_files/piece/piece_store/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_files/piece/piece_store/</guid>
      <description>A PieceStore is an object that can store and retrieve pieces from some local storage. The PieceStore additionally keeps an index of pieces.
import ipld &amp;#34;github.com/filecoin-project/specs/libraries/ipld&amp;#34; type PieceID UVarint // PieceStore is an object that stores pieces into some local storage. // it is internally backed by an IpldStore. type PieceStore struct { Store ipld.Store Index {PieceID: Piece} Get(i PieceID) struct {p Piece, e error} Put(p Piece) error Delete(i PieceID) error }  </description>
    </item>
    
    <item>
      <title>PoSt Parameters</title>
      <link>/docs/algorithms/post/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/post/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
   Parameter Type Value Description     POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.   POST-CHALLENGE-HOURS HOURS 2 PoSt challenge time (see POST_CHALLENGE_BLOCKS).   POST-PROVING-PERIOD BLOCKS 5760 The time interval in which a PoSt has to be submitted    TODO: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</description>
    </item>
    
    <item>
      <title>PoSt Parameters</title>
      <link>/docs/algorithms/post/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/post/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin. (asdf:load-system :orient) (in-package orient.lang)  #&amp;lt;PACKAGE &amp;#34;ORIENT.LANG&amp;#34;&amp;gt;  (defparameter *filecoin* (get-system &amp;#34;../../orient/filecoin.orient&amp;#34;)) (defparameter *input* (interface:get-json-relation-list &amp;#34;../../orient/params.json&amp;#34;)) (defparameter *multi-input* (interface:get-json-relation-list &amp;#34;../../orient/multi-params.json&amp;#34;))  *MULTI-INPUT*  (let ((result-tuple (extract (ask *filecoin* &amp;#39;(post-challenge-blocks post-challenge-hours post-proving-period) *input*)))) (org-present-tuple result-tuple *filecoin*))     Parameter Type Value Description   POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started.</description>
    </item>
    
    <item>
      <title>PoSt Parameters</title>
      <link>/docs/content/algorithms/post/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/algorithms/post/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
   Parameter Type Value Description     POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.   POST-CHALLENGE-HOURS HOURS 2 PoSt challenge time (see POST_CHALLENGE_BLOCKS).   POST-PROVING-PERIOD BLOCKS 5760 The time interval in which a PoSt has to be submitted    TODO: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</description>
    </item>
    
    <item>
      <title>Relayer Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/relayer_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/relayer_node/</guid>
      <description>type RelayerNode interface { FilecoinNode blockchain.MessagePool markets.MarketOrderBook }  </description>
    </item>
    
    <item>
      <title>Research portal</title>
      <link>/docs/intro/process/related_resources/research_portal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/research_portal/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Retrieval Client</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_client/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_client/</guid>
      <description>Client Dependencies The Retrieval Client Depends On The Following Dependencies
 Host: A libp2p host (set setup the libp2p protocols) Filecoin Node: A node implementation to query the chain for pieces and to setup and manage payment channels BlockStore: Same as one used by data transfer module Data Transfer: V1 only &amp;ndash;Module used for transferring payload. Writes to the blockstore.  API import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&amp;#34; import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&amp;#34; import libp2p &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Retrieval Miner Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/retrieval_miner_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/retrieval_miner_node/</guid>
      <description>type RetrievalMinerNode interface { FilecoinNode blockchain.Blockchain markets.RetrievalMarketProvider markets.MarketOrderBook markets.DataTransfers }  </description>
    </item>
    
    <item>
      <title>Retrieval Peer Resolver</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_peer_resolver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_peer_resolver/</guid>
      <description>The peer resolver is a content routing interface to discover retrieval miners that have a given Piece.
It can be backed by both a local store of previous storage deals or by querying the chain.
import piece &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&amp;#34; type RetrievalPeerResolver struct { GetPeers(PieceCID piece.PieceCID) [RetrievalPeer] }  </description>
    </item>
    
    <item>
      <title>Retrieval Protocols</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_protocols/</guid>
      <description>The retrieval market will initially be implemented as two libp2p services.
 Name: Query Protocol Protocol ID V0: /fil/retrieval/qry/0.0.1 Protocol ID V1: /fil/retrieval/qry/1.0.0  Request: CBOR Encoded RetrievalQuery Data Structure Response: CBOR Encoded RetrievalQueryResponse Data Structure
 Name: Retrieval Protocol Protocol ID V0: /fil/retrieval/0.0.1  V0: Request: CBOR Encoded RetrievalDealProposal Data Structure Response: CBOR Encoded RetrievalDealResponse Data Structure &amp;ndash; Following Request: CBOR Encoded RetrievalPayment Data Structure Response: CBOR Encoded RetrievalDealResponse Data Structure w/ Blocks</description>
    </item>
    
    <item>
      <title>Retrieval Provider (Miner)</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_provider/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_provider/</guid>
      <description>Provider Dependencies The Retrieval Provider Depends On The Following Dependencies
 Host: A libp2p host (set setup the libp2p protocols) Filecoin Node: A node implementation to query the chain for pieces and to setup and manage payment channels StorageMining Subsystem: For unsealing sectors BlockStore: Same as one used by data transfer module Data Transfer: V1 only &amp;ndash; Module used for transferring payload. Reads from the blockstore.  API import actor &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Sector Builder</title>
      <link>/docs/systems/filecoin_mining/sector_index/sector_builder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector_index/sector_builder/</guid>
      <description>import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; // import smkt &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&amp;#34; import deal &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&amp;#34; // SectorBuilder accumulates deals, keeping track of their // sector configuration requirements and the piece sizes. // Once there is a sector ready to be sealed, NextSector // will return a sector.  type StageDealResponse struct { SectorID sector.SectorID } type SectorBuilder struct { // DealsToSeal keeps a set of StorageDeal objects.  // These include the info for the relevant pieces.</description>
    </item>
    
    <item>
      <title>Sector Sealer</title>
      <link>/docs/systems/filecoin_mining/storage_proving/sector_sealer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_proving/sector_sealer/</guid>
      <description>Sector Sealer
Something&#39;s not right. The sector_sealer.id file was not found.</description>
    </item>
    
    <item>
      <title>Sector Sealing</title>
      <link>/docs/systems/filecoin_mining/sector/sealing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector/sealing/</guid>
      <description>import file &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; import piece &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&amp;#34; import deal &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&amp;#34; import block &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&amp;#34; type Path struct {} // TODO  type SealRandomness Bytes type InteractiveSealRandomness Bytes // SealSeed is unique to each Sector // SealSeed is: // SealSeedHash(MinerID, SectorNumber, SealRandomness, UnsealedSectorCID) type SealSeed Bytes type SealCfg struct { SectorSize UInt WindowCount UInt Partitions UInt } // SealVerifyInfo is the structure of all thte information a verifier // needs to verify a Seal.</description>
    </item>
    
    <item>
      <title>Sector Set</title>
      <link>/docs/systems/filecoin_mining/sector/sectorset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector/sectorset/</guid>
      <description> // sector sets type SectorSet [SectorID] type UnsealedSectorSet SectorSet type SealedSectorSet SectorSet // compact sector sets type Bitfield Bytes type RLEpBitfield Bitfield type CompactSectorSet RLEpBitfield  </description>
    </item>
    
    <item>
      <title>SectorStore</title>
      <link>/docs/systems/filecoin_mining/sector_index/sector_store/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector_index/sector_store/</guid>
      <description>import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; import piece &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&amp;#34; import file &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; type SectorStore struct { // FileStore stores all the unsealed and sealed sectors.  FileStore file.FileStore // PieceStore is shared with DataTransfer, and is a way to store or read  // pieces temporarily. This may or may not be backed by the FileStore above.  PieceStore piece.PieceStore // GetSectorFile returns the file for a given sector id.  // If the SectorID does not have any sector files associated yet, GetSectorFiles  // returns an error.</description>
    </item>
    
    <item>
      <title>Selectors - IPLD Query Language</title>
      <link>/docs/libraries/ipld/selectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/selectors/</guid>
      <description>// This is a compression of the IPLD Selector Spec // Full spec: https://github.com/ipld/specs/blob/master/selectors/selectors.md  type Selector union { Matcher ExploreAll ExploreFields ExploreIndex ExploreRange ExploreRecursive ExploreUnion ExploreConditional ExploreRecursiveEdge } // ExploreAll is similar to a `*` -- it traverses all elements of an array, // or all entries in a map, and applies a next selector to the reached nodes. type ExploreAll struct { next Selector } // ExploreFields traverses named fields in a map (or equivalently, struct, if // traversing on typed/schema nodes) and applies a next selector to the // reached nodes.</description>
    </item>
    
    <item>
      <title>Sharded IPLD Array</title>
      <link>/docs/appendix/sharray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/sharray/</guid>
      <description>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.
IPLD Representation Each sharray node is represented by an IPLD node of the following schema:
type Node struct { height Int items [Item] } representation tuple  Item may be either a direct value, if height == 0, or the Cid of a child node if height &amp;gt; 0.</description>
    </item>
    
    <item>
      <title>Signatures</title>
      <link>/docs/algorithms/crypto/signatures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/crypto/signatures/</guid>
      <description>Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages with the assurance that each message was generated by a specific entity. In other words, it is infeasible for an entity i to generate a signed message that appears to have been generated by j, with j != i.
Filecoin uses signatures to associate an action to a given party.</description>
    </item>
    
    <item>
      <title>Stacked DRG Commitments</title>
      <link>/docs/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</guid>
      <description>This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in Tight PoS - ZigZag.
Graph In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only to illustrate the nature of the SDR commitment scheme. They accurately represent how parent-child relationships function between layers, and are accurate for expander parents. However, this is not representative of the DRG parent selection algorithm.</description>
    </item>
    
    <item>
      <title>Stacked DRG Commitments</title>
      <link>/docs/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</guid>
      <description>(ql:quickload :orient)     :ORIENT     This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in Tight PoS - ZigZag. Graph  (defparameter *layers* 4) (defparameter *nodes* 8) (defparameter *regenerate-sdr-graph* nil) (defparameter *dumped-sdr-graph* &amp;#39;(:NODES 8 :CHALLENGED-NODE 7 :LAYERS 4 :RENUMBERED-PERMUTATION (:PERM-LIST (7 4 3 6 1 8 2 5) :TYPE PERM) :REVERSED-PERMUTATION (:PERM-LIST (3 7 8 6 5 1 4 2) :TYPE PERM) :TYPE SDR-GRAPH)) (defparameter *sdr-graph* (if *regenerate-sdr-graph* (make-sdr-graph *nodes* *layers*) (load-from-plist *dumped-sdr-graph*))) (let ((lg (first (sdr-graph-layer-graphs *sdr-graph*)))) (defparameter *comm-d-graph* (make-comm-d-layer-graph (layer-graph-nodes lg) (layer-graph-challenged-node lg) :parent *sdr-graph*)) (defparameter *replica-graph* (make-replica-layer-graph (layer-graph-nodes lg) (layer-graph-challenged-node lg) :parent *sdr-graph* :layers *layers*))) (dump *sdr-graph*)  (:NODES 8 :CHALLENGED-NODE 7 :LAYERS 4 :RENUMBERED-PERMUTATION (:PERM-LIST (7 4 3 6 1 8 2 5) :TYPE PERM) :REVERSED-PERMUTATION (:PERM-LIST (3 7 8 6 5 1 4 2) :TYPE PERM) :TYPE SDR-GRAPH)  (emit-legend nil)   In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only to illustrate the nature of the SDR commitment scheme.</description>
    </item>
    
    <item>
      <title>Stacked DRG Commitments</title>
      <link>/docs/content/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/algorithms/porep/porep_commitments/sdr_commitments/sdr_commitments/</guid>
      <description>This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in Tight PoS - ZigZag.
Graph In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only to illustrate the nature of the SDR commitment scheme. They accurately represent how parent-child relationships function between layers, and are accurate for expander parents. However, this is not representative of the DRG parent selection algorithm.</description>
    </item>
    
    <item>
      <title>Stacked DRG PoRep</title>
      <link>/docs/algorithms/porep/stacked_drg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/stacked_drg/</guid>
      <description>This section describes Stacked DRG PoRep (SDR), the specific Proof-of-Replication (PoRep) used in Filecoin. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.
SDR has been presented by Ben Fisch at EUROCRYPT19.
Introduction Background on Proof-of-Replication Proof-of-Replication enables a prover P to convince a verifier V that P is storing a replica R, a physically independent copy of some data D, unique to P.</description>
    </item>
    
    <item>
      <title>Storage Client</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_client/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_client/</guid>
      <description>Both StorageProvider and StorageClient are StorageMarketParticipant. Any party can be a storage provider or client or both at the same time. Storage deal negotiation is expected to happen completely off chain and the request-response style storage deal protocol is to submit agreed-upon storage deal onto the network and gain storage power on chain. StorageClient will initiate the storage deal protocol by submitting a StorageDealProposal to the StorageProvider who will then add the deal data to a Sector and commit the sector onto the blockchain.</description>
    </item>
    
    <item>
      <title>Storage Market Actor</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_market_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_market_actor/</guid>
      <description>StorageMarketActor is responsible for processing and managing on-chain deals. This is also the entry point of all storage deals and data into the system. It maintains a mapping of StorageDealID to StorageDeal and keeps track of locked balances of StorageClient and StorageProvider. When a deal is posted on chain through the StorageMarketActor, it will first check if both transacting parties have sufficient balances locked up and include the deal on chain.</description>
    </item>
    
    <item>
      <title>Storage Miner Actor</title>
      <link>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor/</guid>
      <description>(You can see the old Storage Miner Actor here )
StorageMinerActor interface import libp2p &amp;#34;github.com/filecoin-project/specs/libraries/libp2p&amp;#34; import sealing &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; import address &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&amp;#34; import block &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&amp;#34; import poster &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&amp;#34; import deal &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&amp;#34; type SectorExpirationQueueItem struct { SectorNumber sector.SectorNumber Expiration block.ChainEpoch } type SectorExpirationQueue struct { Add(i SectorExpirationQueueItem) Pop() SectorExpirationQueueItem Peek() SectorExpirationQueueItem Remove(n sector.SectorNumber) } type SectorTable struct { SectorSize sector.SectorSize ActiveSectors sector.CompactSectorSet CommittedSectors sector.CompactSectorSet RecoveringSectors sector.CompactSectorSet FailingSectors sector.</description>
    </item>
    
    <item>
      <title>Storage Miner Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/storage_miner_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/storage_miner_node/</guid>
      <description>type StorageMinerNode interface { FilecoinNode systems.Blockchain systems.Mining markets.StorageMarketProvider markets.MarketOrderBook markets.DataTransfers }  </description>
    </item>
    
    <item>
      <title>Storage Mining Cycle</title>
      <link>/docs/systems/filecoin_mining/storage_mining/mining_cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/mining_cycle/</guid>
      <description>Block miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning ticket to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.
The Miner Actor After successfully calling CreateStorageMiner, a miner actor will be created on-chain, and registered in the storage market.</description>
    </item>
    
    <item>
      <title>Storage Power Actor</title>
      <link>/docs/systems/filecoin_blockchain/storage_power_consensus/storage_power_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/storage_power_consensus/storage_power_actor/</guid>
      <description>StoragePowerActor interface import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&amp;#34; import libp2p &amp;#34;github.com/filecoin-project/specs/libraries/libp2p&amp;#34; import block &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&amp;#34; import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&amp;#34; import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; type PowerTableEntry struct { ActivePower block.StoragePower InactivePower block.StoragePower AvailableBalance actor.TokenAmount LockedPledgeCollateral actor.TokenAmount } type PowerReport struct { ActivePower block.StoragePower // set value  InactivePower block.StoragePower // set value } // type PowerTableHAMT {actor.ActorID: PowerTableEntry} type PowerTableHAMT {addr.Address: PowerTableEntry} // TODO: convert address to ActorID  // TODO: What does graceful removal look like?</description>
    </item>
    
    <item>
      <title>Storage Provider</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_provider/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_provider/</guid>
      <description>Both StorageProvider and StorageClient are StorageMarketParticipant. Any party can be a storage provider or client or both at the same time. Storage deal negotiation is expected to happen completely off chain and the request-response style storage deal protocol is to submit agreed-upon storage deal onto the network and gain storage power on chain. StorageClient will initiate the storage deal protocol by submitting a StorageDealProposal to the StorageProvider who will then add the deal data to a Sector and commit the sector onto the blockchain.</description>
    </item>
    
    <item>
      <title>Testing and implementation compliance</title>
      <link>/docs/intro/process/related_resources/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/testing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>UnixFS</title>
      <link>/docs/libraries/ipfs/unixfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/unixfs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Usage in Systems</title>
      <link>/docs/systems/filecoin_nodes/repository/usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/repository/usage/</guid>
      <description>TODO: - Explain how repo is used with systems and subsystems - compartmentalized local storage - store ipld datastructures of stateful objects</description>
    </item>
    
    <item>
      <title>Verifiable Random Function</title>
      <link>/docs/algorithms/crypto/vrf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/crypto/vrf/</guid>
      <description>Filecoin uses the notion of a Verifiable Random Function (VRF). A VRF uses a private key to produce a digest of an arbitrary message such that the output is unique per signer and per message. Any third party in possession of the corresponding public key, the message and the VRF output can verify if the digest has been computed correctly and from the correct signer. Using a VRF in the ticket generation process allows anyone to verify if a block comes from an eligible block producer (see Ticket Generation for more details).</description>
    </item>
    
    <item>
      <title>VM Interpreter</title>
      <link>/docs/systems/filecoin_vm/interpreter/vm_interpreter_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_vm/interpreter/vm_interpreter_old/</guid>
      <description>VM Interpreter Sending Funds As all messages carry a method ID, the method ID &amp;lsquo;0&amp;rsquo; is reserved for simple transfers of funds. Funds specified by the value field are always transferred, but specifying a method ID of &amp;lsquo;0&amp;rsquo; ensures that no other side effects occur.
State Representation The global state is modeled as a map of actor IDs to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT) with the &amp;lsquo;key&amp;rsquo; being the serialized ID address (every actor has an ID address that can be looked up via the InitActor), and the value is an Actor object with the actors information.</description>
    </item>
    
    <item>
      <title>What are Systems? How do they work?</title>
      <link>/docs/intro/system/why_systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/system/why_systems/</guid>
      <description>Filecoin decouples and modularizes functionality into loosely-joined systems. Each system adds significant functionality, usually to achieve a set of important and tightly related goals.
For example, the Blockchain System provides structures like Block, Tipset, and Chain, and provides functionality like Block Sync, Block Propagation, Block Validation, Chain Selection, and Chain Access. This is separated from the Files, Pieces, Piece Preparation, and Data Transfer. Both of these systems are separated from the Markets, which provide Orders, Deals, Market Visibility, and Deal Settlement.</description>
    </item>
    
  </channel>
</rss>