<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Filecoin Specification on Filecoin Spec</title>
    <link>/</link>
    <description>Recent content in Filecoin Specification on Filecoin Spec</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>/docs/algorithms/porep/porep_commitments/zigzag_commitments/zigzag_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/porep_commitments/zigzag_commitments/zigzag_commitments/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_blockchain/vm/sysactors/account_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/vm/sysactors/account_actor_old/</guid>
      <description>Account Actor  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;account&amp;quot;&amp;gt;  The Account actor is the actor used for normal keypair backed accounts on the filecoin network.
type AccountActorState struct { address Address } Methods    Name Method ID     AccountConstructor 1   GetAddress 2    type AccountConstructor struct { }  GetAddress Parameters
type GetAddress struct { } representation tuple Algorithm
func GetAddress() Address { return self.</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_blockchain/vm/sysactors/init_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/vm/sysactors/init_actor_old/</guid>
      <description>Init Actor  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;init&amp;quot;&amp;gt;  The init actor is responsible for creating new actors on the filecoin network. This is a built-in actor and cannot be replicated. In the future, this actor will be responsible for loading new code into the system (for user programmable actors). ID allocation for user instantiated actors starts at 100. This means that NextID will initially be set to 100.
type InitActorState struct { addressMap {Address:ID}&amp;lt;Hamt&amp;gt; nextId UInt } Methods    Name Method ID     Constructor 1   Exec 2   GetIdForAddress 3    Constructor Parameters</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_market_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_market_actor_old/</guid>
      <description>Storage Market Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;smarket&amp;quot;&amp;gt;  The storage market actor is the central point for the Filecoin storage market. It is responsible for registering new miners to the system, and maintaining the power table. The Filecoin storage market is a singleton that lives at a specific well-known address.
type StorageMarketActorState struct { miners {Address:Null}&amp;lt;Hamt&amp;gt; totalStorage BytesAmount } Methods    Name Method ID     StorageMarketConstructor 1   CreateStorageMiner 2   SlashConsensusFault 3   UpdateStorage 4   GetTotalStorage 5   PowerLookup 6   IsMiner 7   StorageCollateralForSize 8    Constructor Parameters</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor_old/</guid>
      <description>Storage Miner Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;sminer&amp;quot;&amp;gt;
type StorageMinerActorState struct { ## contains mostly static info about this miner info &amp;amp;MinerInfo ## Collateral that is waiting to be withdrawn. dePledgedCollateral TokenAmount ## Time at which the depledged collateral may be withdrawn. dePledgeTime BlockHeight ## All sectors this miner has committed. sectors &amp;amp;SectorSet ## Sectors this miner is currently mining. It is only updated ## when a PoSt is submitted (not as each new sector commitment is added).</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_token/multisig/multisig_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/multisig/multisig_actor_old/</guid>
      <description>Multisig Account Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;multisig&amp;quot;&amp;gt;  A basic multisig account actor. Allows sending of messages like a normal account actor, but with the requirement of M of N parties agreeing to the operation. Completed and/or cancelled operations stick around in the actors state until explicitly cleared out. Proposers may cancel transactions they propose, or transactions by proposers who are no longer approved signers.
Self modification methods (add/remove signer, change requirement) are called by doing a multisig transaction invoking the desired method on the contract itself.</description>
    </item>
    
    <item>
      <title></title>
      <link>/docs/systems/filecoin_token/payment_channels/payment_channel_actor_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/payment_channels/payment_channel_actor_old/</guid>
      <description>Payment Channel Actor (DEPRECATED)  Code Cid: &amp;lt;codec:raw&amp;gt;&amp;lt;mhType:identity&amp;gt;&amp;lt;&amp;quot;paych&amp;quot;&amp;gt;  The payment channel actor manages the on-chain state of a point to point payment channel.
type PaymentChannel struct { from Address to Address toSend TokenAmount closingAt UInt minCloseHeight UInt laneStates {UInt:LaneState} } representation tuple type SignedVoucher struct { TimeLock BlockHeight SecretPreimage Bytes Extra ModVerifyParams Lane Uint Nonce Uint Merges []Merge Amount TokenAmount MinCloseHeight Uint Signature Signature } type ModVerifyParams struct { Actor Address Method Uint Data Bytes } type Merge struct { Lane Uint Nonce Uint } type LaneState struct { Closed bool Redeemed TokenAmount Nonce Uint } type PaymentChannelMethod union { | PaymentChannelConstructor 0 | UpdateChannelState 1 | Close 2 | Collect 3 } representation keyed Methods    Name Method ID     Constructor 1   UpdateChannelState 2   Close 3   Collect 4    Constructor Parameters</description>
    </item>
    
    <item>
      <title>About this specification</title>
      <link>/docs/intro/process/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/about/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>AccountActor</title>
      <link>/docs/systems/filecoin_blockchain/vm/sysactors/account_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/vm/sysactors/account_actor/</guid>
      <description>(You can see the old AccountActor here )
import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/vm/address&amp;#34; type AccountActorState struct { // normal keypair backed accounts  Address addr.Address }  </description>
    </item>
    
    <item>
      <title>Address</title>
      <link>/docs/appendix/address/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/address/</guid>
      <description>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</description>
    </item>
    
    <item>
      <title>Architecture Diagrams</title>
      <link>/docs/intro/arch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/arch/</guid>
      <description>Filecoin Systems Systems   Filecoin Nodes ‚öôÔ∏è   Node Types     Repository     Network Interface     Clock       Files &amp;amp; Data üìë   File     Piece     Data Transfer       Blockchain üì¶   Virtual Machine     Message Pool     Blockchain Components     Storage Power Consensus       Token üìÄ   Wallet     Payments     Payment Channels     Multisig Wallet       Storage Mining ‚õè   Storage Miner     Sector     Sector Index     Storage Proving       Market ‚öñÔ∏è   Orders     Deals     Storage Market     Retrieval Market          Overview Diagram TODO:</description>
    </item>
    
    <item>
      <title>BitSwap</title>
      <link>/docs/libraries/ipfs/bitswap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/bitswap/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Block Producer</title>
      <link>/docs/systems/filecoin_blockchain/blockchain/block_producer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/blockchain/block_producer/</guid>
      <description>Mining Blocks Having registered as a miner, it&amp;rsquo;s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest Tipsets seen on the network.
For additional details around how consensus works in Filecoin, see the expected consensus spec. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner should mine a block themselves, and some rules pertaining to how &amp;ldquo;Tickets&amp;rdquo; should be validated during block validation.</description>
    </item>
    
    <item>
      <title>Block Reception</title>
      <link>/docs/algorithms/block_reception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/block_reception/</guid>
      <description>func (g *BlockValidationGraph_I) ConsiderBlock(block Block) { panic(&amp;ldquo;TODO&amp;rdquo;) // g.UnconnectedBlocks.AddBlock(block) // g.tryConnectBlockToFringe(block) }
func (g *BlockValidationGraph_I) tryConnectBlockToFringe(block Block) { panic(&amp;ldquo;TODO&amp;rdquo;)
// try to connect the block, and then try connecting its descendents. // // this algorithm should be breadth-first because we need to process the fringe // in order. Depth-first search may consider blocks whose parents are still // yet to be added // blocks := Queue &amp;lt; Block &amp;gt; // blocks.</description>
    </item>
    
    <item>
      <title>Block Syncer</title>
      <link>/docs/systems/filecoin_blockchain/blockchain/block_syncer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/blockchain/block_syncer/</guid>
      <description>In order to ensure they are always on the correct latest state of the blockchain, a Filecoin node must continuously monitor and propagate blocks on the network.
When a node receives blocks, it must also validate them. Validation is split into two stages, syntactic and semantic. The syntactic stage may be validated without reference to additional data, the semantic stage requires access to the chain which the block extends.</description>
    </item>
    
    <item>
      <title>BlockSync</title>
      <link>/docs/algorithms/block_sync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/block_sync/</guid>
      <description>Name: Block Sync Protocol ID: /fil/sync/blk/0.0.1  The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol.
The request requests a chain of a given length by the hash of its highest block. The Options allow the requester to specify whether or not blocks and messages to be included.
The response contains the requested chain in reverse iteration order.</description>
    </item>
    
    <item>
      <title>Chain Manager</title>
      <link>/docs/systems/filecoin_blockchain/blockchain/chain_manager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/blockchain/chain_manager/</guid>
      <description>The Chain Manager is a central component in the blockchain system. It tracks and updates competing subchains received by a given node in order to select the appropriate blockchain head: the latest block of the heaviest subchain it is aware of in the system.
In so doing, the chain manager is the central subsystem that handles bookkeeping for numerous other systems in a Filecoin node and exposes convenience methods for use by those systems, enabling systems to sample randomness from the chain for instance, or to see which block has been finalized most recently.</description>
    </item>
    
    <item>
      <title>Chain Verifier Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/verifier_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/verifier_node/</guid>
      <description>type ChainVerifierNode interface { FilecoinNode systems.Blockchain }  </description>
    </item>
    
    <item>
      <title>CIDs - Content IDentifiers</title>
      <link>/docs/libraries/ipld/cid/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/cid/</guid>
      <description> type BytesKey string // so that we can use it in go maps  type CID BytesKey // TODO: remove util.  </description>
    </item>
    
    <item>
      <title>Client Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/client_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/client_node/</guid>
      <description>type ClientNode struct { FilecoinNode systems.Blockchain markets.StorageMarketClient markets.RetrievalMarketClient markets.MarketOrderBook markets.DataTransfers }  </description>
    </item>
    
    <item>
      <title>Components</title>
      <link>/docs/listings/system_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/system_map/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Contributing to the Filecoin spec</title>
      <link>/docs/intro/process/contributing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/contributing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>CronActor</title>
      <link>/docs/systems/filecoin_blockchain/vm/sysactors/cron_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/vm/sysactors/cron_actor/</guid>
      <description> type CronActor struct { // Tick executes built-in periodic actions.  Tick() }  </description>
    </item>
    
    <item>
      <title>Data Model</title>
      <link>/docs/libraries/ipld/datamodel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/datamodel/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Data Structures</title>
      <link>/docs/listings/data_structures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/data_structures/</guid>
      <description>Address An address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. An address encodes information about:
 Network this address belongs to Type of data the address contains The data itself Checksum (depending on the type of address)  For more detail, see the full address spec.
Block A block header contains information relevant to a particular point in time over which the network may achieve consensus.</description>
    </item>
    
    <item>
      <title>Examples</title>
      <link>/docs/systems/filecoin_nodes/node_types/node_types/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/node_types/</guid>
      <description>There are many kinds of Filecoin Nodes &amp;hellip;
This section should contain:
 what all nodes must have, and why examples of using different systems  </description>
    </item>
    
    <item>
      <title>Expected Consensus</title>
      <link>/docs/algorithms/expected_consensus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/expected_consensus/</guid>
      <description>Algorithm Expected Consensus (EC) is a probabilistic Byzantine fault-tolerant consensus protocol. At a high level, it operates by running a leader election every round in which, on expectation, one participant may be eligible to submit a block. EC guarantees that this winner will be anonymous until they reveal themselves by submitting a proof of their election (we call this proof an Election Proof). All valid blocks submitted in a given round form a Tipset.</description>
    </item>
    
    <item>
      <title>Expected Consensus</title>
      <link>/docs/systems/filecoin_blockchain/storage_power_consensus/expected_consensus/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/storage_power_consensus/expected_consensus/</guid>
      <description> type ChainWeight UVarint type ExpectedConsensus struct { // ComputeWeight(Chain)	ChainWeight  // TryElection(StorageMiner, TipSet)	ElectionProof  // VerifyElection(StorageMiner, ElectionProof)	bool  // IsConsensusFault([Block])	bool }  </description>
    </item>
    
    <item>
      <title>Faults</title>
      <link>/docs/systems/filecoin_markets/storage_market/faults/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/faults/</guid>
      <description>There are two main categories of faults in the Filecoin network.
 ConsensusFaults StorageDealFaults  ConsensusFaults are faults that hurt network consensus and StorageDealFaults are faults where data in a StorageDeal is not maintained by the providers. PledgeCollateral is slashed for ConsensusFaults and StorageDealCollateral for StorageDealFaults.
Any misbehavior may result in more than one fault and can lead to slashing on both collaterals. For example, missing a PoStProof will incur a penalty on both PledgeCollateral and StorageDealCollateral if there is the data is stored in a StorageDeal.</description>
    </item>
    
    <item>
      <title>FIL Wallet</title>
      <link>/docs/systems/filecoin_token/wallets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/wallets/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Filecoin libp2p Nodes</title>
      <link>/docs/libraries/libp2p/fil_libp2p_nodes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/fil_libp2p_nodes/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/orient/</guid>
      <description>All Parameters    Parameter Type Value Description     ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.   ALL-POST-MESSAGES-PER-YEAR  122557560.0    ALL-SEAL-MESSAGES-PER-YEAR  335544320    ALL-SEAL-SIZE-PER-YEAR  335544320    AVG-POSTS-MESSAGES-PER-BLOCK  11.650845    AVG-PROOFS-MESSAGES-PER-BLOCK  43.</description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/orient/</guid>
      <description>(asdf:load-system :orient) (in-package orient.lang)  #&amp;lt;PACKAGE &amp;#34;ORIENT.LANG&amp;#34;&amp;gt;  (defparameter *filecoin* (get-system &amp;#34;../orient/filecoin.orient&amp;#34;)) (defparameter *input* (interface:get-json-relation-list &amp;#34;../orient/params.json&amp;#34;)) (defparameter *multi-input* (interface:get-json-relation-list &amp;#34;../orient/multi-params.json&amp;#34;))  *MULTI-INPUT*  All Parameters  (let ((result-tuple (extract (solve-for *filecoin* &amp;#39;() *input*)))) (org-present-tuple result-tuple *filecoin*))     Parameter Type Value Description   ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.</description>
    </item>
    
    <item>
      <title>Filecoin Parameters</title>
      <link>/docs/content/appendix/orient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/appendix/orient/</guid>
      <description>All Parameters    Parameter Type Value Description     ACTOR-METHOD BYTES 8 The size required to represent an actor method.   ACTORS-MESSAGES-FRACTION  0.30000004    ACTORS-MESSAGES-PER-BLOCK  32.661842    ADDRESS-SIZE BYTES 35 The size of an address.   ALL-POST-MESSAGES-PER-YEAR  122557560.0    ALL-SEAL-MESSAGES-PER-YEAR  335544320    ALL-SEAL-SIZE-PER-YEAR  335544320    AVG-POSTS-MESSAGES-PER-BLOCK  11.650845    AVG-PROOFS-MESSAGES-PER-BLOCK  43.</description>
    </item>
    
    <item>
      <title>Filecoin VM</title>
      <link>/docs/intro/filecoin_vm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/filecoin_vm/</guid>
      <description>The majority of Filecoin&amp;rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &amp;lsquo;chain&amp;rsquo; of blocks is the correct one. Each block contains a series of state transitions called messages, and a checkpoint of the current global state after the application of those messages.
The global state here consists of a set of actors, each with their own private state.</description>
    </item>
    
    <item>
      <title>Filecoin VM Actors</title>
      <link>/docs/listings/actors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/actors/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>FileStore - Local Storage for Files</title>
      <link>/docs/systems/filecoin_files/file/filestore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_files/file/filestore/</guid>
      <description> // FileStore is an object that can store and retrieve files by path. type FileStore struct { Open(p Path) union {f File, e error} Create(p Path) union {f File, e error} Store(p Path, f File) error Delete(p Path) error // maybe add:  // Copy(SrcPath, DstPath) }  TODO:
 explain why this abstraction is needed explain OS filesystem as basic impl explain that users can replace w/ other systems give examples:  networked filesystems raw disk sectors - like haystack databases   </description>
    </item>
    
    <item>
      <title>FIPs - Filecoin Improvement Proposals</title>
      <link>/docs/intro/process/fip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/fip/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>GossipSub</title>
      <link>/docs/algorithms/gossip_sub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/gossip_sub/</guid>
      <description>Messages and block headers along side the message references are propagated using the gossipsub libp2p pubsub router. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be syntactically validated before being propagated further.
Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it. This allows any node to fetch missing pieces (e.</description>
    </item>
    
    <item>
      <title>Gossipsub for broadcasts</title>
      <link>/docs/libraries/libp2p/gossipsub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/gossipsub/</guid>
      <description></description>
    </item>
    
    <item>
      <title>GraphStore - IPLD Data Storage</title>
      <link>/docs/libraries/ipld/graphstore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/graphstore/</guid>
      <description> // imported as ipld.Store type GraphStore struct { Get(cid CID) union {o Object, err error} Put(o Object) union {cid CID, err error} }  </description>
    </item>
    
    <item>
      <title>GraphSync</title>
      <link>/docs/libraries/ipfs/graphsync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/graphsync/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Implementing Systems</title>
      <link>/docs/intro/system/impl_systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/system/impl_systems/</guid>
      <description>System Requirements In order to make it easier to decouple functionality into systems, the Filecoin Protocol assumes a set of functionality available to all systems. This functionality can be achieved by implementations in a variety of ways, and should take the guidance here as a recommendation (SHOULD).
All Systems, as defined in this document, require the following:
 Repository:  Local IpldStore. Some amount of persistent local storage for data structures (small structured objects).</description>
    </item>
    
    <item>
      <title>InitActor</title>
      <link>/docs/systems/filecoin_blockchain/vm/sysactors/init_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/vm/sysactors/init_actor/</guid>
      <description>(You can see the old InitActor here )
import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/vm/address&amp;#34; import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/vm/actor&amp;#34; type InitActor struct { // responsible for create new actors  AddressMap {addr.Address: actor.ActorID} IDMap {actor.ActorID: addr.Address} NextID actor.ActorID // 0  InitConstructor() // 1  Exec(code actor.CodeCID, params actor.ActorMethod) addr.Address // 2  GetActorIDForAddress(address addr.Address) actor.ActorID }  package sysactors import msg &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/vm/message&amp;#34; import addr &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/vm/address&amp;#34; import actor &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/vm/actor&amp;#34; import st &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/vm/state_tree&amp;#34; import util &amp;#34;github.com/filecoin-project/specs/util&amp;#34; func (self *InitActor) InitConstructor() { } func (self *InitActor) Exec(codeCID actor.</description>
    </item>
    
    <item>
      <title>Kademlia DHT for Peer Routing</title>
      <link>/docs/libraries/libp2p/kad_dht/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/libp2p/kad_dht/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Key Concepts</title>
      <link>/docs/intro/concepts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/concepts/</guid>
      <description>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:
 Data structures are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).
 Functions are computational procedures that do not depend on external state (i.e., mathematical functions, or programming language functions that do not refer to global variables).
 Components are sets of functionality that are intended to be represented as single software units in the implementation structure.</description>
    </item>
    
    <item>
      <title>libp2p Protocols</title>
      <link>/docs/listings/libp2p_protocols/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/listings/libp2p_protocols/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Message Storage</title>
      <link>/docs/systems/filecoin_blockchain/message_pool/message_storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/message_pool/message_storage/</guid>
      <description> TODO:
 give sample algorithm for miner message selection in block production (to avoid dups) give sample algorithm for message storage caching/purging policies.  </description>
    </item>
    
    <item>
      <title>Message Syncer</title>
      <link>/docs/systems/filecoin_blockchain/message_pool/message_syncer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/message_pool/message_syncer/</guid>
      <description>TODO:
 explain message syncer works include the message syncer code  Message Propagation Messages are propagated over the libp2p pubsub channel /fil/messages. On this channel, every serialised SignedMessage is announced.
Upon receiving the message, its validity must be checked: the signature must be valid, and the account in question must have enough funds to cover the actions specified. If the message is not valid it should be dropped and must not be forwarded.</description>
    </item>
    
    <item>
      <title>Mining Scheduler</title>
      <link>/docs/systems/filecoin_mining/storage_mining/mining_scheduler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/mining_scheduler/</guid>
      <description> import poster &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proofs/poster&amp;#34; // import storage_indexer &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_indexer&amp;#34;  type SectorSet [Sector] type SealedSectorSet [Sector] type ReplicaID CID type MiningScheduler struct { getStagedSectors() SectorSet getSealedSectors() SealedSectorSet getFaultySectors() SectorSet getRepairedSectors() SectorSet getExpiredSectors() SectorSet // same as completedSectors/doneSectors  ProducePost(sectors SectorSet) poster.PoStSubmission VerifyPost(sectors SectorSet) poster.PoStSubmission ReportFaults(actor &amp;amp;StorageMinerActor) bool RemoveSectors(sectorsToRemove SectorSet) bool DePledge(amount TokenAmount) bool SealedSector(sealedSector SealedSector) bool // receives from sector storage subsystem  AddSector( pledge TokenAmount sectorID &amp;amp;SectorID comm &amp;amp;SealCommitment proof SealProof ) SectorID // generateReplicaID(CommD Commitment, block Block) } type SealCommitment struct { CommD Commitment CommR Commitment }  </description>
    </item>
    
    <item>
      <title>Multisig Actor</title>
      <link>/docs/systems/filecoin_token/multisig/multisig_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/multisig/multisig_actor/</guid>
      <description>(You can see the old Multisig Actor here )
type TokenAmount UVarint type TxSeqNo UVarint type NumRequired UVarint type EpochDuration UVarint type Epoch UVarint type MultisigActor struct { signers [Address] required NumRequired nextTxId TxSeqNo initialBalance TokenAmount startingBlock Epoch unlockDuration EpochDuration transactions {TxSeqNo: Transaction} Construct( signers [Address] required NumRequired unlockDuration EpochDuration ) Propose(to Address, value TokenAmount, method String, params Bytes) TxSeqNo Approve(txid TxSeqNo) Cancel(txid TxSeqNo) ClearCompleted() AddSigner(signer Address, increaseReq bool) RemoveSigner(signer Address, decreaseReq bool) SwapSigner(old Address, new Address) ChangeRequirement(req NumRequired) }  </description>
    </item>
    
    <item>
      <title>Network tooling</title>
      <link>/docs/intro/process/related_resources/network_tooling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/network_tooling/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Node Interface</title>
      <link>/docs/systems/filecoin_nodes/node_types/node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/node/</guid>
      <description> import repo &amp;#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository&amp;#34; import filestore &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; import clock &amp;#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&amp;#34; import libp2p &amp;#34;github.com/filecoin-project/specs/libraries/libp2p&amp;#34; type FilecoinNode struct { Node libp2p.Node Repository repo.Repository FileStore filestore.FileStore Clock clock.WallClock }  </description>
    </item>
    
    <item>
      <title>Payment Channel Actor</title>
      <link>/docs/systems/filecoin_token/payment_channels/payment_channel_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/payment_channels/payment_channel_actor/</guid>
      <description>(You can see the old Payment Channel Actor here )
type Voucher struct {} type VouchersApprovalResponse struct {} type PieceInclusionProof struct {} type PaymentChannelActor struct { RedeemVoucherWithApproval(voucher Voucher) RedeemVoucherWithPIP(voucher Voucher, pip PieceInclusionProof) }  </description>
    </item>
    
    <item>
      <title>Payment Channels</title>
      <link>/docs/algorithms/payment_channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/payment_channels/</guid>
      <description>Payment Channels In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.
The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &amp;ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Payments</title>
      <link>/docs/systems/filecoin_token/payments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_token/payments/</guid>
      <description></description>
    </item>
    
    <item>
      <title>PieceStore - storing and indexing pieces</title>
      <link>/docs/systems/filecoin_files/piece/piece_store/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_files/piece/piece_store/</guid>
      <description>A PieceStore is an object that can store and retrieve pieces from some local storage. The PieceStore additionally keeps an index of pieces.
import ipld &amp;#34;github.com/filecoin-project/specs/libraries/ipld&amp;#34; // PieceStore is an object that stores pieces into some local storage. // it is internally backed by an IpldStore. type PieceStore struct { Store ipld.Store Index {PieceID: Piece} Get(i PieceID) struct {p Piece, e error} Put(p Piece) error Delete(i PieceID) error }  </description>
    </item>
    
    <item>
      <title>PoSt Generator</title>
      <link>/docs/systems/filecoin_mining/storage_proving/post_generator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_proving/post_generator/</guid>
      <description>Block miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning ticket to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.
The Miner Actor After successfully calling CreateStorageMiner, a miner actor will be created on-chain, and registered in the storage market.</description>
    </item>
    
    <item>
      <title>PoSt Parameters</title>
      <link>/docs/algorithms/post/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/post/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin. (asdf:load-system :orient) (in-package orient.lang)  #&amp;lt;PACKAGE &amp;#34;ORIENT.LANG&amp;#34;&amp;gt;  (defparameter *filecoin* (get-system &amp;#34;../orient/filecoin.orient&amp;#34;)) (defparameter *input* (interface:get-json-relation-list &amp;#34;../orient/params.json&amp;#34;)) (defparameter *multi-input* (interface:get-json-relation-list &amp;#34;../orient/multi-params.json&amp;#34;))  *MULTI-INPUT*  (let ((result-tuple (extract (ask *filecoin* &amp;#39;(post-challenge-blocks post-challenge-hours post-proving-period) *input*)))) (org-present-tuple result-tuple *filecoin*))     Parameter Type Value Description   POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started.</description>
    </item>
    
    <item>
      <title>Proof of Spacetime Parameters</title>
      <link>/docs/algorithms/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
   Parameter Type Value Description     POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.   POST-CHALLENGE-HOURS HOURS 2 PoSt challenge time (see POST_CHALLENGE_BLOCKS).   POST-PROVING-PERIOD BLOCKS 5760 The time interval in which a PoSt has to be submitted    TODO: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</description>
    </item>
    
    <item>
      <title>Proof of Spacetime Parameters</title>
      <link>/docs/content/algorithms/proof_of_spacetime_parameters/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/algorithms/proof_of_spacetime_parameters/</guid>
      <description>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
   Parameter Type Value Description     POST-CHALLENGE-BLOCKS BLOCKS 480 The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.   POST-CHALLENGE-HOURS HOURS 2 PoSt challenge time (see POST_CHALLENGE_BLOCKS).   POST-PROVING-PERIOD BLOCKS 5760 The time interval in which a PoSt has to be submitted    TODO: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</description>
    </item>
    
    <item>
      <title>Rational-PoSt</title>
      <link>/docs/algorithms/post/rational_post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/post/rational_post/</guid>
      <description>This document describes Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
High Level API Fault Detection Fault detection happens over the course of the life time of a sector. When the sector is for some reason unavailable, the miner is responsible to submit the known faults, before the PoSt challenge begins. (Using the AddFaults message to the chain). Only faults which have been reported at challenge time, will be accounted for. If any other faults have occured the miner can not submit a valid PoSt for this proving period.</description>
    </item>
    
    <item>
      <title>Relayer Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/relayer_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/relayer_node/</guid>
      <description>type RelayerNode interface { FilecoinNode blockchain.MessagePool markets.MarketOrderBook }  </description>
    </item>
    
    <item>
      <title>Research portal</title>
      <link>/docs/intro/process/related_resources/research_portal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/research_portal/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>Retrieval Client</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_client/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_client/</guid>
      <description> import base &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets&amp;#34; type TokenAmount base.TokenAmount type Address base.Address type RetrievalClient struct { CreatePaymentChannel(provider Address, payment TokenAmount) PaymentChannel }  </description>
    </item>
    
    <item>
      <title>Retrieval Miner Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/retrieval_miner_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/retrieval_miner_node/</guid>
      <description>type RetrievalMinerNode interface { FilecoinNode blockchain.Blockchain markets.RetrievalMarketProvider markets.MarketOrderBook markets.DataTransfers }  </description>
    </item>
    
    <item>
      <title>Retrieval Provider (Miner)</title>
      <link>/docs/systems/filecoin_markets/retrieval_market/retrieval_provider/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/retrieval_market/retrieval_provider/</guid>
      <description> type PaymentChannel struct {} type CID struct {} // File Retrieval Query type FileRetrievalAvailable struct { MinPrice TokenAmount Miner Address } type FileRetrievalUnavailable struct {} type RetrievalQueryResponse union { FileRetrievalAvailable FileRetrievalUnavailable } type RetrievalQuery struct { File CID } // File Retrieval Deal Proposal and Deal type RetrievalDealProposalError struct {} type RetrievalDealProposalRejected struct {} type RetrievalDealProposalAccepted struct { CounterParty Address Payment PaymentChannel } type RetrievalDealProposalResponse union { RetrievalDealProposalAccepted RetrievalDealProposalRejected RetrievalDealProposalError } type RetrievalDealProposal struct { File CID Payment PaymentChannel MinPrice TokenAmount } type RetrievalProvider struct { NewRetrievalQuery(query RetrievalQuery) RetrievalQueryResponse // NewRetrievalDealProposal is called to propose a retrieval  NewRetrievalDealProposal(proposal RetrievalDealProposal) RetrievalDealProposalResponse // AcceptRetrievalDeal is called to accept a retrieval deal  AcceptRetrievalDealProposal(deal RetrievalDealProposal) RetrievalDealProposalResponse }  </description>
    </item>
    
    <item>
      <title>Sector Builder</title>
      <link>/docs/systems/filecoin_mining/sector_index/sector_builder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector_index/sector_builder/</guid>
      <description>import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; // import smkt &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&amp;#34; import mkt &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets&amp;#34; // SectorBuilder accumulates deals, keeping track of their // sector configuration requirements and the piece sizes. // Once there is a sector ready to be sealed, NextSector // will return a sector. type SectorBuilder struct { // DealsToSeal keeps a set of StorageDeal objects.  // These include the info for the relevant pieces.  // This builder just accumulates deals, keeping track of their  // sector configuration requirements, and the piece sizes.</description>
    </item>
    
    <item>
      <title>Sector Sealer</title>
      <link>/docs/systems/filecoin_mining/storage_proving/sector_sealer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_proving/sector_sealer/</guid>
      <description>Sector Sealer
Something&#39;s not right. The sector_sealer.id file was not found.</description>
    </item>
    
    <item>
      <title>Sector Sealing</title>
      <link>/docs/systems/filecoin_mining/sector/sealing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector/sealing/</guid>
      <description>import file &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; import base_blockchain &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain&amp;#34; type Path struct {} // TODO  type SealRandomSeed Bytes type SealCfg struct { SectorSize SubsectorCount UInt Partitions UInt } // SealVerifyInfo is the structure of all thte information a verifier // needs to verify a Seal. type SealVerifyInfo struct { SectorID MinerID base_blockchain.Address OnChain OnChainSealVerifyInfo } // OnChainSealVerifyInfo is the structure of information that must go on chain. type OnChainSealVerifyInfo struct { UnsealedCID UnsealedSectorCID // CommD  SealedCID SealedSectorCID // CommR  RandomSeed SealRandomSeed Proof SealProof } // ProofAux is meta data required to generate certain proofs // for a sector, for example PoSt.</description>
    </item>
    
    <item>
      <title>Sector Set</title>
      <link>/docs/systems/filecoin_mining/sector/sectorset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector/sectorset/</guid>
      <description> // sector sets type SectorSet [SectorID] type UnsealedSectorSet SectorSet type SealedSectorSet SectorSet // compact sector sets type Bitfield Bytes // TODO: move to the right place -- a lib? type RLEpBitfield Bitfield // TODO: move to the right place -- a lib? type CompactSectorSet RLEpBitfield  </description>
    </item>
    
    <item>
      <title>SectorStore</title>
      <link>/docs/systems/filecoin_mining/sector_index/sector_store/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/sector_index/sector_store/</guid>
      <description>import sector &amp;#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&amp;#34; import piece &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&amp;#34; import file &amp;#34;github.com/filecoin-project/specs/systems/filecoin_files/file&amp;#34; type SectorStore struct { // FileStore stores all the unsealed and sealed sectors.  FileStore file.FileStore // PieceStore is shared with DataTransfer, and is a way to store or read  // pieces temporarily. This may or may not be backed by the FileStore above.  PieceStore piece.PieceStore // GetSectorFile returns the file for a given sector id.  // If the SectorID does not have any sector files associated yet, GetSectorFiles  // returns an error.</description>
    </item>
    
    <item>
      <title>Selectors</title>
      <link>/docs/libraries/ipld/selectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipld/selectors/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sharded IPLD Array</title>
      <link>/docs/appendix/sharray/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/appendix/sharray/</guid>
      <description>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.
IPLD Representation Each sharray node is represented by an IPLD node of the following schema:
type Node struct { height Int items [Item] } representation tuple  Item may be either a direct value, if height == 0, or the Cid of a child node if height &amp;gt; 0.</description>
    </item>
    
    <item>
      <title>Signatures</title>
      <link>/docs/algorithms/crypto/signatures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/crypto/signatures/</guid>
      <description>Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages among with the assurance that each message was generated by specific individuals. In other words, it is infeasible for another individual i to generate a signed message that appears to have been generated by j.
We use signatures in filecoin to verify something was done by someone.</description>
    </item>
    
    <item>
      <title>Storage Market Actor</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_market_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_market_actor/</guid>
      <description>StorageMarketActor is responsible for processing and managing on-chain deals. This is also the entry point of all storage deals and data into the system. It maintains a mapping of StorageDealID to StorageDeal and keeps track of locked balances of StorageClient and StorageProvider. When a deal is posted on chain through the StorageMarketActor, it will first check if both transacting parties have sufficient balances locked up and include the deal on chain.</description>
    </item>
    
    <item>
      <title>Storage Market Participant</title>
      <link>/docs/systems/filecoin_markets/storage_market/storage_market_participant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_markets/storage_market/storage_market_participant/</guid>
      <description>Both StorageProvider and StorageClient are StorageMarketParticipant and the protocol does not explicitly differentiate the two roles. Any party can be a storage provider or client or both at the same time. Storage deal negotiation is expected to happen completely off chain and the request-response style storage deal protocol is to submit agreed-upon storage deal onto the network and gain storage power on chain.
import base_markets &amp;#34;github.com/filecoin-project/specs/systems/filecoin_markets&amp;#34; type StorageDealProposal base_markets.StorageDealProposal type StorageDealProposalQuery struct {} type StorageDealProposalQueryResponse struct {} type StorageDealQuery struct {} type StorageDealQueryResponse struct {} type StorageMarketParticipant struct { // Participants call each other to submit StorageDealProposal  NewStorageDealProposal(storageDealProposal StorageDealProposal) // When both parties sign on a StorageDealProposal  // counter signer call this function to return the signed deal  NewStorageDeal(storageDeal StorageDeal) // call by StorageMarketPariticipant itself to sign a StorageDealProposal  SignStorageDealProposal(storageDealProposal StorageDealProposal) StorageDeal // call by proposer  QueryStorageDealProposalStatus(storageDealProposalQuery StorageDealProposalQuery) StorageDealProposalQueryResponse // call by countersigner  QueryStorageDealStatus(storageDeal StorageDeal) StorageDealQueryResponse }  </description>
    </item>
    
    <item>
      <title>Storage Miner Actor</title>
      <link>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/storage_miner_actor/</guid>
      <description>(You can see the old Storage Miner Actor here )
type Seed struct {} type SectorCommitment struct {} type StorageMinerActor struct { // CollateralVault CollateralVault  // Sectors {UInt:MinedSector} // sectors and faults, proving period ends  // CommitSector(CommD Commitment, CommR Commitment, proof SealProof, SectorSize UVarint)  // ProvingPeriodEnd Epoch  // // contains mostly static info about this miner  // info &amp;amp;MinerInfo  UpdateDoneSet() UpdateSectorStatus(sectorStateSets SectorStateSets, faultSets [FaultSet]) SubmitPoSt(postProof base.</description>
    </item>
    
    <item>
      <title>Storage Miner Node</title>
      <link>/docs/systems/filecoin_nodes/node_types/storage_miner_node/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/node_types/storage_miner_node/</guid>
      <description>type StorageMinerNode interface { FilecoinNode systems.Blockchain systems.Mining markets.StorageMarketProvider markets.MarketOrderBook markets.DataTransfers }  </description>
    </item>
    
    <item>
      <title>Storage Mining Cycle</title>
      <link>/docs/systems/filecoin_mining/storage_mining/mining_cycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_mining/storage_mining/mining_cycle/</guid>
      <description>Block miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning ticket to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.
The Miner Actor After successfully calling CreateStorageMiner, a miner actor will be created on-chain, and registered in the storage market.</description>
    </item>
    
    <item>
      <title>Storage Power Actor</title>
      <link>/docs/systems/filecoin_blockchain/storage_power_consensus/storage_power_actor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/storage_power_consensus/storage_power_actor/</guid>
      <description>import base &amp;#34;github.com/filecoin-project/specs/systems/filecoin_blockchain&amp;#34; import filcrypto &amp;#34;github.com/filecoin-project/specs/libraries/filcrypto&amp;#34; type BytesAmount UVarint type StoragePowerActor struct { // call by StorageMiningSubsytem on miner creation  RegisterMiner(ownerAddr base.Address, workerPubKey filcrypto.PubKey) // call by StorageMinerActor on successful seal  // TODO: workerKey of type StorageMiner.WorkerPubKey  IncrementPower(minerAddress base.Address) UpdatePower(address base.Address, newPower minerStorage) SuspendMiner(address base.Address) // UpdateStoragePowerSubsystem(Tipset, StateTree)  // VerifyElectionProof(base.Address, base.ElectionProof)	bool  TotalStorage() BytesAmount // // What does graceful removal look like?  // NotifyConsensusFault(base.</description>
    </item>
    
    <item>
      <title>Testing and implementation compliance</title>
      <link>/docs/intro/process/related_resources/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/process/related_resources/testing/</guid>
      <description>TODO</description>
    </item>
    
    <item>
      <title>UnixFS</title>
      <link>/docs/libraries/ipfs/unixfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/libraries/ipfs/unixfs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Usage in Systems</title>
      <link>/docs/systems/filecoin_nodes/repository/usage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_nodes/repository/usage/</guid>
      <description>TODO: - Explain how repo is used with systems and subsystems - compartmentalized local storage - store ipld datastructures of stateful objects</description>
    </item>
    
    <item>
      <title>VM Interpreter</title>
      <link>/docs/systems/filecoin_blockchain/vm/interpreter/vm_interpreter_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/systems/filecoin_blockchain/vm/interpreter/vm_interpreter_old/</guid>
      <description>VM Interpreter Sending Funds As all messages carry a method ID, the method ID &amp;lsquo;0&amp;rsquo; is reserved for simple transfers of funds. Funds specified by the value field are always transferred, but specifying a method ID of &amp;lsquo;0&amp;rsquo; ensures that no other side effects occur.
State Representation The global state is modeled as a map of actor IDs to actor structs. This map is implemented by an ipld HAMT (TODO: link to spec for our HAMT) with the &amp;lsquo;key&amp;rsquo; being the serialized ID address (every actor has an ID address that can be looked up via the InitActor), and the value is an Actor object with the actors information.</description>
    </item>
    
    <item>
      <title>What are Systems? How do they work?</title>
      <link>/docs/intro/system/why_systems/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/intro/system/why_systems/</guid>
      <description>Filecoin decouples and modularizes functionality into loosely-joined systems. Each system adds significant functionality, usually to achieve a set of important and tightly related goals.
For example, the Blockchain System provides structures like Block, Tipset, and Chain, and provides functionality like Block Sync, Block Propagation, Block Validation, Chain Selection, and Chain Access. This is separated from the Files, Pieces, Piece Preparation, and Data Transfer. Both of these systems are separated from the Markets, which provide Orders, Deals, Market Visibility, and Deal Settlement.</description>
    </item>
    
    <item>
      <title>ZigZag Commitments</title>
      <link>/docs/algorithms/porep/porep_commitments/zigzag_commitments/zigzag_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/porep_commitments/zigzag_commitments/zigzag_commitments/</guid>
      <description>(ql:quickload :orient)     :ORIENT     This section summarizes the ZigZag Commitments algorithm described in Tight PoS - ZigZag. Graph  (defparameter *layers* 6) (defparameter *nodes* 8) (defparameter *regenerate-zigzag-graph* nil) (defparameter *dumped-zigzag-graph* &amp;#39;(:NODES 8 :CHALLENGED-NODE 7 :LAYERS 6 :RENUMBERED-PERMUTATION (:PERM-LIST (8 6 1 5 4 7 3 2) :TYPE PERM) :REVERSED-PERMUTATION (:PERM-LIST (6 1 8 3 7 5 4 2) :TYPE PERM) :TYPE ZIGZAG-GRAPH)) (defparameter *zigzag-graph* (if *regenerate-zigzag-graph* (make-zigzag-graph *nodes* *layers*) (load-from-plist *dumped-zigzag-graph*))) (let ((lg (first (zigzag-graph-layer-graphs *zigzag-graph*)))) (defparameter *comm-d-graph* (make-comm-d-layer-graph (layer-graph-nodes lg) (layer-graph-challenged-node lg)))) (dump *zigzag-graph*)  (:NODES 8 :CHALLENGED-NODE 7 :LAYERS 6 :RENUMBERED-PERMUTATION (:PERM-LIST (8 6 1 5 4 7 3 2) :TYPE PERM) :REVERSED-PERMUTATION (:PERM-LIST (6 1 8 3 7 5 4 2) :TYPE PERM) :TYPE ZIGZAG-GRAPH)  (emit-legend :odd)  (emit-legend :even)   Both renumbered (DRG) and reversed (expander) parents are generated by a pseudorandom permutation and are provided only to illustrate the nature of the zigzag commitment scheme.</description>
    </item>
    
    <item>
      <title>ZigZag Commitments</title>
      <link>/docs/algorithms/porep_commitments/zigzag_commitments/zigzag_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep_commitments/zigzag_commitments/zigzag_commitments/</guid>
      <description>This section summarizes the ZigZag Commitments algorithm described in Tight PoS - ZigZag.
Graph Both renumbered (DRG) and reversed (expander) parents are generated by a pseudorandom permutation and are provided only to illustrate the nature of the zigzag commitment scheme. They accurately represent how parent-child relationships change between layers, and are accurate for expander parents. However, this is not representative of the DRG parent selection algorithm.
The following graphs illustrate how the position of challenges, DRG parents, and expander parents change between layers.</description>
    </item>
    
    <item>
      <title>ZigZag Commitments</title>
      <link>/docs/algorithms/zigzag_commitments/zigzag_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/zigzag_commitments/zigzag_commitments/</guid>
      <description>Introduction This document provides a simplified visual explanation of the ZigZag Commitment algorithm described in Tight PoS - ZigZag.
It is intended to confer intuition about the algorithm, and to serve as a reference for implementers. The author of this document and those of the linked paper believe the two are consistent; and converging on this consistent design was a third design goal of this document&amp;rsquo;s construction.
Graph Both renumbered (DRG) and reversed (expander) parents are generated by a pseudorandom permutation and are provided only to illustrate the nature of the zigzag commitment scheme.</description>
    </item>
    
    <item>
      <title>ZigZag Commitments</title>
      <link>/docs/content/algorithms/porep_commitments/zigzag_commitments/zigzag_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/algorithms/porep_commitments/zigzag_commitments/zigzag_commitments/</guid>
      <description>This section summarizes the ZigZag Commitments algorithm described in Tight PoS - ZigZag.
Graph Both renumbered (DRG) and reversed (expander) parents are generated by a pseudorandom permutation and are provided only to illustrate the nature of the zigzag commitment scheme. They accurately represent how parent-child relationships change between layers, and are accurate for expander parents. However, this is not representative of the DRG parent selection algorithm.
The following graphs illustrate how the position of challenges, DRG parents, and expander parents change between layers.</description>
    </item>
    
    <item>
      <title>ZigZag Commitments</title>
      <link>/docs/content/algorithms/zigzag_commitments/zigzag_commitments/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/content/algorithms/zigzag_commitments/zigzag_commitments/</guid>
      <description>Introduction This document provides a simplified visual explanation of the ZigZag Commitment algorithm described in Tight PoS - ZigZag.
It is intended to confer intuition about the algorithm, and to serve as a reference for implementers. The author of this document and those of the linked paper believe the two are consistent; and converging on this consistent design was a third design goal of this document&amp;rsquo;s construction.
Graph Both renumbered (DRG) and reversed (expander) parents are generated by a pseudorandom permutation and are provided only to illustrate the nature of the zigzag commitment scheme.</description>
    </item>
    
    <item>
      <title>ZigZag-PoRep</title>
      <link>/docs/algorithms/porep/zigzag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/algorithms/porep/zigzag/</guid>
      <description>This section describes the specific Proof-of-Replication (PoRep) used in Filecoin called ZigZag. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.
ZigZag has been presented by Ben Fisch at EUROCRYPT19.
Introduction Background on Proof-of-Replication Proof-of-Replication enables a prover P to convince a verifier V that P is storing a replica R, a physically independent copy of some data D, unique to P.</description>
    </item>
    
  </channel>
</rss>