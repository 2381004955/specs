<!DOCTYPE html>
<html lang="en">

<head>
	<meta name="generator" content="Hugo 0.58.0" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Filecoin Specification | Filecoin Spec</title>



<link rel="stylesheet" href="./book.min.80d177ba9eeab42f747930aec886ccdf593ccbbd4ea5800f45db583ed39a4aed.css">
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=EB+Garamond" />


<link rel="icon" href="./favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="./index.xml" title="Filecoin Spec" />

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="./gumshoe.polyfills.min.js"></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="./css/syntax.css">
<link href="./mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="./mermaid/mermaid.js"></script>
<script src="./spec.js"></script>

</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href=""><span>Filecoin Spec</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  
    
    
  

  <style>
  nav ul a[href="\2f "] {
      color: #0b3a53;
  }
  </style>


  <div id="menu-toc">

  <div>
    
    <input id="menu-detail-slider" type="range" onchange="onMenuDetailChange();"
      min="1" value="3" max="5" step="1" />

    <span id="menu-detail-slider-label">3</span>
  </div>

  
  
  <ul class="menu-item-section depth-0">
  
      <li>
      
        











<a href="./#intro" class="menu-item depth-1">
    
    
    <strong>
    
        Introduction
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#intro__arch" class="menu-item depth-2">
    
    
        Architecture Diagrams
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__concepts" class="menu-item depth-2">
    
    
        Key Concepts
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__filecoin_vm" class="menu-item depth-2">
    
    
        Filecoin VM
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process" class="menu-item depth-2">
    
    
        Process
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#intro__process__about" class="menu-item depth-3">
    
    
        About
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process__fip" class="menu-item depth-3">
    
    
        FIPs
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process__contributing" class="menu-item depth-3">
    
    
        Contributing
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources" class="menu-item depth-3">
    
    
        Related Resources
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#intro__process__related_resources__research_portal" class="menu-item depth-4">
    
    
        Research portal
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources__network_tooling" class="menu-item depth-4">
    
    
        Network tooling
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources__testing" class="menu-item depth-4">
    
    
        Testing and implementation compliance
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__changelog" class="menu-item depth-2">
    
    
        Change Log
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__system" class="menu-item depth-2">
    
    
        System Decomposition
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#intro__system__why_systems" class="menu-item depth-3">
    
    
        What are Systems?
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__system__impl_systems" class="menu-item depth-3">
    
    
        Implementing Systems
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#systems" class="menu-item depth-1">
    
    
    <strong>
    
        Systems
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#systems__filecoin_nodes" class="menu-item depth-2">
    ‚öôÔ∏è
    
        <strong>Filecoin Nodes</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types" class="menu-item depth-3">
    
    
        Node Types
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__node" class="menu-item depth-4">
    
    
        Node Interface
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__node_types" class="menu-item depth-4">
    
    
        Examples
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__verifier_node" class="menu-item depth-4">
    
    
        Chain Verifier Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__client_node" class="menu-item depth-4">
    
    
        Client Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__storage_miner_node" class="menu-item depth-4">
    
    
        Storage Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__retrieval_miner_node" class="menu-item depth-4">
    
    
        Retrieval Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__relayer_node" class="menu-item depth-4">
    
    
        Relayer Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository" class="menu-item depth-3">
    
    
        Repository
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository__config" class="menu-item depth-4">
    
    
        Config
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__repository__key" class="menu-item depth-4">
    
    
        KeyStore &amp; user keys
    
</a>



<ul class="menu-item-section depth-4">

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository__ipldstore" class="menu-item depth-4">
    
    
        IpldStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__repository__usage" class="menu-item depth-4">
    
    
        Usage in Systems
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__network" class="menu-item depth-3">
    
    
        Network Interface
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__clock" class="menu-item depth-3">
    
    
        Clock
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__key_store" class="menu-item depth-3">
    
    
        Key Store
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files" class="menu-item depth-2">
    üìë
    
        <strong>Files &amp; Data</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_files__file" class="menu-item depth-3">
    
    
        File
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_files__file__filestore" class="menu-item depth-4">
    
    
        FileStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files__piece" class="menu-item depth-3">
    
    
        Piece
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_files__piece__piece_store" class="menu-item depth-4">
    
    
        PieceStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files__data_transfer" class="menu-item depth-3">
    
    
        Data Transfer
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm" class="menu-item depth-2">
    üíª
    
        <strong>Virtual Machine</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_vm__actor" class="menu-item depth-3">
    
    
        Actor
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_vm__actor__address" class="menu-item depth-4">
    
    
        Address
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__state_tree" class="menu-item depth-3">
    
    
        State Tree
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__message" class="menu-item depth-3">
    
    
        Message
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime" class="menu-item depth-3">
    
    
        Runtime
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime__exitcode" class="menu-item depth-4">
    
    
        Exit Codes
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime__gascost" class="menu-item depth-4">
    
    
        Gas Costs
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors" class="menu-item depth-3">
    
    
        System Actors
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__init_actor" class="menu-item depth-4">
    
    
        InitActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__cron_actor" class="menu-item depth-4">
    
    
        CronActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__account_actor" class="menu-item depth-4">
    
    
        AccountActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__interpreter" class="menu-item depth-3">
    
    
        Interpreter
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain" class="menu-item depth-2">
    üì¶
    
        <strong>Blockchain</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct" class="menu-item depth-3">
    
    
        Blocks
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block" class="menu-item depth-4">
    
    
        Block
    
</a>



<ul class="menu-item-section depth-4">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block__tipset" class="menu-item depth-5">
    
    
        Tipset
    
</a>



<ul class="menu-item-section depth-5">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__chain" class="menu-item depth-4">
    
    
        Chain
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__chain_manager" class="menu-item depth-4">
    
    
        Chain Manager
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block_producer" class="menu-item depth-4">
    
    
        Block Producer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool" class="menu-item depth-3">
    
    
        Message Pool
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool__message_syncer" class="menu-item depth-4">
    
    
        Message Syncer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool__message_storage" class="menu-item depth-4">
    
    
        Message Storage
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_blockchain__chainsync" class="menu-item depth-3">
    
    
        ChainSync
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__storage_power_consensus" class="menu-item depth-3">
    
    
        Storage Power Consensus
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor" class="menu-item depth-4">
    
    
        Storage Power Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_token" class="menu-item depth-2">
    üìÄ
    
        <strong>Token</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_token__wallets" class="menu-item depth-3">
    
    
        Wallet
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__payments" class="menu-item depth-3">
    
    
        Payments
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__payment_channels" class="menu-item depth-3">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_token__payment_channels__payment_channel_actor" class="menu-item depth-4">
    
    
        Payment Channel Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__multisig" class="menu-item depth-3">
    
    
        Multisig Wallet
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_token__multisig__multisig_actor" class="menu-item depth-4">
    
    
        Multisig Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_mining" class="menu-item depth-2">
    ‚õè
    
        <strong>Storage Mining</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_mining" class="menu-item depth-3">
    
    
        Storage Miner
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__mining_cycle" class="menu-item depth-4">
    
    
        Storage Mining Cycle
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor" class="menu-item depth-4">
    
    
        Storage Miner Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__mining_scheduler" class="menu-item depth-4">
    
    
        Mining Scheduler
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector" class="menu-item depth-3">
    
    
        Sector
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_mining__sector__sectorset" class="menu-item depth-4">
    
    
        Sector Set
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector__sealing" class="menu-item depth-4">
    
    
        Sector Sealing
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index" class="menu-item depth-3">
    
    
        Sector Index
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index__sector_builder" class="menu-item depth-4">
    
    
        Sector Builder
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index__sector_store" class="menu-item depth-4">
    
    
        SectorStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_proving" class="menu-item depth-3">
    
    
        Storage Proving
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_proving__sealer" class="menu-item depth-4">
    
    
        Sector Sealer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_proving__poster" class="menu-item depth-4">
    
    
        Sector Poster
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets" class="menu-item depth-2">
    ‚öñÔ∏è
    
        <strong>Market</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_markets__order" class="menu-item depth-3">
    
    
        Orders
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__deal" class="menu-item depth-3">
    
    
        Deals
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__storage_market" class="menu-item depth-3">
    
    
        Storage Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_market_actor" class="menu-item depth-4">
    
    
        Storage Market Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_provider" class="menu-item depth-4">
    
    
        Storage Provider
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_client" class="menu-item depth-4">
    
    
        Storage Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__faults" class="menu-item depth-4">
    
    
        Faults
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__retrieval_market" class="menu-item depth-3">
    
    
        Retrieval Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_client" class="menu-item depth-4">
    
    
        Retrieval Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_provider" class="menu-item depth-4">
    
    
        Retrieval Provider (Miner)
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        










  


<a href="./#libraries" class="menu-item depth-1">
    
    
    <strong>
    
        Libraries
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
    </li>

    <li>
    
      











<a href="./#libraries__fcs" class="menu-item depth-2">
    
    
        FCS
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipld" class="menu-item depth-2">
    
    
        IPLD
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__ipld__cid" class="menu-item depth-3">
    
    
        CID
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipld__datamodel" class="menu-item depth-3">
    
    
        Data Model
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipld__selectors" class="menu-item depth-3">
    
    
        Selectors
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipld__graphstore" class="menu-item depth-3">
    
    
        GraphStore
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p" class="menu-item depth-2">
    
    
        libp2p
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__libp2p__gossipsub" class="menu-item depth-3">
    
    
        gossipsub
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p__kad_dht" class="menu-item depth-3">
    
    
        kad-dht
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p__fil_libp2p_nodes" class="menu-item depth-3">
    
    
        fil-libp2p Nodes
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipfs" class="menu-item depth-2">
    
    
        IPFS
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#libraries__ipfs__bitswap" class="menu-item depth-3">
    
    
        BitSwap
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipfs__graphsync" class="menu-item depth-3">
    
    
        GraphSync
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipfs__unixfs" class="menu-item depth-3">
    
    
        UnixFS
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__multiformats" class="menu-item depth-2">
    
    
        Multiformats
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#algorithms" class="menu-item depth-1">
    
    
    <strong>
    
        Algorithms
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#algorithms__expected_consensus" class="menu-item depth-2">
    
    
        Expected Consensus
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__porep" class="menu-item depth-2">
    
    
        Proof-of-Replication
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#algorithms__porep__stacked_drg" class="menu-item depth-3">
    
    
        Stacked DRG PoRep
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__porep__porep_commitments" class="menu-item depth-3">
    
    
        PoRep Commitments
    
</a>




    
    </li>

    <li>
    
      











<a href="./#algorithms__porep__stacked_drg_circuit" class="menu-item depth-3">
    
    
        
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__post" class="menu-item depth-2">
    
    
        Proof-of-Spacetime
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#algorithms__post__rational_post" class="menu-item depth-3">
    
    
        Rational-PoSt
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__post__proof_of_spacetime_parameters" class="menu-item depth-3">
    
    
        PoSt Parameters
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__payment_channels" class="menu-item depth-2">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__block_sync" class="menu-item depth-2">
    
    
        BlockSync
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__gossip_sub" class="menu-item depth-2">
    
    
        GossipSub
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__crypto" class="menu-item depth-2">
    
    
        Cryptographic Primitives
    
</a>




    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#listings" class="menu-item depth-1">
    
    
    <strong>
    
        Listings
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#listings__actors" class="menu-item depth-2">
    
    
        Filecoin VM Actors
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__data_structures" class="menu-item depth-2">
    
    
        Data Structures
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__system_map" class="menu-item depth-2">
    
    
        Components
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__libp2p_protocols" class="menu-item depth-2">
    
    
        libp2p Protocols
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#listings__libp2p_protocols__data_transfer_protocol" class="menu-item depth-3">
    
    
        Data Transfer Protocol
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#glossary" class="menu-item depth-1">
    
    
    <strong>
    
        Glossary
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#appendix" class="menu-item depth-1">
    
    
    <strong>
    
        Appendix
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#appendix__sharray" class="menu-item depth-2">
    
    
        Sharded IPLD Array
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#appendix__address" class="menu-item depth-2">
    
    
        Address
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#appendix__orient" class="menu-item depth-2">
    
    
        Filecoin Parameters
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
  </ul>
  
</div>










</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="./svg/menu.svg" alt="Menu" />
  </label>
  <strong>Filecoin Specification</strong>
</header>

      
<article class="markdown"><script>
  structSet = new Set([
    "Actor",
    "Address",
    "Bitfield",
    "Block",
    "BytesAmount",
    "ElectionProof",
    "FaultSet",
    "Message",
    "MessageReceipt",
    "PeerId",
    "PoSTProof",
    "PublicKey",
    "SealProof",
    "SectorID",
    "SectorSet",
    "Signature",
    "SignedMessage",
    "StateTree",
    "Ticket",
    "TipSet",
    "TokenAmount",
    "UnsignedMessage",
  ]);

  structRefs = {
    "AddressId":               "Address",
    "AddressSecp256k1":        "Address",
    "AddressActor":            "Address",
    "AddressBLS12_381":        "Address",
    "Bls12_381Signature":      "Signature",
    "Secp256k1Signature":      "Signature",
    "TxMeta":                  "Block",
    "VDFProof":                "Ticket",
    "VDFResult":               "Ticket",
    "VRFProof":                "Ticket",
  };

  fillSingleCodeRef = (x, isTokenDef) => {
    let origKey = x.innerText;
    let key = origKey;
    let newKey = structRefs[key];
    if (newKey !== undefined) {
      key = newKey;
    }
    if (structSet.has(key)) {
      if (x.className == "nx" && isTokenDef) {
        x.innerHTML = "<span id=go__" + origKey + "><a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a></div>";
      } else {
        x.innerHTML = "<a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a>";
      }
    }
  };

  fillCodeRefs = (xs, parent) => {
    if (xs.length == 0 && parent.innerText.length != 0) {
      fillSingleCodeRef(parent);
      return;
    }

    let isTokenDef = false;

    for (let x of xs) {
      if (x.className == "kd" && x.innerHTML == "type") {
        isTokenDef = true;
        continue;
      }

      if (x.className != "nx" && x.className != "codeRef") {
        isTokenDef = false;
        continue;
      }

      fillSingleCodeRef(x, isTokenDef);
      isTokenDef = false;
    }
  };

  window.onload = (event) => {
    let codeBlocks = document.getElementsByTagName("code");
    for (let codeBlock of codeBlocks) {
      fillCodeRefs(codeBlock.children, codeBlock);
    }

    let hashPrev = location.hash;
    if ((typeof hashPrev) == "string" && hashPrev != "") {
      location.hash = "";
      location.hash = hashPrev;
    }
  };
</script>


<div>
  
  








<div id="">

<h0 class="section-header">
  
</h0>

<div class="section-content">




































<style type="text/css">
 
#spec-splash {
  text-align: center;
  margin: 50px auto;
}
#spec-splash #spec-title {
  font-family: EB Garamond;
  font-size: 70px;
}
#spec-splash #spec-logo {
  height: 256px;
  width: 256px;
}
#spec-splash #spec-version {
  margin: 10px auto;
  font-family: Monaco, Menlo;
}
</style>

<div id="spec-splash">
  <div id="spec-title">Filecoin Specification</div>
  <img id="spec-logo" src="./docs/filspeclogo.png" />
  <div id="spec-version">
    protocol version: <span id="protocol-version-number">v0.1.0</span><br />
    spec doc version: <span id="spec-version-number">v1.1</span>-<span id="spec-version-hash">c3f5d5c</span>
    <br /><span id="spec-version-date">2019-11-21_18:10:08Z</span>
  </div>
</div>


</div>


  
    








<div id="intro">

<h1 class="section-header">
  Introduction
</h1>

<div class="section-content">




































<p><center><img src="./docs/intro/underconstruction.gif" height="128px" /></center></p>

<div class="notices warning" ><strong>Warning:</strong> This draft of the Filecoin protocol specification is a work in progress.
It is intended to establish the rough overall structure of the document,
enabling experts to fill in different sections in parallel.
However, within each section, content may be out-of-order, incorrect, and/or incomplete.
The reader is advised to refer to the
<a href="https://filecoin-project.github.io/specs/">official Filecoin spec document</a>
for specification and implementation questions.</div>

<p>Filecoin is a distributed storage network based on a blockchain mechanism.
Filecoin <em>miners</em> can elect to provide storage capacity for the network, and thereby
earn units of the Filecoin cryptocurrency (FIL) by periodically producing
cryptographic proofs that certify that they are providing the capacity specified.
In addition, Filecoin enables parties to exchange FIL currency
through transactions recorded in a shared ledger on the Filecoin blockchain.
Rather than using Nakamoto-style proof of work to maintain consensus on the chain, however,
Filecoin uses proof of storage itself: a miner&rsquo;s power in the consensus protocol
is proportional to the amount of storage it provides.</p>

<p>The Filecoin blockchain not only maintains the ledger for FIL transactions and
accounts, but also implements the Filecoin VM, a replicated state machine which executes
a variety of cryptographic contracts and market mechanisms among participants
on the network.
These contracts include <em>storage deals</em>, in which clients pay FIL currency to miners
in exchange for storing the specific file data that the clients request.
Via the distributed implementation of the Filecoin VM, storage deals
and other contract mechanisms recorded on the chain continue to be processed
over time, without requiring further interaction from the original parties
(such as the clients who requested the data storage).</p>


</div>


  
    








<div id="intro__arch">

<h2 class="section-header">
  Architecture Diagrams
</h2>

<div class="section-content">






































<h3 id="filecoin-systems">Filecoin Systems</h3>

<script type="text/javascript">

function statusIndicatorsShow() {
  var $uls = document.querySelectorAll('.statusIcon')
  $uls.forEach(function (el) {
    el.classList.remove('hidden')
  })
  return false; // stop click event
}

function statusIndicatorsHide() {
  var $uls = document.querySelectorAll('.statusIcon')
  $uls.forEach(function (el) {
    el.classList.add('hidden')
  })
  return false; // stop click event
}

</script>

<p>Status Legend:</p>

<ul>
<li>üõë <strong>Bare</strong> - Very incomplete at this time.

<ul>
<li><strong>Implementors:</strong> This is far from ready for you.</li>
</ul></li>
<li>‚ö†Ô∏è <strong>Rough</strong> &ndash; work in progress, heavy changes coming, as we put in place key functionality.

<ul>
<li><strong>Implementors:</strong> This will be ready for you soon.</li>
</ul></li>
<li>üîÅ <strong>Refining</strong> - Key functionality is there, some small things expected to change. Some big things may change.

<ul>
<li><strong>Implementors:</strong> Almost ready for you. You can start building these parts, but beware there may be changes still.</li>
</ul></li>
<li>‚úÖ <strong>Stable</strong> - Mostly complete, minor things expected to change, no major changes expected.

<ul>
<li><strong>Implementors:</strong> Ready for you. You can build these parts.</li>
</ul></li>
</ul>

<p>[<a href="#" onclick="return statusIndicatorsShow();">Show</a> / <a href="#" onclick="return statusIndicatorsHide();">Hide</a> ] status indicators</p>


<div class="tocMap colorful">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems">
        

        Systems

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes">
        

        <strong>Filecoin Nodes</strong>

        
            <br /><br /><i class="menuIcon">‚öôÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__node_types">
        
            <i class="statusIcon">‚úÖ</i>
        

        Node Types

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__repository">
        
            <i class="statusIcon">‚úÖ</i>
        

        Repository

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__network">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Network Interface

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__clock">
        
            <i class="statusIcon">‚úÖ</i>
        

        Clock

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__key_store">
        
            <i class="statusIcon">üõë</i>
        

        Key Store

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files">
        

        <strong>Files &amp; Data</strong>

        
            <br /><br /><i class="menuIcon">üìë</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file">
        
            <i class="statusIcon">‚úÖ</i>
        

        File

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece">
        
            <i class="statusIcon">üîÅ</i>
        

        Piece

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__data_transfer">
        
            <i class="statusIcon">üîÅ</i>
        

        Data Transfer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm">
        

        <strong>Virtual Machine</strong>

        
            <br /><br /><i class="menuIcon">üíª</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor">
        
            <i class="statusIcon">‚úÖ</i>
        

        Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__state_tree">
        
            <i class="statusIcon">üîÅ</i>
        

        State Tree

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__message">
        
            <i class="statusIcon">üîÅ</i>
        

        Message

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Runtime

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors">
        
            <i class="statusIcon">üîÅ</i>
        

        System Actors

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__interpreter">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Interpreter

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain">
        

        <strong>Blockchain</strong>

        
            <br /><br /><i class="menuIcon">üì¶</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct">
        
            <i class="statusIcon">‚úÖ</i>
        

        Blocks

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool">
        
            <i class="statusIcon">üõë</i>
        

        Message Pool

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__chainsync">
        
            <i class="statusIcon">üîÅ</i>
        

        ChainSync

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Power Consensus

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token">
        

        <strong>Token</strong>

        
            <br /><br /><i class="menuIcon">üìÄ</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__wallets">
        
            <i class="statusIcon">üõë</i>
        

        Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payments">
        
            <i class="statusIcon">üõë</i>
        

        Payments

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels">
        
            <i class="statusIcon">üõë</i>
        

        Payment Channels

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig">
        
            <i class="statusIcon">üõë</i>
        

        Multisig Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining">
        

        <strong>Storage Mining</strong>

        
            <br /><br /><i class="menuIcon">‚õè</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Miner

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector">
        
            <i class="statusIcon">‚úÖ</i>
        

        Sector

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index">
        
            <i class="statusIcon">‚úÖ</i>
        

        Sector Index

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Proving

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets">
        

        <strong>Market</strong>

        
            <br /><br /><i class="menuIcon">‚öñÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__order">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Orders

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__deal">
        
            <i class="statusIcon">üîÅ</i>
        

        Deals

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market">
        
            <i class="statusIcon">üõë</i>
        

        Retrieval Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<h3 id="overview-diagram">Overview Diagram</h3>

<p>TODO:</p>

<ul>
<li>cleanup / reorganize

<ul>
<li>this diagram is accurate, and helps lots to navigate, but it&rsquo;s still a bit confusing</li>
<li>the arrows and lines make it a bit hard to follow. We should have a much cleaner version (maybe based on <a href="https://c4model.com">C4</a>)</li>
</ul></li>
<li>reflect addition of Token system

<ul>
<li>move data_transfers into Token</li>
</ul></li>
</ul>













<div class="diagram">

<span class="diagram-title">Protocol Overview Diagram</span>




(<a href="docs/intro/../diagrams/overview1/overview.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/overview1/overview.dot.svg" />




</div>


<h3 id="protocol-flow-diagram-deals-off-chain">Protocol Flow Diagram &ndash; deals off chain</h3>













<div class="diagram">

<span class="diagram-title">Protocol Sequence Diagram - Deals off Chain</span>




(<a href="docs/intro/../diagrams/sequence/full-deals-off-chain.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/sequence/full-deals-off-chain.mmd.svg" />




</div>


<h3 id="protocol-flow-diagram-deals-on-chain">Protocol Flow Diagram &ndash; deals on chain</h3>













<div class="diagram">

<span class="diagram-title">Protocol Sequence Diagram - Deals on Chain</span>




(<a href="docs/intro/../diagrams/sequence/full-deals-on-chain.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/sequence/full-deals-on-chain.mmd.svg" />




</div>


<h3 id="parameter-calculation-dependency-graph">Parameter Calculation Dependency Graph</h3>

<p>This is a diagram of the model for parameter calculation. This is made with <a href="https://github.com/filecoin-project/orient">orient</a>, our tool for modeling and solving for constraints.</p>













<div class="diagram">

<span class="diagram-title">Parameter Calculation Dependency Graph</span>




(<a href="docs/intro/../diagrams/orient/filecoin.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/orient/filecoin.dot.svg" />




</div>



</div>



</div>

  

  
    








<div id="intro__concepts">

<h2 class="section-header">
  Key Concepts
</h2>

<div class="section-content">




































<p>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:</p>

<ul>
<li><p><strong><em>Data structures</em></strong> are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).</p></li>

<li><p><strong><em>Functions</em></strong> are computational procedures that do not depend on external state (i.e., mathematical functions,
or programming language functions that do not refer to global variables).</p></li>

<li><p><strong><em>Components</em></strong> are sets of functionality that are intended to be represented as single software units
in the implementation structure.
Depending on the choice of language and the particular component, this might
correspond to a single software module,
a thread or process running some main loop, a disk-backed database, or a variety of other design choices.
For example, the <a href="./#systems__filecoin_blockchain__chainsync___index"></a> is a component: it could be implemented
as a process or thread running a single specified main loop, which waits for network messages
and responds accordingly by recording and/or forwarding block data.</p></li>

<li><p><strong><em>APIs</em></strong> are messages that can be sent to components.
A client&rsquo;s view of a given sub-protocol, such as a request to a miner node&rsquo;s
{% {<sref storage_provider>} %} component to store files in the storage market,
may require the execution of a series of APIs.</p></li>

<li><p><strong><em>Nodes</em></strong> are complete software and hardware systems that interact with the protocol.
A node might be constantly running several of the above <em>components</em>, participating in several <em>subsystems</em>,
and exposing <em>APIs</em> locally and/or over the network,
depending on the node configuration.
The term <em>full node</em> refers to a system that runs all of the above components, and supports all of the APIs detailed in the spec.</p></li>

<li><p><strong><em>Subsystems</em></strong> are conceptual divisions of the entire Filecoin protocol, either in terms of complete protocols
(such as the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> or <a href="./#systems__filecoin_markets__retrieval_market___index">Retrieval Market</a>), or in terms of functionality
(such as the <a href="./#systems__filecoin_vm">VM - Virtual Machine</a>). They do not necessarily correspond to any particular node or software component.</p></li>

<li><p><strong><em>Actors</em></strong> are virtual entities embodied in the state of the Filecoin VM.
Protocol actors are analogous to participants in smart contracts;
an actor carries a FIL currency balance and can interact with other actors
via the operations of the VM, but does not necessarily correspond to any particular node or software component.</p></li>
</ul>


</div>



</div>

  

  
    








<div id="intro__filecoin_vm">

<h2 class="section-header">
  Filecoin VM
</h2>

<div class="section-content">




































<p>The majority of Filecoin&rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &lsquo;chain&rsquo; of blocks is the correct one. Each block contains a series of state transitions called <code>messages</code>, and a checkpoint of the current <code>global state</code> after the application of those <code>messages</code>.</p>

<p>The <code>global state</code> here consists of a set of <code>actors</code>, each with their own private <code>state</code>.</p>

<p>An <code>actor</code> is the Filecoin equivalent of Ethereum&rsquo;s smart contracts, it is essentially an &lsquo;object&rsquo; in the filecoin network with state and a set of methods that can be used to interact with it. Every actor has a Filecoin balance attributed to it, a <code>state</code> pointer, a <code>code</code> CID which tells the system what type of actor it is, and a <code>nonce</code> which tracks the number of messages sent by this actor. (TODO: the nonce is really only needed for external user interface actors, AKA <code>account actors</code>. Maybe we should find a way to clean that up?)</p>

<p>There are two routes to calling a method on an <code>actor</code>. First, to call a method as an external participant of the system (aka, a normal user with Filecoin) you must send a signed <code>message</code> to the network, and pay a fee to the miner that includes your <code>message</code>.  The signature on the message must match the key associated with an account with sufficient Filecoin to pay for the messages execution. The fee here is equivalent to transaction fees in Bitcoin and Ethereum, where it is proportional to the work that is done to process the message (Bitcoin prices messages per byte, Ethereum uses the concept of &lsquo;gas&rsquo;. We also use &lsquo;gas&rsquo;).</p>

<p>Second, an <code>actor</code> may call a method on another actor during the invocation of one of its methods.  However, the only time this may happen is as a result of some actor being invoked by an external users message (note: an actor called by a user may call another actor that then calls another actor, as many layers deep as the execution can afford to run for).</p>

<p>For full implementation details, see the <a href="./#systems__filecoin_vm">VM subsystem</a>.</p>


</div>



</div>

  

  
    








<div id="intro__process">

<h2 class="section-header">
  Filecoin Spec Process (v1)
</h2>

<div class="section-content">






































<h3 id="pre-launch-mode">üöÄ Pre-launch mode</h3>

<p>Until we launch, we are making lots of changes to the spec to finish documenting the current version of the protocol. Changes will be made to the spec by a simple PR process, with approvals by key stakeholders. Some refinements are still to happen and testnet is expected to bring a few significant fixes/improvements. Most changes now are changing <em>the document</em>, <strong>NOT</strong> changing <em>the protocol</em>, at least not in a major way.</p>

<p>Until we launch, if something is missing, PR it in. If something is wrong, PR a fix. If something needs to be elaborated, PR in updates. What is in the top level of this repo, in master, is the spec, is the Filecoin Protocol. Nothing else matters (ie. no other documents, issues contain &ldquo;the protocol&rdquo;).</p>

<h3 id="new-proposals-drafts-spec">New Proposals -&gt; Drafts -&gt; Spec</h3>

<div class="notices warning" >‚ö†Ô∏è <strong>WARNING:</strong> Filecoin is in pre-launch mode, and we are finishing protocol spec and implementations of the <em>current</em> construction/version of the protocol only. We are highly unlikely to merge anything new into the Filecoin Protocol until after mainnet. Feel free to explore ideas anyway and propeare improvements for the future.</div>

<p>For anything that is not part of the currently speced systems (like &lsquo;repair&rsquo;, for example) the process we will use is:</p>

<ul>
<li><strong>(1) First, discuss the problem(s) and solution(s) in an issue</strong>

<ul>
<li>Or several issues, if the space is large and multithreaded enough.</li>
<li>Work out all the details required to make this proposal work.</li>
</ul></li>
<li><strong>(2) Write a draft with all the details.</strong>

<ul>
<li>When you feel like a solution is near, write up a draft document that contains all the details, and includes what changes would need to happen to the spec</li>
<li>E.g. &ldquo;Add a System called X with &hellip;&rdquo;, or &ldquo;Add a library called Y, &hellip;&rdquo;, or &ldquo;Modify vm/state_tree to include &hellip;&rdquo;</li>
<li>Place this document inside the <code>src/drafts/</code> directory.</li>
<li>Anybody is welcome to contribute well-reasoned and detailed drafts.</li>
<li>(Note: these drafts will give way to FIPs in the future)</li>
</ul></li>
<li><strong>(3) Seek approval to merge this into the specification.</strong>

<ul>
<li>To seek approval, open an issue and discuss it.</li>
<li>If the draft approved by the owners of the filecoin-spec, then the changes to the spec will need to be made in a PR.</li>
<li>Once changes make it into the spec, remove the draft.</li>
</ul></li>
</ul>

<p>It is acceptable for a PR for a draft to stay open for quite a while, as thought and discussion on the topic happens. At some point, if the reviewers and the author feel that the current state of the draft is stable enough (though not &lsquo;done&rsquo;) then it should be merged into the repo. Further changes to the draft are additional PRs, which may generate more discussion. Comments on these drafts are welcome from anyone, but if you wish to be involved in the actual research process, you will need to devote very considerable time and energy to the process.</p>

<h3 id="on-merging">On merging</h3>

<p>For anything in the drafts or notes folder, merge yourself after a review from a relevant person. For anything in the top level (canonical spec), @whyrusleeping or @jbenet will merge after proper review.</p>

<h3 id="issues">Issues</h3>

<p>Issues in the specs repo will be high signal, they will either be proposals, or issues directly relating to problems in the spec. More speculative research questions and discussion will happen in the research repo.</p>


</div>


  
    








<div id="intro__process__about">

<h3 class="section-header">
  About this specification
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__fip">

<h3 class="section-header">
  FIPs - Filecoin Improvement Proposals
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__contributing">

<h3 class="section-header">
  Contributing to the Filecoin spec
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources">

<h3 class="section-header">
  Related Resources
</h3>

<div class="section-content">




































<p>TODO</p>


</div>


  
    








<div id="intro__process__related_resources__research_portal">

<h4 class="section-header">
  Research portal
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources__network_tooling">

<h4 class="section-header">
  Network tooling
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources__testing">

<h4 class="section-header">
  Testing and implementation compliance
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="intro__changelog">

<h2 class="section-header">
  Change Log - Version History
</h2>

<div class="section-content">






































<h3 id="v1-1-2019-10-30-c3f6a6dd">v1.1 - 2019-10-30 - <code>c3f6a6dd</code></h3>

<ul>
<li><strong>Deals on chain</strong>

<ul>
<li>Storage Deals</li>
<li>Full <code>StorageMarketActor</code> logic:

<ul>
<li>client and miner balances: deposits, locking, charges, and withdrawls</li>
<li>collateral slashing</li>
</ul></li>
<li>Full <code>StorageMinerActor</code> logic:

<ul>
<li>sector states, state transitions, state accounting, power accounting</li>
<li>DeclareFaults + RecoverSectors flow</li>
<li><code>CommitSector</code> flow</li>
<li><code>SubmitPost</code> flow

<ul>
<li>Sector proving, faults, recovery, and expiry</li>
</ul></li>
<li><code>OnMissedPost</code> flow

<ul>
<li>Fault sectors, drop power, expiry, and more</li>
</ul></li>
</ul></li>
<li><code>StoragePowerActor</code>

<ul>
<li>power accounting based on <code>StorageMinerActor</code> state changes</li>
<li>Collaterals: deposit, locking, withdrawal</li>
<li>Slashing collaerals</li>
</ul></li>
<li>Interactive-Post

<ul>
<li><code>StorageMinerActor</code>: <code>PrecommitSector</code> and <code>CommitSector</code></li>
</ul></li>
<li>Surprise-Post

<ul>
<li>Challenge flow through <code>CronActor -&gt; StoragePowerActor -&gt; StorageMiner</code></li>
</ul></li>
</ul></li>
<li><strong>Virtual Machine</strong>

<ul>
<li>Extracted VM system out of blockchain</li>
<li>Addresses</li>
<li>Actors

<ul>
<li>Separation of code and state</li>
</ul></li>
<li>Messages

<ul>
<li>Method invocation representation</li>
</ul></li>
<li>Runtime

<ul>
<li>Slimmed down interface</li>
<li>Safer state Acquire, Release, Commit flow</li>
<li>Exit codes</li>
<li>Full invocation flow</li>
<li>Safer recursive context construction</li>
<li>Error levels and handling</li>
<li>Detecting and handling out of gas errors</li>
</ul></li>
<li>Interpreter

<ul>
<li><code>ApplyMessage</code></li>
<li><code>{Deduct,Deposit} -&gt; Transfer</code> - safer</li>
<li>Gas accounting</li>
</ul></li>
<li>VM system actors

<ul>
<li><code>InitActor</code> basic flow, plug into Runtime</li>
<li><code>CronActor</code> full flow, static registry</li>
</ul></li>
<li><code>AccountActor</code> basic flow</li>
</ul></li>
<li><strong>Data Transfer</strong>

<ul>
<li>Full Data Transfer flows

<ul>
<li>push, pull, 1-RTT pull</li>
</ul></li>
<li>protocol, data structures, interface</li>
<li>diagrams</li>
</ul></li>
<li><strong>blockchain/ChainSync:</strong>

<ul>
<li>first version of ChainSync protocol description</li>
<li>Includes protocol state machine description</li>
<li>Network bootstrap &ndash; connectivity and state</li>
<li>Progressive Block Validation</li>
<li>Progressive Block Propagation</li>
</ul></li>
<li><strong>Other</strong>

<ul>
<li>Spec section status indicators</li>
<li>Changelog</li>
</ul></li>
</ul>

<h3 id="v1-0-2019-10-07-583b1d06">v1.0 - 2019-10-07 - <code>583b1d06</code></h3>

<ul>
<li><strong>Full spec reorganization</strong></li>
<li><strong>Tooling</strong>

<ul>
<li>added a build system to compile tools</li>
<li>added diagraming tools (dot, mermaid, etc)</li>
<li>added dependency installation</li>
<li>added Orient to calculate protocol parameters</li>
</ul></li>
<li><strong>Content</strong>

<ul>
<li><strong>filecoin_nodes</strong>

<ul>
<li>types - an overview of different filecoin node types</li>
<li>repository - local data-structure storage</li>
<li>network interface - connecting to libp2p</li>
<li>clock - a wall clock</li>
</ul></li>
<li><strong>files &amp; data</strong>

<ul>
<li>file - basic representation of data</li>
<li>piece - representation of data to store in filecoin</li>
</ul></li>
<li><strong>blockchain</strong>

<ul>
<li>blocks - basic blockchain data structures (block, tipset, chain, etc)</li>
<li>storage power consensus - basic algorithms and crypto artifacts for SPC</li>
<li><code>StoragePowerActor</code> basics</li>
</ul></li>
<li><strong>token</strong>

<ul>
<li>skeleton of sections</li>
</ul></li>
<li><strong>storage mining</strong>

<ul>
<li>storage miner: module that controls and coordinates storage mining</li>
<li>sector: unit of storage, sealing, crypto artifacts, etc.</li>
<li>sector index: accounting sectors and metadata</li>
<li>storage proving: seals, posts, and more</li>
</ul></li>
<li><strong>market</strong>

<ul>
<li>deals: storage market deal basics</li>
<li>storage market: <code>StorageMarketActor</code> basics</li>
</ul></li>
<li><strong>orient</strong>

<ul>
<li>orient models for proofs and block sizes</li>
</ul></li>
<li><strong>libraries</strong>

<ul>
<li>filcrypto - sealing, PoRep, PoSt algorithms</li>
<li>ipld - cids, ipldstores</li>
<li>libp2p - host/node representation</li>
<li>ipfs - graphsync and bitswap</li>
<li>multiformats - multihash, multiaddr</li>
</ul></li>
<li><strong>diagrams</strong>

<ul>
<li>system overview</li>
<li>full protocol mermaid flow</li>
</ul></li>
</ul></li>
</ul>

<h3 id="pre-v1-0">pre v1.0</h3>

<ul>
<li>Extensive write up of the filecoin protocol - visible <a href="https://github.com/filecoin-project/specs/tree/prevspec">here</a></li>
<li>See full changelog: <a href="https://github.com/filecoin-project/specs/commits/prevspec">https://github.com/filecoin-project/specs/commits/prevspec</a></li>
</ul>


</div>



</div>

  

  
    








<div id="intro__system">

<h2 class="section-header">
  System Decomposition
</h2>

<div class="section-content">






































</div>


  
    








<div id="intro__system__why_systems">

<h3 class="section-header">
  What are Systems? How do they work?
</h3>

<div class="section-content">






































<p>Filecoin decouples and modularizes functionality into loosely-joined <code>systems</code>.
Each system adds significant functionality, usually to achieve a set of important and tightly related goals.</p>

<p>For example, the Blockchain System provides structures like Block, Tipset, and Chain, and provides functionality
like Block Sync, Block Propagation, Block Validation, Chain Selection, and Chain Access. This is
separated from the Files, Pieces, Piece Preparation, and Data Transfer. Both of these systems are separated from
the Markets, which provide Orders, Deals, Market Visibility, and Deal Settlement.</p>

<h4 id="why-is-system-decoupling-useful">Why is System decoupling useful?</h4>

<p>This decoupling is useful for:</p>

<ul>
<li><strong>Implementation Boundaries:</strong> it is possible to build implementations of Filecoin that only implement a
subset of systems. This is especially useful for <em>Implementation Diversity</em>: we want many implementations
of security critical systems (eg Blockchain), but do not need many implementations of Systems that can be
decoupled.</li>
<li><strong>Runtime Decoupling:</strong> system decoupling makes it easier to build and run Filecoin Nodes that isolate
Systems into separate programs, and even separate physical computers.</li>
<li><strong>Security Isolation:</strong> some systems require higher operational security than others. System decoupling allows
implementations to meet their security and functionality needs. A good example of this is separating Blockchain
processing from Data Transfer.</li>
<li><strong>Scalability:</strong> systems and various use cases may drive different performance requirements for different opertators.
System decoupling makes it easier for operators to scale their deployments along system boundaries.</li>
</ul>

<h4 id="filecoin-nodes-don-t-need-all-the-systems">Filecoin Nodes don&rsquo;t need all the systems</h4>

<p>Filecoin Nodes vary significantly, and do not need all the systems.
Most systems are only needed for a subset of use cases.</p>

<p>For example, the Blockchain System is required for synchronizing the chain, participating in secure consensus,
storage mining, and chain validation.
Many Filecoin Nodes do not need the chain and can perform their work by just fetching content from the latest
StateTree, from a node they trust. Of course, such nodes</p>

<p>Note: Filecoin does not use the &ldquo;full node&rdquo; or &ldquo;light client&rdquo; terminology, in wide use in Bitcoin and other blockchain
networks. In filecoin, these terms are not well defined. It is best to define nodes in terms of their capabilities,
and therefore, in terms of the Systems they run. For example:</p>

<ul>
<li><strong>Chain Verifier Node:</strong> Runs the Blockchain system. Can sync and validate the chain. Cannot mine or produce blocks.</li>
<li><strong>Client Node:</strong> Runs the Blockchain, Market, and Data Transfer systems. Can sync and validate the chain. Cannot mine or produce blocks.</li>
<li><strong>Retrieval Miner Node:</strong> Runs the Market and Data Transfer systems. Does not need the chain. Can make Retrieval Deals
(Retrieval Provider side). Can send Clients data, and get paid for it.</li>
<li><strong>Storage Miner Node:</strong> Runs the Blockchain, Storage Market, Storage Mining systems. Can sync and validate the chain.
Can make Storage Deals (Storage Provider side). Can seal stored data into sectors. Can acquire
storage consensus power. Can mine and produce blocks.</li>
</ul>

<h4 id="separating-systems">Separating Systems</h4>

<blockquote>
<p>How do we determine what functionality belongs in one system vs another?</p>
</blockquote>

<p>Drawing boundaries between systems is the art of separating tightly related functionality from unrelated parts.
In a sense, we seek to keep tightly integrated components in the same system, and away from other unrelated
components. This is sometimes straightforward, the boundaries naturally spring from the data structures or
functionality. For example, it is straightforward to observe that Clients and Miners negotiating a deal
with each other is very unrelated to VM Execution.</p>

<p>Sometimes this is harder, and it requires detangling, adding, or removing abstractions. For
example, the <code>StoragePowerActor</code> and the <code>StorageMarketActor</code> were a single <code>Actor</code> previously. This caused
a large coupling of functionality across <code>StorageDeal</code> making, the <code>StorageMarket</code>, markets in general, with
Storage Mining, Sector Sealing, PoSt Generation, and more. Detangling these two sets of related functionality
requried breaking apart the one actor into two.</p>

<h4 id="decomposing-within-a-system">Decomposing within a System</h4>

<p>Systems themselves decompose into smaller subunits. These are sometimes called &ldquo;subsystems&rdquo; to avoid confusion
with the much larger, first-class Systems. Subsystems themselves may break down further. The naming here is not
strictly enforced, as these subdivisions are more related to protocol and implementation engineering concerns
than to user capabilities.</p>


</div>



</div>

  

  
    








<div id="intro__system__impl_systems">

<h3 class="section-header">
  Implementing Systems
</h3>

<div class="section-content">






































<h4 id="system-requirements">System Requirements</h4>

<p>In order to make it easier to decouple functionality into systems, the Filecoin Protocol assumes
a set of functionality available to all systems. This functionality can be achieved by implementations
in a variety of ways, and should take the guidance here as a recommendation (SHOULD).</p>

<p>All Systems, as defined in this document, require the following:</p>

<ul>
<li><strong>Repository:</strong>

<ul>
<li><strong>Local <code>IpldStore</code>.</strong> Some amount of persistent local storage for data structures (small structured objects).
Systems expect to be initialized with an IpldStore in which to store data structures they expect to persist across crashes.</li>
<li><strong>User Configuration Values.</strong> A small amount of user-editable configuration values.
These should be easy for end-users to access, view, and edit.</li>
<li><strong>Local, Secure <code>KeyStore</code>.</strong> A facility to use to generate and use cryptographic keys, which MUST remain secret to the
Filecoin Node. Systems SHOULD NOT access the keys directly, and should do so over an abstraction (ie the <code>KeyStore</code>) which
provides the ability to Encrypt, Decrypt, Sign, SigVerify, and more.</li>
</ul></li>
<li><strong>Local <code>FileStore</code>.</strong> Some amount of persistent local storage for files (large byte arrays).
Systems expect to be initialized with a FileStore in which to store large files.
Some systems (like Markets) may need to store and delete large volumes of smaller files (1MB - 10GB).
Other systems (like Storage Mining) may need to store and delete large volumes of large files (1GB - 1TB).</li>
<li><strong>Network.</strong> Most systems need access to the network, to be able to connect to their counterparts in other Filecoin Nodes.
Systems expect to be initialized with a libp2p.Node on which they can mount their own protocols.</li>
<li><strong>Clock.</strong> Some systems need access to current network time, some with low tolerance for drift.
Systems expect to be initialized with a Clock from which to tell network time. Some systems (like Blockchain)
require very little clock drift, and require <em>secure</em> time.</li>
</ul>

<p>For this purpose, we use the <code>FilecoinNode</code> data structure, which is passed into all systems at initialization:</p>

















<p style="color: #D74848"><b><i>Something's not right. The <code>../../systems/filecoin_nodes/node_types/filecoin_node.id</code> file was not found.</i></b></p>






















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">key</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/key&#34;</span>
<span class="kn">import</span> <span class="nx">config</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/config&#34;</span>

<span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">config</span>          <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
    <span class="nx">ipldStore</span>       <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nx">keyStore</span>        <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>

    <span class="c1">// CreateRepository(config Config, ipldStore IPLDDagStore, keyStore KeyStore) &amp;Repository
</span><span class="c1"></span>    <span class="nf">GetIPLDStore</span><span class="p">()</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetKeyStore</span><span class="p">()</span>   <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetConfig</span><span class="p">()</span>     <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="system-limitations">System Limitations</h4>

<p>Further, Systems MUST abide by the following limitations:</p>

<ul>
<li><strong>Random crashes.</strong> A Filecoin Node may crash at any moment. Systems must be secure and consistent through crashes.
This is primarily achived by limiting the use of persistent state, persisting such state through Ipld data structures,
and through the use of initialization routines that check state, and perhaps correct errors.</li>
<li><strong>Isolation.</strong> Systems must communicate over well-defined, isolated interfaces. They must not build their critical
functionality over a shared memory space. (Note: for performance, shared memory abstractions can be used to power
IpldStore, FileStore, and libp2p, but the systems themselves should not require it). This is not just an operational
concern; it also significantly simplifies the protocol and makes it easier to understand, analyze, debug, and change.</li>
<li><strong>No direct access to host OS Filesystem or Disk.</strong> Systems cannot access disks directly &ndash; they do so over the FileStore
and IpldStore abstractions. This is to provide a high degree of portability and flexibility for end-users, especially
storage miners and clients of large amounts of data, which need to be able to easily replace how their Filecoin Nodes
access local storage.</li>
<li><strong>No direct access to host OS Network stack or TCP/IP.</strong> Systems cannot access the network directly &ndash; they do so over the
libp2p library. There must not be any other kind of network access. This provides a high degree of portability across
platforms and network protocols, enabling Filecoin Nodes (and all their critical systems) to run in a wide variety of
settings, using all kinds of protocols (eg Bluetooth, LANs, etc).</li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems">

<h1 class="section-header">
  Systems
</h1>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes">

<h2 class="section-header">
  <strong>Filecoin Nodes</strong>
</h2>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes__node_types">

<h3 class="section-header">
  Node Types
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes__node_types__node">

<h4 class="section-header">
  Node Interface
</h4>

<div class="section-content">




















































<p style="color: #D74848"><b><i>Something's not right. The <code>filecoin_node.id</code> file was not found.</i></b></p>




</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__node_types">

<h4 class="section-header">
  Examples
</h4>

<div class="section-content">




































<p>There are many kinds of Filecoin Nodes &hellip;</p>

<p>This section should contain:</p>

<ul>
<li>what all nodes must have, and why</li>
<li>examples of using different systems</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__verifier_node">

<h4 class="section-header">
  Chain Verifier Node
</h4>

<div class="section-content">




































<pre><code>type ChainVerifierNode interface {
  FilecoinNode

  systems.Blockchain
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__client_node">

<h4 class="section-header">
  Client Node
</h4>

<div class="section-content">




































<pre><code>type ClientNode struct {
  FilecoinNode

  systems.Blockchain
  markets.StorageMarketClient
  markets.RetrievalMarketClient
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__storage_miner_node">

<h4 class="section-header">
  Storage Miner Node
</h4>

<div class="section-content">




































<pre><code>type StorageMinerNode interface {
  FilecoinNode

  systems.Blockchain
  systems.Mining
  markets.StorageMarketProvider
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__retrieval_miner_node">

<h4 class="section-header">
  Retrieval Miner Node
</h4>

<div class="section-content">




































<pre><code>type RetrievalMinerNode interface {
  FilecoinNode

  blockchain.Blockchain
  markets.RetrievalMarketProvider
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__relayer_node">

<h4 class="section-header">
  Relayer Node
</h4>

<div class="section-content">




































<pre><code>type RelayerNode interface {
  FilecoinNode

  blockchain.MessagePool
  markets.MarketOrderBook
}
</code></pre>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_nodes__repository">

<h3 class="section-header">
  Repository - Local Storage for Chain Data and Systems
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">key</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/key&#34;</span>
<span class="kn">import</span> <span class="nx">config</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/config&#34;</span>

<span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">config</span>          <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
    <span class="nx">ipldStore</span>       <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nx">keyStore</span>        <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>

    <span class="c1">// CreateRepository(config Config, ipldStore IPLDDagStore, keyStore KeyStore) &amp;Repository
</span><span class="c1"></span>    <span class="nf">GetIPLDStore</span><span class="p">()</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetKeyStore</span><span class="p">()</span>   <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetConfig</span><span class="p">()</span>     <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_nodes__repository__config">

<h4 class="section-header">
  Config - Local Storage for ConfigurationValues
</h4>

<div class="section-content">




































<p>Filecoin Node configuration</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ConfigKey</span> <span class="kt">string</span>
<span class="kd">type</span> <span class="nx">ConfigVal</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">c</span> <span class="nx">ConfigVal</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">ConfigVal</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">Subconfig</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">)</span> <span class="nx">Config</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__repository__key">

<h4 class="section-header">
  KeyStore &amp; user keys
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Key</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">//  Algo Algorithm
</span><span class="c1"></span>    <span class="nx">Data</span> <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// key.Name
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Name</span> <span class="kt">string</span>

<span class="c1">// key.Store
</span><span class="c1">// TODO: redo this providing access to enc, dec, sign, sigverify operations, and not the keys.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Store</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">n</span> <span class="nx">Name</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">Key</span><span class="p">)</span> <span class="kt">error</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">n</span> <span class="nx">Name</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">k</span> <span class="nx">Key</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="c1">//  Sign(n Name, data Bytes) Signature
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Algorithm</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Sig</span> <span class="nx">SignatureAlgorithm</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SignatureAlgoC</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Sign</span><span class="p">(</span><span class="nx">b</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">s</span> <span class="nx">Signature</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Verify</span><span class="p">(</span><span class="nx">b</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">s</span> <span class="nx">Signature</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">EdDSASignatureAlgorithm</span> <span class="nx">SignatureAlgoC</span>
<span class="kd">type</span> <span class="nx">Secp256k1SignatureAlgorithm</span> <span class="nx">SignatureAlgoC</span>
<span class="kd">type</span> <span class="nx">BLSAggregateSignatureAlgorithm</span> <span class="nx">SignatureAlgoC</span>

<span class="kd">type</span> <span class="nx">SignatureAlgorithm</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">EdDSASigAlgo</span>      <span class="nx">EdDSASignatureAlgorithm</span>
    <span class="nx">Secp256k1SigAlgo</span>  <span class="nx">Secp256k1SignatureAlgorithm</span>
    <span class="nx">BLSSigAlgo</span>        <span class="nx">BLSAggregateSignatureAlgorithm</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algo</span>           <span class="nx">SignatureAlgorithm</span>
    <span class="nx">Data</span>           <span class="nx">Bytes</span>

    <span class="nf">Verify</span><span class="p">(</span><span class="nx">k</span> <span class="nx">Key</span><span class="p">)</span>  <span class="nx">union</span> <span class="p">{</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  

  

  


</div>

  

  
    








<div id="systems__filecoin_nodes__repository__ipldstore">

<h4 class="section-header">
  IpldStore - Local Storage for hash-linked data
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Store</span> <span class="nx">GraphStore</span>

<span class="c1">// imported as ipld.Object
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Object</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">CID</span><span class="p">()</span> <span class="nx">CID</span>

    <span class="c1">// Populate(v interface{}) error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>






<p>TODO:</p>

<ul>
<li>What is IPLD

<ul>
<li>hash linked data</li>
<li>from IPFS</li>
</ul></li>
<li>Why is it relevant to filecoin

<ul>
<li>all network datastructures are definitively IPLD</li>
<li>all local datastructures can be IPLD</li>
</ul></li>
<li>What is an IpldStore

<ul>
<li>local storage of dags</li>
</ul></li>
<li>How to use IpldStores in filecoin

<ul>
<li>pass it around</li>
</ul></li>
<li>One ipldstore or many

<ul>
<li>temporary caches</li>
<li>intermediately computed state</li>
</ul></li>
<li>Garbage Collection</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__repository__usage">

<h4 class="section-header">
  Usage in Systems
</h4>

<div class="section-content">




































<p>TODO:
- Explain how repo is used with systems and subsystems
- compartmentalized local storage
- store ipld datastructures of stateful objects</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_nodes__network">

<h3 class="section-header">
  Network Interface
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>
</code></pre></div>






<p>Filecoin nodes use the libp2p protocol for peer discovery, peer routing, and message multicast, and so on. Libp2p is a set of modular protocols common to the peer-to-peer networking stack. Nodes open connections with one another and mount different protocols or streams over the same connection. In the initial handshake, nodes exchange the protocols that each of them supports and all Filecoin related protcols will be mounted under <code>/filecoin/...</code> protocol identifiers.</p>

<p>Here is the list of libp2p protocols used by Filecoin.</p>

<ul>
<li>Graphsync: TODO</li>
<li>Bitswap:  TODO</li>
<li>Gossipsub: block headers and messages are broadcasted through a Gossip PubSub protocol where nodes can subscribe to topics such as <code>NewBlock</code>, <code>BlockHeader</code>, <code>BlockMessage</code>, etc and receive messages in those topics. When receiving messages related to a topic, nodes processes the message and forwards it to its peers who also subscribed to the same topic.</li>
<li>Kad-DHT: Kademlia DHT is a distributed hash table with a logarithmic bound on the maximum number of lookups for a particular node. Kad DHT is used primarily for peer routing as well as peer discovery in the Filecoin protocol.</li>
<li>Bootstrap: Bootstrap is a list of nodes that a new node attempts to connect upon joining the network. The list of bootstrap nodes and their addresses are defined by the users.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__clock">

<h3 class="section-header">
  Clock
</h3>

<div class="section-content">






































<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Time</span> <span class="kt">string</span>  <span class="c1">// ISO nano timestamp
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnixTime</span> <span class="kt">int64</span>  <span class="c1">// unix timestamp
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnixTimeNano</span> <span class="kt">int64</span>  <span class="c1">// unix timestamp in nanoseconds
</span><span class="c1"></span>
<span class="c1">// UTCClock is a normal, system clock reporting UTC time.
</span><span class="c1">// It should be kept in sync, with drift less than 1 second.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UTCClock</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">NowUTC</span><span class="p">()</span>          <span class="nx">Time</span>
    <span class="nf">NowUTCUnix</span><span class="p">()</span>      <span class="nx">UnixTime</span>
    <span class="nf">NowUTCUnixNano</span><span class="p">()</span>  <span class="nx">UnixTimeNano</span>
<span class="p">}</span>

<span class="c1">// ChainEpoch represents a round of a blockchain protocol.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ChainEpoch</span> <span class="nx">UVarint</span>

<span class="c1">// ChainEpochClock is a clock that represents epochs of the protocol.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ChainEpochClock</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// GenesisTime is the time of the first block. EpochClock counts
</span><span class="c1"></span>    <span class="c1">// up from there.
</span><span class="c1"></span>    <span class="nx">GenesisTime</span>          <span class="nx">Time</span>

    <span class="nf">EpochAtTime</span><span class="p">(</span><span class="nx">t</span> <span class="nx">Time</span><span class="p">)</span>  <span class="nx">ChainEpoch</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">clock</span>

<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="c1">// UTCMaxDrift is how large the allowable drift is in Filecoin&#39;s use of UTC time.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">UTCMaxDrift</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>

<span class="c1">// UTCSyncPeriod notes how often to sync the UTC clock with an authoritative
</span><span class="c1">// source, such as NTP, or a very precise hardware clock.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">UTCSyncPeriod</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>

<span class="c1">// EpochDuration is a constant that represents the UTC time duration
</span><span class="c1">// of a blockchain epoch.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">EpochDuration</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">15</span>

<span class="c1">// ISOFormat is the ISO timestamp format we use, in Go time package notation.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">ISOFormat</span> <span class="p">=</span> <span class="s">&#34;2006-01-02T15:04:05.999999999Z&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">UTCClock_I</span><span class="p">)</span> <span class="nf">NowUTC</span><span class="p">()</span> <span class="nx">Time</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">Time</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Format</span><span class="p">(</span><span class="nx">ISOFormat</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">UTCClock_I</span><span class="p">)</span> <span class="nf">NowUTCUnix</span><span class="p">()</span> <span class="nx">UnixTime</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">UnixTime</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">UTCClock_I</span><span class="p">)</span> <span class="nf">NowUTCUnixNano</span><span class="p">()</span> <span class="nx">UnixTimeNano</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">UnixTimeNano</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">UnixNano</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// EpochAtTime returns the ChainEpoch corresponding to t.
</span><span class="c1">// It first subtracts GenesisTime, then divides by EpochDuration
</span><span class="c1">// and returns the resulting number of epochs.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ChainEpochClock_I</span><span class="p">)</span> <span class="nf">EpochAtTime</span><span class="p">(</span><span class="nx">t</span> <span class="nx">Time</span><span class="p">)</span> <span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nx">g1</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GenesisTime</span><span class="p">()</span>
	<span class="nx">g2</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">ISOFormat</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">g1</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// an implementation should probably not panic here
</span><span class="c1"></span>		<span class="c1">// this is for simplicity of the spec
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">t2</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Parse</span><span class="p">(</span><span class="nx">ISOFormat</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">t</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">difference</span> <span class="o">:=</span> <span class="nx">t2</span><span class="p">.</span><span class="nf">Sub</span><span class="p">(</span><span class="nx">g2</span><span class="p">)</span>
	<span class="nx">epochs</span> <span class="o">:=</span> <span class="nx">difference</span> <span class="o">/</span> <span class="nx">EpochDuration</span>
	<span class="k">return</span> <span class="nf">ChainEpoch</span><span class="p">(</span><span class="nx">epochs</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>




</p>

<p>Filecoin assumes weak clock synchrony amongst participants in the system. That is, the system relies on participants having access to a globally synchronized clock, tolerating bounded delay in honest clock lower than epoch time (more on this in a forthcoming paper).</p>

<p>Filecoin relies on this system clock in order to secure consensus, specifically ensuring that participants are only running leader elections once per epoch and enabling miners to catch such deviations from the protocol. Given a system start and epoch time by the genesis block, the system clock allows miners to associate epoch and wall clock time, thereby enabling them to reason about block validity and give the protocol liveness.</p>

<h5 id="clock-uses">Clock uses</h5>

<p>Specifically, the Filecoin system clock is used:</p>

<ul>
<li>to validate incoming blocks and ensure they were mined in the appropriate round, looking at the wall clock time in conjunction with the block&rsquo;s <code>ElectionProof</code> (which contains the epoch number) (see <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> and <a href="./#systems__filecoin_blockchain__chainsync__block_validation">Block Validation</a>).</li>
<li>to help protocol convergence by giving miners a specific cutoff after which to reject incoming blocks in this round (see <a href="./#systems__filecoin_blockchain__chainsync">ChainSync - synchronizing the Blockchain</a>).</li>
<li>to maintain protocol liveness by allowing participants to try leader election in the next round if no one has produced a block in this round (see <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a>).</li>
</ul>

<p>In order to allow miners to do the above, the system clock must:</p>

<ol>
<li>have low clock drift: at most on the order of 1s (i.e. markedly lower than epoch time) at any given time.</li>
<li>maintain accurate network time over many epochs: resyncing and enforcing accurate network time.</li>
<li>set epoch number on client initialization equal to <code>epoch ~= (current_time - genesis_time) / epoch_time</code></li>
</ol>

<p>It is expected that other subsystems will register to a NewRound() event from the clock subsystem.</p>

<h5 id="clock-requirements">Clock Requirements</h5>

<p>Computer-grade clock crystals can be expected to have drift rates on the order of <a href="https://www.hindawi.com/journals/jcnc/2008/583162/">1ppm</a> (i.e. 1 microsecond every second or .6 seconds a week), therefore, in order to respect the first above-requirement,</p>

<ul>
<li>clients SHOULD query an NTP server (<code>pool.ntp.org</code> is recommended) on an hourly basis to adjust clock skew.

<ul>
<li>We recommend one of the following:</li>
<li><code>pool.ntp.org</code> (can be catered to a <a href="https://www.ntppool.org/zone">specific zone</a>)</li>
<li><code>time.cloudflare.com:1234</code> (more on <a href="https://www.cloudflare.com/time/">Cloudflare time services</a>)</li>
<li><code>time.google.com</code> (more on <a href="https://developers.google.com/time">Google Public NTP</a>)</li>
<li><code>ntp-b.nist.gov</code> (<a href="https://tf.nist.gov/tf-cgi/servers.cgi">NIST</a> servers require registration)</li>
<li>We further recommend making 3 measurements in order to drop by using the network to drop outliers</li>
<li>See how <a href="https://github.com/ethereum/go-ethereum/blob/master/p2p/discv5/ntp.go">go-ethereum does this</a> for inspiration</li>
</ul></li>
<li>clients CAN consider using cesium clocks instead for accurate synchrony within larger mining operations</li>
</ul>

<p>Assuming a majority of rational participants, the above should lead to relatively low skew over time, with seldom more than 10-20% clock skew that should be rectified periodically by the network, as is the case in other networks. This assumption can be tested over time by ensuring that:</p>

<ul>
<li>(real-time) epoch time is as dictated by the protocol</li>
<li>(historical) the current epoch number is as expected</li>
</ul>

<h5 id="future-work">Future work</h5>

<p>If either of the above metrics show significant network skew over time, future versions of Filecoin may include potential timestamp/epoch correction periods at regular intervals.</p>

<p>More generally, future versions of the Filecoin protocol will use Verifiable Delay Functions (VDFs) to strongly enforce block time and fulfill this leader election requirement; we choose to explicitly assume clock synchrony until hardware VDF security has been proven more extensively.</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__key_store">

<h3 class="section-header">
  Key Store
</h3>

<div class="section-content">




































<p>The <code>Key Store</code> is a fundamental abstraction in any full Filecoin node used to store the keypairs associated to a given miner&rsquo;s address and distinct workers (should the miner choose to run multiple workers).</p>

<p>Node security depends in large part on keeping these keys secure. To that end we recommend keeping keys separate from any given subsystem and using a separate key store to sign requests as required by subsystems as well as keeping those keys not used as part of mining in cold storage.</p>

<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">KeyStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ownerAddress</span>  <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">ownerKey</span>      <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">SigKeyPair</span>
    <span class="nx">Workers</span>       <span class="p">[</span><span class="nx">Worker</span><span class="p">]</span>

    <span class="c1">// SignWithKey(key, sigType, input)
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Worker</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Address</span>     <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">VRFKeyPair</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFKeyPair</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">key_store</span>
</code></pre></div>




</p>

<p>TODO:</p>

<ul>
<li>describe the different types of keys used in the protocol and their usage</li>
<li>clean interfaces for getting signatures for full filecoin mining cycles</li>
<li>potential reccomendations or clear disclaimers with regards to consequences of failed key security</li>
<li>protocol for changing worker keys in filecoin</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files">

<h2 class="section-header">
  Files &amp; Data
</h2>

<div class="section-content">




































<p>Filecoin&rsquo;s primary aim is to store client&rsquo;s Files and Data.
This section details data structures and tooling related to working with files,
chunking, encoding, graph representations, <code>Pieces</code>, storage abstractions, and more.</p>


<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files">
        

        <strong>Files &amp; Data</strong>

        
            <br /><br /><i class="menuIcon">üìë</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file">
        
            <i class="statusIcon">‚úÖ</i>
        

        File

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file__filestore">
        

        FileStore

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece">
        
            <i class="statusIcon">üîÅ</i>
        

        Piece

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece__piece_store">
        

        PieceStore

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__data_transfer">
        
            <i class="statusIcon">üîÅ</i>
        

        Data Transfer

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="systems__filecoin_files__file">

<h3 class="section-header">
  File
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Path is an opaque locator for a file (e.g. in a unix-style filesystem).
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Path</span> <span class="kt">string</span>

<span class="c1">// File is a variable length data container.
</span><span class="c1">// The File interface is modeled after a unix-style file, but abstracts the
</span><span class="c1">// underlying storage system.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">File</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Path</span><span class="p">()</span>   <span class="nx">Path</span>
    <span class="nf">Size</span><span class="p">()</span>   <span class="kt">int</span>
    <span class="nf">Close</span><span class="p">()</span>  <span class="kt">error</span>

    <span class="c1">// Read reads from File into buf, starting at offset, and for size bytes.
</span><span class="c1"></span>    <span class="nf">Read</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Write writes from buf into File, starting at offset, and for size bytes.
</span><span class="c1"></span>    <span class="nf">Write</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_files__file__filestore">

<h4 class="section-header">
  FileStore - Local Storage for Files
</h4>

<div class="section-content">






































<p>The <code>FileStore</code> is an abstraction used to refer to any underlying system or device
that Filecoin will store its data to. It is based on Unix filesystem semantics, and
includes the notion of <code>Paths</code>. This abstraction is here in order to make sure Filecoin
implementations make it easy for end-users to replace the underlying storage system with
whatever suits their needs. The simplest version of <code>FileStore</code> is just the host operating
system&rsquo;s file system.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FileStore is an object that can store and retrieve files by path.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FileStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Open</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>           <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Create</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>         <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Store</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">,</span> <span class="nx">f</span> <span class="nx">File</span><span class="p">)</span>  <span class="kt">error</span>
    <span class="nf">Delete</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>         <span class="kt">error</span>

    <span class="c1">// maybe add:
</span><span class="c1"></span>    <span class="c1">// Copy(SrcPath, DstPath)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>






<h5 id="varying-user-needs">Varying user needs</h5>

<p>Filecoin user needs vary significantly, and many users &ndash; especially miners &ndash; will implement
complex storage architectures underneath and around Filecoin. The <code>FileStore</code> abstraction is here
to make it easy for these varying needs to be easy to satisfy. All file and sector local data
storage in the Filecoin Protocol is defined in terms of this <code>FileStore</code> interface, which makes
it easy for implementations to make swappable, and for end-users to swap out with their system
of choice.</p>

<h5 id="implementation-examples">Implementation examples</h5>

<p>The <code>FileStore</code> interface may be implemented by many kinds of backing data storage systems. For example:</p>

<ul>
<li>The host Operating System file system</li>
<li>Any Unix/Posix file system</li>
<li>RAID-backed file systems</li>
<li>Networked of distributed file systems (NFS, HDFS, etc)</li>
<li>IPFS</li>
<li>Databases</li>
<li>NAS systems</li>
<li>Raw serial or block devices</li>
<li>Raw hard drives (hdd sectors, etc)</li>
</ul>

<p>Implementations SHOULD implement support for the host OS file system.
Implementations MAY implement support for other storage systems.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files__piece">

<h3 class="section-header">
  Piece - a part of a file
</h3>

<div class="section-content">




































<p>A <code>Piece</code> is an object that represents a whole or part of a <code>File</code>,
and is used by <code>Clients</code> and <code>Miners</code> in <code>Deals</code>. <code>Clients</code> hire <code>Miners</code>
to store <code>Pieces</code>.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="c1">// PieceCID is the main reference to pieces in Filecoin. It is the CID
</span><span class="c1">// of the Piece.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="kd">type</span> <span class="nx">NumBytes</span> <span class="nx">UVarint</span>  <span class="c1">// TODO: move into util
</span><span class="c1"></span>
<span class="c1">// PieceSize is the size of a piece, in bytes
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceSize</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PayloadSize</span>   <span class="nx">NumBytes</span>
    <span class="nx">OverheadSize</span>  <span class="nx">NumBytes</span>

    <span class="nf">Total</span><span class="p">()</span>       <span class="nx">NumBytes</span>
<span class="p">}</span>

<span class="c1">// PieceInfo is an object that describes details about a piece, and allows
</span><span class="c1">// decoupling storage of this information from the piece itself.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>    <span class="nx">PieceID</span>
    <span class="nx">Size</span>  <span class="nx">PieceSize</span>
    <span class="c1">// TODO: store which algorithms were used to construct this piece.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Piece represents the basic unit of tradeable data in Filecoin. Clients
</span><span class="c1">// break files and data up into Pieces, maybe apply some transformations,
</span><span class="c1">// and then hire Miners to store the Pieces.
</span><span class="c1">//
</span><span class="c1">// The kinds of transformations that may ocurr include erasure coding,
</span><span class="c1">// encryption, and more.
</span><span class="c1">//
</span><span class="c1">// Note: pieces are well formed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Piece</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Info</span>       <span class="nx">PieceInfo</span>

    <span class="c1">// tree is the internal representation of Piece. It is a tree
</span><span class="c1"></span>    <span class="c1">// formed according to a sequence of algorithms, which make the
</span><span class="c1"></span>    <span class="c1">// piece able to be verified.
</span><span class="c1"></span>    <span class="nx">tree</span>       <span class="nx">PieceTree</span>

    <span class="c1">// Payload is the user&#39;s data.
</span><span class="c1"></span>    <span class="nf">Payload</span><span class="p">()</span>  <span class="nx">Bytes</span>

    <span class="c1">// Data returns the serialized representation of the Piece.
</span><span class="c1"></span>    <span class="c1">// It includes the payload data, and intermediate tree objects,
</span><span class="c1"></span>    <span class="c1">// formed according to relevant storage algorithms.
</span><span class="c1"></span>    <span class="nf">Data</span><span class="p">()</span>     <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// // LocalPieceRef is an object used to refer to pieces in local storage.
</span><span class="c1">// // This is used by subsystems to store and locate pieces.
</span><span class="c1">// type LocalPieceRef struct {
</span><span class="c1">//   ID   PieceID
</span><span class="c1">//   Path file.Path
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="c1">// PieceTree is a data structure used to form pieces. The algorithms involved
</span><span class="c1">// in the storage proofs determine the shape of PieceTree and how it must be
</span><span class="c1">// constructed.
</span><span class="c1">//
</span><span class="c1">// Usually, a node in PieceTree will include either Children or Data, but not
</span><span class="c1">// both.
</span><span class="c1">//
</span><span class="c1">// TODO: move this into filproofs -- use a tree from there, as that&#39;s where
</span><span class="c1">// the algorightms are defined. Or keep this as an interface, met by others.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Children</span>  <span class="p">[</span><span class="nx">PieceTree</span><span class="p">]</span>
    <span class="nx">Data</span>      <span class="nx">Bytes</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_files__piece__piece_store">

<h4 class="section-header">
  PieceStore - storing and indexing pieces
</h4>

<div class="section-content">




































<p>A <code>PieceStore</code> is an object that can store and retrieve pieces
from some local storage. The <code>PieceStore</code> additionally keeps
an index of pieces.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="kd">type</span> <span class="nx">PieceID</span> <span class="nx">UVarint</span>

<span class="c1">// PieceStore is an object that stores pieces into some local storage.
</span><span class="c1">// it is internally backed by an IpldStore.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Store</span>              <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nx">Index</span>              <span class="p">{</span><span class="nx">PieceID</span><span class="p">:</span> <span class="nx">Piece</span><span class="p">}</span>

    <span class="nf">Get</span><span class="p">(</span><span class="nx">i</span> <span class="nx">PieceID</span><span class="p">)</span>     <span class="kd">struct</span> <span class="p">{</span><span class="nx">p</span> <span class="nx">Piece</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Piece</span><span class="p">)</span>       <span class="kt">error</span>
    <span class="nf">Delete</span><span class="p">(</span><span class="nx">i</span> <span class="nx">PieceID</span><span class="p">)</span>  <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files__data_transfer">

<h3 class="section-header">
  Data Transfer in Filecoin
</h3>

<div class="section-content">






































<p><em>Data Transfer</em> is a system for transferring all or part of a <code>Piece</code> across the network when a deal is made.</p>

<h4 id="modules">Modules</h4>

<p>This diagram shows how Data Tranfer and its modules fit into the picture with the Storage and Retrieval Markets.
In particular, note how the Data Transfer Request Validators from the markets are plugged into the Data Transfer module,
but their code belongs in the Markets system.</p>













<div class="diagram">

<span class="diagram-title">Data Transfer - Push Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/data-transfer-modules.png" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/data-transfer-modules.png" />




</div>


<h4 id="terminology">Terminology</h4>

<ul>
<li><strong>Push Request</strong>: A request to send data to the other party</li>
<li><strong>Pull Request</strong>: A request to have the other party send data</li>
<li><strong>Requestor</strong>: The party that initiates the data transfer request (whether Push or Pull)</li>
<li><strong>Responder</strong>: The party that receives the data transfer request</li>
<li><strong>Data Transfer Voucher</strong>: A wrapper around storage or retrieval data that can identify and validate the transfer request to the other party</li>
<li><strong>Request Validator</strong>: The data transfer module only initiates a transfer when the responder can validate that the request is tied directly to either an existing storage deal or retrieval deal. Validation is not performed by the data transfer module itself. Instead, a request validator inspects the data transfer voucher to determine whether to respond to the request.</li>
<li><strong>Scheduler</strong>:  Once a request is negotiated and validated, actual transfer is managed by a scheduler on both sides. The scheduler is part of the data transfer module but is isolated from the negotiation process. It has access to an underlying verifiable transport protocol and uses it to send data and track progress.</li>
<li><strong>Subscriber</strong>: An external component that monitors progress of a data transfer by subscribing to data transfer events, such as progress or completion.</li>
<li><strong>GraphSync</strong>: The default underlying transfer protocol used by the Scheduler. The full graphsync specification can be found at <a href="https://github.com/ipld/specs/blob/master/block-layer/graphsync/graphsync.md">https://github.com/ipld/specs/blob/master/block-layer/graphsync/graphsync.md</a></li>
</ul>

<h4 id="request-phases">Request Phases</h4>

<p>There are two basic phases to any data transfer:</p>

<ol>
<li>Negotiation - the requestor and responder agree to the transfer by validating with the data transfer voucher</li>
<li>Transfer - Once both parties have negotiated and agreed upon, the data is actually transferred. The default protocol used to do the transfer is Graphsync</li>
</ol>

<p>Note that the Negotiation and Transfer stages can occur in seperate round trips,
or potentially the same round trip, where the requesting party implicitly agrees by sending the request, and the responding party can agree and immediately send or receive data.</p>

<h4 id="example-flows">Example Flows</h4>

<h5 id="push-flow">Push Flow</h5>













<div class="diagram">

<span class="diagram-title">Data Transfer - Push Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/push-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/push-flow.mmd.svg" />




</div>


<ol>
<li>A requestor initiates a Push transfer when it wants to send data to another party.</li>
<li>The requestors&rsquo; data transfer module will send a push request to the responder along with the data transfer voucher. It also puts the data transfer in the scheduler queue, meaning it expects the responder to initiate a transfer once the request is verified</li>
<li>The responder&rsquo;s data transfer module validates the data transfer request via the Validator provided as a dependency by the responder</li>
<li>The responder&rsquo;s data transfer module schedules the transfer</li>
<li>The responder makes a GraphSync request for the data</li>
<li>The requestor receives the graphsync request, verifies it&rsquo;s in the scheduler and begins sending data</li>
<li>The responder receives data and can produce an indication of progress</li>
<li>The responder completes receiving data, and notifies any listeners</li>
</ol>

<p>The push flow is ideal for storage deals, where the client initiates the push
once it verifies the the deal is signed and on chain</p>

<h5 id="pull-flow">Pull Flow</h5>













<div class="diagram">

<span class="diagram-title">Data Transfer - Pull Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/pull-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/pull-flow.mmd.svg" />




</div>


<ol>
<li>A requestor initiates a Pull transfer when it wants to receive data from another party.</li>
<li>The requestors&rsquo; data transfer module will send a pull request to the responder along with the data transfer voucher.</li>
<li>The responder&rsquo;s data transfer module validates the data transfer request via a PullValidator provided as a dependency by the responder</li>
<li>The responder&rsquo;s data transfer module schedules the transfer (meaning it is expecting the requestor to initiate the actual transfer)</li>
<li>The responder&rsquo;s data transfer module sends a response to the requestor saying it has accepted the transfer and is waiting for the requestor to initiate the transfer</li>
<li>The requestor schedules the data transfer</li>
<li>The requestor makes a GraphSync request for the data</li>
<li>The responder receives the graphsync request, verifies it&rsquo;s in the scheduler and begins sending data</li>
<li>The requestor receives data and can produce an indication of progress</li>
<li>The requestor completes receiving data, and notifies any listeners</li>
</ol>

<p>The pull flow is ideal for retrieval deals, where the client initiates the pull when the deal is agreed upon.</p>

<h4 id="alternater-pull-flow-single-round-trip">Alternater Pull Flow - Single Round Trip</h4>













<div class="diagram">

<span class="diagram-title">Data Transfer - Single Round Trip Pull Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/alternate-pull-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/alternate-pull-flow.mmd.svg" />




</div>


<ol>
<li>A requestor initiates a Pull transfer when it wants to receive data from another party.</li>
<li>The requestor‚Äôs DTM schedules the data transfer</li>
<li>The requestor makes a Graphsync request to the responder with a data transfer request</li>
<li>The responder receives the graphsync request, and forwards the data transfer request to the data transfer module</li>
<li>The requestors&rsquo; data transfer module will send a pull request to the responder along with the data transfer voucher.</li>
<li>The responder&rsquo;s data transfer module validates the data transfer request via a PullValidator provided as a dependency by the responder</li>
<li>The responder&rsquo;s data transfer module schedules the transfer</li>
<li>The responder sends a graphsync response along with a data transfer accepted response piggypacked</li>
<li>The requestor receives data and can produce an indication of progress</li>
<li>The requestor completes receiving data, and notifies any listeners</li>
</ol>

<h4 id="protocol">Protocol</h4>

<p>A data transfer CAN be negotiated over the network via the <a href="./#listings__libp2p_protocols__data_transfer_protocol">Data Transfer Protocol</a>, a Libp2p protocol type</p>

<p>A Pull request expects a response. The requestor does not initiate the transfer
until they know the request is accepted.</p>

<p>The responder should send a response to a push request as well so the requestor can release the resources (if not accepted). However, if the Responder accepts the request they can immediately initiate the transfer</p>

<p>Using the Data Transfer Protocol as an independent libp2p communciation mechanism is not a hard requirement &ndash; as long as both parties have an implementation of the Data Transfer Subsystem that can talk to the other, any
transport mechanism (including offline mechanisms) is acceptable.</p>

<h4 id="data-structures">Data Structures</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>

<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>

<span class="kd">type</span> <span class="nx">StorageDeal</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalDeal</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// A DataTransferVoucher is used to validate
</span><span class="c1">// a data transfer request against the underlying storage or retrieval deal
</span><span class="c1">// that precipitated it
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DataTransferVoucher</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">StorageDealVoucher</span>
    <span class="nx">RetrievalDealVoucher</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageDealVoucher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">deal</span> <span class="nx">StorageDeal</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalDealVoucher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">deal</span> <span class="nx">RetrievalDeal</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Ongoing</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Completed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Failed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ChannelNotFoundError</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">DataTransferStatus</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Ongoing</span>
    <span class="nx">Completed</span>
    <span class="nx">Failed</span>
    <span class="nx">ChannelNotFoundError</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TransferID</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">ChannelID</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">to</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>
    <span class="nx">id</span> <span class="nx">TransferID</span>
<span class="p">}</span>

<span class="c1">// All immutable data for a channel
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DataTransferChannel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// an identifier for this channel shared by request and responder, set by requestor through protocol
</span><span class="c1"></span>    <span class="nx">transferID</span>  <span class="nx">TransferID</span>
    <span class="c1">// base CID for the piece being transferred
</span><span class="c1"></span>    <span class="nx">PieceRef</span>    <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
    <span class="c1">// portion of Piece to return, specified by an IPLD selector
</span><span class="c1"></span>    <span class="nx">Selector</span>    <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="c1">// used to verify this channel
</span><span class="c1"></span>    <span class="nx">voucher</span>     <span class="nx">DataTransferVoucher</span>
    <span class="c1">// the party that is sending the data (not who initiated the request)
</span><span class="c1"></span>    <span class="nx">sender</span>      <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>
    <span class="c1">// the party that is receiving the data (not who initiated the request)
</span><span class="c1"></span>    <span class="nx">recipient</span>   <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>
    <span class="c1">// expected amount of data to be transferred
</span><span class="c1"></span>    <span class="nx">totalSize</span>   <span class="nx">UVarint</span>
<span class="p">}</span>

<span class="c1">// DataTransferState is immutable channel data plus mutable state
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DataTransferState</span> <span class="kd">struct</span> <span class="err">@</span><span class="p">(</span><span class="nx">mutable</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">DataTransferChannel</span>
    <span class="c1">// total bytes sent from this node (0 if receiver)
</span><span class="c1"></span>    <span class="nx">sent</span>                 <span class="nx">UVarint</span>
    <span class="c1">// total bytes received by this node (0 if sender)
</span><span class="c1"></span>    <span class="nx">received</span>             <span class="nx">UVarint</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Open</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Progress</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Error</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Complete</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">DataTransferEvent</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Open</span>
    <span class="nx">Progress</span>
    <span class="nx">Error</span>
    <span class="nx">Complete</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DataTransferSubscriber</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">OnEvent</span><span class="p">(</span><span class="nx">event</span> <span class="nx">DataTransferEvent</span><span class="p">,</span> <span class="nx">channelState</span> <span class="nx">DataTransferState</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// RequestValidator is an interface implemented by the client of the data transfer module to validate requests
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RequestValidator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ValidatePush</span><span class="p">(</span>
        <span class="nx">sender</span>    <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span>
    <span class="nf">ValidatePull</span><span class="p">(</span>
        <span class="nx">receiver</span>  <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DataTransferSubsystem</span> <span class="kd">struct</span> <span class="err">@</span><span class="p">(</span><span class="nx">mutable</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">host</span>              <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>
    <span class="nx">dataTransfers</span>     <span class="p">{</span><span class="nx">ChannelID</span><span class="p">:</span> <span class="nx">DataTransferState</span><span class="p">}</span>
    <span class="nx">requestValidator</span>  <span class="nx">RequestValidator</span>
    <span class="nx">pieceStore</span>        <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceStore</span>

    <span class="c1">// open a data transfer that will send data to the recipient peer and
</span><span class="c1"></span>    <span class="c1">// open a data transfer that will send data to the recipient peer and
</span><span class="c1"></span>    <span class="c1">// transfer parts of the piece that match the selector
</span><span class="c1"></span>    <span class="nf">OpenPushDataChannel</span><span class="p">(</span>
        <span class="nx">to</span>        <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span> <span class="nx">ChannelID</span>

    <span class="c1">// open a data transfer that will request data from the sending peer and
</span><span class="c1"></span>    <span class="c1">// transfer parts of the piece that match the selector
</span><span class="c1"></span>    <span class="nf">OpenPullDataChannel</span><span class="p">(</span>
        <span class="nx">to</span>        <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span> <span class="nx">ChannelID</span>

    <span class="c1">// close an open channel (effectively a cancel)
</span><span class="c1"></span>    <span class="nf">CloseDataTransferChannel</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ChannelID</span><span class="p">)</span>

    <span class="c1">// get status of a transfer
</span><span class="c1"></span>    <span class="nf">TransferChannelStatus</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ChannelID</span><span class="p">)</span> <span class="nx">DataTransferStatus</span>

    <span class="c1">// get notified when certain types of events happen
</span><span class="c1"></span>    <span class="nf">SubscribeToEvents</span><span class="p">(</span><span class="nx">subscriber</span> <span class="nx">DataTransferSubscriber</span><span class="p">)</span>

    <span class="c1">// get all in progress transfers
</span><span class="c1"></span>    <span class="nf">InProgressChannels</span><span class="p">()</span> <span class="p">{</span><span class="nx">ChannelID</span><span class="p">:</span> <span class="nx">DataTransferState</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm">

<h2 class="section-header">
  VM - Virtual Machine
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm">
        

        <strong>Virtual Machine</strong>

        
            <br /><br /><i class="menuIcon">üíª</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor">
        
            <i class="statusIcon">‚úÖ</i>
        

        Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor__address">
        

        Address

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__state_tree">
        
            <i class="statusIcon">üîÅ</i>
        

        State Tree

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__message">
        
            <i class="statusIcon">üîÅ</i>
        

        Message

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Runtime

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime__exitcode">
        

        Exit Codes

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime__gascost">
        

        Gas Costs

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors">
        
            <i class="statusIcon">üîÅ</i>
        

        System Actors

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__init_actor">
        

        InitActor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__cron_actor">
        

        CronActor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__account_actor">
        

        AccountActor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__interpreter">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Interpreter

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>





















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>

<span class="c1">// VM is the object that controls execution.
</span><span class="c1">// It is a stateless, pure function. It uses no local storage.
</span><span class="c1">//
</span><span class="c1">// TODO: make it just a function: VMExec(...) ?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VM</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Execute computes and returns outTree, a new StateTree which is the
</span><span class="c1"></span>    <span class="c1">// application of msgs to inTree.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// *Important:* Execute is intended to be a pure function, with no side-effects.
</span><span class="c1"></span>    <span class="c1">// however, storage of the new parts of the computed outTree may exist in
</span><span class="c1"></span>    <span class="c1">// local storage.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// *TODO:* define whether this should take 0, 1, or 2 IpldStores:
</span><span class="c1"></span>    <span class="c1">// - (): storage of IPLD datastructures is assumed implicit
</span><span class="c1"></span>    <span class="c1">// - (store): get and put to same IpldStore
</span><span class="c1"></span>    <span class="c1">// - (inStore, outStore): get from inStore, put new structures into outStore
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// This decision impacts callers, and potentially impacts how we reason about
</span><span class="c1"></span>    <span class="c1">// local storage, and intermediate storage. It is definitely the case that
</span><span class="c1"></span>    <span class="c1">// implementations may want to operate on this differently, depending on
</span><span class="c1"></span>    <span class="c1">// how their IpldStores work.
</span><span class="c1"></span>    <span class="nf">Execute</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msgs</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">])</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_vm__actor">

<h3 class="section-header">
  VM Actor Interface
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// This contains actor things that are _outside_ of VM exection.
</span><span class="c1">// The VM uses this to execute actors.
</span><span class="c1"></span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="c1">// TokenAmount is an amount of Filecoin tokens. This type is used within
</span><span class="c1">// the VM in message execution, to account movement of tokens, payment
</span><span class="c1">// of VM gas, and more.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TokenAmount</span> <span class="nx">UVarint</span>  <span class="c1">// TODO: bigint or varint?
</span><span class="c1"></span>
<span class="c1">// MethodNum is an integer that represents a particular method
</span><span class="c1">// in an actor&#39;s function table. These numbers are used to compress
</span><span class="c1">// invocation of actor code, and to decouple human language concerns
</span><span class="c1">// about method names from the ability to uniquely refer to a particular
</span><span class="c1">// method.
</span><span class="c1">//
</span><span class="c1">// Consider MethodNum numbers to be similar in concerns as for
</span><span class="c1">// offsets in function tables (in programming languages), and for
</span><span class="c1">// tags in ProtocolBuffer fields. Tags in ProtocolBuffers recommend
</span><span class="c1">// assigning a unique tag to a field and never reusing that tag.
</span><span class="c1">// If a field is no longer used, the field name may change but should
</span><span class="c1">// still remain defined in the code to ensure the tag number is not
</span><span class="c1">// reused accidentally. The same should apply to the MethodNum
</span><span class="c1">// associated with methods in Filecoin VM Actors.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MethodNum</span> <span class="nx">Int</span>

<span class="c1">// MethodParams is an array of objects to pass into a method. This
</span><span class="c1">// is the list of arguments/parameters.
</span><span class="c1">//
</span><span class="c1">// TODO: serialized or deserialized? (serialized for now)
</span><span class="c1">// TODO: force CIDs or by value is fine?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MethodParam</span> <span class="nx">Serialization</span>
<span class="kd">type</span> <span class="nx">MethodParams</span> <span class="p">[</span><span class="nx">MethodParam</span><span class="p">]</span>

<span class="c1">// CallSeqNum is an invocation (Call) sequence (Seq) number (Num).
</span><span class="c1">// This is a value used for securing against replay attacks:
</span><span class="c1">// each AccountActor (user) invocation must have a unique CallSeqNum
</span><span class="c1">// value. The sequenctiality of the numbers is used to make it
</span><span class="c1">// easy to verify, and to order messages.
</span><span class="c1">//
</span><span class="c1">// Q&amp;A
</span><span class="c1">// - &gt; Does it have to be sequential?
</span><span class="c1">//   No, a random nonce could work against replay attacks, but
</span><span class="c1">//   making it sequential makes it much easier to verify.
</span><span class="c1">// - &gt; Can it be used to order events?
</span><span class="c1">//   Yes, a user may submit N separate messages with increasing
</span><span class="c1">//   sequence number, causing them to execute in order.
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CallSeqNum</span> <span class="nx">UVarint</span>

<span class="c1">// Code is a serialized object that contains the code for an Actor.
</span><span class="c1">// Until we accept external user-provided contracts, this is the
</span><span class="c1">// serialized code for the actor in the Filecoin Specification.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Code</span> <span class="nx">Bytes</span>

<span class="c1">// CodeID identifies an actor&#39;s code (either one of the builtin actors,
</span><span class="c1">// or, in the future, potentially a CID of VM code for a custom actor.)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CodeID</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Builtin</span>        <span class="nx">BuiltinActorID</span>
    <span class="nx">UserDefined</span>    <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

    <span class="nf">IsBuiltin</span><span class="p">()</span>    <span class="kt">bool</span>
    <span class="nf">IsSingleton</span><span class="p">()</span>  <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">BuiltinActorID</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">Init</span>
    <span class="nx">Cron</span>
    <span class="nx">Account</span>
    <span class="nx">PaymentChannel</span>
    <span class="nx">StoragePower</span>
    <span class="nx">StorageMiner</span>
    <span class="nx">StorageMarket</span>
<span class="p">}</span>

<span class="c1">// Actor is a base computation object in the Filecoin VM. Similar
</span><span class="c1">// to Actors in the Actor Model (programming), or Objects in Object-
</span><span class="c1">// Oriented Programming, or Ethereum Contracts in the EVM.
</span><span class="c1">//
</span><span class="c1">// Questions for id language:
</span><span class="c1">// - we should not do inheritance, we should do composition.
</span><span class="c1">//   but we should make including actor state nicer.
</span><span class="c1">//
</span><span class="c1">// ActorState represents the on-chain storage actors keep.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// common fields for all actors
</span><span class="c1"></span>
    <span class="nx">CodeID</span>
    <span class="c1">// use a CID here, load it in interpreter.
</span><span class="c1"></span>    <span class="c1">// Alternative is to use ActorState here but tricky w/ the type system
</span><span class="c1"></span>    <span class="nx">State</span>                    <span class="nx">ActorSubstateCID</span>

    <span class="nx">Balance</span>                  <span class="nx">TokenAmount</span>
    <span class="nx">CallSeqNum</span>  <span class="c1">// FKA Nonce
</span><span class="c1"></span>
    <span class="c1">// Note: may be nil if actor has no public key
</span><span class="c1"></span>    <span class="nf">GetSignaturePublicKey</span><span class="p">()</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ActorSystemStateCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">ActorSubstateCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="c1">// ActorState represents the on-chain storage actors keep. This type is a
</span><span class="c1">// union of concrete types, for each of the Actors:
</span><span class="c1">// - InitActor
</span><span class="c1">// - CronActor
</span><span class="c1">// - AccountActor
</span><span class="c1">// - PaymentChannelActor
</span><span class="c1">// - StoragePowerActor
</span><span class="c1">// - StorageMinerActor
</span><span class="c1">// - StroageMarketActor
</span><span class="c1">//
</span><span class="c1">// TODO: move this into a directory inside the VM that patches in all
</span><span class="c1">// the actors from across the system. this will be where we declare/mount
</span><span class="c1">// all actors in the VM.
</span><span class="c1">// type ActorState union {
</span><span class="c1">//     Init struct {
</span><span class="c1">//         AddressMap  {addr.Address: ActorID}
</span><span class="c1">//         NextID      ActorID
</span><span class="c1">//     }
</span><span class="c1">// }
</span></code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">actor</span>

<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">MethodSend</span>        <span class="p">=</span> <span class="nf">MethodNum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">MethodConstructor</span> <span class="p">=</span> <span class="nf">MethodNum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">MethodCron</span>        <span class="p">=</span> <span class="nf">MethodNum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

	<span class="c1">// TODO: remove this once canonical method numbers are finalized
</span><span class="c1"></span>	<span class="nx">MethodPlaceholder</span> <span class="p">=</span> <span class="nf">MethodNum</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">ActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Note: may be nil if actor has no public key
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">ActorState_I</span><span class="p">)</span> <span class="nf">GetSignaturePublicKey</span><span class="p">()</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">id</span> <span class="o">*</span><span class="nx">CodeID_I</span><span class="p">)</span> <span class="nf">IsBuiltin</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">id</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">CodeID_Case_Builtin</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Actor code ID case not supported&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">id</span> <span class="o">*</span><span class="nx">CodeID_I</span><span class="p">)</span> <span class="nf">IsSingleton</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">id</span><span class="p">.</span><span class="nf">IsBuiltin</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="nx">BuiltinActorID</span><span class="p">{</span>
		<span class="nx">BuiltinActorID_Init</span><span class="p">,</span>
		<span class="nx">BuiltinActorID_Cron</span><span class="p">,</span>
		<span class="nx">BuiltinActorID_Init</span><span class="p">,</span>
		<span class="nx">BuiltinActorID_StoragePower</span><span class="p">,</span>
		<span class="nx">BuiltinActorID_StorageMarket</span><span class="p">,</span>
	<span class="p">}</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">id</span><span class="p">.</span><span class="nf">As_Builtin</span><span class="p">()</span> <span class="o">==</span> <span class="nx">a</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="p">[]</span><span class="nx">BuiltinActorID</span><span class="p">{</span>
		<span class="nx">BuiltinActorID_Account</span><span class="p">,</span>
		<span class="nx">BuiltinActorID_PaymentChannel</span><span class="p">,</span>
		<span class="nx">BuiltinActorID_StorageMiner</span><span class="p">,</span>
	<span class="p">}</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">id</span><span class="p">.</span><span class="nf">As_Builtin</span><span class="p">()</span> <span class="o">==</span> <span class="nx">a</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Actor code ID case not supported&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_vm__actor__address">

<h4 class="section-header">
  Address
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Address is defined here because this is where addresses start to make sense.
</span><span class="c1">// Addresses refer to actors defined in the StateTree, so Addresses are defined
</span><span class="c1">// on top of the StateTree.
</span><span class="c1">//
</span><span class="c1">// TODO: potentially move into a library, or its own directory.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Address</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">NetworkID</span> <span class="nx">enum</span> <span class="p">{</span>
        <span class="nx">Testnet</span>
        <span class="nx">Mainnet</span>
    <span class="p">}</span>

    <span class="nx">Data</span> <span class="nx">union</span> <span class="p">{</span>
        <span class="nx">ID</span>                   <span class="nx">ActorID</span>
        <span class="nx">PublicKey_Secp256k1</span>  <span class="nx">KeyHash</span>  <span class="c1">// TODO: reorder
</span><span class="c1"></span>        <span class="nx">ActorExec</span>            <span class="nx">ActorExecHash</span>
        <span class="nx">PublicKey_BLS</span>        <span class="nx">KeyHash</span>
    <span class="p">}</span>

    <span class="nf">VerifySyntax</span><span class="p">()</span>   <span class="kt">bool</span>
    <span class="nf">String</span><span class="p">()</span>         <span class="nx">AddressString</span>
    <span class="nf">IsKeyType</span><span class="p">()</span>      <span class="kt">bool</span>
    <span class="nf">Equals</span><span class="p">(</span><span class="nx">Address</span><span class="p">)</span>  <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// ActorID is a sequential number assigned to actors in a Filecoin Chain.
</span><span class="c1">// ActorIDs are assigned by the InitActor, when an Actor is introduced into
</span><span class="c1">// the Runtime.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorID</span> <span class="nx">Int</span>

<span class="kd">type</span> <span class="nx">KeyHash</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">ActorExecHash</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">AddressString</span> <span class="kt">string</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__state_tree">

<h3 class="section-header">
  State Tree
</h3>

<div class="section-content">




































<p>The State Tree is the output of applying operations on the Filecoin Blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="c1">// Epoch is an epoch in time in the StateTree.
</span><span class="c1">// It corresponds to rounds in the blockchain, but it
</span><span class="c1">// is defined here as actors need a notion of time.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Epoch</span> <span class="nx">UVarint</span>

<span class="c1">// TODO: move this into a directory w/ all the actors + states
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorName</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">StoragePowerActor</span>
    <span class="nx">StorageMarketActor</span>
    <span class="nx">StorageMinerActor</span>
    <span class="nx">PaymentChannelActor</span>
    <span class="nx">InitActor</span>
    <span class="nx">AccountActor</span>
    <span class="nx">CronActor</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StateTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SystemActors</span>  <span class="p">{</span><span class="nx">ActorName</span><span class="p">:</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">}</span>
    <span class="nx">ActorStates</span>   <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState</span><span class="p">}</span>

    <span class="c1">// TODO: API ConvenienceAPI
</span><span class="c1"></span>
    <span class="nf">GetActorState</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState</span>

    <span class="c1">// Balance returns the balance of a given actor
</span><span class="c1"></span>    <span class="nf">Balance</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>
</code></pre></div>






<p>TODO</p>

<ul>
<li>Add ConvenienceAPI state to provide more user-friendly views.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_vm__message">

<h3 class="section-header">
  VM Message - Actor Method Invocation
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>

<span class="c1">// GasAmount is a quantity of gas.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GasAmount</span> <span class="nx">UVarint</span>

<span class="c1">// GasPrice is a Gas-to-FIL cost
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GasPrice</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

<span class="kd">type</span> <span class="nx">Message</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">UnsignedMessage</span>
    <span class="nx">SignedMessage</span>
<span class="p">}</span>  <span class="c1">// representation keyed
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">UnsignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">From</span>        <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">To</span>          <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="nx">Method</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span>
    <span class="nx">Params</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span>  <span class="c1">// Serialized parameters to the method.
</span><span class="c1"></span>
    <span class="c1">// When receiving a message from a user account the nonce in the message must match
</span><span class="c1"></span>    <span class="c1">// the expected nonce in the &#34;from&#34; actor. This prevents replay attacks.
</span><span class="c1"></span>    <span class="nx">CallSeqNum</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>
    <span class="nx">Value</span>       <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

    <span class="nx">GasPrice</span>
    <span class="nx">GasLimit</span>    <span class="nx">GasAmount</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">SignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Message</span>    <span class="nx">UnsignedMessage</span>
    <span class="nx">Signature</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">InvocInput</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">To</span>      <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">Method</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span>
    <span class="nx">Params</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span>
    <span class="nx">Value</span>   <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ExitCode</span>     <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span>
    <span class="nx">ReturnValue</span>  <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessageReceipt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ExitCode</span>     <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span>
    <span class="nx">ReturnValue</span>  <span class="nx">Bytes</span>
    <span class="nx">GasUsed</span>      <span class="nx">GasAmount</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span></code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">message</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">type</span> <span class="nx">Serialization</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>

<span class="kd">func</span> <span class="nf">MessageReceipt_Make</span><span class="p">(</span><span class="nx">output</span> <span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">gasUsed</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nx">MessageReceipt</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">MessageReceipt_I</span><span class="p">{</span>
		<span class="nx">ExitCode_</span><span class="p">:</span>    <span class="nx">output</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(),</span>
		<span class="nx">ReturnValue_</span><span class="p">:</span> <span class="nx">output</span><span class="p">.</span><span class="nf">ReturnValue</span><span class="p">(),</span>
		<span class="nx">GasUsed_</span><span class="p">:</span>     <span class="nx">gasUsed</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">UnsignedMessage_Make</span><span class="p">(</span>
	<span class="nx">from</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">to</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
	<span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">,</span>
	<span class="nx">callSeqNum</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">,</span>
	<span class="nx">value</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="nx">gasPrice</span> <span class="nx">GasPrice</span><span class="p">,</span>
	<span class="nx">gasLimit</span> <span class="nx">GasAmount</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">UnsignedMessage</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">UnsignedMessage_I</span><span class="p">{</span>
		<span class="nx">From_</span><span class="p">:</span>       <span class="nx">from</span><span class="p">,</span>
		<span class="nx">To_</span><span class="p">:</span>         <span class="nx">to</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span>     <span class="nx">method</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span>     <span class="nx">params</span><span class="p">,</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="nx">callSeqNum</span><span class="p">,</span>
		<span class="nx">Value_</span><span class="p">:</span>      <span class="nx">value</span><span class="p">,</span>
		<span class="nx">GasPrice_</span><span class="p">:</span>   <span class="nx">gasPrice</span><span class="p">,</span>
		<span class="nx">GasLimit_</span><span class="p">:</span>   <span class="nx">gasLimit</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SignedMessage_Make</span><span class="p">(</span><span class="nx">message</span> <span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">signature</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="nx">SignedMessage</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SignedMessage_I</span><span class="p">{</span>
		<span class="nx">Message_</span><span class="p">:</span>   <span class="nx">message</span><span class="p">,</span>
		<span class="nx">Signature_</span><span class="p">:</span> <span class="nx">signature</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Sign</span><span class="p">(</span><span class="nx">message</span> <span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">keyPair</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">SigKeyPair</span><span class="p">)</span> <span class="p">(</span><span class="nx">SignedMessage</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sig</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">keyPair</span><span class="p">,</span> <span class="nx">util</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nf">Serialize_UnsignedMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">)))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">SignedMessage_Make</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">sig</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SignatureVerificationError</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">message</span> <span class="nx">SignedMessage</span><span class="p">,</span> <span class="nx">publicKey</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span><span class="p">)</span> <span class="p">(</span><span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nf">Serialize_UnsignedMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">Message</span><span class="p">()))</span>
	<span class="nx">sigValid</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">publicKey</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Signature</span><span class="p">(),</span> <span class="nx">m</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">sigValid</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">SignatureVerificationError</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Message</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nf">Subtract</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nf">LessThan</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GasAmount_Zero</span><span class="p">()</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">InvocInput_Make</span><span class="p">(</span><span class="nx">to</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">InvocInput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">InvocInput_I</span><span class="p">{</span>
		<span class="nx">To_</span><span class="p">:</span>     <span class="nx">to</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span> <span class="nx">method</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span> <span class="nx">params</span><span class="p">,</span>
		<span class="nx">Value_</span><span class="p">:</span>  <span class="nx">value</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">returnValue</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">InvocOutput_I</span><span class="p">{</span>
		<span class="nx">ExitCode_</span><span class="p">:</span>    <span class="nx">exitCode</span><span class="p">,</span>
		<span class="nx">ReturnValue_</span><span class="p">:</span> <span class="nx">returnValue</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MessageReceipt_MakeSystemError</span><span class="p">(</span><span class="nx">errCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">SystemErrorCode</span><span class="p">,</span> <span class="nx">gasUsed</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nx">MessageReceipt</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">MessageReceipt_Make</span><span class="p">(</span>
		<span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">errCode</span><span class="p">),</span> <span class="kc">nil</span><span class="p">),</span>
		<span class="nx">gasUsed</span><span class="p">,</span>
	<span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__runtime">

<h3 class="section-header">
  VM Runtime Environment (Inside the VM)
</h3>

<div class="section-content">






































<h4 id="vm-runtime-interface"><code>vm/runtime</code> interface</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="c1">// Runtime is the VM&#39;s internal runtime object.
</span><span class="c1">// this is everything that is accessible to actors, beyond parameters.
</span><span class="c1">// FKA as vm.Context
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Runtime</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">CurrEpoch</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>

    <span class="c1">// Randomness returns a (pseudo)random stream (indexed by offset) for the current epoch.
</span><span class="c1"></span>    <span class="nf">Randomness</span><span class="p">(</span><span class="nx">e</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">offset</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="c1">// Note: This is the _immediate_ caller.
</span><span class="c1"></span>    <span class="c1">// Not necessarily the actor in the From field of the initial on-chain Message.
</span><span class="c1"></span>    <span class="nf">ImmediateCaller</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">caller</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
    <span class="nf">ValidateImmediateCallerAcceptAny</span><span class="p">()</span>
    <span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nx">CallerPattern</span><span class="p">)</span>

    <span class="nf">CurrMethodNum</span><span class="p">()</span>             <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span>

    <span class="c1">// Note: This is the actor in the From field of the initial on-chain message.
</span><span class="c1"></span>    <span class="c1">// Not necessarily the immediate caller.
</span><span class="c1"></span>    <span class="nf">ToplevelSender</span><span class="p">()</span>            <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// The actor who mined the block in which the initial on-chain message appears.
</span><span class="c1"></span>    <span class="nf">ToplevelBlockWinner</span><span class="p">()</span>       <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// Top-level call sequence number of the &#34;From&#34; actor in the initial on-chain message.
</span><span class="c1"></span>    <span class="nf">ToplevelSenderCallSeqNum</span><span class="p">()</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>

    <span class="c1">// Sequence number representing the total number of calls (to any actor, any method)
</span><span class="c1"></span>    <span class="c1">// during the current top-level message execution.
</span><span class="c1"></span>    <span class="c1">// Note: resets with every top-level message, and therefore not necessarily monotonic.
</span><span class="c1"></span>    <span class="nf">InternalCallSeqNum</span><span class="p">()</span>        <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>

    <span class="nf">AcquireState</span><span class="p">()</span>              <span class="nx">ActorStateHandle</span>

    <span class="nf">SuccessReturn</span><span class="p">()</span>             <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
    <span class="nf">ValueReturn</span><span class="p">(</span><span class="nx">Bytes</span><span class="p">)</span>          <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
    <span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>

    <span class="c1">// Throw an error indicating a failure condition has occurred, from which the given actor
</span><span class="c1"></span>    <span class="c1">// code is unable to recover. If an error is thrown in actor code, and not handled by any
</span><span class="c1"></span>    <span class="c1">// of its callers, then the VM will not apply the state transition.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Note: this should only be used for exceptional conditions, such as inconsistent state
</span><span class="c1"></span>    <span class="c1">// values or precondition violations. Operations that may fail during normal execution
</span><span class="c1"></span>    <span class="c1">// should use error return values, not call this method.
</span><span class="c1"></span>    <span class="nf">Abort</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>

    <span class="c1">// Check that the given condition is true (and call Abort if not).
</span><span class="c1"></span>    <span class="nf">Assert</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>

    <span class="nf">CurrentBalance</span><span class="p">()</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nf">ValueReceived</span><span class="p">()</span>   <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

    <span class="nf">VerifySignature</span><span class="p">(</span>
        <span class="nx">signerActor</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">sig</span>          <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
        <span class="nx">m</span>            <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Message</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// Run a (pure function) computation, consuming the gas cost associated with that function.
</span><span class="c1"></span>    <span class="c1">// This mechanism is intended to capture the notion of an ABI between the VM and native
</span><span class="c1"></span>    <span class="c1">// functions, and should be used for any function whose computation is expensive.
</span><span class="c1"></span>    <span class="nf">Compute</span><span class="p">(</span><span class="nx">ComputeFunctionID</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[</span><span class="nx">Any</span><span class="p">])</span> <span class="nx">Any</span>

    <span class="c1">// Send allows the current execution context to invoke methods on other actors in the system.
</span><span class="c1"></span>    <span class="nf">SendPropagatingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
    <span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>

    <span class="c1">// Create an actor in the state tree. May only be called by InitActor.
</span><span class="c1"></span>    <span class="nf">CreateActor</span><span class="p">(</span>
        <span class="nx">stateCID</span>           <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSystemStateCID</span>
        <span class="nx">a</span>                  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">initBalance</span>        <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
        <span class="nx">constructorParams</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span>
    <span class="p">)</span>

    <span class="nf">IpldGet</span><span class="p">(</span><span class="nx">c</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">Bytes</span><span class="p">,</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">IpldPut</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">Object</span><span class="p">)</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="vm-runtime-implementation"><code>vm/runtime</code> implementation</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">type</span> <span class="nx">ActorSubstateCID</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span>
<span class="kd">type</span> <span class="nx">InvocInput</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocInput</span>
<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">ExitCode</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span>
<span class="kd">type</span> <span class="nx">RuntimeError</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">RuntimeError</span>

<span class="kd">var</span> <span class="nx">EnsureErrorCode</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">EnsureErrorCode</span>
<span class="kd">var</span> <span class="nx">SystemError</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">SystemError</span>
<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">func</span> <span class="nf">ActorSubstateCID_Equals</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ActorCode is the interface that all actor code types should satisfy.
</span><span class="c1">// It is merely a method dispatch interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorCode</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ActorStateHandle</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_initValue</span> <span class="o">*</span><span class="nx">ActorSubstateCID</span>
	<span class="nx">_rt</span>        <span class="o">*</span><span class="nx">VMContext</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">ActorStateHandle</span><span class="p">)</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">_rt</span><span class="p">.</span><span class="nf">_updateReleaseActorSubstate</span><span class="p">(</span><span class="nx">newStateCID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">ActorStateHandle</span><span class="p">)</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">checkStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">_rt</span><span class="p">.</span><span class="nf">_releaseActorSubstate</span><span class="p">(</span><span class="nx">checkStateCID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">ActorStateHandle</span><span class="p">)</span> <span class="nf">Take</span><span class="p">()</span> <span class="nx">ActorSubstateCID</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">_initValue</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">_rt</span><span class="p">.</span><span class="nf">_apiError</span><span class="p">(</span><span class="s">&#34;Must call Take() only once on actor substate object&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">_initValue</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">_initValue</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="c1">// Concrete instantiation of the Runtime interface. This should be instantiated by the
</span><span class="c1">// interpreter once per actor method invocation, and responds to that method&#39;s Runtime
</span><span class="c1">// API calls.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VMContext</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_globalStateInit</span>        <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
	<span class="nx">_globalStatePending</span>     <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
	<span class="nx">_running</span>                <span class="kt">bool</span>
	<span class="nx">_actorAddress</span>           <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">_actorStateAcquired</span>     <span class="kt">bool</span>
	<span class="nx">_actorStateAcquiredInit</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span>

	<span class="nx">_immediateCaller</span>          <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">_toplevelSender</span>           <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">_toplevelBlockWinner</span>      <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">_toplevelSenderCallSeqNum</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>
	<span class="nx">_internalCallSeqNum</span>       <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>
	<span class="nx">_valueReceived</span>            <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">_gasRemaining</span>             <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span>
	<span class="nx">_numValidateCalls</span>         <span class="kt">int</span>
	<span class="nx">_output</span>                   <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">VMContext_Make</span><span class="p">(</span>
	<span class="nx">toplevelSender</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">toplevelBlockWinner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">toplevelSenderCallSeqNum</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">,</span>
	<span class="nx">internalCallSeqNum</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">,</span>
	<span class="nx">globalState</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span>
	<span class="nx">actorAddress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">valueReceived</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="nx">gasRemaining</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="o">*</span><span class="nx">VMContext</span> <span class="p">{</span>

	<span class="nx">actorStateInit</span> <span class="o">:=</span> <span class="nx">globalState</span><span class="p">.</span><span class="nf">GetActorState</span><span class="p">(</span><span class="nx">actorAddress</span><span class="p">)</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">VMContext</span><span class="p">{</span>
		<span class="nx">_globalStateInit</span><span class="p">:</span>        <span class="nx">globalState</span><span class="p">,</span>
		<span class="nx">_globalStatePending</span><span class="p">:</span>     <span class="nx">globalState</span><span class="p">,</span>
		<span class="nx">_running</span><span class="p">:</span>                <span class="kc">false</span><span class="p">,</span>
		<span class="nx">_actorAddress</span><span class="p">:</span>           <span class="nx">actorAddress</span><span class="p">,</span>
		<span class="nx">_actorStateAcquired</span><span class="p">:</span>     <span class="kc">false</span><span class="p">,</span>
		<span class="nx">_actorStateAcquiredInit</span><span class="p">:</span> <span class="nx">actorStateInit</span><span class="p">.</span><span class="nf">State</span><span class="p">(),</span>

		<span class="nx">_toplevelSender</span><span class="p">:</span>           <span class="nx">toplevelSender</span><span class="p">,</span>
		<span class="nx">_toplevelBlockWinner</span><span class="p">:</span>      <span class="nx">toplevelBlockWinner</span><span class="p">,</span>
		<span class="nx">_toplevelSenderCallSeqNum</span><span class="p">:</span> <span class="nx">toplevelSenderCallSeqNum</span><span class="p">,</span>
		<span class="nx">_internalCallSeqNum</span><span class="p">:</span>       <span class="nx">internalCallSeqNum</span><span class="p">,</span>
		<span class="nx">_valueReceived</span><span class="p">:</span>            <span class="nx">valueReceived</span><span class="p">,</span>
		<span class="nx">_gasRemaining</span><span class="p">:</span>             <span class="nx">gasRemaining</span><span class="p">,</span>
		<span class="nx">_numValidateCalls</span><span class="p">:</span>         <span class="mi">0</span><span class="p">,</span>
		<span class="nx">_output</span><span class="p">:</span>                   <span class="kc">nil</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CreateActor</span><span class="p">(</span>
	<span class="nx">stateCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSystemStateCID</span><span class="p">,</span>
	<span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">initBalance</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="nx">constructorParams</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">Runtime_CreateActor_FunRet</span> <span class="p">{</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nx">InitActorAddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Only InitActor may call rt.CreateActor&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">_updateActorSystemStateInternal</span><span class="p">(</span><span class="nx">address</span><span class="p">,</span> <span class="nx">stateCID</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendPropagatingErrors</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">InvocInput_I</span><span class="p">{</span>
		<span class="nx">To_</span><span class="p">:</span>     <span class="nx">address</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodConstructor</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span> <span class="nx">constructorParams</span><span class="p">,</span>
		<span class="nx">Value_</span><span class="p">:</span>  <span class="nx">initBalance</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Runtime_CreateActor_FunRet_I</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_updateActorSystemStateInternal</span><span class="p">(</span><span class="nx">actorAddress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">newStateCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSystemStateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newGlobalStatePending</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithActorSystemState</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">newStateCID</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Error in runtime implementation: failed to update actor system state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">newGlobalStatePending</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_updateActorSubstateInternal</span><span class="p">(</span><span class="nx">actorAddress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">newStateCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newGlobalStatePending</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithActorSubstate</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">newStateCID</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Error in runtime implementation: failed to update actor substate&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">newGlobalStatePending</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_updateReleaseActorSubstate</span><span class="p">(</span><span class="nx">newStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateAcquired</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_updateActorSubstateInternal</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">newStateCID</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_releaseActorSubstate</span><span class="p">(</span><span class="nx">checkStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateAcquired</span><span class="p">()</span>

	<span class="nx">prevState</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActorState</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">)</span>
	<span class="nx">prevStateCID</span> <span class="o">:=</span> <span class="nx">prevState</span><span class="p">.</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">ActorSubstateCID_Equals</span><span class="p">(</span><span class="nx">prevStateCID</span><span class="p">,</span> <span class="nx">checkStateCID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;State CID differs upon release call&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Assert</span><span class="p">(</span><span class="nx">cond</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">Runtime_Assert_FunRet</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">cond</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Runtime check failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Runtime_Assert_FunRet_I</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkActorStateAcquired</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Error in runtime implementation: actor interface invoked without running actor&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Actor state not acquired&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Abort</span><span class="p">(</span><span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Runtime_Abort_FunRet</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">MethodAbort</span><span class="p">),</span> <span class="nx">errMsg</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Runtime_Abort_FunRet_I</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ImmediateCaller</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_immediateCaller</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ToplevelSender</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_toplevelSender</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ToplevelBlockWinner</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_toplevelBlockWinner</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">InternalCallSeqNum</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ToplevelSenderCallSeqNum</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_toplevelSenderCallSeqNum</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span>
	<span class="nx">callerExpectedPattern</span> <span class="nx">CallerPattern</span><span class="p">)</span> <span class="nx">Runtime_ValidateImmediateCallerMatches_FunRet</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkNumValidateCalls</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">caller</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">callerExpectedPattern</span><span class="p">.</span><span class="nf">Matches</span><span class="p">(</span><span class="nx">caller</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Method invoked by incorrect caller&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_numValidateCalls</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Runtime_ValidateImmediateCallerMatches_FunRet_I</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CallerPattern</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Matches</span> <span class="kd">func</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CallerPattern_MakeSingleton</span><span class="p">(</span><span class="nx">x</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">CallerPattern</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">CallerPattern</span><span class="p">{</span>
		<span class="nx">Matches</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">y</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">y</span> <span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CallerPattern_MakeAcceptAny</span><span class="p">()</span> <span class="nx">CallerPattern</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">CallerPattern</span><span class="p">{</span>
		<span class="nx">Matches</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span> <span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">callerExpected</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">Runtime_ValidateImmediateCallerIs_FunRet</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nf">CallerPattern_MakeSingleton</span><span class="p">(</span><span class="nx">callerExpected</span><span class="p">))</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Runtime_ValidateImmediateCallerIs_FunRet_I</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerAcceptAny</span><span class="p">()</span> <span class="nx">Runtime_ValidateImmediateCallerAcceptAny_FunRet</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nf">CallerPattern_MakeAcceptAny</span><span class="p">())</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Runtime_ValidateImmediateCallerAcceptAny_FunRet_I</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkNumValidateCalls</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_numValidateCalls</span> <span class="o">!=</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Method must validate caller identity exactly once&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkRunning</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Internal runtime error: actor API called with no actor code running&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SuccessReturn</span><span class="p">()</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">OK</span><span class="p">(),</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValueReturn</span><span class="p">(</span><span class="nx">value</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">OK</span><span class="p">(),</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">exitCode</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nf">EnsureErrorCode</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">RuntimeError_Make</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">,</span> <span class="nx">errMsg</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_apiError</span><span class="p">(</span><span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">RuntimeAPIError</span><span class="p">),</span> <span class="nx">errMsg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkStateLock</span><span class="p">(</span><span class="nx">expected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="o">!=</span> <span class="nx">expected</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_apiError</span><span class="p">(</span><span class="s">&#34;State update and message send blocks must be disjoint&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkGasRemaining</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">.</span><span class="nf">LessThan</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">())</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">OutOfGas</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_deductGasRemaining</span><span class="p">(</span><span class="nx">x</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: check x &gt;= 0
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkGasRemaining</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_gasRemaining</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkGasRemaining</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_refundGasRemaining</span><span class="p">(</span><span class="nx">x</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: check x &gt;= 0
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkGasRemaining</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_gasRemaining</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkGasRemaining</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_transferFunds</span><span class="p">(</span><span class="nx">from</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkStateLock</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

	<span class="nx">newGlobalStatePending</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithFundsTransfer</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">newGlobalStatePending</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ErrorHandlingSpec</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PropagateErrors</span> <span class="nx">ErrorHandlingSpec</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">CatchErrors</span>
<span class="p">)</span>

<span class="c1">// TODO: This function should be private (not intended to be exposed to actors).
</span><span class="c1">// (merging runtime and interpreter packages should solve this)
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendToplevelFromInterpreter</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_sendInternal</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">CatchErrors</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">return</span> <span class="nx">ret</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_catchRuntimeErrors</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span><span class="p">)</span> <span class="p">(</span><span class="nx">output</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="nx">r</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">*</span><span class="nx">RuntimeError</span><span class="p">:</span>
				<span class="nx">output</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nf">EnsureErrorCode</span><span class="p">(</span><span class="nx">r</span><span class="p">.(</span><span class="o">*</span><span class="nx">RuntimeError</span><span class="p">).</span><span class="nx">ExitCode</span><span class="p">),</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nb">panic</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">output</span> <span class="p">=</span> <span class="nf">f</span><span class="p">()</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_invokeMethodInternal</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">,</span>
	<span class="nx">actorCode</span> <span class="nx">ActorCode</span><span class="p">,</span>
	<span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
	<span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">ret</span> <span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">gasUsed</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">internalCallSeqNumFinal</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodSend</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">OK</span><span class="p">(),</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="nx">gasUsed</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">()</span> <span class="c1">// TODO: verify
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">ret</span> <span class="p">=</span> <span class="nf">_catchRuntimeErrors</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
		<span class="nx">methodOutput</span> <span class="o">:=</span> <span class="nx">actorCode</span><span class="p">.</span><span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">method</span><span class="p">,</span> <span class="nx">params</span><span class="p">)</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkStateLock</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkNumValidateCalls</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">methodOutput</span>
	<span class="p">})</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="c1">// TODO: Update gasUsed
</span><span class="c1"></span>	<span class="nf">TODO</span><span class="p">()</span>

	<span class="nx">internalCallSeqNumFinal</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rtOuter</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_sendInternal</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">,</span> <span class="nx">errSpec</span> <span class="nx">ErrorHandlingSpec</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span> <span class="p">{</span>
	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_checkStateLock</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>

	<span class="nx">toActor</span> <span class="o">:=</span> <span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActorState</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nf">To</span><span class="p">())</span>

	<span class="nx">toActorCode</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">loadActorCode</span><span class="p">(</span><span class="nx">toActor</span><span class="p">.</span><span class="nf">CodeID</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorCodeNotFound</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">toActorMethodGasBound</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: obtain from actor registry
</span><span class="c1"></span>	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_deductGasRemaining</span><span class="p">(</span><span class="nx">toActorMethodGasBound</span><span class="p">)</span>
	<span class="c1">// TODO: gasUsed may be larger than toActorMethodGasBound if toActor itself makes sub-calls.
</span><span class="c1"></span>	<span class="c1">// To prevent this, we would need to calculate the gas bounds recursively.
</span><span class="c1"></span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_transferFunds</span><span class="p">(</span><span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nf">To</span><span class="p">(),</span> <span class="nx">input</span><span class="p">.</span><span class="nf">Value</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InsufficientFunds</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="nx">rtInner</span> <span class="o">:=</span> <span class="nf">VMContext_Make</span><span class="p">(</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_toplevelSender</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_toplevelBlockWinner</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_toplevelSenderCallSeqNum</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">,</span>
		<span class="nx">input</span><span class="p">.</span><span class="nf">To</span><span class="p">(),</span>
		<span class="nx">input</span><span class="p">.</span><span class="nf">Value</span><span class="p">(),</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="nx">invocOutput</span><span class="p">,</span> <span class="nx">gasUsed</span><span class="p">,</span> <span class="nx">internalCallSeqNumFinal</span> <span class="o">:=</span> <span class="nf">_invokeMethodInternal</span><span class="p">(</span>
		<span class="nx">rtInner</span><span class="p">,</span>
		<span class="nx">toActorCode</span><span class="p">,</span>
		<span class="nx">input</span><span class="p">.</span><span class="nf">Method</span><span class="p">(),</span>
		<span class="nx">input</span><span class="p">.</span><span class="nf">Params</span><span class="p">(),</span>
	<span class="p">)</span>

	<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span> <span class="p">=</span> <span class="nx">internalCallSeqNumFinal</span>

	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_refundGasRemaining</span><span class="p">(</span><span class="nx">toActorMethodGasBound</span><span class="p">)</span>
	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_deductGasRemaining</span><span class="p">(</span><span class="nx">gasUsed</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">errSpec</span> <span class="o">==</span> <span class="nx">PropagateErrors</span> <span class="o">&amp;&amp;</span> <span class="nx">invocOutput</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">().</span><span class="nf">IsError</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">MethodSubcallError</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">invocOutput</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">().</span><span class="nf">AllowsStateUpdate</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">rtInner</span><span class="p">.</span><span class="nx">_globalStatePending</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">MessageReceipt_Make</span><span class="p">(</span><span class="nx">invocOutput</span><span class="p">,</span> <span class="nx">gasUsed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rtOuter</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_sendInternalOutputOnly</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">,</span> <span class="nx">errSpec</span> <span class="nx">ErrorHandlingSpec</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_sendInternal</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">errSpec</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput_I</span><span class="p">{</span>
		<span class="nx">ExitCode_</span><span class="p">:</span>    <span class="nx">ret</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(),</span>
		<span class="nx">ReturnValue_</span><span class="p">:</span> <span class="nx">ret</span><span class="p">.</span><span class="nf">ReturnValue</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendPropagatingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_sendInternalOutputOnly</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">PropagateErrors</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_sendInternalOutputOnly</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">CatchErrors</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CurrentBalance</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValueReceived</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_valueReceived</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Randomness</span><span class="p">(</span><span class="nx">e</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">offset</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="c1">// TODO: validate CurrEpoch() - K &lt;= e &lt;= CurrEpoch()?
</span><span class="c1"></span>	<span class="c1">// TODO: finish
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">IpldPut</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">Object</span><span class="p">)</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">IpldGet</span><span class="p">(</span><span class="nx">c</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="nx">Runtime_IpldGet_FunRet</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CurrEpoch</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AcquireState</span><span class="p">()</span> <span class="nx">ActorStateHandle</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CurrMethodNum</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">VerifySignature</span><span class="p">(</span><span class="nx">signerActor</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">GetActorState</span><span class="p">(</span><span class="nx">signerActor</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">st</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;VerifySignature: signer actor not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">pk</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">GetSignaturePublicKey</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">pk</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;VerifySignature: signer actor has no public key&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">Compute</span><span class="p">(</span><span class="nx">ComputeFunctionID_VerifySignature</span><span class="p">,</span> <span class="p">[]</span><span class="nx">Any</span><span class="p">{</span><span class="nx">pk</span><span class="p">,</span> <span class="nx">sig</span><span class="p">,</span> <span class="nx">m</span><span class="p">})</span>
	<span class="k">return</span> <span class="nx">ret</span><span class="p">.(</span><span class="kt">bool</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Compute</span><span class="p">(</span><span class="nx">f</span> <span class="nx">ComputeFunctionID</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">Any</span><span class="p">)</span> <span class="nx">Any</span> <span class="p">{</span>
	<span class="nx">def</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">_computeFunctionDefs</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Function definition in rt.Compute() not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gasCost</span> <span class="o">:=</span> <span class="nx">def</span><span class="p">.</span><span class="nf">GasCostFn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_deductGasRemaining</span><span class="p">(</span><span class="nx">gasCost</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">def</span><span class="p">.</span><span class="nf">Body</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="code-loading">Code Loading</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="kd">func</span> <span class="nf">loadActorCode</span><span class="p">(</span><span class="nx">codeID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">)</span> <span class="p">(</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="c1">// TODO: resolve circular dependency
</span><span class="c1"></span>
	<span class="c1">// // load the code from StateTree.
</span><span class="c1"></span>	<span class="c1">// // TODO: this is going to be enabled in the future.
</span><span class="c1"></span>	<span class="c1">// // code, err := loadCodeFromStateTree(input.InTree, codeCID)
</span><span class="c1"></span>	<span class="c1">// return staticActorCodeRegistry.LoadActor(codeCID)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_vm__runtime__exitcode">

<h4 class="section-header">
  VM Exit Code Constants
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ExitCode</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nf">IsSuccess</span><span class="p">()</span>          <span class="kt">bool</span>
    <span class="nf">IsError</span><span class="p">()</span>            <span class="kt">bool</span>
    <span class="nf">AllowsStateUpdate</span><span class="p">()</span>  <span class="kt">bool</span>

    <span class="nx">Success</span>              <span class="kd">struct</span> <span class="p">{}</span>
    <span class="nx">SystemError</span>          <span class="nx">SystemErrorCode</span>
    <span class="nx">UserDefinedError</span>     <span class="nx">UVarint</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">exitcode</span>

<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">SystemErrorCode</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// TODO: remove once canonical error codes are finalized
</span><span class="c1"></span>	<span class="nx">SystemErrorCode_Placeholder</span> <span class="p">=</span> <span class="nf">SystemErrorCode</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span>
<span class="p">)</span>

<span class="c1">// TODO: assign all of these.
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// ActorNotFound represents a failure to find an actor.
</span><span class="c1"></span>	<span class="nx">ActorNotFound</span> <span class="p">=</span> <span class="nx">SystemErrorCode_Placeholder</span> <span class="o">+</span> <span class="kc">iota</span>

	<span class="c1">// ActorCodeNotFound represents a failure to find the code for a
</span><span class="c1"></span>	<span class="c1">// particular actor in the VM registry.
</span><span class="c1"></span>	<span class="nx">ActorCodeNotFound</span>

	<span class="c1">// InvalidMethod represents a failure to find a method in
</span><span class="c1"></span>	<span class="c1">// an actor
</span><span class="c1"></span>	<span class="nx">InvalidMethod</span>

	<span class="c1">// InvalidArguments indicates that a method was called with the incorrect
</span><span class="c1"></span>	<span class="c1">// number of arguments, or that its arguments did not satisfy its
</span><span class="c1"></span>	<span class="c1">// preconditions
</span><span class="c1"></span>	<span class="nx">InvalidArguments</span>

	<span class="c1">// InsufficientFunds represents a failure to apply a message, as
</span><span class="c1"></span>	<span class="c1">// it did not carry sufficient funds for its application.
</span><span class="c1"></span>	<span class="nx">InsufficientFunds</span>

	<span class="c1">// InvalidCallSeqNum represents a message invocation out of sequence.
</span><span class="c1"></span>	<span class="c1">// This happens when message.CallSeqNum is not exactly actor.CallSeqNum + 1
</span><span class="c1"></span>	<span class="nx">InvalidCallSeqNum</span>

	<span class="c1">// OutOfGasError is returned when the execution of an actor method
</span><span class="c1"></span>	<span class="c1">// (including its subcalls) uses more gas than initially allocated.
</span><span class="c1"></span>	<span class="nx">OutOfGas</span>

	<span class="c1">// RuntimeAPIError is returned when an actor method invocation makes a call
</span><span class="c1"></span>	<span class="c1">// to the runtime that does not satisfy its preconditions.
</span><span class="c1"></span>	<span class="nx">RuntimeAPIError</span>

	<span class="c1">// MethodPanic is returned when an actor method invocation calls rt.Abort.
</span><span class="c1"></span>	<span class="nx">MethodAbort</span>

	<span class="c1">// MethodSubcallError is returned when an actor method&#39;s Send call has
</span><span class="c1"></span>	<span class="c1">// returned with a failure error code (and the Send call did not specify
</span><span class="c1"></span>	<span class="c1">// to ignore errors).
</span><span class="c1"></span>	<span class="nx">MethodSubcallError</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">InvalidSectorPacking</span> <span class="p">=</span> <span class="nf">UserDefinedError</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">OK</span><span class="p">()</span> <span class="nx">ExitCode</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">ExitCode_Make_Success</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ExitCode_Success_I</span><span class="p">{})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SystemError</span><span class="p">(</span><span class="nx">x</span> <span class="nx">SystemErrorCode</span><span class="p">)</span> <span class="nx">ExitCode</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">ExitCode_Make_SystemError</span><span class="p">(</span><span class="nf">ExitCode_SystemError</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">ExitCode_I</span><span class="p">)</span> <span class="nf">IsSuccess</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="o">==</span> <span class="nx">ExitCode_Case_Success</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">ExitCode_I</span><span class="p">)</span> <span class="nf">IsError</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">!</span><span class="nx">x</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">ExitCode_I</span><span class="p">)</span> <span class="nf">AllowsStateUpdate</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// TODO: Confirm whether this is the desired behavior
</span><span class="c1"></span>
	<span class="c1">// return x.IsSuccess() || x.Which() == ExitCode_Case_UserDefinedError
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">EnsureErrorCode</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="nx">ExitCode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">x</span><span class="p">.</span><span class="nf">IsError</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Throwing an error with a non-error exit code is itself an error
</span><span class="c1"></span>		<span class="nx">x</span> <span class="p">=</span> <span class="nf">SystemError</span><span class="p">(</span><span class="nx">RuntimeAPIError</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RuntimeError</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ExitCode</span> <span class="nx">ExitCode</span>
	<span class="nx">ErrMsg</span>   <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">RuntimeError</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Runtime error: %v&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ErrMsg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="o">+=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34; (\&#34;%v\&#34;)&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ErrMsg</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RuntimeError_Make</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">RuntimeError</span> <span class="p">{</span>
	<span class="nx">exitCode</span> <span class="p">=</span> <span class="nf">EnsureErrorCode</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RuntimeError</span><span class="p">{</span>
		<span class="nx">ExitCode</span><span class="p">:</span> <span class="nx">exitCode</span><span class="p">,</span>
		<span class="nx">ErrMsg</span><span class="p">:</span>   <span class="nx">errMsg</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">UserDefinedError</span><span class="p">(</span><span class="nx">e</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">)</span> <span class="nx">ExitCode</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">ExitCode_Make_UserDefinedError</span><span class="p">(</span><span class="nf">ExitCode_UserDefinedError</span><span class="p">(</span><span class="nx">e</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__runtime__gascost">

<h4 class="section-header">
  VM Gas Cost Constants
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="c1">// TODO: assign all of these.
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// SimpleValueSend is the amount of gas charged for sending value from one
</span><span class="c1"></span>	<span class="c1">// contract to another, without executing any other code.
</span><span class="c1"></span>	<span class="nx">SimpleValueSend</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// // ActorLookupFail is the amount of gas charged for a failure to lookup
</span><span class="c1"></span>	<span class="c1">// // an actor
</span><span class="c1"></span>	<span class="c1">// ActorLookupFail = msg.GasAmount(1)
</span><span class="c1"></span>
	<span class="c1">// CodeLookupFail is the amount of gas charged for a failure to lookup
</span><span class="c1"></span>	<span class="c1">// code in the VM&#39;s code registry.
</span><span class="c1"></span>	<span class="nx">CodeLookupFail</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// ApplyMessageFail represents the gas cost for failures to apply message.
</span><span class="c1"></span>	<span class="c1">// These failures are basic failures encountered at first application.
</span><span class="c1"></span>	<span class="nx">ApplyMessageFail</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// TODO: determine these costs
</span><span class="c1"></span>	<span class="nx">PublicKeyCryptoOp</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__sysactors">

<h3 class="section-header">
  System Actors
</h3>

<div class="section-content">




































<ul>
<li>There are two system actors required for VM processing:

<ul>
<li><a href="#CronActor">CronActor</a> - runs critical functions at every epoch</li>
<li><a href="#InitActor">InitActor</a> - initializes new actors</li>
</ul></li>
<li>There is one more VM level actor:

<ul>
<li><a href="#AccountActor">AccountActor</a> - for user accounts.</li>
</ul></li>
</ul>


</div>


  
    








<div id="systems__filecoin_vm__sysactors__init_actor">

<h4 class="section-header">
  InitActor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> InitActor <a href="docs/systems/filecoin_vm/actors/init_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">type</span> <span class="nx">InitActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// responsible for create new actors
</span><span class="c1"></span>    <span class="nx">AddressMap</span>       <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">}</span>
    <span class="nx">IDMap</span>            <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">:</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">}</span>
    <span class="nx">NextID</span>           <span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span>

    <span class="nf">_assignNextID</span><span class="p">()</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InitActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Constructor</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span>
    <span class="nf">Exec</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">code</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nf">GetActorIDForAddress</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ActorExecAddressSeed</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">creator</span>             <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">toplevelCallSeqNum</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>
    <span class="nx">internalCallSeqNum</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">sysactors</span>

<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Method_InitActor_Exec</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodPlaceholder</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">Method_InitActor_GetActorIDForAddress</span>
<span class="p">)</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Boilerplate
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>
<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">Serialization</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">InitActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">ipld</span><span class="p">.</span><span class="nf">CID</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">ipld</span><span class="p">.</span><span class="nf">CID_Equals</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="nx">ipld</span><span class="p">.</span><span class="nf">EmptyCID</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrMethodNum</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodConstructor</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Actor state not initialized&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>
	<span class="nx">stateBytes</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">ipld</span><span class="p">.</span><span class="nf">CID</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">stateBytes</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime_IpldGet_FunRet_Case_Bytes</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;IPLD lookup error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">state</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">Deserialize_InitActorState</span><span class="p">(</span><span class="nf">Serialization</span><span class="p">(</span><span class="nx">stateBytes</span><span class="p">.</span><span class="nf">As_Bytes</span><span class="p">()))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;State deserialization error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">InitActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">InitActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">InitActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">InitActorState_I</span><span class="p">{</span>
		<span class="nx">AddressMap_</span><span class="p">:</span> <span class="kd">map</span><span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">{},</span> <span class="c1">// TODO: HAMT
</span><span class="c1"></span>		<span class="nx">IDMap_</span><span class="p">:</span>      <span class="kd">map</span><span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">{},</span> <span class="c1">// TODO: HAMT
</span><span class="c1"></span>		<span class="nx">NextID_</span><span class="p">:</span>     <span class="nx">addr</span><span class="p">.</span><span class="nf">ActorID</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReturn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">codeID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">,</span> <span class="nx">constructorParams</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">_codeIDSupportsExec</span><span class="p">(</span><span class="nx">codeID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;cannot exec an actor of this type&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">newAddr</span> <span class="o">:=</span> <span class="nf">_computeNewActorExecAddress</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">actorState</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState_I</span><span class="p">{</span>
		<span class="nx">CodeID_</span><span class="p">:</span>     <span class="nx">codeID</span><span class="p">,</span>
		<span class="nx">State_</span><span class="p">:</span>      <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">ipld</span><span class="p">.</span><span class="nf">EmptyCID</span><span class="p">()),</span>
		<span class="nx">Balance_</span><span class="p">:</span>    <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">actorStateCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSystemStateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">actorState</span><span class="p">))</span>

	<span class="c1">// Get the actor ID for this actor.
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">actorID</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_assignNextID</span><span class="p">()</span>

	<span class="c1">// Store the mappings of address to actor ID.
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">AddressMap</span><span class="p">()[</span><span class="nx">newAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actorID</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">IDMap</span><span class="p">()[</span><span class="nx">actorID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newAddr</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Note: the following call may fail (e.g., if the actor already exists, or the actor&#39;s own
</span><span class="c1"></span>	<span class="c1">// constructor call fails). In this case, an error should propagate up and cause Exec to fail
</span><span class="c1"></span>	<span class="c1">// as well.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">CreateActor</span><span class="p">(</span><span class="nx">actorStateCID</span><span class="p">,</span> <span class="nx">newAddr</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReceived</span><span class="p">(),</span> <span class="nx">constructorParams</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReturn</span><span class="p">(</span>
		<span class="nf">Bytes</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nf">Serialize_Address_Compact</span><span class="p">(</span><span class="nx">newAddr</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">InitActorState_I</span><span class="p">)</span> <span class="nf">_assignNextID</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ActorID</span> <span class="p">{</span>
	<span class="nx">actorID</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NextID_</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">NextID_</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">actorID</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_computeNewActorExecAddress</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="nx">seed</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">ActorExecAddressSeed_I</span><span class="p">{</span>
		<span class="nx">creator_</span><span class="p">:</span>            <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">(),</span>
		<span class="nx">toplevelCallSeqNum_</span><span class="p">:</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ToplevelSenderCallSeqNum</span><span class="p">(),</span>
		<span class="nx">internalCallSeqNum_</span><span class="p">:</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">InternalCallSeqNum</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">ActorExecHash</span><span class="p">(</span><span class="nf">Serialize_ActorExecAddressSeed</span><span class="p">(</span><span class="nx">seed</span><span class="p">))</span>

	<span class="c1">// Intended to be a unique identifier, stable across reorgs
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">Address_Make_ActorExec</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address_NetworkID_Testnet</span><span class="p">,</span> <span class="nx">hash</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">GetActorIDForAddress</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">actorID</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">AddressMap</span><span class="p">()[</span><span class="nx">address</span><span class="p">]</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReturn</span><span class="p">(</span><span class="nf">Bytes</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nf">Serialize_ActorID</span><span class="p">(</span><span class="nx">actorID</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_codeIDSupportsExec</span><span class="p">(</span><span class="nx">codeID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">codeID</span><span class="p">.</span><span class="nf">IsBuiltin</span><span class="p">()</span> <span class="o">||</span> <span class="nx">codeID</span><span class="p">.</span><span class="nf">IsSingleton</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">which</span> <span class="o">:=</span> <span class="nx">codeID</span><span class="p">.</span><span class="nf">As_Builtin</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">which</span> <span class="o">==</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_Account</span> <span class="p">{</span>
		<span class="c1">// Special case: account actors must be created implicitly by sending value;
</span><span class="c1"></span>		<span class="c1">// cannot be created via exec.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span>
		<span class="nx">which</span> <span class="o">==</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_PaymentChannel</span> <span class="o">||</span>
			<span class="nx">which</span> <span class="o">==</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_StorageMiner</span><span class="p">)</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">argError</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidArguments</span><span class="p">))</span>

	<span class="k">switch</span> <span class="nx">method</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodConstructor</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">argError</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// case actor.MethodCron:
</span><span class="c1"></span>	<span class="c1">//     disable. init has no cron action
</span><span class="c1"></span>
	<span class="k">case</span> <span class="nx">Method_InitActor_Exec</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">argError</span>
		<span class="p">}</span>
		<span class="nx">codeId</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">Deserialize_CodeID</span><span class="p">(</span><span class="nf">Serialization</span><span class="p">(</span><span class="nx">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">argError</span>
		<span class="p">}</span>
		<span class="nx">params</span> <span class="p">=</span> <span class="nx">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">codeId</span><span class="p">,</span> <span class="nx">params</span><span class="p">)</span>

	<span class="k">case</span> <span class="nx">Method_InitActor_GetActorIDForAddress</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">argError</span>
		<span class="p">}</span>
		<span class="nx">address</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">Deserialize_Address</span><span class="p">(</span><span class="nf">Serialization</span><span class="p">(</span><span class="nx">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">argError</span>
		<span class="p">}</span>
		<span class="nx">params</span> <span class="p">=</span> <span class="nx">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">argError</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">GetActorIDForAddress</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidMethod</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__sysactors__cron_actor">

<h4 class="section-header">
  CronActor
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">type</span> <span class="nx">CronActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Cron has no internal state
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">CronActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// actors is a set of actors to call during EpochTick.
</span><span class="c1"></span>    <span class="c1">// This can be done a bunch of ways. We do it this way here to make it easy to add
</span><span class="c1"></span>    <span class="c1">// a handler to Cron elsewhere in the spec code. How to do this is implementation
</span><span class="c1"></span>    <span class="c1">// specific.
</span><span class="c1"></span>    <span class="nx">Actors</span> <span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>

    <span class="c1">// EpochTick executes built-in periodic actions, run at every Epoch.
</span><span class="c1"></span>    <span class="c1">// EpochTick(r) is called after all other messages in the epoch have been applied.
</span><span class="c1"></span>    <span class="c1">// This can be seen as an implicit last message.
</span><span class="c1"></span>    <span class="nf">EpochTick</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">sysactors</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">CronActorCode_I</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="c1">// Nothing. intentionally left blank.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">CronActorCode_I</span><span class="p">)</span> <span class="nf">EpochTick</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="c1">// Hook period actions in here.
</span><span class="c1"></span>
	<span class="c1">// a.actors is basically a static registry for now, loaded
</span><span class="c1"></span>	<span class="c1">// in the interpreter static registry.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">a</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Actors</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">InvocInput_I</span><span class="p">{</span>
			<span class="nx">To_</span><span class="p">:</span>     <span class="nx">a</span><span class="p">,</span>
			<span class="nx">Method_</span><span class="p">:</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodCron</span><span class="p">,</span>
			<span class="nx">Params_</span><span class="p">:</span> <span class="p">[]</span><span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParam</span><span class="p">{},</span>
			<span class="nx">Value_</span><span class="p">:</span>  <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">CronActorCode_I</span><span class="p">)</span> <span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">method</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodConstructor</span><span class="p">:</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">case</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodCron</span><span class="p">:</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">EpochTick</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidMethod</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__sysactors__account_actor">

<h4 class="section-header">
  AccountActor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> AccountActor <a href="docs/systems/filecoin_vm/actors/account_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">type</span> <span class="nx">AccountActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">VerifySignature</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="nx">InvocOutput</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">AccountActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// normal keypair backed accounts
</span><span class="c1"></span>    <span class="nx">Address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">sysactors</span>

<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Boilerplate
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AccountActorCode_I</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">AccountActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">()</span>
	<span class="nx">stateBytes</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">ipld</span><span class="p">.</span><span class="nf">CID</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">stateBytes</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime_IpldGet_FunRet_Case_Bytes</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;IPLD lookup error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="nf">AccDeserializeState</span><span class="p">(</span><span class="nx">stateBytes</span><span class="p">.</span><span class="nf">As_Bytes</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">AccRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">AccountActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">AccUpdateRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">AccountActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">AccountActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">AccDeserializeState</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">AccountActorState</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AccountActorCode_I</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="c1">// Nothing. intentionally left blank.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AccountActorCode_I</span><span class="p">)</span> <span class="nf">VerifySignature</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AccountActorCode_I</span><span class="p">)</span> <span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">method</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodConstructor</span><span class="p">:</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">SystemError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidMethod</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__interpreter">

<h3 class="section-header">
  VM Interpreter - Message Invocation (Outside VM)
</h3>

<div class="section-content">






































<p>(You can see the <em>old</em> VM interpreter <a href="docs/systems/filecoin_vm/vm_interpreter_old">here</a> )</p>

<h4 id="vm-interpreter-interface"><code>vm/interpreter</code> interface</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">MessageRef</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Message</span>  <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span>
    <span class="nx">Miner</span>    <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">VMInterpreter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ApplyMessageBatch</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msgs</span> <span class="p">[</span><span class="nx">MessageRef</span><span class="p">])</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">]}</span>
    <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msg</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="vm-interpreter-implementation"><code>vm/interpreter</code> implementation</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">interpreter</span>

<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>
<span class="kn">import</span> <span class="nx">gascost</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/gascost&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">vmi</span> <span class="o">*</span><span class="nx">VMInterpreter_I</span><span class="p">)</span> <span class="nf">ApplyMessageBatch</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msgs</span> <span class="p">[]</span><span class="nx">MessageRef</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="p">[]</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">compTree</span> <span class="o">:=</span> <span class="nx">inTree</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">m</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgs</span> <span class="p">{</span>
		<span class="nx">oT</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nx">vmi</span><span class="p">.</span><span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Message</span><span class="p">(),</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Miner</span><span class="p">())</span>
		<span class="nx">compTree</span> <span class="p">=</span> <span class="nx">oT</span>        <span class="c1">// assign the current tree. (this call always succeeds)
</span><span class="c1"></span>		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="c1">// add message receipt
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">compTree</span><span class="p">,</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_applyError</span><span class="p">(</span><span class="nx">errCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">SystemErrorCode</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span> <span class="p">{</span>
	<span class="c1">// TODO: should this gasUsed value be zero?
</span><span class="c1"></span>	<span class="c1">// If nonzero, there is not guaranteed to be a nonzero gas balance from which to deduct it.
</span><span class="c1"></span>	<span class="nx">gasUsed</span> <span class="o">:=</span> <span class="nx">gascost</span><span class="p">.</span><span class="nx">ApplyMessageFail</span>
	<span class="nf">TODO</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">MessageReceipt_MakeSystemError</span><span class="p">(</span><span class="nx">errCode</span><span class="p">,</span> <span class="nx">gasUsed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span><span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">from</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span> <span class="p">{</span>
	<span class="c1">// TODO: assert amount nonnegative
</span><span class="c1"></span>	<span class="nx">retTree</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithFundsTransfer</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Interpreter error: insufficient funds (or transfer error) despite checks&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">retTree</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">vmi</span> <span class="o">*</span><span class="nx">VMInterpreter_I</span><span class="p">)</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">compTree</span> <span class="o">:=</span> <span class="nx">inTree</span>
	<span class="kd">var</span> <span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
	<span class="kd">var</span> <span class="nx">toActor</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>

	<span class="nx">fromActor</span> <span class="o">:=</span> <span class="nx">compTree</span><span class="p">.</span><span class="nf">GetActorState</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">fromActor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// TODO: This was originally exitcode.InvalidMethod; which is correct?
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="nf">_applyError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorNotFound</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// make sure fromActor has enough money to run the max invocation
</span><span class="c1"></span>	<span class="nx">maxGasCost</span> <span class="o">:=</span> <span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">(),</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">())</span>
	<span class="nx">totalCost</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">()</span> <span class="o">+</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nx">maxGasCost</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nf">Balance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">totalCost</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="nf">_applyError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InsufficientFunds</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// make sure this is the right message order for fromActor
</span><span class="c1"></span>	<span class="c1">// (this is protection against replay attacks, and useful sequencing)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="nf">_applyError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidCallSeqNum</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// WithActorForAddress may create new account actors
</span><span class="c1"></span>	<span class="nx">compTree</span><span class="p">,</span> <span class="nx">toActor</span> <span class="p">=</span> <span class="nx">compTree</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithActorForAddress</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">To</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">toActor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="nf">_applyError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorNotFound</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// deduct maximum expenditure gas funds first
</span><span class="c1"></span>	<span class="nx">compTree</span> <span class="p">=</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">(),</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">maxGasCost</span><span class="p">)</span>

	<span class="nx">rt</span> <span class="o">:=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">VMContext_Make</span><span class="p">(</span>
		<span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">(),</span>
		<span class="nx">minerAddr</span><span class="p">,</span> <span class="c1">// TODO: may not exist? (see below)
</span><span class="c1"></span>		<span class="nx">fromActor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span>
		<span class="nx">actor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">compTree</span><span class="p">,</span>
		<span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">(),</span>
		<span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">(),</span>
	<span class="p">)</span>

	<span class="nx">sendRet</span><span class="p">,</span> <span class="nx">sendRetStateTree</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SendToplevelFromInterpreter</span><span class="p">(</span>
		<span class="nx">msg</span><span class="p">.</span><span class="nf">InvocInput_Make</span><span class="p">(</span>
			<span class="nx">message</span><span class="p">.</span><span class="nf">To</span><span class="p">(),</span>
			<span class="nx">message</span><span class="p">.</span><span class="nf">Method</span><span class="p">(),</span>
			<span class="nx">message</span><span class="p">.</span><span class="nf">Params</span><span class="p">(),</span>
			<span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">(),</span>
		<span class="p">),</span>
	<span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">sendRet</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">().</span><span class="nf">AllowsStateUpdate</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// error -- revert all state changes -- ie drop updates. burn used gas.
</span><span class="c1"></span>		<span class="nx">outTree</span> <span class="p">=</span> <span class="nx">inTree</span>
		<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span>
			<span class="nx">outTree</span><span class="p">,</span>
			<span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">(),</span>
			<span class="nx">addr</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span>
			<span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">sendRet</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">(),</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">()),</span>
		<span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// success -- refund unused gas
</span><span class="c1"></span>		<span class="nx">outTree</span> <span class="p">=</span> <span class="nx">sendRetStateTree</span>
		<span class="nx">refundGas</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">()</span> <span class="o">-</span> <span class="nx">sendRet</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">()</span>
		<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: assert refundGas is nonnegative
</span><span class="c1"></span>		<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span>
			<span class="nx">outTree</span><span class="p">,</span>
			<span class="nx">addr</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span>
			<span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">(),</span>
			<span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">refundGas</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">()),</span>
		<span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">outTree</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">outTree</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithIncrementedCallSeqNum</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">To</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// TODO: if actor deletion is possible at some point, may need to allow this case
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Internal interpreter error: failed to increment call sequence number&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// reward miner gas fees
</span><span class="c1"></span>	<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span>
		<span class="nx">outTree</span><span class="p">,</span>
		<span class="nx">addr</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span>
		<span class="nx">minerAddr</span><span class="p">,</span> <span class="c1">// TODO: may not exist
</span><span class="c1"></span>		<span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">sendRet</span><span class="p">.</span><span class="nf">GasUsed</span><span class="p">(),</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">()),</span>
	<span class="p">)</span>

	<span class="k">return</span> <span class="nx">outTree</span><span class="p">,</span> <span class="nx">sendRet</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">gas</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">price</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">gas</span><span class="p">)</span> <span class="o">*</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">price</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="vm-interpreter-registry"><code>vm/interpreter/registry</code></h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">interpreter</span>

<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">market</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&#34;</span>
<span class="kn">import</span> <span class="nx">spc</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/storage_power_consensus&#34;</span>
<span class="kn">import</span> <span class="nx">sysactors</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/sysactors&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">ErrActorNotFound</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Actor Not Found&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">// CodeIDs for system actors
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">InitActorCodeID</span>           <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeID_Make_Builtin</span><span class="p">(</span><span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_Init</span><span class="p">)</span>
	<span class="nx">CronActorCodeID</span>           <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeID_Make_Builtin</span><span class="p">(</span><span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_Cron</span><span class="p">)</span>
	<span class="nx">AccountActorCodeID</span>        <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeID_Make_Builtin</span><span class="p">(</span><span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_Account</span><span class="p">)</span>
	<span class="nx">StoragePowerActorCodeID</span>   <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeID_Make_Builtin</span><span class="p">(</span><span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_StoragePower</span><span class="p">)</span>
	<span class="nx">StorageMinerActorCodeID</span>   <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeID_Make_Builtin</span><span class="p">(</span><span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_StorageMiner</span><span class="p">)</span>
	<span class="nx">StorageMarketActorCodeID</span>  <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeID_Make_Builtin</span><span class="p">(</span><span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_StorageMarket</span><span class="p">)</span>
	<span class="nx">PaymentChannelActorCodeID</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeID_Make_Builtin</span><span class="p">(</span><span class="nx">actor</span><span class="p">.</span><span class="nx">BuiltinActorID_PaymentChannel</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">staticActorCodeRegistry</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">actorCodeRegistry</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">actorCodeRegistry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="kd">map</span><span class="p">[</span><span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">]</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">actorCodeRegistry</span><span class="p">)</span> <span class="nf">_registerActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">,</span> <span class="nx">actor</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actor</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">actorCodeRegistry</span><span class="p">)</span> <span class="nf">_loadActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrActorNotFound</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">,</span> <span class="nx">actor</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">staticActorCodeRegistry</span><span class="p">.</span><span class="nf">_registerActor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">actor</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LoadActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeID</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">staticActorCodeRegistry</span><span class="p">.</span><span class="nf">_loadActor</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// init is called in Go during initialization of a program.
</span><span class="c1">// this is an idiomatic way to do this. Implementations should approach this
</span><span class="c1">// howevery they wish. The point is to initialize a static registry with
</span><span class="c1">// built in pure types that have the code for each actor. Once we have
</span><span class="c1">// a way to load code from the StateTree, use that instead.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">_registerBuiltinActors</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_registerBuiltinActors</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// TODO
</span><span class="c1"></span>
	<span class="nx">cron</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sysactors</span><span class="p">.</span><span class="nx">CronActorCode_I</span><span class="p">{}</span>

	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">InitActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sysactors</span><span class="p">.</span><span class="nx">InitActorCode_I</span><span class="p">{})</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">CronActorCodeID</span><span class="p">,</span> <span class="nx">cron</span><span class="p">)</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">AccountActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sysactors</span><span class="p">.</span><span class="nx">AccountActorCode_I</span><span class="p">{})</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">StoragePowerActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">spc</span><span class="p">.</span><span class="nx">StoragePowerActorCode_I</span><span class="p">{})</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">StorageMarketActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">market</span><span class="p">.</span><span class="nx">StorageMarketActorCode_I</span><span class="p">{})</span>

	<span class="c1">// wire in CRON actions.
</span><span class="c1"></span>	<span class="c1">// TODO: there&#39;s probably a better place to put this, but for now, do it here.
</span><span class="c1"></span>	<span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span><span class="p">,</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">)</span>
	<span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span><span class="p">,</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain">

<h2 class="section-header">
  <strong>Blockchain</strong>
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain">
        

        <strong>Blockchain</strong>

        
            <br /><br /><i class="menuIcon">üì¶</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct">
        
            <i class="statusIcon">‚úÖ</i>
        

        Blocks

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__block">
        

        Block

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__chain">
        

        Chain

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__chain_manager">
        

        Chain Manager

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__block_producer">
        

        Block Producer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool">
        
            <i class="statusIcon">üõë</i>
        

        Message Pool

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool__message_syncer">
        

        Message Syncer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool__message_storage">
        

        Message Storage

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__chainsync">
        
            <i class="statusIcon">üîÅ</i>
        

        ChainSync

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Power Consensus

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">
        

        Storage Power Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<p>The Filecoin Blockchain is a distributed virtual machine that achieves consensus, processes messages, accounts for storage, and maintains security in the Filecoin Protocol. It is the main interface linking various actors in the Filecoin system.</p>

<p>It includes:</p>

<ul>
<li>A <a href="./#systems__filecoin_blockchain__message_pool___index">Message Pool</a> subsystem that nodes use to track and propagate messages related to the storage market throughout a gossip network.</li>
<li>A <a href="./#systems__filecoin_vm">VM - Virtual Machine</a> subsystem used to interpret and execute messages in order to update system state.</li>
<li>A <a href="./#systems__filecoin_vm__state_tree___index"></a> subsystem which manages the creation and maintenance of state trees (the system state) deterministically generated by the vm from a given subchain.</li>
<li>A <a href="./#systems__filecoin_blockchain__chainsync___index"></a> susbystem that tracks and propagates validated message blocks, maintaining sets of candidate chains on which the miner may mine and running syntactic validation on incoming blocks.</li>
<li>A <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem which tracks <a href="./#systems__filecoin_mining__storage_mining">storage</a> state for a given chain and helps the blockchain system choose subchains to extend and blocks to include in them.</li>
</ul>

<p>And also:</p>

<ul>
<li>A {{ <sref chain_manager> }} &ndash; which maintains a given chain&rsquo;s state, providing facilities to other blockchain subsystems which will query state about the latest chain in order to run, and ensuring incoming blocks are semantically validated before inclusion into the chain.</li>
<li>A {{ <sref block_producer> }} &ndash; which is called in the event of a successful leader election in order to produce a new block that will extend the current heaviest chain before forwarding it to the syncer for propagation.</li>
</ul>

<p>At a high-level, the Filecoin blockchain grows through successive rounds of leader election in which a number of miners are elected to generate a block, whose inclusion in the chain will earn them block rewards.
Filecoin&rsquo;s blockchain runs on storage power. That is, its consensus algorithm by which miners agree on which subchain to mine is predicated on the amount of storage backing that subchain. At a high-level, the <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem maintains a <em>Power Table</em> that tracks the amount of storage <a href="./#systems__filecoin_mining__storage_mining">storage miner actors</a> have contributed to the network through <em>Sector commitments</em> and <em>Proofs of Spacetime</em>.</p>

<p>Most of the functions of the Filecoin blockchain system are detailed in the code below.</p>


</div>


  
    








<div id="systems__filecoin_blockchain__struct">

<h3 class="section-header">
  Blocks
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_blockchain__struct__block">

<h4 class="section-header">
  Block
</h4>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__struct__block__block"></div>
The Block is a unit of the Filecoin blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>

<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">BlockCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">MessageRoot</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">ReceiptRoot</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">ChainWeight</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">ChainEpoch</span> <span class="nx">UVarint</span>

<span class="c1">// Randomness is a string of random bytes
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Randomness</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">BlockHeader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Chain linking
</span><span class="c1"></span>    <span class="nx">Parents</span>          <span class="nx">Tipset</span>
    <span class="nx">Weight</span>           <span class="nx">ChainWeight</span>
    <span class="nx">Epoch</span>            <span class="nx">ChainEpoch</span>

    <span class="c1">// Miner Info
</span><span class="c1"></span>    <span class="nx">MinerAddress</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// State
</span><span class="c1"></span>    <span class="nx">StateTree</span>        <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
    <span class="nx">Messages</span>         <span class="nx">MessageRoot</span>
    <span class="nx">MessageReceipts</span>  <span class="nx">ReceiptRoot</span>

    <span class="c1">// Consensus things
</span><span class="c1"></span>    <span class="nx">Timestamp</span>        <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">Ticket</span>
    <span class="nx">ElectionProof</span>

    <span class="c1">// Signatures
</span><span class="c1"></span>    <span class="nx">BlockSig</span>         <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
    <span class="nx">BLSAggregateSig</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>

    <span class="c1">//	SerializeSigned()            []byte
</span><span class="c1"></span>    <span class="c1">//	ComputeUnsignedFingerprint() []
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// TODO: remove this. header is signed
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SignedBlock</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BlockCID</span>   <span class="o">&amp;</span><span class="nx">Block</span>
    <span class="nx">MinerAddr</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">Signature</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Header</span>    <span class="nx">BlockHeader</span>
    <span class="nx">Messages</span>  <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">]</span>
    <span class="nx">Receipts</span>  <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Chain</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">HeadEpoch</span><span class="p">()</span>         <span class="nx">ChainEpoch</span>
    <span class="nf">HeadTipset</span><span class="p">()</span>        <span class="nx">Tipset</span>
    <span class="nf">LatestCheckpoint</span><span class="p">()</span>  <span class="nx">ChainEpoch</span>

    <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span>
    <span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// Checkpoint represents a particular block to use as a trust anchor
</span><span class="c1">// in Consensus and ChainSync
</span><span class="c1">//
</span><span class="c1">// Note: a Block uniquely identifies a tipset (the parents)
</span><span class="c1">// from here, we may consider many tipsets that _include_ Block
</span><span class="c1">// but we must indeed include t and not consider tipsets that
</span><span class="c1">// fork from Block.Parents, but do not include Block.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Checkpoint</span> <span class="nx">BlockCID</span>

<span class="c1">// SoftCheckpoint is a checkpoint that Filecoin nodes may use as they
</span><span class="c1">// gain confidence in the blockchain. It is a unilateral checkpoint,
</span><span class="c1">// and derived algorithmically from notions of probabilistic consensus
</span><span class="c1">// and finality.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SoftCheckpoint</span> <span class="nx">Checkpoint</span>

<span class="c1">// TrustedCheckpoint is a Checkpoint that is trusted by the broader
</span><span class="c1">// Filecoin Network. These TrustedCheckpoints are arrived at through
</span><span class="c1">// the higher level economic consensus that surrounds Filecoin.
</span><span class="c1">// TrustedCheckpoints:
</span><span class="c1">// - MUST be at least 200,000 blocks old (&gt;1mo)
</span><span class="c1">// - MUST be at least
</span><span class="c1">// - MUST be widely known and accepted
</span><span class="c1">// - MAY ship with Filecoin software implementations
</span><span class="c1">// - MAY be propagated through other side-channel systems
</span><span class="c1">// For more, see the Checkpoints section.
</span><span class="c1">// TODO: consider renaming as EconomicCheckpoint
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TrustedCheckpoint</span> <span class="nx">Checkpoint</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">block</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">SmallerBytes</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">util</span><span class="p">.</span><span class="nf">CompareBytesStrict</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="c1">// TODO: add SHA256 to filcrypto
</span><span class="c1">// TODO: import SHA256 from filcrypto
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">SHA256</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">sliceEqual</span><span class="p">(</span><span class="nx">a</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">v</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">epochToLittleEndianBytes</span><span class="p">(</span><span class="nx">e</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addrToLittleEndianBytes</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="c1">// will return tipset from closest prior (or equal) epoch with a tipset
</span><span class="c1">// return epoch should be checked accordingly
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span> <span class="p">{</span>

	<span class="nx">dist</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">HeadEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">epoch</span>
	<span class="nx">current</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">HeadTipset</span><span class="p">()</span>
	<span class="nx">parents</span> <span class="o">:=</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Parents</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">dist</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="p">=</span> <span class="nx">parents</span>
		<span class="nx">parents</span> <span class="p">=</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Parents</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">current</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>

	<span class="c1">// doesn&#39;t matter if ts.Epoch() != epoch
</span><span class="c1"></span>	<span class="c1">// since we generate new ticket from prior one in any case
</span><span class="c1"></span>	<span class="c1">// else we use ticket from that epoch and derive new randomness from it
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">SHA256</span><span class="p">(</span><span class="nx">ts</span><span class="p">.</span><span class="nf">MinTicket</span><span class="p">().</span><span class="nf">DrawRandomness</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">epoch</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">HeadEpoch</span><span class="p">()</span> <span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">HeadTipset</span><span class="p">()</span> <span class="nx">Tipset</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_blockchain__struct__block__tipset">

<h5 class="section-header">
  Tipset
</h5>

<div class="section-content">




































<p>EC can elect multiple leaders in a given epoch meaning Filecoin chains can contain multiple blocks at each height (one per winning miner). This greatly increases chain throughput by allowing blocks to propagate through the network of nodes more efficiently but also means miners should coordinate how they select messages for inclusion in their blocks in order to avoid duplicates and maximize their earnings from transaction fees (see <a href="./#systems__filecoin_blockchain__message_pool___index">Message Pool</a>).</p>

<p>Accordingly, all valid blocks generated in a round form a <code>Tipset</code> that participants will attempt to mine off of in the subsequent round (see above). Tipsets are valid so long as:
- All blocks in a Tipset have the same parent Tipset
- All blocks in a Tipset are mined in the same Epoch</p>

<p>During state computation, blocks in a tipset are processed in order of block ticket, breaking ties with the block CID bytes. The Filecoin state tree is modified by the execution of all messages in a given Tipset.</p>

<p>Due to this fact, adding new blocks to the chain actually validates those blocks&rsquo; parent Tipset, that is: executing the messages of a new block, a miner cannot know exactly what state tree this will yield. That state tree is only known once all messages in that block&rsquo;s Tipset have been executed. Accordingly, it is in the next round (and based on the number of blocks mined on a given Tipset) that a miner will be able to choose which state tree to extend.</p>

<p>Due to network propagation delay, it is possible for a miner in epoch N+1 to omit valid blocks mined at epoch N from their Tipset. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol as defined by EC&rsquo;s <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> function.</p>

<p><div id="systems__filecoin_blockchain__struct__block__tipset__tipset"></div>
The Tipset is a group of blocks in the same exact round, that all share the exact same parents.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>

<span class="kd">type</span> <span class="nx">Tipset</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BlockCIDs</span>          <span class="p">[</span><span class="nx">BlockCID</span><span class="p">]</span>
    <span class="nx">Blocks</span>             <span class="p">[</span><span class="nx">BlockHeader</span><span class="p">]</span>

    <span class="nf">Has</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">)</span>   <span class="kt">bool</span>           <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Parents</span>            <span class="nx">Tipset</span>         <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">StateTree</span>          <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>   <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Weight</span>             <span class="nx">ChainWeight</span>    <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Epoch</span>              <span class="nx">ChainEpoch</span>     <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>

    <span class="nf">ValidateSyntax</span><span class="p">()</span>   <span class="kt">bool</span>           <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nf">LatestTimestamp</span><span class="p">()</span>  <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span>     <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nf">MinTicket</span><span class="p">()</span>        <span class="nx">Ticket</span>         <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">block</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>

	<span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Tipset_I</span><span class="p">)</span> <span class="nf">MinTicket</span><span class="p">()</span> <span class="nx">Ticket</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ret</span> <span class="nx">Ticket</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">currBlock</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">ts</span><span class="p">.</span><span class="nf">Blocks</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">tix</span> <span class="o">:=</span> <span class="nx">currBlock</span><span class="p">.</span><span class="nf">Ticket</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">ret</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">ret</span> <span class="p">=</span> <span class="nx">tix</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">smaller</span> <span class="o">:=</span> <span class="nf">SmallerBytes</span><span class="p">(</span><span class="nx">tix</span><span class="p">.</span><span class="nf">Output</span><span class="p">(),</span> <span class="nx">ret</span><span class="p">.</span><span class="nf">Output</span><span class="p">())</span>
			<span class="k">if</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nx">smaller</span><span class="p">,</span> <span class="nx">tix</span><span class="p">.</span><span class="nf">Output</span><span class="p">())</span> <span class="p">{</span>
				<span class="nx">ret</span> <span class="p">=</span> <span class="nx">tix</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Tipset_I</span><span class="p">)</span> <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ts</span><span class="p">.</span><span class="nx">Blocks_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>

	<span class="c1">// parents := ts.Parents_
</span><span class="c1"></span>	<span class="c1">// grandparent := parents[0].Parents_
</span><span class="c1"></span>	<span class="c1">// for i := 1; i &lt; len(parents); i++ {
</span><span class="c1"></span>	<span class="c1">// 	if grandparent != parents[i].Parents_ {
</span><span class="c1"></span>	<span class="c1">// 		return false
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// numTickets := len(ts.Blocks_[0].Tickets_)
</span><span class="c1"></span>	<span class="c1">// for i := 1; i &lt; len(ts.Blocks_); i++ {
</span><span class="c1"></span>	<span class="c1">// 	if numTickets != len(ts.Blocks_[i].Tickets_) {
</span><span class="c1"></span>	<span class="c1">// 		return false
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Tipset_I</span><span class="p">)</span> <span class="nf">LatestTimestamp</span><span class="p">()</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">latest</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="c1">// for _, blk := range ts.Blocks_ {
</span><span class="c1"></span>	<span class="c1">// 	if blk.Timestamp().After(latest) || latest.IsZero() {
</span><span class="c1"></span>	<span class="c1">// 		latest = blk.Timestamp()
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">latest</span>
<span class="p">}</span>

<span class="c1">// func (tipset *Tipset_I) StateTree() stateTree.StateTree {
</span><span class="c1">// 	var currTree stateTree.StateTree = nil
</span><span class="c1">// 	for _, block := range tipset.Blocks() {
</span><span class="c1">// 		if currTree == nil {
</span><span class="c1">// 			currTree = block.StateTree()
</span><span class="c1">// 		} else {
</span><span class="c1">// 			Assert(block.StateTree().CID().Equals(currTree.CID()))
</span><span class="c1">// 		}
</span><span class="c1">// 	}
</span><span class="c1">// 	Assert(currTree != nil)
</span><span class="c1">// 	for _, block := range tipset.Blocks() {
</span><span class="c1">// 		currTree = UpdateStateTree(currTree, block)
</span><span class="c1">// 	}
</span><span class="c1">// 	return currTree
</span><span class="c1">// }
</span></code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__chain">

<h4 class="section-header">
  Chain
</h4>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__struct__chain__chain"></div>
A Chain is a sequence of tipsets, linked together. It is a single history of execution in the Filecoin blockchain.</p>

















<p style="color: #D74848"><b><i>Something's not right. The <code>chain.id</code> file was not found.</i></b></p>



















<p style="color: #D74848"><b><i>Something's not right. The <code>chain.go</code> file was not found.</i></b></p>




</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__chain_manager">

<h4 class="section-header">
  Chain Manager
</h4>

<div class="section-content">






































<p>The <em>Chain Manager</em> is a central component in the blockchain system. It tracks and updates competing subchains received by a given node in order to select the appropriate blockchain head: the latest block of the heaviest subchain it is aware of in the system.</p>

<p>In so doing, the <em>chain manager</em> is the central subsystem that handles bookkeeping for numerous other systems in a Filecoin node and exposes convenience methods for use by those systems, enabling systems to sample randomness from the chain for instance, or to see which block has been finalized most recently.</p>

<p>The chain manager interfaces and functions are included here, but we expand on important details below for clarity.</p>

<h5 id="chain-expansion">Chain Expansion</h5>

<h6 id="incoming-blocks-and-semantic-validation">Incoming blocks and semantic validation</h6>

<p>Once a block has been received and syntactically validated by the <a href="./#systems__filecoin_blockchain__chainsync___index"></a>, it must be semantically validated by the chain manager for inclusion on a given chain.</p>

<p>A semantically valid block:</p>

<ul>
<li>must be from a valid miner with power on the chain</li>
<li>must only have valid parents in the tipset, meaning

<ul>
<li>that each parent itself must be a valid block</li>
<li>that they all have the same parents themselves</li>
<li>that they are all at the same height (i.e. include the same number of tickets)</li>
</ul></li>
<li>must have a valid tickets generated from the minTicket in its parent tipset.</li>
<li>must only have valid state transitions:

<ul>
<li>all messages in the block must be valid</li>
<li>the execution of each message, in the order they are in the block, must produce a receipt matching the corresponding one in the receipt set of the block.</li>
</ul></li>
<li>the resulting state root after all messages are applied, must match the one in the block</li>
</ul>

<div class="notices info" >Once the block passes validation, it must be added to the local datastore, regardless whether it is understood as the best tip at this point. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching.</div>

<div class="notices info" >To make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.</div>

<p>The following requires having and processing (executing) the messages</p>

<ul>
<li>Messages can be checked by verifying the messages hash correctly to the value.</li>
<li>MessageAggregateSig can be checked by verifying the messages sign correctly</li>
<li>MessageReceipts can only be checked by executing the messages</li>
<li>StateRoot is the result of the execution of the messages, and can only be verified by executing them</li>
</ul>

<h6 id="block-reception-algorithm">Block reception algorithm</h6>

<p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier Tipset rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="expected-consensus.md#chain-selection">chain selection</a> in the Expected Consensus spec.</p>

<p>However, ahead of finality, a given subchain may be abandoned in order of another, heavier one mined in a given round. In order to rapidly adapt to this, the chain manager must maintain and update all subchains being considered up to finality.</p>

<p>That is, for every incoming block, even if the incoming block is not added to the current heaviest tipset, the chain manager should add it to the appropriate subchain it is tracking, or keep track of it independently until either:
- it is able to do so, through the reception of another block in that subchain
- it is able to discard it, as that block was mined before finality</p>

<p>We give an example of how this could work in the block reception algorithm.</p>

<h6 id="chaintipsmanager">ChainTipsManager</h6>

<p>The Chain Tips Manager is a subcomponent of Filecoin consensus that is technically up to the implementer, but since the pseudocode in previous sections reference it, it is documented here for clarity.</p>

<p>The Chain Tips Manager is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current &lsquo;best&rsquo; tipset is.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Returns the ticket that is at round &#39;r&#39; in the chain behind &#39;head&#39;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TicketFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// Returns the tipset that contains round r (Note: multiple rounds&#39; worth of tickets may exist within a single block due to losing tickets being added to the eventually successfully generated block)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TipsetFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// GetBestTipset returns the best known tipset. If the &#39;best&#39; tipset hasn&#39;t changed, then this
</span><span class="c1">// will return the previous best tipset.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetBestTipset</span><span class="p">()</span>

<span class="c1">// Adds the losing ticket to the chaintips manager so that blocks can be mined on top of it
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddLosingTicket</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Ticket</span><span class="p">)</span></code></pre></div>

</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__block_producer">

<h4 class="section-header">
  Block Producer
</h4>

<div class="section-content">






































<div id="systems__filecoin_blockchain__struct__block_producer__block_producer"></div>

<h5 id="mining-blocks">Mining Blocks</h5>

<p>Having registered as a miner, it&rsquo;s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest tipsets seen on the network.</p>

<p>For additional details around how consensus works in Filecoin, see <a href="./#algorithms__expected_consensus___index">Expected Consensus</a>. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner is eligible to mine a block itself, and other rules pertaining to the production of some artifacts required of valid blocks (e.g. Tickets, ElectionProofs).</p>

<h6 id="mining-cycle">Mining Cycle</h6>

<p>At any height <code>H</code>, there are three possible situations:</p>

<ul>
<li>The miner is eligible to mine a block: they produce their block and propagate it. They then resume mining at the next height <code>H+1</code>.</li>
<li>The miner is not eligible to mine a block but has received blocks: they form a Tipset with them and resume mining at the next height <code>H+1</code>.</li>
<li>The miner is not eligible to mine a block and has received no blocks: prompted by their clock they run leader election again, incrementing the epoch number.</li>
</ul>

<p>This process is repeated until either a winning ticket is found (and block published) or a new valid Tipset comes in from the network.</p>

<p>Let&rsquo;s illustrate this with an example.</p>

<p>Miner M is mining at Height H.
Heaviest tipset at H-1 is {B0}</p>

<ul>
<li>New Round:

<ul>
<li>M produces a ticket at H, from B0&rsquo;s ticket (the min ticket at H-1)</li>
<li>M draws the ticket from height H-K to generate an ElectionProof</li>
<li>That ElectionProof is invalid</li>
<li>M has not heard about other blocks on the network.</li>
</ul></li>
<li>New Round:

<ul>
<li>Epoch/Height is incremented to H + 1.</li>
<li>M generates a new ElectionProof with this new epoch number.</li>
<li>That ElectionProof is valid</li>
<li>M generates a block B1 using the new ElectionProof and the ticket drawn last round.</li>
<li>M has received blocks B2, B3 from the network with the same parents and same height.</li>
<li>M forms a tipset {B1, B2, B3}</li>
</ul></li>
</ul>

<p>Anytime a miner receives new blocks, it should evaluate what is the heaviest Tipset it knows about and mine atop it.</p>

<h6 id="block-creation">Block Creation</h6>

<p>Scratching a winning ticket, and armed with a valid <code>ElectionProof</code>, a miner can now publish a new block!</p>

<p>To create a block, the eligible miner must compute a few fields:</p>

<ul>
<li><code>Ticket</code> - new ticket generated from that in the prior epoch (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_generation">Ticket Generation</a>).</li>
<li><code>ElectionProof</code> - A specific signature over the min_ticket from <code>randomness_lokkback</code> epochs back (see <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a>).</li>
<li><code>ParentWeight</code> - The parent chain&rsquo;s weight (see <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a>).</li>
<li><code>Parents</code> - the CIDs of the parent blocks.</li>
<li><code>ParentState</code> - Note that it will not end up in the newly generated block, but is necessary to compute to generate other fields. To compute this:

<ul>
<li>Take the <code>ParentState</code> of one of the blocks in the chosen parent set (invariant: this is the same value for all blocks in a given parent set).</li>
<li>For each block in the parent set, ordered by their tickets:</li>
<li>Apply each message in the block to the parent state, in order. If a message was already applied in a previous block, skip it.</li>
<li>Transaction fees are given to the miner of the block that the first occurance of the message is included in. If there are two blocks in the parent set, and they both contain the exact same set of messages, the second one will receive no fees.</li>
<li>It is valid for messages in two different blocks of the parent set to conflict, that is, A conflicting message from the combined set of messages will always error.  Regardless of conflicts all messages are applied to the state.</li>
<li>TODO: define message conflicts in the state-machine doc, and link to it from here</li>
</ul></li>
<li><code>MsgRoot</code> - To compute this:

<ul>
<li>Select a set of messages from the mempool to include in the block.</li>
<li>Separate the messages into BLS signed messages and secpk signed messages</li>
<li>For the BLS messages:</li>
<li>Strip the signatures off of the messages, and insert all the bare <code>Message</code>s for them into a sharray.</li>
<li>Aggregate all of the bls signatures into a single signature and use this to fill out the <code>BLSAggregate</code> field</li>
<li>For the secpk messages:</li>
<li>Insert each of the secpk <code>SignedMessage</code>s into a sharray</li>
<li>Create a <code>TxMeta</code> object and fill each of its fields as follows:</li>
<li><code>blsMessages</code>: the root cid of the bls messages sharray</li>
<li><code>secpkMessages</code>: the root cid of the secp messages sharray</li>
<li>The cid of this <code>TxMeta</code> object should be used to fill the <code>MsgRoot</code> field of the block header.</li>
</ul></li>
<li><code>BLSAggregate</code> - The aggregated signatures of all messages in the block that used BLS signing.</li>
<li><code>StateRoot</code> - Apply each chosen message to the <code>ParentState</code> to get this.

<ul>
<li>Note: first apply bls messages in the order that they appear in the blsMsgs sharray, then apply secpk messages in the order that they appear in the secpkMessages sharray.</li>
</ul></li>
<li><code>ReceiptsRoot</code> - To compute this:

<ul>
<li>Apply the set of messages to the parent state as described above, collecting invocation receipts as this happens.</li>
<li>Insert them into a sharray and take its root.</li>
</ul></li>
<li><code>Timestamp</code> - A Unix Timestamp generated at block creation. We use an unsigned integer to represent a UTC timestamp (in seconds). The Timestamp in the newly created block must satisfy the following conditions:

<ul>
<li>the timestamp on the block corresponds to the current epoch (it is neither in the past nor in the future) as defined by the clock subsystem.</li>
</ul></li>
<li><code>BlockSig</code> - A signature with the miner&rsquo;s private key (must also match the ticket signature) over the entire block. This is to ensure that nobody tampers with the block after it propagates to the network, since unlike normal PoW blockchains, a winning ticket is found independently of block generation.</li>
</ul>

<p>An eligible miner can start by filling out <code>Parents</code>, <code>Tickets</code> and <code>ElectionProof</code> with values from the ticket checking process.</p>

<p>Next, they compute the aggregate state of their selected parent blocks, the <code>ParentState</code>. This is done by taking the aggregate parent state of the blocks&rsquo; parent Tipset, sorting the parent blocks by their tickets, and applying each message in each block to that state. Any message whose nonce is already used (duplicate message) in an earlier block should be skipped (application of this message should fail anyway). Note that re-applied messages may result in different receipts than they produced in their original blocks, an open question is how to represent the receipt trie of this tipset&rsquo;s messages (one can think of a tipset as a &lsquo;virtual block&rsquo; of sorts).</p>

<p>Once the miner has the aggregate <code>ParentState</code>, they must apply the block reward. This is done by adding the correct block reward amount to the miner owner&rsquo;s account balance in the state tree. The reward will be spendable immediately in this block.</p>

<p>Now, a set of messages is selected to put into the block. For each message, the miner subtracts <code>msg.GasPrice * msg.GasLimit</code> from the sender&rsquo;s account balance, returning a fatal processing error if the sender does not have enough funds (this message should not be included in the chain).</p>

<p>They then apply the messages state transition, and generate a receipt for it containing the total gas actually used by the execution, the executions exit code, and the return value . Then, they refund the sender in the amount of <code>(msg.GasLimit - GasUsed) * msg.GasPrice</code>. In the event of a message processing error, the remaining gas is refunded to the user, and all other state changes are reverted. (Note: this is a divergence from the way things are done in Ethereum)</p>

<p>Each message should be applied on the resultant state of the previous message execution, unless that message execution failed, in which case all state changes caused by that message are thrown out. The final state tree after this process will be the block&rsquo;s <code>StateRoot</code>.</p>

<p>The miner merklizes the set of messages selected, and put the root in <code>MsgRoot</code>. They gather the receipts from each execution into a set, merklize them, and put that root in <code>ReceiptsRoot</code>. Finally, they set the <code>StateRoot</code> field with the resultant state.</p>

<div class="notices info" >Note that the <code>ParentState</code> field from the expected consensus document is left out, this is to help minimize the size of the block header. The parent state for any given parent set should be computed by the client and cached locally.</div>

<p>Finally, the miner can generate a Unix Timestamp to add to their block, to show that the block generation was appropriately delayed.</p>

<p>The miner will wait until BLOCK_DELAY has passed since the latest block in the parent set was generated to timestamp and send out their block. We recommend using NTP or another clock synchronization protocol to ensure that the timestamp is correctly generated (lest the block be rejected). While this timestamp does not provide a hard proof that the block was delayed (we rely on the VDF in the ticket-chain to do so), it provides some softer form of block delay by ensuring that honest miners will reject undelayed blocks.</p>

<p>Now the block is complete, all that&rsquo;s left is to sign it. The miner serializes the block now (without the signature field), takes the sha256 hash of it, and signs that hash. They place the resultant signature in the <code>BlockSig</code> field.</p>

<h6 id="block-broadcast">Block Broadcast</h6>

<p>An eligible miner broadcasts the completed block to the network and assuming everything was done correctly, the network will accept it and other miners will mine on top of it, earning the miner a block reward!</p>

<h5 id="block-rewards">Block Rewards</h5>

<p>Over the entire lifetime of the protocol, 1,400,000,000 FIL (<code>TotalIssuance</code>) will be given out to miners. The rate at which the funds are given out is set to halve every six years, smoothly (not a fixed jump like in Bitcoin). These funds are initially held by the network account actor, and are transferred to miners in blocks that they mine. Over time, the reward will eventually become close zero as the fractional amount given out at each step shrinks the network account&rsquo;s balance to 0.</p>

<p>The equation for the current block reward is of the form:</p>

<pre><code>Reward = (IV * RemainingInNetworkActor) / TotalIssuance
</code></pre>

<p><code>IV</code> is the initial value, and is set to:</p>

<pre><code>IV = 153856861913558700202 attoFIL // 153.85 FIL
</code></pre>

<p>IV was derived from:</p>

<pre><code>// Given one block every 30 seconds, this is how many blocks are in six years
HalvingPeriodBlocks = 6 * 365 * 24 * 60 * 2 = 6,307,200 blocks
Œª = ln(2) / HalvingPeriodBlocks
IV = TotalIssuance * (1-e^(-Œª)) // Converted to attoFIL (10e18)
</code></pre>

<p>Note: Due to jitter in EC, and the gregorian calendar, there may be some error in the issuance schedule over time. This is expected to be small enough that it&rsquo;s not worth correcting for. Additionally, since the payout mechanism is transferring from the network account to the miner, there is no risk of minting <em>too much</em> FIL.</p>

<p>TODO: Ensure that if a miner earns a block reward while undercollateralized, then <code>min(blockReward, requiredCollateral-availableBalance)</code> is garnished (transfered to the miner actor instead of the owner).</p>

<h6 id="notes-on-block-reward-application">Notes on Block Reward Application</h6>

<p>As mentioned above, every round, a miner checks to see if they have been selected as the leader for that particular round. Thus, it is possible that multiple miners may be selected as winners in a given round, and thus, that there will be multiple blocks with the same parents that are produced at the same block height (forming a Tipset). Each of the winning miners will apply the block reward directly to their actor&rsquo;s state in their state tree.</p>

<p>Other nodes will receive these blocks and form a Tipset out of the eligible blocks (those that have the same parents and are at the same block height). These nodes will then validate the Tipset. To validate Tipset state, the validating node will, for each block in the Tipset, first apply the block reward value directly to the mining node&rsquo;s account and then apply the messages contained in the block.</p>

<p>Thus, each of the miners who produced a block in the Tipset will receive a block reward. There will be no lockup. These rewards can be spent immediately.</p>

<p>Messages in Filecoin also have an associated transaction fee (based on the gas costs of executing the message). In the case where multiple winning miners included the same message in their blocks, only the first miner will be paid this transaction fee. The first miner is the miner with the lowest ticket value (sorted lexicographically).</p>

<h5 id="open-questions">Open Questions</h5>

<ul>
<li>How should receipts for tipsets be referenced? It is common for applications to provide the merkleproof of a receipt to prove that a transaction was successfully executed.</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__message_pool">

<h3 class="section-header">
  Message Pool
</h3>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__message_pool__message_pool"></div>
The Message Pool is a subsystem in the Filecoin blockchain system. The message pool is acts as the interface between Filecoin nodes and a peer-to-peer network used for off-chain message transmission. It is used by nodes to maintain a set of messages to transmit to the Filecoin VM (for &ldquo;on-chain&rdquo; execution).</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">MessagePoolSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// needs access to:
</span><span class="c1"></span>    <span class="c1">// - BlockchainSubsystem
</span><span class="c1"></span>    <span class="c1">//   - needs access to StateTree
</span><span class="c1"></span>    <span class="c1">//   - needs access to Messages mined into blocks (probably past finality)
</span><span class="c1"></span>    <span class="c1">//     to remove from the MessagePool
</span><span class="c1"></span>    <span class="c1">// - NetworkSubsystem
</span><span class="c1"></span>    <span class="c1">//   - needs access to MessagePubsub
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Important remaining questions:
</span><span class="c1"></span>    <span class="c1">// - how does BlockchainSubsystem.BlockReceiver handle asking for messages?
</span><span class="c1"></span>    <span class="c1">// - how do we note messages are now part of the blockchain
</span><span class="c1"></span>    <span class="c1">//   - how are they cleared from the mempool
</span><span class="c1"></span>    <span class="c1">// - do we need to have some sort of purge?
</span><span class="c1"></span>
    <span class="c1">// AddNewMessage is called to add messages created at this node,
</span><span class="c1"></span>    <span class="c1">// or to be propagated by this node. All messages enter the network
</span><span class="c1"></span>    <span class="c1">// through one of these calls, in at least one filecoin node. They
</span><span class="c1"></span>    <span class="c1">// are then propagated to other filecoin nodes via the MessagePool
</span><span class="c1"></span>    <span class="c1">// subsystem. Other nodes receive and propagate Messages via their
</span><span class="c1"></span>    <span class="c1">// own MessagePools.
</span><span class="c1"></span>    <span class="nf">AddNewMessage</span><span class="p">(</span><span class="nx">m</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>

    <span class="c1">// Stats returns information about the MessagePool contents.
</span><span class="c1"></span>    <span class="nf">Stats</span><span class="p">()</span> <span class="nx">MessagePoolStats</span>

    <span class="c1">// FindMessage receives a descriptor query q, and returns a set of
</span><span class="c1"></span>    <span class="c1">// messages currently in the mempool that match the Query constraints.
</span><span class="c1"></span>    <span class="c1">// q may have all, any, or no constraints specified.
</span><span class="c1"></span>    <span class="c1">// FindMessage(q MessageQuery) union {
</span><span class="c1"></span>    <span class="c1">//  [base.Message],
</span><span class="c1"></span>    <span class="c1">//  Error
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>
    <span class="c1">// MostProfitableMessages returns messages that are most profitable
</span><span class="c1"></span>    <span class="c1">// to mine for this miner.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Note: This is where algorithms about chosing best messages given
</span><span class="c1"></span>    <span class="c1">//       many leaders should go.
</span><span class="c1"></span>    <span class="nf">GetMostProfitableMessages</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessagePoolStats</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Size is the amount of messages in the MessagePool
</span><span class="c1"></span>    <span class="nx">Size</span> <span class="nx">UInt</span>
<span class="p">}</span>

<span class="c1">// MessageQuery is a descriptor used to find messages matching one or more
</span><span class="c1">// of the constraints specified.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MessageQuery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="cm">/*
</span><span class="cm">  From   base.Address
</span><span class="cm">  To     base.Address
</span><span class="cm">  Method ActorMethodId
</span><span class="cm">  Params ActorMethodParams
</span><span class="cm">
</span><span class="cm">  ValueMin    TokenAmount
</span><span class="cm">  ValueMax    TokenAmount
</span><span class="cm">  GasPriceMin TokenAmount
</span><span class="cm">  GasPriceMax TokenAmount
</span><span class="cm">  GasLimitMin TokenAmount
</span><span class="cm">  GasLimitMax TokenAmount
</span><span class="cm">  */</span>
<span class="p">}</span>
</code></pre></div>






<p>Clients that use a message pool include:</p>

<ul>
<li>storage market provider and client nodes - for transmission of deals on chain</li>
<li>storage miner nodes - for transmission of PoSts, sector commitments, deals, and other operations tracked on chain</li>
<li>verifier nodes - for transmission of potential faults on chain</li>
<li>relayer nodes - for forwarding and discarding messages appropriately.</li>
</ul>

<p>The message pool subsystem is made of two components:</p>

<ul>
<li>The message syncer <a href="./#systems__filecoin_blockchain__message_pool__message_syncer">Message Syncer</a> &ndash; which receives and propagates messages.</li>
<li>Message storage <a href="./#systems__filecoin_blockchain__message_pool__message_storage">Message Storage</a> &ndash; which caches messages according to a given policy.</li>
</ul>

<p>TODOs:</p>

<ul>
<li>discuss how messages are meant to propagate slowly/async</li>
<li>explain algorithms for choosing profitable txns</li>
</ul>


</div>


  
    








<div id="systems__filecoin_blockchain__message_pool__message_syncer">

<h4 class="section-header">
  Message Syncer
</h4>

<div class="section-content">






































<div id="systems__filecoin_blockchain__message_pool__message_syncer__message_syncer"></div>

<p>TODO:</p>

<ul>
<li>explain message syncer works</li>
<li>include the message syncer code</li>
</ul>

<h5 id="message-propagation">Message Propagation</h5>

<p>Messages are propagated over the libp2p pubsub channel <code>/fil/messages</code>. On this channel, every <a href="data-structures.md#messages">serialised <code>SignedMessage</code></a> is announced.</p>

<p>Upon receiving the message, its validity must be checked: the signature must be valid, and the account in question must have enough funds to cover the actions specified. If the message is not valid it should be dropped and must not be forwarded.</p>

<div class="notices todo" >discuss checking signatures and account balances, some tricky bits that need consideration. Does the fund check cause improper dropping? E.g. I have a message sending funds then use the newly constructed account to send funds, as long as the previous wasn&rsquo;t executed the second will be considered &ldquo;invalid&rdquo; &hellip; though it won&rsquo;t be at the time of execution.</div>


</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__message_pool__message_storage">

<h4 class="section-header">
  Message Storage
</h4>

<div class="section-content">




































<div id="systems__filecoin_blockchain__message_pool__message_storage__message_storage"></div>

<p>TODO:</p>

<ul>
<li>give sample algorithm for miner message selection in block production (to avoid dups)</li>
<li>give sample algorithm for message storage caching/purging policies.</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__chainsync">

<h3 class="section-header">
  ChainSync - synchronizing the Blockchain
</h3>

<div class="section-content">






































<div id="systems__filecoin_blockchain__chainsync__chain_sync"></div>

<h4 id="what-is-blockchain-synchronization">What is blockchain synchronization?</h4>

<p>Blockchain synchronization (&ldquo;sync&rdquo;) is a key part of a blockchain system.
It handles retrieval and propagation of blocks and transactions (messages), and
thus in charge of distributed state replication.
<strong>This process is security critical &ndash; problems here can be catastrophic to the
operation of a blockchain.</strong></p>

<h4 id="what-is-chainsync">What is ChainSync?</h4>

<p><code>ChainSync</code> is the protocol Filecoin uses to synchronize its blockchain. It is
specific to Filecoin&rsquo;s choices in state representation and consensus rules,
but is general enough that it can serve other blockchains. <code>ChainSync</code> is a
group of smaller protocols, which handle different parts of the sync process.</p>

<h4 id="terms-and-concepts">Terms and Concepts</h4>

<ul>
<li><code>LastCheckpoint</code> the last hard social-consensus oriented checkpoint that <code>ChainSync</code> is aware of.
This consensus checkpoint defines the minimum finality, and a minimum of history to build on.
<code>ChainSync</code> takes <code>LastCheckpoint</code> on faith, and builds on it, never switching away from its history.</li>
<li><code>TargetHeads</code> a list of <code>BlockCIDs</code> that represent blocks at the fringe of block production.
These are the newest and best blocks <code>ChainSync</code> knows about. They are &ldquo;target&rdquo; heads because
<code>ChainSync</code> will try to sync to them. This list is sorted by &ldquo;likelihood of being the best chain&rdquo; (eg for now, simply <code>ChainWeight</code>)</li>
<li><code>BestTargetHead</code> the single best chain head <code>BlockCID</code> to try to sync to.
This is the first element of <code>TargetHeads</code></li>
</ul>

<h4 id="chainsync-summary">ChainSync Summary</h4>

<p>At a high level, <code>ChainSync</code> does the following:</p>

<ul>
<li><strong>Part 1: Verify internal state (<code>INIT</code> state below)</strong>

<ul>
<li>SHOULD verify data structures and validate local chain</li>
<li>Resource expensive verification MAY be skipped at nodes&rsquo; own risk</li>
</ul></li>
<li><strong>Part 2: Bootstrap to the network (<code>BOOTSTRAP</code>)</strong>

<ul>
<li>Step 1. Bootstrap to the network, and acquire a &ldquo;secure enough&rdquo; set of peers (more details below)</li>
<li>Step 2. Bootstrap to the <code>BlockPubsub</code> channels</li>
<li>Step 3. Listen and serve on Graphsync</li>
</ul></li>
<li><strong>Part 3: Synchronize trusted checkpoint state (<code>SYNC_CHECKPOINT</code>)</strong>

<ul>
<li>Step 1. Start with a <code>TrustedCheckpoint</code> (defaults to <code>GenesisCheckpoint</code>).</li>
<li>Step 2. Get the block it points to, and that block&rsquo;s parents</li>
<li>Step 3. Graphsync the <code>StateTree</code></li>
</ul></li>
<li><strong>Part 4: Catch up to the chain  (<code>CHAIN_CATCHUP</code>)</strong>

<ul>
<li>Step 1. Maintain a set of <code>TargetHeads</code> (<code>BlockCIDs</code>), and select the <code>BestTargetHead</code> from it</li>
<li>Step 2. Synchronize to the latest heads observed, validating blocks towards them (requesting intermediate points)</li>
<li>Step 3. As validation progresses, <code>TargetHeads</code> and <code>BestTargetHead</code> will likely change, as new blocks at the production fringe will arrive,
and some target heads or paths to them may fail to validate.</li>
<li>Step 4. Finish when node has &ldquo;caught up&rdquo; with <code>BestTargetHead</code> (retrieved all the state, linked to local chain, validated all the blocks, etc).</li>
</ul></li>
<li><strong>Part 5: Stay in sync, and participate in block propagation (<code>CHAIN_FOLLOW</code>)</strong>

<ul>
<li>Step 1. If security conditions change, go back to Part 4 (<code>CHAIN_CATCHUP</code>)</li>
<li>Step 2. Receive, validate, and propagate received <code>Blocks</code></li>
<li>Step 3. Now with greater certainty of having the best chain, finalize Tipsets, and advance chain state.</li>
</ul></li>
</ul>

<h4 id="libp2p-network-protocols">libp2p Network Protocols</h4>

<p>As a networking-heavy protocol, <code>ChainSync</code> makes heavy use of <code>libp2p</code>. In particular, we use two sets of protocols:</p>

<ul>
<li><strong><code>libp2p.PubSub</code> a family of publish/subscribe protocols to propagate recent <code>Blocks</code>.</strong>
The concrete protocol choice impacts <code>ChainSync</code>&rsquo;s effectiveness, efficiency, and security dramatically.
For Filecoin v1.0 we will use <code>libp2p.Gossipsub</code>, a recent <code>libp2p</code> protocol that combines features and learnings
from many excellent PubSub systems. In the future, Filecoin may use other <code>PubSub</code> protocols. <em>Important Note:</em> is entirely
possible for Filecoin Nodes to run multiple versions simultaneously. That said, this specification <em>requires</em> that filecoin
nodes <code>MUST</code> connect and participate in the main channel, using <code>libp2p.Gossipsub</code>.</li>
<li><strong><code>libp2p.PeerDiscovery</code> a family of discovery protocols, to learn about peers in the network.</strong>
This is especially important for security because network &ldquo;Bootstrap&rdquo; is a difficult problem in peer-to-peer networks.
The set of peers we initially connect to may completely dominate our awareness of other peers, and therefore all state.
We use a union of <code>PeerDiscovery</code> protocols as each by itself is not secure or appropriate for users&rsquo; threat models.
The union of these provides a pragmatic and effective solution.</li>
</ul>

<p>More concretely, we use these protocols:</p>

<ul>
<li><strong><code>libp2p.PeerDiscovery</code></strong>

<ul>
<li><strong>(required)</strong> <code>libp2p.BootstrapList</code> a protocol that uses a persistent and user-configurable list of semi-trusted
bootstrap peers. The default list includes a set of peers semi-trusted by the Filecoin Community.</li>
<li><strong>(required)</strong> <code>libp2p.Gossipsub</code> a pub/sub protocol that &ndash; as a side-effect &ndash; disseminates peer information</li>
<li><strong>(optional/TODO)</strong> <code>libp2p.PersistentPeerstore</code> a connectivity component that keeps persistent information about peers
observed in the network throughout the lifetime of the node. This is useful because we resume and continually
improve Bootstrap security.</li>
<li><strong>(optional/TODO)</strong> <code>libp2p.DNSDiscovery</code> to learn about peers via DNS lookups to semi-trusted peer aggregators</li>
<li><strong>(optional/TODO)</strong> <code>libp2p.HTTPDiscovery</code> to learn about peers via HTTP lookups to semi-trusted peer aggregators</li>
<li><strong>(optional)</strong> <code>libp2p.KademliaDHT</code> a dht protocol that enables random queries across the entire network</li>
</ul></li>
<li><strong><code>libp2p.PubSub</code></strong>

<ul>
<li><strong>(required)</strong> <code>libp2p.Gossipsub</code> the concrete <code>libp2p.PubSub</code> protocol <code>ChainSync</code> uses.</li>
</ul></li>
</ul>

<h4 id="subcomponents">Subcomponents</h4>

<p>Aside from <code>libp2p</code>, <code>ChainSync</code> uses or relies on the following components:</p>

<ul>
<li>Libraries:

<ul>
<li><code>ipld</code> data structures, selectors, and protocols</li>
<li><code>ipld.Store</code> local persistent storage for <code>chain</code> datastructures</li>
<li><code>ipld.Selector</code> a way to express requests for chain data structures</li>
<li><code>ipfs.GraphSync</code> a general-purpose <code>ipld</code> datastructure syncing protocol</li>
</ul></li>
<li>Data Structures:

<ul>
<li>Data structures in the <code>chain</code> package: <code>Block, Tipset, Chain, Checkpoint ...</code></li>
<li><code>chainsync.BlockCache</code> a temporary cache of blocks, to constrain resource expended</li>
<li><code>chainsync.AncestryGraph</code> a datastructure to efficiently link <code>Blocks</code>, <code>Tipsets</code>, and <code>PartialChains</code></li>
<li><code>chainsync.ValidationGraph</code> a datastructure for efficient and secure validation of <code>Blocks</code> and <code>Tipsets</code></li>
</ul></li>
</ul>

<h5 id="graphsync-in-chainsync">Graphsync in ChainSync</h5>

<p><code>ChainSync</code> is written in terms of <code>Graphsync</code>. <code>ChainSync</code> adds blockchain and filecoin-specific
synchronization functionality that is critical for Filecoin security.</p>

<h6 id="rate-limiting-graphsync-responses-should">Rate Limiting Graphsync responses (SHOULD)</h6>

<p>When running Graphsync, Filecoin nodes must respond to graphsync queries. Filecoin requires nodes
to provide critical data structures to others, otherwise the network will not function. During
ChainSync, it is in operators&rsquo; interests to provide data structures critical to validating,
following, and participating in the blockchain they are on. However, this has limitations, and
some level of rate limiting is critical for maintaining security in the presence of attackers
who might issue large Graphsync requests to cause DOS.</p>

<p>We recommend the following:</p>

<ul>
<li><strong>Set and enforce batch size rate limits.</strong>
Force selectors to be shaped like: <code>LimitedBlockIpldSelector(blockCID, BatchSize)</code> for a single
constant <code>BatchSize = 1000</code>.
Nodes may push for this equilibrium by only providing <code>BatchSize</code> objects in responses,
even for pulls much larger than <code>BatchSize</code>. This forces subsequent pulls to be run, re-rooted
appropriately, and hints at other parties that they should be requesting with that <code>BatchSize</code>.</li>
<li><strong>Force all Graphsync queries for blocks to be aligned along cacheable bounderies.</strong>
In conjunction with a <code>BatchSize</code>, implementations should aim to cache the results of Graphsync
queries, so that they may propagate them to others very efficiently. Aligning on certain boundaries
(eg specific <code>ChainEpoch</code> limits) increases the likelihood many parties in the network will request
the same batches of content.
Another good cacheable boundary is the entire contents of a <code>Block</code> (<code>BlockHeader</code>, <code>Messages</code>,
<code>Signatures</code>, etc).</li>
<li><strong>Maintain per-peer rate-limits.</strong>
Use bandwidth usage to decide whether to respond and how much on a per-peer basis. Libp2p already
tracks bandwidth usage in each connection. This information can be used to impose rate limits in
Graphsync and other Filecoin protocols.</li>
<li><strong>Detect and react to  DOS: restrict operation.</strong>
The safest implementations will likely detect and react to DOS attacks. Reactions could include:

<ul>
<li>Smaller <code>Graphsync.BatchSize</code> limits</li>
<li>Fewer connections to other peers</li>
<li>Rate limit total Graphsync bandwidth</li>
<li>Assign Graphsync bandwidth based on a peer priority queue</li>
<li>Disconnect from and do not accept connections from unknown peers</li>
<li>Introspect Graphsync requests and filter/deny/rate limit suspicious ones</li>
</ul></li>
</ul>

<h5 id="previous-blocksync-protocol">Previous BlockSync protocol</h5>

<p>Prior versions of this spec recommended a <code>BlockSync</code> protocol. This protocol definition is
<a href="https://github.com/filecoin-project/specs/blob/prevspec/network-protocols.md#blocksync">available here</a>.
Filecoin nodes are libp2p nodes, and therefore may run a variety
of other protocols, including this <code>BlockSync</code> protocol. As with anything else in Filecoin, nodes
MAY opt to use additional protocols to achieve the results.
That said, Nodes MUST implement the version of <code>ChainSync</code> as described in this spec in order to
be considered implementations of Filecoin. Test suites will assume this protocol.</p>

<h4 id="chainsync-state-machine">ChainSync State Machine</h4>

<p><code>ChainSync</code> uses the following <em>conceptual</em> state machine. Since this is a <em>conceptual</em> state machine,
implementations MAY deviate from implementing precisely these states, or dividing them strictly.
Implementations MAY blur the lines between the states. If so, implementations MUST ensure security
of the altered protocol.</p>

<p>State Machine:</p>













<div class="diagram">

<span class="diagram-title">ChainSync State Machine</span>




(<a href="docs/systems/filecoin_blockchain/chainsync/chainsync_fsm.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_blockchain/chainsync/chainsync_fsm.dot.svg" />




</div>


<h5 id="chainsync-fsm-init">ChainSync FSM: <code>INIT</code></h5>

<ul>
<li>beginning state. no network connections, not synchronizing.</li>
<li>local state is loaded: internal data structures (eg chain, cache) are loaded</li>
<li><code>LastTrustedCheckpoint</code> is set the latest network-wide accepted <code>TrustedCheckpoint</code></li>
<li><code>FinalityTipset</code> is set to finality achieved in a prior protocol run.

<ul>
<li>Default: If no later <code>FinalityTipset</code> has been achieved, set <code>FinalityTipset</code> to <code>LastTrustedCheckpoint</code></li>
</ul></li>
<li><strong>Chain State and Finality</strong>:

<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has.</li>
<li>No new blocks are reported to consumers.</li>
<li>The chain state provided is whatever was loaded from prior executions (worst case is <code>LastTrustedCheckpoint</code>)</li>
</ul></li>
<li><strong>security conditions to transition out:</strong>

<ul>
<li>local state and data structures SHOULD be verified to be correct</li>
<li>this means validating any parts of the chain or <code>StateTree</code> the node has, from <code>LastTrustedCheckpoint</code> on.</li>
<li><code>LastTrustedCheckpoint</code> is well-known across the Filecoin Network to be a true <code>TrustedCheckpoint</code></li>
<li>this SHOULD NOT be verified in software, it SHOULD be verified by operators</li>
<li>Note: we ALWAYS have at least one <code>TrustedCheckpoint</code>, the <code>GenesisCheckpoint</code>.</li>
</ul></li>
<li><strong>transitions out:</strong>

<ul>
<li>once done verifying things: move to <code>BOOTSTRAP</code></li>
</ul></li>
</ul>

<h5 id="chainsync-fsm-bootstrap">ChainSync FSM: <code>BOOTSTRAP</code></h5>

<ul>
<li><code>network.Bootstrap()</code>: establish connections to peers until we satisfy security requirement

<ul>
<li>for better security, use many different <code>libp2p.PeerDiscovery</code> protocols</li>
</ul></li>
<li><code>BlockPubsub.Bootstrap()</code>: establish connections to <code>BlockPubsub</code> peers

<ul>
<li>The subscription is for both peer discovery and to start selecting best heads.
Listing on pubsub from the start keeps the node informed about potential head changes.</li>
</ul></li>
<li><code>Graphsync.Serve()</code>: set up a Graphsync service, that responds to others&rsquo; queries</li>
<li><strong>Chain State and Finality</strong>:

<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has.</li>
<li>No new blocks are reported to consumers.</li>
<li>The chain state provided is whatever was loaded from prior executions (worst case is <code>LastTrustedCheckpoint</code>).</li>
</ul></li>
<li><strong>security conditions to transition out:</strong>

<ul>
<li><code>Network</code> connectivity MUST have reached the security level acceptable for <code>ChainSync</code></li>
<li><code>BlockPubsub</code> connectivity MUST have reached the security level acceptable for <code>ChainSync</code></li>
<li>&ldquo;on time&rdquo; blocks MUST be arriving through <code>BlockPubsub</code></li>
</ul></li>
<li><strong>transitions out:</strong>

<ul>
<li>once bootstrap is deemed secure enough:</li>
<li>if node does not have the <code>Blocks</code> or <code>StateTree</code> corresponding to <code>LastTrustedCheckpoint</code>: move to <code>SYNC_CHECKPOINT</code></li>
<li>otherwise: move to <code>CHAIN_CATCHUP</code></li>
</ul></li>
</ul>

<h5 id="chainsync-fsm-sync-checkpoint">ChainSync FSM: <code>SYNC_CHECKPOINT</code></h5>

<ul>
<li>While in this state:

<ul>
<li><code>ChainSync</code> is well-bootstrapped, but does not yet have the <code>Blocks</code> or <code>StateTree</code> for <code>LastTrustedCheckpoint</code></li>
<li><code>ChainSync</code> issues <code>Graphsync</code> requests to its peers randomly for the <code>Blocks</code> and <code>StateTree</code> for <code>LastTrustedCheckpoint</code>:</li>
<li><code>ChainSync</code>&rsquo;s counterparts in other peers MUST provide the state tree.</li>
<li>It is only semi-rational to do so, so <code>ChainSync</code> may have to try many peers.</li>
<li>Some of these requests MAY fail.</li>
</ul></li>
<li><strong>Chain State and Finality</strong>:

<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has.</li>
<li>No new blocks are reported to consumers.</li>
<li>The chain state provided is the available <code>Blocks</code> and <code>StateTree</code> for <code>LastTrustedCheckpoint</code>.</li>
</ul></li>
<li><strong>Important Notes:</strong>

<ul>
<li><code>ChainSync</code> needs to fetch several blocks: the <code>Block</code> pointed at by <code>LastTrustedCheckpoint</code>, and its direct <code>Block.Parents</code>.</li>
<li>Nodes only need hashing to validate these <code>Blocks</code> and <code>StateTrees</code> &ndash; no block validation or state machine computation is needed.</li>
<li>The initial value of <code>LastTrustedCheckpoint</code> is <code>GenesisCheckpoint</code>, but it MAY be a value later in Chain history.</li>
<li><code>LastTrustedCheckpoint</code> enables efficient syncing by making the implicit economic consensus of chain history explicit.</li>
<li>By allowing fetching of the <code>StateTree</code> of <code>LastTrustedCheckpoint</code> via <code>Graphsync</code>, <code>ChainSync</code> can yield much more
efficient syncing than comparable blockchain synchronization protocols, as syncing and validation can start there.</li>
<li>Nodes DO NOT need to validate the chain from <code>GenesisCheckpoint</code>. <code>LastTrustedCheckpoint</code> MAY be a value later in Chain history.</li>
<li>Nodes DO NOT need to but MAY sync earlier <code>StateTrees</code> than <code>LastTrustedCheckpoint</code> as well.</li>
</ul></li>

<li><p>Pseudocode 1: a basic version of <code>SYNC_CHECKPOINT</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ChainSync</span><span class="p">)</span> <span class="nf">SyncCheckpoint</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">while</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">HasCompleteStateTreeFor</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">LastTrustedCheckpoint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">selector</span> <span class="o">:=</span> <span class="nx">ipldselector</span><span class="p">.</span><span class="nf">SelectAll</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">LastTrustedCheckpoint</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">Graphsync</span><span class="p">.</span><span class="nf">Pull</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Peers</span><span class="p">,</span> <span class="nx">sel</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">IpldStore</span><span class="p">)</span>
        <span class="c1">// Pull SHOULD NOT pull what c.IpldStore already has (check first)
</span><span class="c1"></span>        <span class="c1">// Pull SHOULD pull from different peers simultaneously
</span><span class="c1"></span>        <span class="c1">// Pull SHOULD be efficient (try different parts of the tree from many peers)
</span><span class="c1"></span>        <span class="c1">// Graphsync implementations may not offer these features. These features
</span><span class="c1"></span>        <span class="c1">// can be implemented on top of a graphsync that only pulls from a single
</span><span class="c1"></span>        <span class="c1">// peer and does not check local store first.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">ChainCatchup</span><span class="p">()</span> <span class="c1">// on to CHAIN_CATCHUP
</span><span class="c1"></span><span class="p">}</span></code></pre></div></li>

<li><p><strong>security conditions to transition out:</strong></p>

<ul>
<li><code>StateTree</code> for <code>LastTrustedCheckpoint</code> MUST be stored locally and verified (hashing is enough)</li>
</ul></li>

<li><p><strong>transitions out:</strong></p>

<ul>
<li>once node receives and verifies complete <code>StateTree</code> for <code>LastTrustedCheckpoint</code>: move to <code>CHAIN_CATCHUP</code></li>
</ul></li>
</ul>

<h5 id="chainsync-fsm-chain-catchup">ChainSync FSM: <code>CHAIN_CATCHUP</code></h5>

<ul>
<li>While in this state:

<ul>
<li><code>ChainSync</code> is well-bootstrapped, and has an initial <strong>trusted</strong> <code>StateTree</code> to start from.</li>
<li><code>ChainSync</code> is receiving latest <code>Blocks</code> from <code>BlockPubsub</code></li>
<li><code>ChainSync</code> starts fetching and validating blocks (see <em>Block Fetching and Validation</em> above).</li>
<li><code>ChainSync</code> has unvalidated blocks between <code>ChainSync.FinalityTipset</code> and <code>ChainSync.TargetHeads</code></li>
</ul></li>
<li><strong>Chain State and Finality</strong>:

<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has:</li>
<li><code>FinalityTipset</code> does not change.</li>
<li>No new blocks are reported to consumers/users of <code>ChainSync</code> yet.</li>
<li>The chain state provided is the available <code>Blocks</code> and <code>StateTree</code> for all available epochs,
specially the <code>FinalityTipset</code>.</li>
<li>finality must not move forward here because there are serious attack vectors where a node can be forced to end up on the wrong fork if finality advances before validation is complete up to the block production fringe.</li>
<li>Validation must advance, all the way to the block production fringe:</li>
<li>Validate the whole chain, from <code>FinalityTipset</code> to <code>BestTargetHead</code></li>
<li>The node can reach <code>BestTargetHead</code> only to find out it was invalid, then has to update <code>BestTargetHead</code> with next best one, and sync to it
(without having advanced <code>FinalityTipset</code> yet, as otherwise we may end up on the wrong fork)</li>
</ul></li>
<li><strong>security conditions to transition out:</strong>

<ul>
<li>Gaps between <code>ChainSync.FinalityTipset ... ChainSync.BestTargetHead</code> have been closed:</li>
<li>All <code>Blocks</code> and their content MUST be fetched, stored, linked, and validated locally.
This includes <code>BlockHeaders</code>, <code>Messages</code>, etc.</li>
<li>Bad heads have been expunged from <code>ChainSync.TargetHeads</code>. Bad heads include heads that initially
seemed good but turned out invalid, or heads that <code>ChainSync</code> has failed to connect (ie. cannot
fetch ancestors connecting back to <code>ChainSync.FinalityTipset</code> within a reasonable amount of time).</li>
<li>All blocks between <code>ChainSync.FinalityTipset ... ChainSync.TargetHeads</code> have been validated
This means all blocks <em>before</em> the best heads.</li>
<li>Not under a temporary network partition</li>
</ul></li>
<li><strong>transitions out:</strong>

<ul>
<li>once gaps between <code>ChainSync.FinalityTipset ... ChainSync.TargetHeads</code> are closed: move to <code>CHAIN_FOLLOW</code></li>
<li>(Perhaps moving to <code>CHAIN_FOLLOW</code> when 1-2 blocks back in validation may be ok.</li>
<li>we dont know we have the right head until we validate it, so if other heads of similar height are right/better, we wont know till then.)</li>
</ul></li>
</ul>

<h5 id="chainsync-fsm-chain-follow">ChainSync FSM: <code>CHAIN_FOLLOW</code></h5>

<ul>
<li>While in this state:

<ul>
<li><code>ChainSync</code> is well-bootstrapped, and has an initial <strong>trusted</strong> <code>StateTree</code> to start from.</li>
<li><code>ChainSync</code> fetches and validates blocks (see <em>Block Fetching and Validation</em>).</li>
<li><code>ChainSync</code> is receiving and validating latest <code>Blocks</code> from <code>BlockPubsub</code></li>
<li><code>ChainSync</code> DOES NOT have unvalidated blocks between <code>ChainSync.FinalityTipset</code> and <code>ChainSync.TargetHeads</code></li>
<li><code>ChainSync</code> MUST drop back to another state if security conditions change.</li>
<li>Keep a set of gap measures:</li>
<li><code>BlockGap</code> is the number of remaining blocks to validate between the Validated blocks and <code>BestTargetHead</code>.

<ul>
<li>(ie how many epochs do we need to validate to have validated <code>BestTargetHead</code>. does not include null blocks)</li>
</ul></li>
<li><code>EpochGap</code> is the number of epochs between the latest validated block, and <code>BestTargetHead</code> (includes null blocks).</li>
<li><code>MaxBlockGap = 2</code>, which means how many blocks may <code>ChainSync</code> fall behind on before switching back to <code>CHAIN_CATCHUP</code> (does not include null blocks)</li>
<li><code>MaxEpochGap = 10</code>, which means how many epochs may <code>ChainSync</code> fall behind on before switching back to <code>CHAIN_CATCHUP</code> (includes null blocks)</li>
</ul></li>
<li><strong>Chain State and Finality</strong>:

<ul>
<li>In this state, the <strong>chain MUST advance</strong> as all the blocks up to <code>BestTargetHead</code> are validated.</li>
<li>New blocks are finalized as they cross the finality threshold (<code>ValidG.Heads[0].ChainEpoch - FinalityLookback</code>)</li>
<li>New finalized blocks are reported to consumers.</li>
<li>The chain state provided includes the <code>Blocks</code> and <code>StateTree</code> for the <code>Finality</code> epoch, as well as
candidate <code>Blocks</code> and <code>StateTrees</code> for unfinalized epochs.</li>
</ul></li>
<li><strong>security conditions to transition out:</strong>

<ul>
<li>Temporary network partitions (see <em>Detecting Network Partitions</em>).</li>
<li>Encounter gaps of <code>&gt;MaxBlockGap</code> or <code>&gt;MaxEpochGap</code> between Validated set and a new <code>ChainSync.BestTargetHead</code></li>
</ul></li>
<li><strong>transitions out:</strong>

<ul>
<li>if a temporary network partition is detected: move to <code>CHAIN_CATCHUP</code></li>
<li>if <code>BlockGap &gt; MaxBlockGap</code>: move to <code>CHAIN_CATCHUP</code></li>
<li>if <code>EpochGap &gt; MaxEpochGap</code>: move to <code>CHAIN_CATCHUP</code></li>
<li>if node is shut down: move to <code>INIT</code></li>
</ul></li>
</ul>

<h4 id="block-fetching-validation-and-propagation">Block Fetching, Validation, and Propagation</h4>

<h5 id="notes-on-changing-targetheads-while-syncing">Notes on changing <code>TargetHeads</code> while syncing</h5>

<ul>
<li><code>TargetHeads</code> is changing, as <code>ChainSync</code> must be aware of the best heads at any time. reorgs happen, and our first set of peers could&rsquo;ve been bad, we keep discovering others.

<ul>
<li>Hello protocol is good, but it&rsquo;s polling. unless node is constantly polllng, wont see all the heads.</li>
<li><code>BlockPubsub</code> gives us the realtime view into what&rsquo;s actually going on.</li>
<li>weight can also be close between 2+ possible chains (long-forked), and <code>ChainSync</code> must select the right one (which, we may not be able to distinguish until validating all the way)</li>
</ul></li>
<li>fetching + validation are strictly faster per round on average than blocks produced/block time (if they&rsquo;re not, will always fall behind), so we definitely catch up eventually (and even quickly). the last couple rounds can be close (&ldquo;almost got it, almost got it, there&rdquo;).</li>
</ul>

<h5 id="general-notes-on-fetching-blocks">General notes on fetching Blocks</h5>

<ul>
<li><code>ChainSync</code> selects and maintains a set of the most likely heads to be correct from among those received
via <code>BlockPubsub</code>. As more blocks are received, the set of <code>TargetHeads</code> is reevaluated.</li>
<li><code>ChainSync</code> fetches <code>Blocks</code>, <code>Messages</code>, and <code>StateTree</code> through the <code>Graphsync</code> protocol.</li>
<li><code>ChainSync</code> maintains sets of <code>Blocks/Tipsets</code> in <code>Graphs</code> (see <code>ChainSync.id</code>)</li>
<li><code>ChainSync</code> gathers a list of <code>TargetHeads</code> from <code>BlockPubsub</code>, sorted by likelihood of being the best chain (see below).</li>
<li><code>ChainSync</code> makes requests for chains of <code>BlockHeaders</code> to close gaps between  <code>TargetHeads</code></li>
<li><code>ChainSync</code> forms partial unvalidated chains of <code>BlockHeaders</code>, from those received via <code>BlockPubsub</code>, and those requested via <code>Graphsync</code>.</li>
<li><code>ChainSync</code> attempts to form fully connected chains of <code>BlockHeaders</code>, parting from <code>StateTree</code>, toward observed <code>Heads</code></li>
<li><code>ChainSync</code> minimizes resource expenditures to fetch and validate blocks, to protect against DOS attack vectors.
<code>ChainSync</code> employs <strong>Progressive Block Validation</strong>, validating different facets at different stages of syncing.</li>
<li><code>ChainSync</code> delays syncing <code>Messages</code> until they are needed. Much of the structure of the partial chains can
be checked and used to make syncing decisions without fetching the <code>Messages</code>.</li>
</ul>

<div id="systems__filecoin_blockchain__chainsync__block_validation"></div>

<h5 id="progressive-block-validation">Progressive Block Validation</h5>

<ul>
<li>Blocks can be validated in progressive stages, in order to minimize resource expenditure.</li>
<li>Validation computation is considerable, and a serious DOS attack vector.</li>
<li>Secure implementations must carefully schedule validation and minimize the work done by pruning blocks without validating them fully.</li>
<li><code>ChainSync</code> SHOULD keep a cache of unvalidated blocks (ideally sorted by likelihood of belonging to the chain), and delete unvalidated blocks when they are passed by <code>FinalityTipset</code>, or when <code>ChainSync</code> is under significant resource load.</li>

<li><p>It is key to note that any block received after the <code>ROUND_CUTOFF</code> time must be automatically discarded by the miner until the start of the next epoch.</p></li>

<li><p><strong>Progressive Stages of Block Validation</strong></p>

<ul>
<li><em>(TODO: move this to blockchain/Block section)</em></li>
<li><strong>BV0 - Syntactic Validation</strong>: Validate data structure packing and ensure correct typing.</li>
<li><strong>BV1 - Light Consensus State Checks</strong>: Validate <code>b.ChainWeight</code>, <code>b.ChainEpoch</code>, <code>b.MinerAddress</code>, <code>b.Timestamp</code>, are plausible (some ranges of bad values can be detected easily, especially if we have the state of the chain at <code>b.ChainEpoch - consensus.LookbackParameter</code>. Eg Weight and Epoch have well defined valid ranges, and <code>b.MinerAddress</code>
must exist in the lookback state). This requires some chain state, enough to establish plausibility levels of each of these values. A node should be able to estimate valid ranges for <code>b.ChainEpoch</code> based on the <code>LastTrustedCheckpoint</code>. <code>b.ChainWeight</code> is easy if some of the relatively recent chain is available, otherwise hard.</li>
<li><strong>BV2 - Signature Validation</strong>: Verify <code>b.BlockSig</code> is correct.</li>
<li><strong>BV3 - Verify ElectionProof</strong>: Verify <code>b.ElectionProof</code> is correct. This requires having state for relevant lookback parameters.</li>
<li><strong>BV4 - Verify Ancestry links to chain</strong>: Verify ancestry links back to trusted blocks. If the ancestry forks off before finality, or does not connect at all, it is a bad block.</li>
<li><strong>BV4 - Verify MessageSigs</strong>: Verify the signatures on messages</li>
<li><strong>BV5 - Verify StateTree</strong>: Verify the application of <code>b.Parents.Messages()</code> correctly produces <code>b.StateTree</code> and <code>b.MessageReceipts</code></li>
</ul></li>

<li><p>These stages can be used partially across many blocks in a candidate chain, in order to prune out clearly bad blocks long before actually doing the expensive validation work.</p></li>
</ul>

<p>Notes:
- in <code>CHAIN_CATCHUP</code>, if a node is receiving/fetching hundreds/thousands of <code>BlockHeaders</code>, validating signatures can be very expensive, and can be deferred in favor of other validation. (ie lots of BlockHeaders coming in through network pipe, dont want to bound on sig verification, other checks can help dump blocks on the floor faster (BV0, BV1)
- in <code>CHAIN_FOLLOW</code>, we&rsquo;re not receiving thousands, we&rsquo;re receiving maybe a dozen or 2 dozen packets in a few seconds. We receive cid w/ Sig and addr first (ideally fits in 1 packet), and can afford to (a) check if we already have the cid (if so done, cheap), or (b) if not, check if sig is correct before fetching header (expensive computation, but checking 1 sig is way faster than checking a ton). In practice likely that which one to do is dependent on miner tradeoffs. we&rsquo;ll recommend something but let miners decide, because one strat or the other may be much more effective depending on their hardware, on their bandwidth limitations, or their propensity to getting DOSed</p>

<h5 id="progressive-block-propagation-or-blocksend">Progressive Block Propagation (or BlockSend)</h5>

<ul>
<li>In order to make Block propagation more efficient, we trade off network round trips for bandwidth usage.</li>
<li><strong>Motivating observations:</strong>

<ul>
<li>Block propagation is one of the most security critical points of the whole protocol.</li>
<li>Bandwidth usage during Block propagation is the biggest rate limiter for network scalability.</li>
<li>The time it takes for a Block to propagate to the whole network is a critical factor in determining a secure <code>BlockTime</code></li>
<li>Blocks propagating through the network should take as few <em>sequential</em> roundtrips as possible, as these roundtrips impose serious block time delays. However, interleaved roundtrips may be fine. Meaning that <code>block.CIDs</code> may be propagated on their own, without the header, then the header without the messages, then the messages.</li>
<li><code>Blocks</code> will propagate over a <code>libp2p.PubSub</code>. <code>libp2p.PubSub.Messages</code> will most likely arrive multiple times at a node. Therefore, using only the <code>block.CID</code> here could make this very cheap in bandwidth (more expensive in round trips)</li>
<li><code>Blocks</code> in a single epoch may include the same <code>Messages</code>, and duplicate transfers can be avoided</li>
<li><code>Messages</code> propagate through their own <code>MessagePubsub</code>, and nodes have a significant probability of already having a large fraction of the messages in a block. Since messages are the <em>bulk</em> of the size of a <code>Block</code>, this can present great bandwidth savings.</li>
</ul></li>
<li><strong>Progressive Steps of Block Propagation</strong>

<ul>
<li><strong>IMPORTANT NOTES</strong>:

<ul>
<li>these can be effectively pipelined. The <code>receiver</code> is in control of what to pull, and when. It is up them to decide when to trade-off RTTs for Bandwidth.</li>
<li>If the <code>sender</code> is propagating the block at all to <code>receiver</code>, it is in their interest to provide the full content to <code>receiver</code> when asked. Otherwise the block may not get included at all.</li>
<li>Lots of security assumptions here &ndash; this needs to be hyper verified, in both spec and code.</li>
<li><code>sender</code> is a filecoin node running <code>ChainSync</code>, propagating a block via Gossipsub
(as the originator, as another peer in the network, or just a Gossipsub router).</li>
<li><code>receiver</code> is the local filecoin node running <code>ChainSync</code>, trying to get the blocks.</li>
<li>for <code>receiver</code> to <code>Pull</code> things from <code>sender</code>, <code>receiver</code>must conntect to <code>sender</code>. Usually <code>sender</code> is sending to <code>receiver</code> because of the Gossipsub propagation rules. <code>receiver</code> could choose to <code>Pull</code> from any other node they are connected to, but it is most likely <code>sender</code> will have the needed information. They usually may be more well-connected in the network.</li>
</ul></li>
<li><strong>Step 1. (sender) <code>Push BlockHeader</code></strong>:

<ul>
<li><code>sender</code> sends <code>block.BlockHeader</code> to <code>receiver</code> via Gossipsub:

<ul>
<li><code>bh := Gossipsub.Send(h block.BlockHeader)</code></li>
<li>This is a light-ish object (&lt;4KB).</li>
</ul></li>
<li><code>receiver</code> receives <code>bh</code>.

<ul>
<li>This has many fields that can be validated before pulling the messages. (See <strong>Progressive Block Validation</strong>).</li>
<li><strong>BV0</strong>, <strong>BV1</strong>, and <strong>BV2</strong> validation takes place before propagating <code>bh</code> to other nodes.</li>
<li><code>receiver</code> MAY receive many advertisements for each winning block in an epoch in quick succession. this is because (a) many want propagation as fast as possible, (b) many want to make those network advertisements as light as reasonable, &copy; we want to enable <code>receiver</code> to choose who to ask it from (usually the first party to advertise it, and that&rsquo;s what spec will recommend), and (d) want to be able to fall back to asking others if that fails (fail = dont get it in 1s or so)</li>
</ul></li>
</ul></li>
<li><strong>Step 2. (receiver) <code>Pull MessageCids</code></strong>:

<ul>
<li>upon receiving <code>bh</code>, <code>receiver</code> checks whether it already has the full block for <code>bh.BlockCID</code>. if not:

<ul>
<li><code>receiver</code> requests <code>bh.MessageCids</code> from <code>sender</code>:

<ul>
<li><code>bm := Graphsync.Pull(sender, SelectAMTCIDs(b.Messages))</code></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Step 3. (receiver) <code>Pull Messages</code></strong>:

<ul>
<li>if <code>receiver</code> <strong>DOES NOT</strong> already have the all messages for <code>b.BlockCID</code>, then:

<ul>
<li>if <code>receiver</code> has <em>some</em> of the messages:

<ul>
<li><code>receiver</code> requests missing <code>Messages</code> from <code>sender</code>:

<ul>
<li><code>Graphsync.Pull(sender, SelectAll(bm[3], bm[10], bm[50], ...))</code> or</li>

<li><pre><code>for m in bm {
Graphsync.Pull(sender, SelectAll(m))
}
</code></pre></li>
</ul></li>
</ul></li>
<li>if <code>receiver</code> does not have any of the messages (default safe but expensive thing to do):

<ul>
<li><code>receiver</code> requests all <code>Messages</code> from <code>sender</code>:

<ul>
<li><code>Graphsync.Pull(sender, SelectAll(bh.Messages))</code></li>
</ul></li>
</ul></li>
<li>(This is the largest amount of stuff)</li>
</ul></li>
</ul></li>
<li><strong>Step 4. (receiver) <code>Validate Block</code></strong>:

<ul>
<li>the only remaining thing to do is to complete Block Validation.</li>
</ul></li>
</ul></li>
</ul>

<!--
  - **Step 1. (sender) `Send SignedBlock`**: (TODO: rename to `BlockStamp`)
      - Block propagation begins with the `sender` propagating the `block.SignedBlock`
          - `Gossipsub.Send(b block.SignedBlock)`
      - This is a very light object (~200 bytes), which fits into one network packet.
      - This has the BlockCID, the MinerAddress and the Signature. This enables parties to (a) learn that a block from a particular miner is propagating, (b) validate the `MinerAddress` and `Signature`, and decide whether to invest more resources pulling the `BlockHeader`, or the `Messages`.
      - Note that this can propagate to ther rest of the network before the next steps complete.
  - **Step 2. (receiver) `Pull BlockHeader`**:
      - if `receiver` **DOES NOT** already have the `BlockHeader` for `b.BlockCID`, then:
          - `receiver` requests `BlockHeader` from `sender`:
              - `bh := Graphsync.Pull(sender, SelectCID(b.BlockCID))`
          - This is a light-ish object (<4KB).
          - This has many fields that can be validated before pulling the messages. (See **Progressive Block Validation**).
  - **Step 3. (receiver) `Pull MessageHints` (TODO: validate/decide on this)**:
      - if `receiver` **DOES NOT** already have the full block for `b.BlockCID`, then:
          - `receiver` requests `MessagePoolHints` from `sender`: ...
          - `MessagePoolHints` are TBD -- this is a compressed representation of messages that can expedite message propagation by leveraging prior `MessagePool` syncing.
          - (This is an extension and not required. can just do Step 4.)

-->

<h4 id="calculations">Calculations</h4>

<h5 id="security-parameters">Security Parameters</h5>

<ul>
<li><code>Peers</code> &gt;= 32 &ndash; direct connections

<ul>
<li>ideally <code>Peers</code> &gt;= {64, 128}
-</li>
</ul></li>
</ul>

<h5 id="pubsub-bandwidth">Pubsub Bandwidth</h5>

<p>These bandwidth calculations are used to motivate choices in <code>ChainSync</code>.</p>

<p>If you imagine that you will receive the header once per gossipsub peer (or if lucky, half of them), and that there is EC.E_LEADERS=10 blocks per round, then we&rsquo;re talking the difference between:</p>

<pre><code>16 peers, 1 pkt  -- 1 * 16 * 10 = 160 dup pkts (256KB) in &lt;5s
16 peers, 4 pkts -- 4 * 16 * 10 = 640 dup pkts (1MB)   in &lt;5s

32 peers, 1 pkt  -- 1 * 32 * 10 =   320 dup pkts (512KB) in &lt;5s
32 peers, 4 pkts -- 4 * 32 * 10 = 1,280 dup pkts (2MB)   in &lt;5s

64 peers, 1 pkt  -- 1 * 32 * 10 =   320 dup pkts (1MB) in &lt;5s
64 peers, 4 pkts -- 4 * 32 * 10 = 1,280 dup pkts (4MB)   in &lt;5s
</code></pre>

<p>2MB in &lt;5s may not be worth saving&ndash; and maybe gossipsub can be much better about supressing dups.</p>

<h4 id="notes-todo-move-elsewhere">Notes (TODO: move elsewhere)</h4>

<h5 id="checkpoints">Checkpoints</h5>

<ul>
<li>A checkpoint is the CID of a block (not a tipset list of CIDs, or StateTree)</li>
<li>The reason a block is OK is that it uniquely identifies a tipset.</li>
<li>using tipsets directly would make Checkpoints harder to communicate. we want to make checkpoints a single hash, as short as we can have it. They will be shared in tweets, URLs, emails, printed into newspapers, etc. Compactness, ease of copy-paste, etc matters.</li>
<li>we&rsquo;ll make human readable lists of checkpoints, and making &ldquo;lists of lists&rdquo; is more annoying.</li>
<li>When we have <code>EC.E_PARENTS &gt; 5</code> or <code>= 10</code>, tipsets will get annoyingly large.</li>
<li>the big quirk/weirdness with blocks it that it also must be in the chain. (if you relaxed that constraint you could end up in a weird case where a checkpoint isnt in the chain and that&rsquo;s weird/violates assumptions).</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/138401/67015561-8c929000-f0ab-11e9-847a-ec42f23b14da.png" alt="" /></p>

<h5 id="bootstrap-chain-stub">Bootstrap chain stub</h5>

<ul>
<li>the mainnet filecoin chain will need to start with a small chain stub of blocks.</li>
<li>we must include some data in different blocks.</li>
<li>we do need a genesis block &ndash; we derive randomness from the ticket there. Rather than special casing, it is easier/less complex to ensure a well-formed chain always, including at the beginning</li>
<li>A lot of code expects lookbacks, especially actor code. Rather than introducing a bunch of special case logic for what happens ostensibly once in network history (special case logic which adds complexity and likelihood of problems), it is easiest to assume the chain is always at least X blocks long, and the system lookback parameters are all fine and dont need to be scaled in the beginning of network&rsquo;s history.</li>
</ul>

<h5 id="partialgraph">PartialGraph</h5>

<p>The <code>PartialGraph</code> of blocks.</p>

<blockquote>
<p>Is a graph necessarily connected, or is this just a bag of blocks, with each disconnected subgraph being reported in heads/tails?</p>
</blockquote>

<p>The latter.  the partial graph is a DAG fragment&ndash; including disconnected components.
here&rsquo;s a visual example, 4 example PartialGraphs, with Heads and Tails. (note they aren&rsquo;t tipsets)</p>

<p><img src="https://user-images.githubusercontent.com/138401/67014349-90bdae00-f0a9-11e9-9f29-bdca6c673c4b.png" alt="" /></p>


</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__storage_power_consensus">

<h3 class="section-header">
  Storage Power Consensus
</h3>

<div class="section-content">






































<p><div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_consensus"></div>
The Storage Power Consensus subsystem is the main interface which enables Filecoin nodes to agree on the state of the system. SPC accounts for individual storage miners&rsquo; effective power over consensus in given chains in its <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a>. It also runs <a href="./#algorithms__expected_consensus___index">Expected Consensus</a> (the underlying consensus algorithm in use by Filecoin), enabling storage miners to run leader election and generate new blocks updating the state of the Filecoin system.</p>

<p>Succinctly, the SPC subsystem offers the following services:
- Access to the <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a> for every subchain, accounting for individual storage miner power and total power on-chain.
- Access to <a href="./#algorithms__expected_consensus___index">Expected Consensus</a> for individual storage miners, enabling:
    - Access to verifiable randomness <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a> as needed in the rest of the protocol.
    - Running  <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> to produce new blocks.
    - Running <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> across subchains using EC&rsquo;s weighting function.
    - Identification of <a href="./#algorithms__expected_consensus__finality">the most recently finalized tipset</a>, for use by all protocol participants.</p>

<p>Much of the Storage Power Consensus&rsquo; subsystem functionality is detailed in the code below but we touch upon some of its behaviors in more detail.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusSubsystem</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">//(@mutable)
</span><span class="c1"></span>    <span class="c1">// actor                StoragePowerActor
</span><span class="c1"></span>    <span class="nx">associatedStateTree</span> <span class="o">&amp;</span><span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>  <span class="c1">// TODO: remove this. should not store this here.
</span><span class="c1"></span>
    <span class="nf">GenerateElectionProof</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
    <span class="nf">ChooseTipsetToMine</span><span class="p">(</span><span class="nx">tipsets</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">])</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">]</span>

    <span class="nx">ec</span> <span class="nx">ExpectedConsensus</span>

    <span class="c1">// call by BlockchainSubsystem during block reception
</span><span class="c1"></span>    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">IsWinningElectionProof</span><span class="p">(</span>
        <span class="nx">electionProof</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
        <span class="nx">workerAddr</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">validateElectionProof</span><span class="p">(</span>
        <span class="nx">height</span>         <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
        <span class="nx">electionProof</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
        <span class="nx">workerAddr</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">validateTicket</span><span class="p">(</span><span class="nx">tix</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">computeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>

    <span class="nf">StoragePowerConsensusError</span><span class="p">()</span> <span class="nx">StoragePowerConsensusError</span>

    <span class="c1">// Randomness methods
</span><span class="c1"></span>
    <span class="c1">// call by StorageMiningSubsystem during block production
</span><span class="c1"></span>    <span class="nf">GetTicketProductionSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="c1">// call by StorageMiningSubsystem during block production
</span><span class="c1"></span>    <span class="nf">GetElectionProofSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="c1">// call by StorageMiningSubsystem in sealing sector
</span><span class="c1"></span>    <span class="nf">GetSealSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="c1">// call by StorageMiningSubsystem after sealing
</span><span class="c1"></span>    <span class="nf">GetPoStChallenge</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="nf">GetFinality</span><span class="p">()</span>     <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nf">FinalizedEpoch</span><span class="p">()</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusError</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>






<h4 id="distinguishing-between-storage-miners-and-block-miners">Distinguishing between storage miners and block miners</h4>

<p>There are two ways to earn Filecoin tokens in the Filecoin network:
- By participating in the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> as a storage provider and being paid by clients for file storage deals.
- By mining new blocks on the network, helping modify system state and secure the Filecoin consensus mechanism.</p>

<p>We must distinguish between both types of &ldquo;miners&rdquo; (storage and block miners). <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> in Filecoin is predicated on a miner&rsquo;s storage power. Thus, while all block miners will be storage miners, the reverse is not necessarily true.</p>

<p>However, given Filecoin&rsquo;s &ldquo;useful Proof-of-Work&rdquo; is achieved through file storage (PoRep and PoSt), there is little overhead cost for storage miners to participate in leader election. Such a <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">Storage Miner Actor</a> need only register with the <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">Storage Power Actor</a> in order to participate in Expected Consensus and mine blocks.</p>

<div id="systems__filecoin_blockchain__storage_power_consensus__tickets"></div>

<h5 id="tickets">Tickets</h5>

<p>Tickets are used across the Filecoin protocol as sources of randomness:
- The <a href="./#systems__filecoin_mining__storage_proving__sector_sealer">Sector Sealer</a> uses tickets as SealSeeds to bind sector commitments to a given subchain.
- The <a href="./#systems__filecoin_mining__storage_mining">Storage Miner</a> likewise uses tickets as PoStChallenges to prove sectors remain committed as of a given block.
- They are drawn by the Storage Power subsystem as randomness in <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> to determine their eligibility to mine a block
- They are drawn by the Storage Power subsystem in order to generate new tickets for future use.</p>

<p>Each of these ticket uses may require drawing tickets at different chain epochs, according to the security requirements of the particular protocol making use of tickets. Specifically, the ticket output (which is a SHA256 output) is used for randomness.</p>

<p>In Filecoin, every block header contains a single ticket.</p>

<p>You can find the Ticket data structure <a href="./#listings__data_structures">here</a>.</p>

<h6 id="comparing-tickets-in-a-tipset">Comparing Tickets in a Tipset</h6>

<p>Whenever comparing tickets is evoked in Filecoin, for instance when discussing selecting the &ldquo;min ticket&rdquo; in a Tipset, the comparison is that of the little endian representation of the ticket&rsquo;s VFOutput bytes.</p>

<div id="systems__filecoin_blockchain__storage_power_consensus__ticket_chain"></div>

<h5 id="the-ticket-chain-and-drawing-randomness">The Ticket chain and drawing randomness</h5>

<p>While each Filecoin block header contains a ticket field (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>), it is useful to think of a ticket chain abstraction.
Due to the nature of Filecoin&rsquo;s Tipsets and the possibility of using tickets from epochs that did not yield leaders to produce randomness at a given epoch, tracking the canonical ticket of a subchain at a given height can be arduous to reason about in terms of blocks. To that end, it is helpful to create a ticket chain abstraction made up of only those tickets to be used for randomness generation at a given height.</p>

<p>To sample a ticket for a given epoch n:
- Set referenceTipsetOffset = 0
- While true:
    - Set referenceTipsetHeight = n - referenceTipsetOffset
    - If blocks were mined at referenceTipsetHeight:
        - ReferenceTipset = TipsetAtHeight(referenceTipsetHeight)
        - Select the block in ReferenceTipset with the smallest final ticket, return its ticket (pastTicket).
    - If no blocks were mined at referenceTipsetHeight:
        - Increment referenceTipsetOffset
        - (Repeat)
- newRandomness = H(pastTicket || minerAddress || n)</p>

<p>In english, this means two things:
- When sampling a ticket from an epoch with no blocks, draw the min ticket from the prior epoch with blocks and concatenate it with
    - the minerAddress of the miner using this input
    - the wanted epoch number
    - hash this concatenation for a usable ticket value
- Choose the smallest ticket in the Tipset if it contains multiple blocks.</p>

<p>See the <code>RandomnessAtEpoch</code> method below:
















<p style="color: #D74848"><b><i>Something's not right. The <code>block.go</code> file was not found.</i></b></p>

</p>

<p>The above means that ticket randomness is reseeded with every new block, but can indeed be derived by any miner for an arbitrary epoch number using a past epoch. However, this does not affect protocol security under Filecoin&rsquo;s clock synchrony assumption.</p>

<div id="systems__filecoin_blockchain__storage_power_consensus__ticket_generation"></div>

<h6 id="ticket-generation">Ticket generation</h6>

<p>This section discusses how tickets are generated by EC for the <code>Ticket</code> field in every block header.</p>

<p>At round <code>N</code>, a new ticket is generated using tickets drawn from the Tipset at round <code>N-1</code> (as shown below).</p>

<p>The miner runs the prior ticket through a Verifiable Random Function (VRF) to get a new unique ticket which can later be derived for randomness (as shown above).</p>

<p>The VRF&rsquo;s deterministic output adds entropy to the ticket chain, limiting a miner&rsquo;s ability to alter one block to influence a future ticket (given a miner does not know who will win a given round in advance).</p>

<p>We use the VRF from <a href="./#algorithms__crypto__vrf">Verifiable Random Function</a> for ticket generation in EC (see the <code>PrepareNewTicket</code> method below).</p>

<p>















<p style="color: #D74848"><b><i>Something's not right. The <code>storage_mining_subsystem.id</code> file was not found.</i></b></p>


















<p style="color: #D74848"><b><i>Something's not right. The <code>storage_mining_subsystem.go</code> file was not found.</i></b></p>

</p>

<h6 id="ticket-validation">Ticket Validation</h6>

<p>Each Ticket should be generated from the prior one in the ticket-chain and verified accordingly as shown in <code>validateTicket</code> below.</p>

<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusSubsystem</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">//(@mutable)
</span><span class="c1"></span>    <span class="c1">// actor                StoragePowerActor
</span><span class="c1"></span>    <span class="nx">associatedStateTree</span> <span class="o">&amp;</span><span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>  <span class="c1">// TODO: remove this. should not store this here.
</span><span class="c1"></span>
    <span class="nf">GenerateElectionProof</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
    <span class="nf">ChooseTipsetToMine</span><span class="p">(</span><span class="nx">tipsets</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">])</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">]</span>

    <span class="nx">ec</span> <span class="nx">ExpectedConsensus</span>

    <span class="c1">// call by BlockchainSubsystem during block reception
</span><span class="c1"></span>    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">IsWinningElectionProof</span><span class="p">(</span>
        <span class="nx">electionProof</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
        <span class="nx">workerAddr</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">validateElectionProof</span><span class="p">(</span>
        <span class="nx">height</span>         <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
        <span class="nx">electionProof</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
        <span class="nx">workerAddr</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">validateTicket</span><span class="p">(</span><span class="nx">tix</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">computeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>

    <span class="nf">StoragePowerConsensusError</span><span class="p">()</span> <span class="nx">StoragePowerConsensusError</span>

    <span class="c1">// Randomness methods
</span><span class="c1"></span>
    <span class="c1">// call by StorageMiningSubsystem during block production
</span><span class="c1"></span>    <span class="nf">GetTicketProductionSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="c1">// call by StorageMiningSubsystem during block production
</span><span class="c1"></span>    <span class="nf">GetElectionProofSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="c1">// call by StorageMiningSubsystem in sealing sector
</span><span class="c1"></span>    <span class="nf">GetSealSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="c1">// call by StorageMiningSubsystem after sealing
</span><span class="c1"></span>    <span class="nf">GetPoStChallenge</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>

    <span class="nf">GetFinality</span><span class="p">()</span>     <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nf">FinalizedEpoch</span><span class="p">()</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusError</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_power_consensus</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
	<span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">FINALITY</span> <span class="p">=</span> <span class="mi">500</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">SPC_LOOKBACK_RANDOMNESS</span> <span class="p">=</span> <span class="mi">300</span>      <span class="c1">// this is EC.K maybe move it there. TODO
</span><span class="c1"></span>	<span class="nx">SPC_LOOKBACK_TICKET</span>     <span class="p">=</span> <span class="mi">1</span>        <span class="c1">// we chain blocks together one after the other
</span><span class="c1"></span>	<span class="nx">SPC_LOOKBACK_POST</span>       <span class="p">=</span> <span class="mi">1</span>        <span class="c1">// cheap to generate, should be set as close to current TS as possible
</span><span class="c1"></span>	<span class="nx">SPC_LOOKBACK_SEAL</span>       <span class="p">=</span> <span class="nx">FINALITY</span> <span class="c1">// should be set to finality
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">VRFPersonalizationTicket</span>        <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">VRFPersonalizationElectionProof</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span>

<span class="c1">// Storage Power Consensus Subsystem
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block_I</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// minerPK := PowerTable.GetMinerPublicKey(block.MinerAddress())
</span><span class="c1"></span>	<span class="c1">// minerPower := PowerTable.GetMinerPower(block.MinerAddress())
</span><span class="c1"></span>
	<span class="c1">// // 1. Verify miner has not been slashed and is still valid miner
</span><span class="c1"></span>	<span class="c1">// if minerPower &lt;= 0 {
</span><span class="c1"></span>	<span class="c1">// 	return StoragePowerConsensusError(&#34;block miner not valid&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// // 2. Verify ParentWeight
</span><span class="c1"></span>	<span class="c1">// if block.Weight() != computeTipsetWeight(block.Parents()) {
</span><span class="c1"></span>	<span class="c1">// 	return errors.New(&#34;invalid parent weight&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// // 3. Verify Tickets
</span><span class="c1"></span>	<span class="c1">// if !validateTicket(block.Ticket, minerPK) {
</span><span class="c1"></span>	<span class="c1">// 	return StoragePowerConsensusError(&#34;ticket was invalid&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// // 4. Verify ElectionProof construction
</span><span class="c1"></span>	<span class="c1">// if !ValidateElectionProof(block.Height, block.ElectionProof, block.MinerAddress) {
</span><span class="c1"></span>	<span class="c1">// 	return StoragePowerConsensusError(&#34;election proof was not a valid signature of the last ticket&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// // 5. and value
</span><span class="c1"></span>	<span class="c1">// if !IsWinningElectionProof(block.ElectionProof, spa.GetMinerPower(), spa.GetTotalPower()) {
</span><span class="c1"></span>	<span class="c1">// 	return StoragePowerConsensusError(&#34;election proof was not a winner&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// return nil
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">validateTicket</span><span class="p">(</span><span class="nx">ticket</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// Randomness1 := storagePowerConsensus.GetTicketProductionSeed(sms.CurrentChain, sms.Blockchain.LatestEpoch())
</span><span class="c1"></span>	<span class="c1">// input := VRFPersonalizationTicket
</span><span class="c1"></span>	<span class="c1">// input.append(Randomness1)
</span><span class="c1"></span>	<span class="c1">// return ticket.Verify(input, pk)
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">ComputeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">ec</span><span class="p">().</span><span class="nf">ComputeChainWeight</span><span class="p">(</span><span class="nx">tipset</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">StoragePowerConsensusError</span><span class="p">(</span><span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">StoragePowerConsensusError</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">IsWinningElectionProof</span><span class="p">(</span><span class="nx">electionProof</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span><span class="p">,</span> <span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// return spc.ec().IsWinningElectionProof(electionProof, minerPower, totalPower)
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">GetTicketProductionSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">epoch</span><span class="o">-</span><span class="nx">SPC_LOOKBACK_TICKET</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">GetElectionProofSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">epoch</span><span class="o">-</span><span class="nx">SPC_LOOKBACK_RANDOMNESS</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">GetSealSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">epoch</span><span class="o">-</span><span class="nx">SPC_LOOKBACK_SEAL</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">GetPoStChallenge</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">epoch</span><span class="o">-</span><span class="nx">SPC_LOOKBACK_POST</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">ValidateElectionProof</span><span class="p">(</span><span class="nx">height</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">electionProof</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span><span class="p">,</span> <span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// // 1. Check that ElectionProof was validated in appropriate time
</span><span class="c1"></span>	<span class="c1">// if height &gt; clock.roundTime {
</span><span class="c1"></span>	<span class="c1">// 	return false
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// // 2. Determine that ticket was validly scratched
</span><span class="c1"></span>	<span class="c1">// minerPK := spc.PowerTable.GetMinerPublicKey(workerAddr)
</span><span class="c1"></span>	<span class="c1">// input := VRFPersonalizationElectionProof
</span><span class="c1"></span>	<span class="c1">// TK := storagePowerConsensus.GetElectionProofSeed(sms.CurrentChain, sms.block.LatestEpoch())
</span><span class="c1"></span>	<span class="c1">// input.append(TK.Output)
</span><span class="c1"></span>	<span class="c1">// input.append(height)
</span><span class="c1"></span>
	<span class="c1">// return electionProof.Verify(input, minerPK)
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">GetFinality</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// return FINALITY
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">FinalizedEpoch</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// currentEpoch := rt.HeadEpoch()
</span><span class="c1"></span>	<span class="c1">// return currentEpoch - spc.GetFinality()
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>




</p>

<h6 id="repeated-leader-election-attempts">Repeated Leader Election attempts</h6>

<p>In the case that no miner is eligible to produce a block in a given round of EC, the storage power consensus subsystem will be called by the block producer to attempt another leader election by incrementing the nonce appended to the ticket drawn from the past in order to attempt to craft a new valid <code>ElectionProof</code> and trying again.
 Note that a miner may attempt to grind through tickets by incrementing the nonce repeatedly until they find a winning ticket. However, any block so generated in the future will be rejected by other miners (with synchronized clocks) until that epoch&rsquo;s appropriate time.</p>


</div>


  
    








<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">

<h4 class="section-header">
  Storage Power Actor
</h4>

<div class="section-content">






































<h5 id="storagepoweractor-interface"><code>StoragePowerActor</code> interface</h5>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="kd">type</span> <span class="nx">PowerTableEntry</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ActivePower</span>             <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nx">InactivePower</span>           <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nx">AvailableBalance</span>        <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">LockedPledgeCollateral</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PowerReport</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ActivePower</span>    <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>  <span class="c1">// set value
</span><span class="c1"></span>    <span class="nx">InactivePower</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>  <span class="c1">// set value
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">FaultReport</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">NewDeclaredFaults</span>          <span class="nx">UVarint</span>  <span class="c1">// diff value
</span><span class="c1"></span>    <span class="nx">NewDetectedFaults</span>          <span class="nx">UVarint</span>  <span class="c1">// diff value
</span><span class="c1"></span>    <span class="nx">NewTerminatedFaults</span>        <span class="nx">UVarint</span>  <span class="c1">// diff value
</span><span class="c1"></span>
    <span class="nf">GetDeclaredFaultSlash</span><span class="p">()</span>    <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nf">GetDetectedFaultSlash</span><span class="p">()</span>    <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nf">GetTerminatedFaultSlash</span><span class="p">()</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="c1">// type PowerTableHAMT {actor.ActorID: PowerTableEntry}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PowerTableHAMT</span> <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">PowerTableEntry</span><span class="p">}</span>  <span class="c1">// TODO: convert address to ActorID
</span><span class="c1"></span>
<span class="c1">// TODO: What does graceful removal look like?
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">StoragePowerActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// PowerTable is a mapping from MinerActorID to PowerTableEntry
</span><span class="c1"></span>    <span class="nx">PowerTable</span>  <span class="nx">PowerTableHAMT</span>
    <span class="nx">EC</span>          <span class="nx">ExpectedConsensus</span>

    <span class="nf">_slashPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">_lockPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">_unlockPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">_getPledgeCollateralReq</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">newPower</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nf">_sampleMinersToSurprise</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">challengeCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StoragePowerActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>
    <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>

    <span class="c1">// call by StorageMiningSubsytem on miner creation
</span><span class="c1"></span>    <span class="nf">CreateStorageMiner</span><span class="p">(</span>
        <span class="c1">// TODO: document differences in Addr, Key and ID accross spec
</span><span class="c1"></span>        <span class="nx">rt</span>          <span class="nx">Runtime</span>
        <span class="nx">ownerAddr</span>   <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">workerAddr</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">peerId</span>      <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>  <span class="c1">// TODO: will be removed likely (see: https://github.com/filecoin-project/specs/pull/555#pullrequestreview-300991681)
</span><span class="c1"></span>    <span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="nf">RemoveStorageMiner</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>

    <span class="c1">// PowerTable Operations
</span><span class="c1"></span>    <span class="nf">GetTotalPower</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>

    <span class="nf">EnsurePledgeCollateralSatisfied</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">ProcessPowerReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">report</span> <span class="nx">PowerReport</span><span class="p">)</span>
    <span class="nf">ProcessFaultReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">report</span> <span class="nx">FaultReport</span><span class="p">)</span>
    <span class="nf">ReportConsensusFault</span><span class="p">(</span>
        <span class="c1">// slasherAddr  addr.Address TODO: fromActor
</span><span class="c1"></span>        <span class="nx">rt</span>         <span class="nx">Runtime</span>
        <span class="nx">faultType</span>  <span class="nx">ConsensusFaultType</span>
        <span class="nx">proof</span>      <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="nf">Surprise</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">ticket</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">)</span> <span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>
    <span class="c1">// this should be part of ReportConsensusFault, numSectors should be all sectors
</span><span class="c1"></span>    <span class="c1">// ReportUncommittedPowerFault(cheaterAddr addr.Address, numSectors UVarint)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>






<h5 id="storagepoweractor-implementation"><code>StoragePowerActor</code> implementation</h5>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_power_consensus</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
	<span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
	<span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
	<span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
	<span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Method_StoragePowerActor_ProcessPowerReport</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodPlaceholder</span>
	<span class="nx">Method_StoragePowerActor_ProcessFaultReport</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodPlaceholder</span>
<span class="p">)</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Boilerplate
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>
<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">State</span> <span class="p">=</span> <span class="nx">StoragePowerActorState</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">()</span>
	<span class="nx">stateBytes</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">ipld</span><span class="p">.</span><span class="nf">CID</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">stateBytes</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime_IpldGet_FunRet_Case_Bytes</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;IPLD lookup error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">stateBytes</span><span class="p">.</span><span class="nf">As_Bytes</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">State</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">FaultReport_I</span><span class="p">)</span> <span class="nf">GetDeclaredFaultSlash</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">FaultReport_I</span><span class="p">)</span> <span class="nf">GetDetectedFaultSlash</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">FaultReport_I</span><span class="p">)</span> <span class="nf">GetTerminatedFaultSlash</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState_I</span><span class="p">)</span> <span class="nf">_slashPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">amount</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: convert address to MinerActorID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">currEntry</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;minerID not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">amountToSlash</span> <span class="o">:=</span> <span class="nx">amount</span>

	<span class="k">if</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">LockedPledgeCollateral</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">amount</span> <span class="p">{</span>
		<span class="nx">amountToSlash</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">LockedPledgeCollateral_</span>
		<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">LockedPledgeCollateral_</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="c1">// TODO: extra handling of not having enough pledgecollateral to be slashed
</span><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">LockedPledgeCollateral_</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">LockedPledgeCollateral</span><span class="p">()</span> <span class="o">-</span> <span class="nx">amount</span>
	<span class="p">}</span>

	<span class="c1">// TODO: send amountToSlash to TreasuryActor
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">amountToSlash</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">PowerTable_</span><span class="p">[</span><span class="nx">minerID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">currEntry</span>

	<span class="c1">// TODO: commit state change
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// TODO: batch process this if possible
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState_I</span><span class="p">)</span> <span class="nf">_lockPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// AvailableBalance -&gt; LockedPledgeCollateral
</span><span class="c1"></span>	<span class="c1">// TODO: potentially unnecessary check
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">amount</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: convert address to MinerActorID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">currEntry</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;minerID not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">AvailableBalance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">amount</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;insufficient available balance.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">AvailableBalance_</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">AvailableBalance</span><span class="p">()</span> <span class="o">-</span> <span class="nx">amount</span>
	<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">LockedPledgeCollateral_</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">LockedPledgeCollateral</span><span class="p">()</span> <span class="o">+</span> <span class="nx">amount</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">PowerTable_</span><span class="p">[</span><span class="nx">minerID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">currEntry</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState_I</span><span class="p">)</span> <span class="nf">_unlockPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// lockedPledgeCollateral -&gt; AvailableBalance
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">amount</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: convert address to MinerActorID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">currEntry</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;minerID not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">LockedPledgeCollateral</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">amount</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;insufficient locked balance.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">LockedPledgeCollateral_</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">LockedPledgeCollateral</span><span class="p">()</span> <span class="o">-</span> <span class="nx">amount</span>
	<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">AvailableBalance_</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">AvailableBalance</span><span class="p">()</span> <span class="o">+</span> <span class="nx">amount</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">PowerTable_</span><span class="p">[</span><span class="nx">minerID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">currEntry</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState_I</span><span class="p">)</span> <span class="nf">_getPledgeCollateralReq</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">power</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>

	<span class="c1">// TODO: Implement
</span><span class="c1"></span>	<span class="nx">pcRequired</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">pcRequired</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState_I</span><span class="p">)</span> <span class="nf">_sampleMinersToSurprise</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">challengeCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="c1">// this wont quite work -- a.PowerTable() is a HAMT by actor address, doesn&#39;t
</span><span class="c1"></span>	<span class="c1">// support enumerating by int index. maybe we need that as an interface too,
</span><span class="c1"></span>	<span class="c1">// or something similar to an iterator (or iterator over the keys)
</span><span class="c1"></span>	<span class="c1">// or even a seeded random call directly in the HAMT: myhamt.GetRandomElement(seed []byte, idx int)
</span><span class="c1"></span>
	<span class="nx">allMiners</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()))</span>
	<span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">address</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">allMiners</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">address</span>
		<span class="nx">index</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">postSurpriseSample</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">allMiners</span><span class="p">,</span> <span class="nx">challengeCount</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// postSurpriseSample implements the PoSt-Surprise sampling algorithm
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">postSurpriseSample</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">allMiners</span> <span class="p">[]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">challengeCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>

	<span class="nx">sm</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">challengeCount</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">challengeCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="c1">// rInt := rt.NextRandomInt() // we need something like this in the runtime
</span><span class="c1"></span>		<span class="nx">rInt</span> <span class="o">:=</span> <span class="mi">4</span> <span class="c1">// xkcd prng for now.
</span><span class="c1"></span>		<span class="nx">miner</span> <span class="o">:=</span> <span class="nx">allMiners</span><span class="p">[</span><span class="nx">rInt</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="nx">allMiners</span><span class="p">)]</span>
		<span class="nx">sm</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sm</span><span class="p">,</span> <span class="nx">miner</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">sm</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>

	<span class="kd">var</span> <span class="nx">msgValue</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

	<span class="c1">// TODO: this should be enforced somewhere else
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">msgValue</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative message value.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: convert msgSender to MinerActorID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">currEntry</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="c1">// AddBalance will just fail if miner is not created before hand
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;minerID not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">AvailableBalance_</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">AvailableBalance</span><span class="p">()</span> <span class="o">+</span> <span class="nx">msgValue</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">PowerTable_</span><span class="p">[</span><span class="nx">minerID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">currEntry</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nx">amount</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: convert msgSender to MinerActorID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">currEntry</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;minerID not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">AvailableBalance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">amount</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;insufficient balance.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">currEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">AvailableBalance_</span> <span class="p">=</span> <span class="nx">currEntry</span><span class="p">.</span><span class="nf">AvailableBalance</span><span class="p">()</span> <span class="o">-</span> <span class="nx">amount</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">PowerTable_</span><span class="p">[</span><span class="nx">minerID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">currEntry</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// TODO: send funds to msgSender
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">CreateStorageMiner</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span>
	<span class="nx">ownerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">peerId</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>

	<span class="c1">// TODO: anything to check here?
</span><span class="c1"></span>	<span class="nx">newMiner</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PowerTableEntry_I</span><span class="p">{</span>
		<span class="nx">ActivePower_</span><span class="p">:</span>            <span class="nx">block</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">InactivePower_</span><span class="p">:</span>          <span class="nx">block</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">AvailableBalance_</span><span class="p">:</span>       <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">LockedPledgeCollateral_</span><span class="p">:</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="c1">// TODO: call constructor of StorageMinerActor
</span><span class="c1"></span>	<span class="c1">// store ownerAddr and workerAddr there
</span><span class="c1"></span>	<span class="c1">// and return StorageMinerActor address
</span><span class="c1"></span>
	<span class="c1">// TODO: minerID should be a MinerActorID
</span><span class="c1"></span>	<span class="c1">// which is smaller than MinerAddress
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newMiner</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">minerID</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">RemoveStorageMiner</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// TODO: make explicit address type
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">].</span><span class="nf">ActivePower</span><span class="p">()</span> <span class="o">+</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">].</span><span class="nf">InactivePower</span><span class="p">())</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;power still remains.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">(),</span> <span class="nx">minerID</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">GetTotalPower</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>

	<span class="nx">totalPower</span> <span class="o">:=</span> <span class="nx">block</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">miner</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">totalPower</span> <span class="p">=</span> <span class="nx">totalPower</span> <span class="o">+</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">ActivePower</span><span class="p">()</span> <span class="o">+</span> <span class="nx">miner</span><span class="p">.</span><span class="nf">InactivePower</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">totalPower</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">EnsurePledgeCollateralSatisfied</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>

	<span class="nx">ret</span> <span class="o">:=</span> <span class="kc">false</span>

	<span class="c1">// TODO: convert msgSender to MinerActorID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">powerEntry</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;miner not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">pledgeCollateralRequired</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getPledgeCollateralReq</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">powerEntry</span><span class="p">.</span><span class="nf">ActivePower</span><span class="p">()</span><span class="o">+</span><span class="nx">powerEntry</span><span class="p">.</span><span class="nf">InactivePower</span><span class="p">())</span>

	<span class="k">if</span> <span class="nx">pledgeCollateralRequired</span> <span class="p">&lt;</span> <span class="nx">powerEntry</span><span class="p">.</span><span class="nf">LockedPledgeCollateral</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">pledgeCollateralRequired</span> <span class="p">&lt;</span> <span class="p">(</span><span class="nx">powerEntry</span><span class="p">.</span><span class="nf">LockedPledgeCollateral</span><span class="p">()</span> <span class="o">+</span> <span class="nx">powerEntry</span><span class="p">.</span><span class="nf">AvailableBalance</span><span class="p">())</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_lockPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerID</span><span class="p">,</span> <span class="p">(</span><span class="nx">pledgeCollateralRequired</span> <span class="o">-</span> <span class="nx">powerEntry</span><span class="p">.</span><span class="nf">LockedPledgeCollateral</span><span class="p">()))</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">ProcessFaultReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">report</span> <span class="nx">FaultReport</span><span class="p">)</span> <span class="p">{</span>

	<span class="kd">var</span> <span class="nx">msgSender</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="c1">// TODO replace this
</span><span class="c1"></span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">declaredFaultSlash</span> <span class="o">:=</span> <span class="nx">report</span><span class="p">.</span><span class="nf">GetDeclaredFaultSlash</span><span class="p">()</span>
	<span class="nx">detectedFaultSlash</span> <span class="o">:=</span> <span class="nx">report</span><span class="p">.</span><span class="nf">GetDetectedFaultSlash</span><span class="p">()</span>
	<span class="nx">terminatedFaultSlash</span> <span class="o">:=</span> <span class="nx">report</span><span class="p">.</span><span class="nf">GetTerminatedFaultSlash</span><span class="p">()</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_slashPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">msgSender</span><span class="p">,</span> <span class="p">(</span><span class="nx">declaredFaultSlash</span> <span class="o">+</span> <span class="nx">detectedFaultSlash</span> <span class="o">+</span> <span class="nx">terminatedFaultSlash</span><span class="p">))</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">ProcessPowerReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">report</span> <span class="nx">PowerReport</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// TODO: convert msgSender to MinerActorID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">minerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">powerEntry</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">()[</span><span class="nx">minerID</span><span class="p">]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;miner not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">powerEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ActivePower_</span> <span class="p">=</span> <span class="nx">report</span><span class="p">.</span><span class="nf">ActivePower</span><span class="p">()</span>
	<span class="nx">powerEntry</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">InactivePower_</span> <span class="p">=</span> <span class="nx">report</span><span class="p">.</span><span class="nf">InactivePower</span><span class="p">()</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">PowerTable_</span><span class="p">[</span><span class="nx">minerID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">powerEntry</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">ReportConsensusFault</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">slasherAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">faultType</span> <span class="nx">ConsensusFaultType</span><span class="p">,</span> <span class="nx">proof</span> <span class="p">[]</span><span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>

	<span class="c1">// Use EC&#39;s IsValidConsensusFault method to validate the proof
</span><span class="c1"></span>	<span class="c1">// slash block miner&#39;s pledge collateral
</span><span class="c1"></span>	<span class="c1">// reward slasher
</span><span class="c1"></span>
	<span class="c1">// include ReportUncommittedPowerFault(cheaterAddr addr.Address, numSectors util.UVarint) as case
</span><span class="c1"></span>	<span class="c1">// Quite a bit more straightforward since only called by the cron actor (ie publicly verified)
</span><span class="c1"></span>	<span class="c1">// slash cheater pledge collateral accordingly based on num sectors faulted
</span><span class="c1"></span>
<span class="p">}</span>

<span class="c1">// TODO: add Surprise to the cron actor
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">Surprise</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">ticket</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// The number of blocks that a challenged miner has to respond
</span><span class="c1"></span>	<span class="c1">// TODO: this should be set in.. spa?
</span><span class="c1"></span>	<span class="c1">// var postChallengeTime util.UInt
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">provingPeriod</span> <span class="kt">uint</span> <span class="c1">// TODO
</span><span class="c1"></span>
	<span class="c1">// sample the actor addresses
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">challengeCount</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PowerTable</span><span class="p">())</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="nx">provingPeriod</span><span class="p">)</span>
	<span class="nx">surprisedMiners</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_sampleMinersToSurprise</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">challengeCount</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// now send the messages
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">surprisedMiners</span> <span class="p">{</span>
		<span class="c1">// TODO: rt.SendMessage(addr, ...)
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActorCode_I</span><span class="p">)</span> <span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>






<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table"></div>

<h5 id="the-power-table">The Power Table</h5>

<p>The portion of blocks a given miner generates through leader election in EC (and so the block rewards they earn) is proportional to their <code>Power Fraction</code> over time. That is, a miner whose storage represents 1% of total storage on the network should mine 1% of blocks on expectation.</p>

<p>SPC provides a power table abstraction which tracks miner power (i.e. miner storage in relation to network storage) over time. The power table is updated for new sector commitments (incrementing miner power), when PoSts fail to be put on-chain (decrementing miner power) or for other storage and consensus faults.</p>

<p>An invariant of the storage power consensus subsystem is that all storage in the power table must be verified. That is, miners can only derive power from storage they have already proven to the network.</p>

<p>In order to achieve this, Filecoin delays updating power for new sector commitments until the first valid PoSt in the next proving period corresponding to that sector. (TODO: potential delay this further in order to ensure that any power cut goes undetected at most as long as the shortest power delay on new sector commitments).</p>

<p>For instance, say a miner X does the following:
- In epoch 100: commits 10 TB
- In epoch 110: publishes a PoSt for their storage
- In epoch 120: commits another 10TB
- In epoch 135: publishes a new PoSt for their storage</p>

<p>Querying the power table for this miner at different rounds should yield (using the following shorthand as an illustration only):
- <code>Power(X, 90) == 0</code>
- <code>Power(X, 100) == 0</code>
- <code>Power(X, 110) == 0</code>
- <code>Power(X, 111) == 10</code>
- <code>Power(X, 120) == 10</code>
- <code>Power(X, 135) == 10</code>
- <code>Power(x, 136) == 20</code></p>

<p>Conversely, storage faults only lead to power loss once they are detected (up to one proving period after the fault) so miners will mine with no more power than they have used to store data over time.</p>

<p>Put another way, power accounting in the SPC is delayed between storage being proven or faulted, and power being updated in the power table (and so for leader election). This ensures fairness over time.</p>

<p>The Miner lifecycle in the power table should be roughly as follows:
- MinerRegistration: A new miner with an associated worker public key and address is registered on the power table by the storage mining subsystem, along with their associated sector size (there is only one per worker).
- UpdatePower: These power increments and decrements are called by various storage actor (and must thus be verified by every full node on the network). Specifically:
    - Power is incremented to account for a new SectorCommitment at the first PoSt past the first ProvingPeriod.
    - All Power is decremented immediately after a missed PoSt.
    - Power is decremented immediately after faults are declared, proportional to the faulty sector size.
    - Power is incremented after a PoSt recovering from a fault.
    - Power is definitively removed from the Power Table past the sector failure timeout (see <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>)
To summarize, only sectors in the Active state will command power. A Sector becomes Active after their first PoSt from Committed and Recovering stages. Power is immediately decremented when an Active Sector enters the Failing state (through DeclareFaults or Cron) and when an Active Sector expires.</p>

<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></div>

<h5 id="pledge-collateral">Pledge Collateral</h5>

<p>Consensus in Filecoin is secured in part by economic incentives enforced by Pledge Collateral.</p>

<p>Pledge collateral amount is committed based on power pledged to the system (i.e. proportional to number of sectors committed and sector size for a miner). It is a system-wide parameter and is committed to the <code>StoragePowerActor</code>. TODO: define parameter value. Pledge Collateral submission methods take on storage deals to determine the appropriate amount of collateral to be pledged. Pledge collateral can be posted by the <code>StorageMinerActor</code> at any time by a miner up to sector commitments. A sector commitment without the requisite posted pledge collateral will be deemed invalid.</p>

<p>Pledge Collateral will be slashed when <a href="./#algorithms__expected_consensus__consensus_faults">Consensus Faults</a> are reported to the <code>StoragePowerActor</code>&rsquo;s <code>ReportConsensusFault</code> method or when the <code>CronActor</code> calls the <code>StoragePowerActor</code>&rsquo;s <code>ReportUncommittedPowerFault</code> method.</p>

<p>Pledge Collateral is slashed for any fault affecting storage-power consensus, these include:
- faults to expected consensus in particular (see <a href="./#algorithms__expected_consensus__consensus_faults">Consensus Faults</a>) which will be reported by a slasher to the <code>StoragePowerActor</code> in exchange for a reward.
- faults affecting consensus power more generally, specifically uncommitted power faults (i.e. <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>) which will be reported by the <code>CronActor</code> automatically.</p>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_token">

<h2 class="section-header">
  <strong>Token</strong>
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token">
        

        <strong>Token</strong>

        
            <br /><br /><i class="menuIcon">üìÄ</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__wallets">
        
            <i class="statusIcon">üõë</i>
        

        Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payments">
        
            <i class="statusIcon">üõë</i>
        

        Payments

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels">
        
            <i class="statusIcon">üõë</i>
        

        Payment Channels

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels__payment_channel_actor">
        

        Payment Channel Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig">
        
            <i class="statusIcon">üõë</i>
        

        Multisig Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig__multisig_actor">
        

        Multisig Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="systems__filecoin_token__wallets">

<h3 class="section-header">
  FIL Wallet
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="systems__filecoin_token__payments">

<h3 class="section-header">
  Payments
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="systems__filecoin_token__payment_channels">

<h3 class="section-header">
  Payment Channels
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_token__payment_channels__payment_channel_actor">

<h4 class="section-header">
  Payment Channel Actor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> Payment Channel Actor <a href="docs/systems/filecoin_token/payment_channels/payment_channel_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Voucher</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">VouchersApprovalResponse</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">PieceInclusionProof</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">PaymentChannelActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">RedeemVoucherWithApproval</span><span class="p">(</span><span class="nx">voucher</span> <span class="nx">Voucher</span><span class="p">)</span>
    <span class="nf">RedeemVoucherWithPIP</span><span class="p">(</span><span class="nx">voucher</span> <span class="nx">Voucher</span><span class="p">,</span> <span class="nx">pip</span> <span class="nx">PieceInclusionProof</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_token__multisig">

<h3 class="section-header">
  Multisig - Wallet requiring multiple signatures
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_token__multisig__multisig_actor">

<h4 class="section-header">
  Multisig Actor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> Multisig Actor <a href="docs/systems/filecoin_token/multisig/multisig_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="kd">type</span> <span class="nx">TxSeqNo</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">NumRequired</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">EpochDuration</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">Epoch</span> <span class="nx">UVarint</span>

<span class="kd">type</span> <span class="nx">MultisigActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">signers</span>         <span class="p">[</span><span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>
    <span class="nx">required</span>        <span class="nx">NumRequired</span>
    <span class="nx">nextTxId</span>        <span class="nx">TxSeqNo</span>
    <span class="nx">initialBalance</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">startingBlock</span>   <span class="nx">Epoch</span>
    <span class="nx">unlockDuration</span>  <span class="nx">EpochDuration</span>
    <span class="c1">// transactions    {TxSeqNo: Transaction} // TODO Transaction type does not exist
</span><span class="c1"></span>
    <span class="nf">Construct</span><span class="p">(</span>
        <span class="nx">signers</span>         <span class="p">[</span><span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>
        <span class="nx">required</span>        <span class="nx">NumRequired</span>
        <span class="nx">unlockDuration</span>  <span class="nx">EpochDuration</span>
    <span class="p">)</span>
    <span class="nf">Propose</span><span class="p">(</span>
        <span class="nx">to</span>      <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">value</span>   <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
        <span class="nx">method</span>  <span class="kt">string</span>
        <span class="nx">params</span>  <span class="nx">Bytes</span>
    <span class="p">)</span> <span class="nx">TxSeqNo</span>
    <span class="nf">Approve</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">TxSeqNo</span><span class="p">)</span>
    <span class="nf">Cancel</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">TxSeqNo</span><span class="p">)</span>
    <span class="nf">ClearCompleted</span><span class="p">()</span>
    <span class="nf">AddSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">increaseReq</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nf">RemoveSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">decreaseReq</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nf">SwapSigner</span><span class="p">(</span><span class="nx">old</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
    <span class="nf">ChangeRequirement</span><span class="p">(</span><span class="nx">req</span> <span class="nx">NumRequired</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining">

<h2 class="section-header">
  Storage Mining System - proving storage for producing blocks
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining">
        

        <strong>Storage Mining</strong>

        
            <br /><br /><i class="menuIcon">‚õè</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Miner

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__mining_cycle">
        

        Storage Mining Cycle

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">
        

        Storage Miner Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__mining_scheduler">
        

        Mining Scheduler

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector">
        
            <i class="statusIcon">‚úÖ</i>
        

        Sector

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector__sectorset">
        

        Sector Set

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector__sealing">
        

        Sector Sealing

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index">
        
            <i class="statusIcon">‚úÖ</i>
        

        Sector Index

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index__sector_builder">
        

        Sector Builder

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index__sector_store">
        

        SectorStore

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Proving

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving__sealer">
        

        Sector Sealer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving__poster">
        

        Sector Poster

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<p>The Storage Mining System is the part of the Filecoin Protocol that deals with storing Client&rsquo;s
data, producing proof artifacts that demonstrate correct storage behavior, and managing the work
involved.</p>

<p>Storing data and producing proofs is a complex, highly optimizable process, with lots of tunable
choices. Miners should explore the design space to arrive at something that (a) satisfies protocol
and network-wide constraints, (b) satisfies clients&rsquo; requests and expectations (as expressed in
<code>Deals</code>), and (c) gives them the most cost-effective operation. This part of the Filecoin Spec
primarily describes in detail what MUST and SHOULD happen here, and leaves ample room for
various optimizations for implementers, miners, and users to make. In some parts, we describe
algorithms that could be replaced by other, more optimized versions, but in those cases it is
important that the <strong>protocol constraints</strong> are satisfied. The <strong>protocol constraints</strong> are
spelled out in clear detail (an unclear, unmentioned constraint is a &ldquo;spec error&rdquo;).  It is up
to implementers who deviate from the algorithms presented here to ensure their modifications
satisfy those constraints, especially those relating to protocol security.</p>


</div>


  
    








<div id="systems__filecoin_mining__storage_mining">

<h3 class="section-header">
  Storage Miner
</h3>

<div class="section-content">






































<div id="systems__filecoin_mining__storage_mining__storage_mining_subsystem"></div>

<p>TODO:</p>

<ul>
<li>rename &ldquo;Storage Mining Worker&rdquo; ?</li>
</ul>

<p>Filecoin Storage Mining Subsystem</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sectoridx</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>
<span class="kn">import</span> <span class="nx">spc</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/storage_power_consensus&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">blockchain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain&#34;</span>
<span class="kn">import</span> <span class="nx">blockproducer</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block_producer&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">storage_proving</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving&#34;</span>
<span class="kn">import</span> <span class="nx">key_store</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/key_store&#34;</span>
<span class="kn">import</span> <span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>

<span class="kd">type</span> <span class="nx">StorageMiningSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">FilecoinNode</span>       <span class="nx">node_base</span><span class="p">.</span><span class="nx">FilecoinNode</span>

    <span class="c1">// TODO: constructor
</span><span class="c1"></span>    <span class="c1">// InitStorageMiningSubsystem(node node_base.FilecoinNode) struct{}
</span><span class="c1"></span>
    <span class="c1">// Component subsystems
</span><span class="c1"></span>    <span class="c1">// StorageProvider    storage_provider.StorageProvider
</span><span class="c1"></span>    <span class="nx">StoragePowerActor</span>  <span class="nx">spc</span><span class="p">.</span><span class="nx">StoragePowerActorCode</span>
    <span class="nx">MinerActor</span>         <span class="nx">StorageMinerActorCode</span>
    <span class="nx">SectorIndex</span>        <span class="nx">sectoridx</span><span class="p">.</span><span class="nx">SectorIndexerSubsystem</span>
    <span class="nx">StorageProving</span>     <span class="nx">storage_proving</span><span class="p">.</span><span class="nx">StorageProvingSubsystem</span>

    <span class="c1">// Need access to block producer in order to publish blocks
</span><span class="c1"></span>    <span class="nx">blockProducer</span>      <span class="nx">blockproducer</span><span class="p">.</span><span class="nx">BlockProducer</span>

    <span class="c1">// Need access to SPC in order to mine a block
</span><span class="c1"></span>    <span class="nx">consensus</span>          <span class="nx">spc</span><span class="p">.</span><span class="nx">StoragePowerConsensusSubsystem</span>

    <span class="c1">// Need access to the blockchain system in order to query for things in the chain
</span><span class="c1"></span>    <span class="nx">blockchain</span>         <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainSubsystem</span>

    <span class="c1">// Need access to the key store in order to generate tickets and election proofs
</span><span class="c1"></span>    <span class="nx">keyStore</span>           <span class="nx">key_store</span><span class="p">.</span><span class="nx">KeyStore</span>

    <span class="c1">// TODO: why are these here? remove?
</span><span class="c1"></span>    <span class="nf">StartMining</span><span class="p">()</span>
    <span class="nf">StopMining</span><span class="p">()</span>

    <span class="c1">// call by StorageMiningSubsystem itself to create miner
</span><span class="c1"></span>    <span class="nf">createMiner</span><span class="p">(</span>
        <span class="nx">ownerPubKey</span>   <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span>
        <span class="nx">workerPubKey</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span>
        <span class="nx">pledgeAmt</span>     <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">)</span>

    <span class="c1">// get miner key by address
</span><span class="c1"></span>    <span class="nf">GetMinerKeyByAddress</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span>

    <span class="c1">// call by StorageMarket.StorageProvider at the start of a deal.
</span><span class="c1"></span>    <span class="c1">// Triggers AddNewDeal on SectorIndexer
</span><span class="c1"></span>    <span class="c1">// StorageDeal contains DealCID
</span><span class="c1"></span>    <span class="nf">HandleStorageDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span>

    <span class="c1">// call by StorageMinerActor when error in sealing
</span><span class="c1"></span>    <span class="nf">CommitSectorError</span><span class="p">()</span>

    <span class="c1">// call by StorageMiningSubsystem itself in BlockProduction
</span><span class="c1"></span>    <span class="nf">DrawElectionProof</span><span class="p">(</span>
        <span class="nx">randomness</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>
        <span class="nx">height</span>      <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
        <span class="nx">vrfKP</span>       <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFKeyPair</span>
    <span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>

    <span class="c1">// call by StorageMiningSubsystem itself in BlockProduction
</span><span class="c1"></span>    <span class="nf">PrepareNewTicket</span><span class="p">(</span>
        <span class="nx">randomness</span>     <span class="nx">block</span><span class="p">.</span><span class="nx">Randomness</span>
        <span class="nx">workerKeyPair</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFKeyPair</span>
    <span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>

    <span class="c1">// call by BlockChain when a new block is produced
</span><span class="c1"></span>    <span class="nf">OnNewBestChain</span><span class="p">()</span>

    <span class="c1">// call by clock during BlockProduction
</span><span class="c1"></span>    <span class="c1">// TODO: define clock better
</span><span class="c1"></span>    <span class="nf">OnNewRound</span><span class="p">()</span>

    <span class="nf">tryLeaderElection</span><span class="p">()</span>

    <span class="nf">submitPoStMessage</span><span class="p">(</span><span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="sector-in-storageminer-state-machine-new-one">Sector in StorageMiner State Machine (new one)</h4>













<div class="diagram">

<span class="diagram-title">Sector State (new one)</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_fsm.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_fsm.dot.svg" />




</div>














<div class="diagram">

<span class="diagram-title">Sector State Legend (new one)</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_legend.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_legend.dot.svg" />




</div>


<h4 id="sector-in-storageminer-state-machine-both">Sector in StorageMiner State Machine (both)</h4>













<div class="diagram">

<span class="diagram-title">Sector State Machine (both)</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_fsm.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_fsm.dot.svg" />




</div>



</div>


  
    








<div id="systems__filecoin_mining__storage_mining__mining_cycle">

<h4 class="section-header">
  Storage Mining Cycle
</h4>

<div class="section-content">






































<p>Block miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning <code>ticket</code> to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.</p>

<h5 id="the-miner-actor">The Miner Actor</h5>

<p>After successfully calling <code>CreateStorageMiner</code>, a miner actor will be created on-chain, and registered in the storage market. This miner, like all other Filecoin State Machine actors, has a fixed set of methods that can be used to interact with or control it.</p>

<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">sealing</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>

<span class="kd">type</span> <span class="nx">Seed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">SectorCommitment</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">SectorExpirationQueueItem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorNumber</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span>
    <span class="nx">Expiration</span>    <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorExpirationQueue</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Add</span><span class="p">(</span><span class="nx">i</span> <span class="nx">SectorExpirationQueueItem</span><span class="p">)</span>
    <span class="nf">Pop</span><span class="p">()</span> <span class="nx">SectorExpirationQueueItem</span>
    <span class="nf">Peek</span><span class="p">()</span> <span class="nx">SectorExpirationQueueItem</span>
    <span class="nf">Remove</span><span class="p">(</span><span class="nx">n</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorTable</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSize</span>             <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="nx">ActiveSectors</span>          <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="nx">CommittedSectors</span>       <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="nx">RecoveringSectors</span>      <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="nx">FailingSectors</span>         <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>

    <span class="nf">ActivePower</span><span class="p">()</span>          <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nf">InactivePower</span><span class="p">()</span>        <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>

    <span class="nx">TerminationFaultCount</span>  <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>  <span class="c1">// transient State that get reset on every constructPowerReport
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorOnChainInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealCommitment</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCommitment</span>
    <span class="nx">State</span>           <span class="nx">SectorState</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ChallengeStatus</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">LastChallengeEpoch</span>     <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>  <span class="c1">// get updated by NotifyOfPoStChallenge
</span><span class="c1"></span>    <span class="nx">LastChallengeEndEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>  <span class="c1">// get updated upon successful submitPoSt
</span><span class="c1"></span>
    <span class="nf">IsChallenged</span><span class="p">()</span>         <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PreCommittedSector</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Info</span>           <span class="nx">sealing</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span>
    <span class="nx">ReceivedEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PreCommittedSectorsAMT</span> <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">PreCommittedSector</span><span class="p">}</span>
<span class="kd">type</span> <span class="nx">SectorsAMT</span> <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">SectorOnChainInfo</span><span class="p">}</span>
<span class="kd">type</span> <span class="nx">StagedCommittedSectorAMT</span> <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">SectorOnChainInfo</span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMinerActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// CollateralVault CollateralVault
</span><span class="c1"></span>
    <span class="nx">PreCommittedSectors</span>        <span class="nx">PreCommittedSectorsAMT</span>
    <span class="nx">Sectors</span>                    <span class="nx">SectorsAMT</span>
    <span class="nx">StagedCommittedSectors</span>     <span class="nx">StagedCommittedSectorAMT</span>

    <span class="c1">// ProvingSet get copied over to NextProvingSet on PoSt challenge and CheckPoStSubmissionHappened
</span><span class="c1"></span>    <span class="c1">// successful SubmitPoSt will perform changes to NextProvingSet
</span><span class="c1"></span>    <span class="c1">// and update ProvingSet with NextProvingSet at the end
</span><span class="c1"></span>    <span class="c1">// No DeclareFaults and CommitSector can happen when SM is in the isChallenged state
</span><span class="c1"></span>    <span class="nx">ProvingSet</span>                 <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span>

    <span class="nx">SectorTable</span>
    <span class="nx">SectorExpirationQueue</span>
    <span class="nx">ChallengeStatus</span>

    <span class="c1">// contains mostly static info about this miner
</span><span class="c1"></span>    <span class="nx">Info</span>                       <span class="o">&amp;</span><span class="nx">MinerInfo</span>

    <span class="c1">// TODO ProvingPeriodEnd   Epoch
</span><span class="c1"></span>
    <span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>  <span class="kt">bool</span>
    <span class="nf">_isSealVerificationCorrect</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">_updateFailSector</span><span class="p">(</span>
        <span class="nx">rt</span>                   <span class="nx">Runtime</span>
        <span class="nx">sectorNo</span>             <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span>
        <span class="nx">incrementFaultCount</span>  <span class="kt">bool</span>
    <span class="p">)</span>
    <span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>
    <span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>
    <span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
    <span class="nf">_updateActivateSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMinerActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">NotifyOfPoStChallenge</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="nf">PreCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span><span class="p">)</span>  <span class="c1">// TODO: check with Magik on sizes
</span><span class="c1"></span>    <span class="nf">ProveCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorProveCommitInfo</span><span class="p">)</span>

    <span class="nf">SubmitPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span>

    <span class="nf">CheckPoStSubmissionHappened</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="c1">// TODO: should depledge be in here or in storage market actor?
</span><span class="c1"></span>
    <span class="nf">DeclareFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">failingSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span>

    <span class="nf">RecoverFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">recoveringSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span>

    <span class="nf">_onMissedPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="nf">_submitFaultReport</span><span class="p">(</span>
        <span class="nx">rt</span>          <span class="nx">Runtime</span>
        <span class="nx">declared</span>    <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
        <span class="nx">detected</span>    <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
        <span class="nx">terminated</span>  <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="p">)</span>
    <span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="nf">_verifyPoStSubmission</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// _computeProvingPeriodEndSectorState(rt Runtime)  // TODO
</span><span class="c1"></span>
    <span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MinerInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Account that owns this miner.
</span><span class="c1"></span>    <span class="c1">// - Income and returned collateral are paid to this address.
</span><span class="c1"></span>    <span class="c1">// - This address is also allowed to change the worker address for the miner.
</span><span class="c1"></span>    <span class="nx">Owner</span>           <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// Worker account for this miner.
</span><span class="c1"></span>    <span class="c1">// This will be the key that is used to sign blocks created by this miner, and
</span><span class="c1"></span>    <span class="c1">// sign messages sent on behalf of this miner to commit sectors, submit PoSts, and
</span><span class="c1"></span>    <span class="c1">// other day to day miner activities.
</span><span class="c1"></span>    <span class="nx">Worker</span>          <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// Libp2p identity that should be used when connecting to this miner.
</span><span class="c1"></span>    <span class="nx">PeerId</span>          <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>

    <span class="c1">// Amount of space in each sector committed to the network by this miner.
</span><span class="c1"></span>    <span class="nx">SectorSize</span>      <span class="nx">util</span><span class="p">.</span><span class="nx">BytesAmount</span>
    <span class="nx">SubsectorCount</span>  <span class="nx">UVarint</span>
    <span class="nx">Partitions</span>      <span class="nx">UVarint</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_mining</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">filproofs</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto/filproofs&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>
<span class="kn">import</span> <span class="nx">power</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/storage_power_consensus&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">storage_market</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Method_StorageMinerActor_SubmitPoSt</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodPlaceholder</span>
<span class="p">)</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Boilerplate
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">State</span> <span class="p">=</span> <span class="nx">StorageMinerActorState</span>
<span class="kd">type</span> <span class="nx">Any</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Any</span>
<span class="kd">type</span> <span class="nx">Bool</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bool</span>
<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>

<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">()</span>
	<span class="nx">stateBytes</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">ipld</span><span class="p">.</span><span class="nf">CID</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">stateBytes</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime_IpldGet_FunRet_Case_Bytes</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;IPLD lookup error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">stateBytes</span><span class="p">.</span><span class="nf">As_Bytes</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">State</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="c1">// TODO: placeholder epoch value -- this will be set later
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">=</span> <span class="nx">block</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">SectorTable_I</span><span class="p">)</span> <span class="nf">ActivePower</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">block</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">ActiveSectors_</span> <span class="o">*</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">SectorSize_</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">SectorTable_I</span><span class="p">)</span> <span class="nf">InactivePower</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">block</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">((</span><span class="nx">st</span><span class="p">.</span><span class="nx">CommittedSectors_</span> <span class="o">+</span> <span class="nx">st</span><span class="p">.</span><span class="nx">RecoveringSectors_</span> <span class="o">+</span> <span class="nx">st</span><span class="p">.</span><span class="nx">FailingSectors_</span><span class="p">)</span> <span class="o">*</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">SectorSize_</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ChallengeStatus_I</span><span class="p">)</span> <span class="nf">OnNewChallenge</span><span class="p">(</span><span class="nx">currEpoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">ChallengeStatus</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">LastChallengeEpoch_</span> <span class="p">=</span> <span class="nx">currEpoch</span>
	<span class="k">return</span> <span class="nx">cs</span>
<span class="p">}</span>

<span class="c1">// Call by either SubmitPoSt or OnMissedPoSt
</span><span class="c1">// TODO: verify this is correct and if we need to distinguish SubmitPoSt vs OnMissedPoSt
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ChallengeStatus_I</span><span class="p">)</span> <span class="nf">OnChallengeResponse</span><span class="p">(</span><span class="nx">currEpoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">ChallengeStatus</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">LastChallengeEndEpoch_</span> <span class="p">=</span> <span class="nx">currEpoch</span>
	<span class="k">return</span> <span class="nx">cs</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ChallengeStatus_I</span><span class="p">)</span> <span class="nf">IsChallenged</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// true (isChallenged) when LastChallengeEpoch is later than LastChallengeEndEpoch
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">LastChallengeEpoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">LastChallengeEndEpoch</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">IsChallenged</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="c1">// called by CronActor to notify StorageMiner of PoSt Challenge
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">NotifyOfPoStChallenge</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nx">CronActorAddr</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span> <span class="c1">// silent return, dont re-challenge
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">LastChallengeEpoch_</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="nx">sealOnChainInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">StagedCommittedSectors</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sealOnChainInfo</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// empty StagedCommittedSectors
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">StagedCommittedSectors_</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// construct FaultReport
</span><span class="c1">// reset NewTerminatedFaults
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_submitFaultReport</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span>
	<span class="nx">newDeclaredFaults</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span>
	<span class="nx">newDetectedFaults</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span>
	<span class="nx">newTerminatedFaults</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="nx">faultReport</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">power</span><span class="p">.</span><span class="nx">FaultReport_I</span><span class="p">{</span>
		<span class="nx">NewDeclaredFaults_</span><span class="p">:</span>   <span class="nx">newDeclaredFaults</span><span class="p">,</span>
		<span class="nx">NewDetectedFaults_</span><span class="p">:</span>   <span class="nx">newDetectedFaults</span><span class="p">,</span>
		<span class="nx">NewTerminatedFaults_</span><span class="p">:</span> <span class="nx">newTerminatedFaults</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span> <span class="c1">// TODO: Send(SPA, ProcessFaultReport(faultReport))
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">faultReport</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">TerminationFaultCount_</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// construct PowerReport from SectorTable
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">powerReport</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">power</span><span class="p">.</span><span class="nx">PowerReport_I</span><span class="p">{</span>
		<span class="nx">ActivePower_</span><span class="p">:</span>   <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">ActivePower</span><span class="p">(),</span>
		<span class="nx">InactivePower_</span><span class="p">:</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">InactivePower</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span> <span class="c1">// TODO: Send(SPA, ProcessPowerReport(powerReport))
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">powerReport</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_onMissedPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">failingSectorNumbers</span> <span class="o">:=</span> <span class="nf">getSectorNums</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">())</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">failingSectorNumbers</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">newDetectedFaults</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">FailingSectors</span><span class="p">()</span>
	<span class="nx">newTerminatedFaults</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">TerminationFaultCount</span><span class="p">()</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Note: NewDetectedFaults is now the sum of all
</span><span class="c1"></span>	<span class="c1">// previously active, committed, and recovering sectors minus expired ones
</span><span class="c1"></span>	<span class="c1">// and any previously Failing sectors that did not exceed MaxFaultCount
</span><span class="c1"></span>	<span class="c1">// Note: previously declared faults is now treated as part of detected faults
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitFaultReport</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">,</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// NewDeclaredFaults
</span><span class="c1"></span>		<span class="nx">newDetectedFaults</span><span class="p">,</span>
		<span class="nx">newTerminatedFaults</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// end of challenge
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">OnChallengeResponse</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// If a Post is missed (either due to faults being not declared on time or
</span><span class="c1">// because the miner run out of time, every sector is reported as failing
</span><span class="c1">// for the current proving period.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">CheckPoStSubmissionHappened</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Miner gets out of a challenge when submit a successful PoSt
</span><span class="c1"></span>		<span class="c1">// or when detected by CronActor. Hence, not being in isChallenged means that we are good here
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// oh no -- we missed it. rekt
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_onMissedPoSt</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_verifyPoStSubmission</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 1. A proof must be submitted after the postRandomness for this proving
</span><span class="c1"></span>	<span class="c1">// period is on chain
</span><span class="c1"></span>	<span class="c1">// if rt.ChainEpoch &lt; sm.ProvingPeriodEnd - challengeTime {
</span><span class="c1"></span>	<span class="c1">//   rt.Abort(&#34;too early&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// 2. A proof must be a valid snark proof with the correct public inputs
</span><span class="c1"></span>	<span class="c1">// 2.1 Get randomness from the chain at the right epoch
</span><span class="c1"></span>	<span class="c1">// postRandomness := rt.Randomness(postSubmission.Epoch, 0)
</span><span class="c1"></span>	<span class="c1">// 2.2 Generate the set of challenges
</span><span class="c1"></span>	<span class="c1">// challenges := GenerateChallengesForPoSt(r, keys(sm.Sectors))
</span><span class="c1"></span>	<span class="c1">// 2.3 Verify the PoSt Proof
</span><span class="c1"></span>	<span class="c1">// verifyPoSt(challenges, TODO)
</span><span class="c1"></span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span> <span class="c1">// TODO: finish
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">preCommitSector</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()</span> <span class="p">{</span>

		<span class="nx">elapsedEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">ReceivedEpoch</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">elapsedEpoch</span> <span class="p">&gt;</span> <span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">{</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">(),</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">())</span>
			<span class="c1">// TODO: potentially some slashing if ProveCommitSector comes late
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

<span class="p">}</span>

<span class="c1">// move Sector from Active/Failing
</span><span class="c1">// into Cleared State which means deleting the Sector from state
</span><span class="c1">// remove SectorNumber from all states on chain
</span><span class="c1">// update SectorTable
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sectorState</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
		<span class="c1">// expiration case
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ActiveSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
		<span class="c1">// expiration and termination cases
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// Committed and Recovering should not go to Cleared directly
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;invalid state in clearSector&#34;</span><span class="p">)</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">(),</span> <span class="nx">sectorNo</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorExpirationQueue</span><span class="p">().</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// move Sector from Committed/Recovering into Active State
</span><span class="c1">// reset FaultCount to zero
</span><span class="c1">// update SectorTable
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateActivateSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sectorState</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SectorCommittedSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">case</span> <span class="nx">SectorRecoveringSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">RecoveringSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;invalid state in activateSector&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorActive</span><span class="p">()</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ActiveSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// failSector moves Sector from Active/Committed/Recovering into Failing State
</span><span class="c1">// and increments FaultCount if asked to do so (DeclareFaults does not increment faultCount)
</span><span class="c1">// move Sector from Failing to Cleared State if increment results in faultCount exceeds MaxFaultCount
</span><span class="c1">// update SectorTable
</span><span class="c1">// remove from ProvingSet
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">,</span> <span class="nx">increment</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newFaultCount</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">().</span><span class="nx">FaultCount</span>

	<span class="k">if</span> <span class="nx">increment</span> <span class="p">{</span>
		<span class="nx">newFaultCount</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">state</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
		<span class="c1">// wont be terminated from Active
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ActiveSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">SectorCommittedSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">SectorRecoveringSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">RecoveringSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
		<span class="c1">// no change to SectorTable but increase in FaultCount
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in CronAction&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">newFaultCount</span> <span class="p">&gt;</span> <span class="nx">MAX_CONSECUTIVE_FAULTS</span> <span class="p">{</span>
		<span class="c1">// TODO: heavy penalization: slash pledge collateral and delete sector
</span><span class="c1"></span>		<span class="c1">// TODO: SendMessage(SPA.SlashPledgeCollateral)
</span><span class="c1"></span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">TerminationFaultCount_</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Decision is to currently account for power based on sector
</span><span class="c1">// with at least one active deals and deals cannot be updated
</span><span class="c1">// an alternative proposal is to account for power based on active deals
</span><span class="c1">// an improvement proposal is to allow storage deal update in a sector
</span><span class="c1"></span>
<span class="c1">// TODO: decide whether declared faults sectors should be
</span><span class="c1">// penalized in the same way as undeclared sectors and how
</span><span class="c1"></span>
<span class="c1">// SubmitPoSt Workflow:
</span><span class="c1">// - Verify PoSt Submission
</span><span class="c1">// - Process ProvingSet.SectorsOn()
</span><span class="c1">//   - State Transitions
</span><span class="c1">//     - Committed -&gt; Active and credit power
</span><span class="c1">//     - Recovering -&gt; Active and credit power
</span><span class="c1">//   - Process Active Sectors (pay miners)
</span><span class="c1">// - Process ProvingSet.SectorsOff()
</span><span class="c1">//     - increment FaultCount
</span><span class="c1">//     - clear Sector and slash pledge collateral if count &gt; MAX_CONSECUTIVE_FAULTS
</span><span class="c1">// - Process Expired Sectors (settle deals and return storage collateral to miners)
</span><span class="c1">//     - State Transition
</span><span class="c1">//       - Failing / Recovering / Active / Committed -&gt; Cleared
</span><span class="c1">//     - Remove SectorNumber from Sectors, ProvingSet
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">SubmitPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;cannot SubmitPoSt when not challenged&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Verify correct PoSt Submission
</span><span class="c1"></span>	<span class="nx">isPoStVerified</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_verifyPoStSubmission</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">postSubmission</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isPoStVerified</span> <span class="p">{</span>
		<span class="c1">// no state transition, just error out and miner should submitPoSt again
</span><span class="c1"></span>		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// The proof is verified, process ProvingSet.SectorsOn():
</span><span class="c1"></span>	<span class="c1">// ProvingSet.SectorsOn() contains SectorCommitted, SectorActive, SectorRecovering
</span><span class="c1"></span>	<span class="c1">// ProvingSet itself does not store states, states are all stored in Sectors.State
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">sectorState</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector state not found in map&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorCommittedSN</span><span class="p">,</span> <span class="nx">SectorRecoveringSN</span><span class="p">:</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateActivateSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
			<span class="c1">// Process payment in all active deals
</span><span class="c1"></span>			<span class="c1">// Note: this must happen before marking sectors as expired.
</span><span class="c1"></span>			<span class="c1">// TODO: Pay miner in a single batch message
</span><span class="c1"></span>			<span class="c1">// SendMessage(sma.ProcessStorageDealsPayment(sm.Sectors()[sectorNumber].DealIDs()))
</span><span class="c1"></span>		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in ProvingSet.SectorsOn()&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// commit state change so that committed and recovering are now active
</span><span class="c1"></span>
	<span class="c1">// Process ProvingSet.SectorsOff()
</span><span class="c1"></span>	<span class="c1">// ProvingSet.SectorsOff() contains SectorFailing
</span><span class="c1"></span>	<span class="c1">// SectorRecovering is Proving and hence will not be in GetZeros()
</span><span class="c1"></span>	<span class="c1">// heavy penalty if Failing for more than or equal to MAX_CONSECUTIVE_FAULTS
</span><span class="c1"></span>	<span class="c1">// otherwise increment FaultCount in Sectors().State
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">SectorsOff</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">sectorState</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in ProvingSet.SectorsOff&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Process Expiration.
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">terminationFaultCount</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">TerminationFaultCount_</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitFaultReport</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">,</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// NewDeclaredFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// NewDetectedFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">terminationFaultCount</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// TODO: check EnsurePledgeCollateralSatisfied
</span><span class="c1"></span>	<span class="c1">// pledgeCollateralSatisfied
</span><span class="c1"></span>
	<span class="c1">// Reset Proving Period and report power updates
</span><span class="c1"></span>	<span class="c1">// sm.ProvingPeriodEnd_ = PROVING_PERIOD_TIME
</span><span class="c1"></span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">OnChallengeResponse</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">currEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>

	<span class="nx">queue</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorExpirationQueue</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Peek</span><span class="p">().</span><span class="nf">Expiration</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">currEpoch</span> <span class="p">{</span>
		<span class="nx">expiredSectorNo</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Pop</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">()</span>

		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">expiredSectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
		<span class="c1">// sc := sm.Sectors()[expiredSectorNo]
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">state</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
			<span class="c1">// Note: in order to verify if something was stored in the past, one must
</span><span class="c1"></span>			<span class="c1">// scan the chain. SectorNumber can be re-used.
</span><span class="c1"></span>
			<span class="c1">// Settle deals
</span><span class="c1"></span>			<span class="c1">// SendMessage(sma.SettleExpiredDeals(sc.DealIDs()))
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">expiredSectorNo</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
			<span class="c1">// TODO: check if there is any fault that we should handle here
</span><span class="c1"></span>			<span class="c1">// If a SectorFailing Expires, return remaining StorageDealCollateral and remove sector
</span><span class="c1"></span>			<span class="c1">// SendMessage(sma.SettleExpiredDeals(sc.DealIDs()))
</span><span class="c1"></span>
			<span class="c1">// a failing sector expires, no change to FaultCount
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">expiredSectorNo</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// Note: SectorCommittedSN, SectorRecoveringSN transition first to SectorFailingSN, then expire
</span><span class="c1"></span>			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in SectorExpirationQueue&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Return PledgeCollateral for active expirations
</span><span class="c1"></span>	<span class="c1">// SendMessage(spa.Depledge) // TODO
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO: refactor use of this method in order for caller to send this message&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// RecoverFaults checks if miners have sufficent collateral
</span><span class="c1">// and adds SectorFailing into SectorRecovering
</span><span class="c1">// - State Transition
</span><span class="c1">//   - Failing -&gt; Recovering with the same FaultCount
</span><span class="c1">// - Add SectorNumber to ProvingSet
</span><span class="c1">// Note that power is not updated until it is active
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">RecoverFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">recoveringSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;cannot RecoverFaults when sm isChallenged&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// for all SectorNumber marked as recovering by recoveringSet
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">recoveringSet</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">sectorState</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector state not found in map&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
			<span class="c1">// Check if miners have sufficient balances in sma
</span><span class="c1"></span>
			<span class="c1">// SendMessage(sma.PublishStorageDeals) or sma.ResumeStorageDeals?
</span><span class="c1"></span>			<span class="c1">// throw if miner cannot cover StorageDealCollateral
</span><span class="c1"></span>
			<span class="c1">// Check if miners have sufficient pledgeCollateral
</span><span class="c1"></span>
			<span class="c1">// copy over the same FaultCount
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorRecovering</span><span class="p">(</span><span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">FaultCount</span><span class="p">)</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>

			<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">RecoveringSectors_</span> <span class="o">+=</span> <span class="mi">1</span>

		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="c1">// TODO: consider this a no-op (as opposed to a failure), because this is a user
</span><span class="c1"></span>			<span class="c1">// call that may be delayed by the chain beyond some other state transition.
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in RecoverFaults&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// DeclareFaults penalizes miners (slashStorageDealCollateral and remove power)
</span><span class="c1">// TODO: decide how much storage collateral to slash
</span><span class="c1">// - State Transition
</span><span class="c1">//   - Active / Commited / Recovering -&gt; Failing
</span><span class="c1">// - Update State in Sectors()
</span><span class="c1">// - Remove Active / Commited / Recovering from ProvingSet
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">DeclareFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">faultSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;cannot DeclareFaults when challenged&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// fail all SectorNumber marked as Failing by faultSet
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">faultSet</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">declaredFaults</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">faultSet</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">())</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitFaultReport</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">,</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">declaredFaults</span><span class="p">),</span> <span class="c1">// DeclaredFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>              <span class="c1">// DetectedFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>              <span class="c1">// TerminatedFault
</span><span class="c1"></span>	<span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_isSealVerificationCorrect</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Info</span><span class="p">()</span>
	<span class="nx">sectorSize</span> <span class="o">:=</span> <span class="nx">info</span><span class="p">.</span><span class="nf">SectorSize</span><span class="p">()</span>
	<span class="nx">dealIDs</span> <span class="o">:=</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">DealIDs</span><span class="p">()</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParam</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">dealIDs</span><span class="p">))</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span> <span class="c1">// if no modifications made; or
</span><span class="c1"></span>
	<span class="c1">// TODO: serialize method param as {sectorSize,  DealIDs...}.
</span><span class="c1"></span>
	<span class="nx">receipt</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">InvocInput_I</span><span class="p">{</span>
		<span class="nx">To_</span><span class="p">:</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span> <span class="nx">storage_market</span><span class="p">.</span><span class="nx">MethodGetUnsealedCIDForDealIDs</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span> <span class="nx">params</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">receipt</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">()</span> <span class="o">==</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidSectorPacking</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">receipt</span><span class="p">.</span><span class="nf">ReturnValue</span><span class="p">()</span>

	<span class="nx">pieceInfos</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">PieceInfosFromBytes</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span>

	<span class="c1">// Unless we enforce a minimum padding amount, this totalPieceSize calculation can be removed.
</span><span class="c1"></span>	<span class="c1">// Leaving for now until that decision is entirely finalized.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">totalPieceSize</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pieceInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pieceInfos</span> <span class="p">{</span>
		<span class="nx">pieceSize</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pieceInfo</span><span class="p">).</span><span class="nf">Size</span><span class="p">()</span>
		<span class="nx">totalPieceSize</span> <span class="o">+=</span> <span class="nx">pieceSize</span>
	<span class="p">}</span>

	<span class="nx">unsealedCID</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">ComputeUnsealedSectorCIDFromPieceInfos</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">pieceInfos</span><span class="p">)</span>

	<span class="nx">sealCfg</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg_I</span><span class="p">{</span>
		<span class="nx">SectorSize_</span><span class="p">:</span>     <span class="nx">sectorSize</span><span class="p">,</span>
		<span class="nx">SubsectorCount_</span><span class="p">:</span> <span class="nx">info</span><span class="p">.</span><span class="nf">SubsectorCount</span><span class="p">(),</span>
		<span class="nx">Partitions_</span><span class="p">:</span>     <span class="nx">info</span><span class="p">.</span><span class="nf">Partitions</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">svInfo</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo_I</span><span class="p">{</span>
		<span class="nx">SectorID_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID_I</span><span class="p">{</span>
			<span class="nx">MinerID_</span><span class="p">:</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Worker</span><span class="p">(),</span> <span class="c1">// TODO: This is actually miner address. MinerID needs to be derived.
</span><span class="c1"></span>			<span class="nx">Number_</span><span class="p">:</span>  <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">(),</span>
		<span class="p">},</span>
		<span class="nx">OnChain_</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">,</span>

		<span class="c1">// TODO: Make SealCfg sector.SealCfg from miner configuration (where is that?)
</span><span class="c1"></span>		<span class="nx">SealCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">sealCfg</span><span class="p">,</span>

		<span class="nx">Randomness_</span><span class="p">:</span>            <span class="nx">sector</span><span class="p">.</span><span class="nf">SealRandomness</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">Randomness</span><span class="p">(</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SealEpoch</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)),</span>
		<span class="nx">InteractiveRandomness_</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">InteractiveSealRandomness</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">Randomness</span><span class="p">(</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">InteractiveEpoch</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)),</span>
		<span class="nx">UnsealedCID_</span><span class="p">:</span>           <span class="nx">unsealedCID</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">sdr</span> <span class="o">:=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">SDRParams</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">filproofs</span><span class="p">.</span><span class="nx">SDRCfg_I</span><span class="p">{</span><span class="nx">SealCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">sealCfg</span><span class="p">})</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">VerifySeal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">svInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">found</span>
<span class="p">}</span>

<span class="c1">// Deals must be posted on chain via sma.PublishStorageDeals before PreCommitSector
</span><span class="c1">// TODO(optimization): PreCommitSector could contain a list of deals that are not published yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">PreCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="c1">// no checks needed
</span><span class="c1"></span>	<span class="c1">// can be called regardless of Challenged status
</span><span class="c1"></span>
	<span class="c1">// TODO: might record CurrEpoch for PreCommitSector expiration
</span><span class="c1"></span>	<span class="c1">// in other words, a ProveCommitSector must be on chain X Epoch after a PreCommitSector goes on chain
</span><span class="c1"></span>	<span class="c1">// TODO: might take collateral in case no ProveCommit follows within sometime
</span><span class="c1"></span>	<span class="c1">// TODO: collateral also penalizes repeated precommit to get randomness that one likes
</span><span class="c1"></span>	<span class="c1">// TODO: might be a good place for Treasury
</span><span class="c1"></span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()[</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span>

	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="c1">// TODO: burn some funds?
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector already pre committed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">sectorExists</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">sectorExists</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector already exists.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: verify every DealID has been published and not yet expired
</span><span class="c1"></span>
	<span class="nx">precommittedSector</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PreCommittedSector_I</span><span class="p">{</span>
		<span class="nx">Info_</span><span class="p">:</span>          <span class="nx">info</span><span class="p">,</span>
		<span class="nx">ReceivedEpoch_</span><span class="p">:</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()[</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">precommittedSector</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">ProveCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorProveCommitInfo</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">preCommitSector</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()[</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector not pre committed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">sectorExists</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">())</span>

	<span class="k">if</span> <span class="nx">sectorExists</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector already exists.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// check if ProveCommitSector comes too late after PreCommitSector
</span><span class="c1"></span>	<span class="nx">elapsedEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">ReceivedEpoch</span><span class="p">()</span>

	<span class="c1">// if more than MAX_PROVE_COMMIT_SECTOR_EPOCH has elapsed
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">elapsedEpoch</span> <span class="p">&gt;</span> <span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">{</span>
		<span class="c1">// TODO: potentially some slashing if ProveCommitSector comes late
</span><span class="c1"></span>
		<span class="c1">// expired
</span><span class="c1"></span>		<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">(),</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">())</span>
		<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">UserDefinedError</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1">// TODO: user dfined error code?
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">onChainInfo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo_I</span><span class="p">{</span>
		<span class="nx">SealedCID_</span><span class="p">:</span>        <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SealedCID</span><span class="p">(),</span>
		<span class="nx">SealEpoch_</span><span class="p">:</span>        <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SealEpoch</span><span class="p">(),</span>
		<span class="nx">InteractiveEpoch_</span><span class="p">:</span> <span class="nx">info</span><span class="p">.</span><span class="nf">InteractiveEpoch</span><span class="p">(),</span>
		<span class="nx">Proof_</span><span class="p">:</span>            <span class="nx">info</span><span class="p">.</span><span class="nf">Proof</span><span class="p">(),</span>
		<span class="nx">DealIDs_</span><span class="p">:</span>          <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">DealIDs</span><span class="p">(),</span>
		<span class="nx">SectorNumber_</span><span class="p">:</span>     <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="nx">isSealVerificationCorrect</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isSealVerificationCorrect</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">onChainInfo</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isSealVerificationCorrect</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Seal verification failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: check EnsurePledgeCollateralSatisfied
</span><span class="c1"></span>	<span class="c1">// pledgeCollateralSatisfied
</span><span class="c1"></span>
	<span class="c1">// determine lastDealExpiration from sma
</span><span class="c1"></span>	<span class="c1">// TODO: proper onchain transaction
</span><span class="c1"></span>	<span class="c1">// lastDealExpiration := SendMessage(sma, GetLastDealExpirationFromDealIDs(onChainInfo.DealIDs()))
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lastDealExpiration</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>

	<span class="c1">// Note: in the current iteration, a Sector expires only when all storage deals in it have expired.
</span><span class="c1"></span>	<span class="c1">// This is likely to change but it aims to meet user requirement that users can enter into deals of any size.
</span><span class="c1"></span>	<span class="c1">// add sector expiration to SectorExpirationQueue
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorExpirationQueue</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">SectorExpirationQueueItem_I</span><span class="p">{</span>
		<span class="nx">SectorNumber_</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">(),</span>
		<span class="nx">Expiration_</span><span class="p">:</span>   <span class="nx">lastDealExpiration</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="c1">// no need to store the proof and randomseed in the state tree
</span><span class="c1"></span>	<span class="c1">// verify and drop, only SealCommitment{CommR, DealIDs} on chain
</span><span class="c1"></span>	<span class="nx">sealCommitment</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SealCommitment_I</span><span class="p">{</span>
		<span class="nx">SealedCID_</span><span class="p">:</span>  <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SealedCID</span><span class="p">(),</span>
		<span class="nx">DealIDs_</span><span class="p">:</span>    <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">DealIDs</span><span class="p">(),</span>
		<span class="nx">Expiration_</span><span class="p">:</span> <span class="nx">lastDealExpiration</span><span class="p">,</span> <span class="c1">// TODO decide if we need this too
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// add SectorNumber and SealCommitment to Sectors
</span><span class="c1"></span>	<span class="c1">// set Sectors.State to SectorCommitted
</span><span class="c1"></span>	<span class="c1">// Note that SectorNumber will only become Active at the next successful PoSt
</span><span class="c1"></span>	<span class="nx">sealOnChainInfo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">SectorOnChainInfo_I</span><span class="p">{</span>
		<span class="nx">SealCommitment_</span><span class="p">:</span> <span class="nx">sealCommitment</span><span class="p">,</span>
		<span class="nx">State_</span><span class="p">:</span>          <span class="nf">SectorCommitted</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// move PreCommittedSector to StagedCommittedSectors if in Challenged status
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">StagedCommittedSectors</span><span class="p">()[</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">sealOnChainInfo</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// move PreCommittedSector to CommittedSectors if not in Challenged status
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">sealOnChainInfo</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">())</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// now remove SectorNumber from PreCommittedSectors (processed)
</span><span class="c1"></span>	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">(),</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">())</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getSectorNums</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">l</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>
</code></pre></div>




</p>

<h6 id="owner-worker-distinction">Owner Worker distinction</h6>

<p>The miner actor has two distinct &lsquo;controller&rsquo; addresses. One is the worker, which is the address which will be responsible for doing all of the work, submitting proofs, committing new sectors, and all other day to day activities. The owner address is the address that created the miner, paid the collateral, and has block rewards paid out to it. The reason for the distinction is to allow different parties to fulfil the different roles. One example would be for the owner to be a multisig wallet, or a cold storage key, and the worker key to be a &lsquo;hot wallet&rsquo; key.</p>

<h6 id="storage-mining-cycle">Storage Mining Cycle</h6>

<p>Storage miners must continually produce Proofs of SpaceTime over their storage to convince the network that they are actually storing the sectors that they have committed to. Each PoSt covers a miner&rsquo;s entire storage.</p>

<h6 id="step-0-registration">Step 0: Registration</h6>

<p>To initially become a miner, a miner first register a new miner actor on-chain. This is done through the storage power actor&rsquo;s <code>CreateStorageMiner</code> method. The call will then create a new miner actor instance and return its address.</p>

<p>The next step is to place one or more storage market asks on the market. This is done off-chain as part of storagee market functions. A miner may create a single ask for their entire storage, or partition their storage up in some way with multiple asks (at potentially different prices).</p>

<p>After that, they need to make deals with clients and begin filling up sectors with data. For more information on making deals, see the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a>.</p>

<p>When they have a full sector, they should seal it. This is done by invoking the <a href="./#systems__filecoin_mining__storage_proving__sector_sealer">Sector Sealer</a>.</p>

<h6 id="changing-worker-addresses">Changing Worker Addresses</h6>

<p>Note that any change to worker keys after registration (TODO: spec how this works) must be appropriately delayed in relation to randomness lookback for SEALing data (see <a href="https://github.com/filecoin-project/specs/issues/415">this issue</a>).</p>

<h6 id="step-1-commit">Step 1: Commit</h6>

<p>When the miner has completed their first seal, they should post it on-chain using the <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">Storage Miner Actor</a>&rsquo;s <code>ProveCommitSector</code> function. If the miner had zero committed sectors prior to this call, this begins their proving period.</p>

<p>The proving period is a fixed amount of time in which the miner must submit a Proof of Space Time to the network.</p>

<p>During this period, the miner may also commit to new sectors, but they will not be included in proofs of space time until the next proving period starts.
For example, if a miner currently PoSts for 10 sectors, and commits to 20 more sectors. The next PoSt they submit (i.e. the one they&rsquo;re currently proving) will be for 10 sectors again, the subsequent one will be for 30.</p>

<p>TODO: sectors need to be globally unique. This can be done either by having the seal proof prove the sector is unique to this miner in some way, or by having a giant global map on-chain is checked against on each submission. As the system moves towards sector aggregation, the latter option will become unworkable, so more thought needs to go into how that proof statement could work.</p>

<h6 id="step-2-proving-storage-post-creation">Step 2: Proving Storage (PoSt creation)</h6>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ProveStorage</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="p">[]</span><span class="nx">commR</span><span class="p">)</span> <span class="nx">PoStProof</span> <span class="p">{</span>
    <span class="nx">challengeBlockHeight</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">-</span> <span class="nx">POST_CHALLENGE_TIME</span>

    <span class="c1">// Faults to be used are the currentFaultSet for the miner.
</span><span class="c1"></span>    <span class="nx">faults</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">currentFaultSet</span>
    <span class="nx">seed</span> <span class="o">:=</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">challengeBlockHeight</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">sectors</span><span class="p">,</span> <span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Note: See <a href="proof-of-spacetime.md">&lsquo;Proof of Space Time&rsquo;</a> for more details.</p>

<p>The proving set remains consistent during the proving period. Any sectors added in the meantime will be included in the next proving set, at the beginning of the next proving period.</p>

<h6 id="step-3-post-submission">Step 3: PoSt Submission</h6>

<p>When the miner has completed their PoSt, they must submit it to the network by calling <a href="actors.md#submitpost">SubmitPoSt</a>. There are two different times that this <em>could</em> be done.</p>

<ol>
<li><strong>Standard Submission</strong>: A standard submission is one that makes it on-chain before the end of the proving period. The length of time it takes to compute the PoSts is set such that there is a grace period between then and the actual end of the proving period, so that the effects of network congestion on typical miner actions is minimized.</li>
<li><strong>Penalized Submission</strong>: A penalized submission is one that makes it on-chain after the end of the proving period, but before the generation attack threshold. These submissions count as valid PoSt submissions, but the miner must pay a penalty for their late submission. (See &lsquo;<a href="faults.md">Faults</a>&rsquo; for more information)

<ul>
<li>Note: In this case, the next PoSt should still be started at the beginning of the proving period, even if the current one is not yet complete. Miners must submit one PoSt per proving period.</li>
</ul></li>
</ol>

<p>Along with the PoSt submission, miners may also submit a set of sectors that they wish to remove from their proving set. This is done by selecting the sectors in the &lsquo;done&rsquo; bitfield passed to <code>SubmitPoSt</code>.</p>

<h5 id="stop-mining">Stop Mining</h5>

<p>In order to stop mining, a miner must complete all of its storage contracts, and remove them from their proving set during a PoSt submission. A miner may then call <a href="actors.md#depledge"><code>DePledge()</code></a> to retrieve their collateral. <code>DePledge</code> must be called twice, once to start the cooldown, and once again after the cooldown to reclaim the funds. The cooldown period is to allow clients whose files have been dropped by a miner to slash them before they get their money back and get away with it.</p>

<h5 id="faults">Faults</h5>

<p>Faults are described in the <a href="faults.md">faults document</a>.</p>

<h6 id="on-being-slashed-wip-needs-discussion">On Being Slashed (WIP, needs discussion)</h6>

<p>If a miner is slashed for failing to submit their PoSt on time, they currently lose all their pledge collateral. They do not necessarily lose their storage collateral. Storage collateral is lost when a miner&rsquo;s clients slash them for no longer having the data. Missing a PoSt does not necessarily imply that a miner no longer has the data. There should be an additional timeout here where the miner can submit a PoSt, along with &lsquo;refilling&rsquo; their pledge collateral. If a miner does this, they can continue mining, their mining power will be reinstated, and clients can be assured that their data is still there.</p>

<p>TODO: disambiguate the two collaterals across the entire spec</p>

<p>Review Discussion Note: Taking all of a miners collateral for going over the deadline for PoSt submission is really really painful, and is likely to dissuade people from even mining filecoin in the first place (If my internet going out could cause me to lose a very large amount of money, that leads to some pretty hard decisions around profitability). One potential strategy could be to only penalize miners for the amount of sectors they could have generated in that timeframe.</p>

<h5 id="future-work">Future Work</h5>

<p>There are many ideas for improving upon the storage miner, here are ideas that may be potentially implemented in the future.</p>

<ul>
<li><strong>Sector Resealing</strong>: Miners should be able to &rsquo;re-seal&rsquo; sectors, to allow them to take a set of sectors with mostly expired pieces, and combine the not-yet-expired pieces into a single (or multiple) sectors.</li>
<li><strong>Sector Transfer</strong>: Miners should be able to re-delegate the responsibility of storing data to another miner. This is tricky for many reasons, and will not be implemented in the initial release of Filecoin, but could provide interesting capabilities down the road.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_mining__storage_miner_actor">

<h4 class="section-header">
  Storage Miner Actor
</h4>

<div class="section-content">






































<div id="systems__filecoin_mining__storage_mining__storage_miner_actor__storage_miner_actor"></div>

<p>(You can see the <em>old</em> Storage Miner Actor <a href="docs/systems/filecoin_mining/storage_mining/storage_miner_actor_old">here</a> )</p>

<h5 id="storagemineractor-interface"><code>StorageMinerActor</code> interface</h5>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">sealing</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>

<span class="kd">type</span> <span class="nx">Seed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">SectorCommitment</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">SectorExpirationQueueItem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorNumber</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span>
    <span class="nx">Expiration</span>    <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorExpirationQueue</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Add</span><span class="p">(</span><span class="nx">i</span> <span class="nx">SectorExpirationQueueItem</span><span class="p">)</span>
    <span class="nf">Pop</span><span class="p">()</span> <span class="nx">SectorExpirationQueueItem</span>
    <span class="nf">Peek</span><span class="p">()</span> <span class="nx">SectorExpirationQueueItem</span>
    <span class="nf">Remove</span><span class="p">(</span><span class="nx">n</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorTable</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSize</span>             <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="nx">ActiveSectors</span>          <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="nx">CommittedSectors</span>       <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="nx">RecoveringSectors</span>      <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="nx">FailingSectors</span>         <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>

    <span class="nf">ActivePower</span><span class="p">()</span>          <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nf">InactivePower</span><span class="p">()</span>        <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>

    <span class="nx">TerminationFaultCount</span>  <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>  <span class="c1">// transient State that get reset on every constructPowerReport
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorOnChainInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealCommitment</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCommitment</span>
    <span class="nx">State</span>           <span class="nx">SectorState</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ChallengeStatus</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">LastChallengeEpoch</span>     <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>  <span class="c1">// get updated by NotifyOfPoStChallenge
</span><span class="c1"></span>    <span class="nx">LastChallengeEndEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>  <span class="c1">// get updated upon successful submitPoSt
</span><span class="c1"></span>
    <span class="nf">IsChallenged</span><span class="p">()</span>         <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PreCommittedSector</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Info</span>           <span class="nx">sealing</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span>
    <span class="nx">ReceivedEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PreCommittedSectorsAMT</span> <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">PreCommittedSector</span><span class="p">}</span>
<span class="kd">type</span> <span class="nx">SectorsAMT</span> <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">SectorOnChainInfo</span><span class="p">}</span>
<span class="kd">type</span> <span class="nx">StagedCommittedSectorAMT</span> <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">SectorOnChainInfo</span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMinerActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// CollateralVault CollateralVault
</span><span class="c1"></span>
    <span class="nx">PreCommittedSectors</span>        <span class="nx">PreCommittedSectorsAMT</span>
    <span class="nx">Sectors</span>                    <span class="nx">SectorsAMT</span>
    <span class="nx">StagedCommittedSectors</span>     <span class="nx">StagedCommittedSectorAMT</span>

    <span class="c1">// ProvingSet get copied over to NextProvingSet on PoSt challenge and CheckPoStSubmissionHappened
</span><span class="c1"></span>    <span class="c1">// successful SubmitPoSt will perform changes to NextProvingSet
</span><span class="c1"></span>    <span class="c1">// and update ProvingSet with NextProvingSet at the end
</span><span class="c1"></span>    <span class="c1">// No DeclareFaults and CommitSector can happen when SM is in the isChallenged state
</span><span class="c1"></span>    <span class="nx">ProvingSet</span>                 <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span>

    <span class="nx">SectorTable</span>
    <span class="nx">SectorExpirationQueue</span>
    <span class="nx">ChallengeStatus</span>

    <span class="c1">// contains mostly static info about this miner
</span><span class="c1"></span>    <span class="nx">Info</span>                       <span class="o">&amp;</span><span class="nx">MinerInfo</span>

    <span class="c1">// TODO ProvingPeriodEnd   Epoch
</span><span class="c1"></span>
    <span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>  <span class="kt">bool</span>
    <span class="nf">_isSealVerificationCorrect</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">_updateFailSector</span><span class="p">(</span>
        <span class="nx">rt</span>                   <span class="nx">Runtime</span>
        <span class="nx">sectorNo</span>             <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span>
        <span class="nx">incrementFaultCount</span>  <span class="kt">bool</span>
    <span class="p">)</span>
    <span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>
    <span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>
    <span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
    <span class="nf">_updateActivateSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMinerActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">NotifyOfPoStChallenge</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="nf">PreCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span><span class="p">)</span>  <span class="c1">// TODO: check with Magik on sizes
</span><span class="c1"></span>    <span class="nf">ProveCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorProveCommitInfo</span><span class="p">)</span>

    <span class="nf">SubmitPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span>

    <span class="nf">CheckPoStSubmissionHappened</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="c1">// TODO: should depledge be in here or in storage market actor?
</span><span class="c1"></span>
    <span class="nf">DeclareFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">failingSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span>

    <span class="nf">RecoverFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">recoveringSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span>

    <span class="nf">_onMissedPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="nf">_submitFaultReport</span><span class="p">(</span>
        <span class="nx">rt</span>          <span class="nx">Runtime</span>
        <span class="nx">declared</span>    <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
        <span class="nx">detected</span>    <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
        <span class="nx">terminated</span>  <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="p">)</span>
    <span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="nf">_verifyPoStSubmission</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// _computeProvingPeriodEndSectorState(rt Runtime)  // TODO
</span><span class="c1"></span>
    <span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MinerInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Account that owns this miner.
</span><span class="c1"></span>    <span class="c1">// - Income and returned collateral are paid to this address.
</span><span class="c1"></span>    <span class="c1">// - This address is also allowed to change the worker address for the miner.
</span><span class="c1"></span>    <span class="nx">Owner</span>           <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// Worker account for this miner.
</span><span class="c1"></span>    <span class="c1">// This will be the key that is used to sign blocks created by this miner, and
</span><span class="c1"></span>    <span class="c1">// sign messages sent on behalf of this miner to commit sectors, submit PoSts, and
</span><span class="c1"></span>    <span class="c1">// other day to day miner activities.
</span><span class="c1"></span>    <span class="nx">Worker</span>          <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// Libp2p identity that should be used when connecting to this miner.
</span><span class="c1"></span>    <span class="nx">PeerId</span>          <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>

    <span class="c1">// Amount of space in each sector committed to the network by this miner.
</span><span class="c1"></span>    <span class="nx">SectorSize</span>      <span class="nx">util</span><span class="p">.</span><span class="nx">BytesAmount</span>
    <span class="nx">SubsectorCount</span>  <span class="nx">UVarint</span>
    <span class="nx">Partitions</span>      <span class="nx">UVarint</span>
<span class="p">}</span>
</code></pre></div>






<h5 id="storagemineractor-implementation"><code>StorageMinerActor</code> implementation</h5>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_mining</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">filproofs</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto/filproofs&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>
<span class="kn">import</span> <span class="nx">power</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/storage_power_consensus&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">storage_market</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Method_StorageMinerActor_SubmitPoSt</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodPlaceholder</span>
<span class="p">)</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Boilerplate
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">State</span> <span class="p">=</span> <span class="nx">StorageMinerActorState</span>
<span class="kd">type</span> <span class="nx">Any</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Any</span>
<span class="kd">type</span> <span class="nx">Bool</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bool</span>
<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>

<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">()</span>
	<span class="nx">stateBytes</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">ipld</span><span class="p">.</span><span class="nf">CID</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">stateBytes</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime_IpldGet_FunRet_Case_Bytes</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;IPLD lookup error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">stateBytes</span><span class="p">.</span><span class="nf">As_Bytes</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">State</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="c1">// TODO: placeholder epoch value -- this will be set later
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">=</span> <span class="nx">block</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">SectorTable_I</span><span class="p">)</span> <span class="nf">ActivePower</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">block</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">ActiveSectors_</span> <span class="o">*</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">SectorSize_</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">SectorTable_I</span><span class="p">)</span> <span class="nf">InactivePower</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">block</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">((</span><span class="nx">st</span><span class="p">.</span><span class="nx">CommittedSectors_</span> <span class="o">+</span> <span class="nx">st</span><span class="p">.</span><span class="nx">RecoveringSectors_</span> <span class="o">+</span> <span class="nx">st</span><span class="p">.</span><span class="nx">FailingSectors_</span><span class="p">)</span> <span class="o">*</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">SectorSize_</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ChallengeStatus_I</span><span class="p">)</span> <span class="nf">OnNewChallenge</span><span class="p">(</span><span class="nx">currEpoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">ChallengeStatus</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">LastChallengeEpoch_</span> <span class="p">=</span> <span class="nx">currEpoch</span>
	<span class="k">return</span> <span class="nx">cs</span>
<span class="p">}</span>

<span class="c1">// Call by either SubmitPoSt or OnMissedPoSt
</span><span class="c1">// TODO: verify this is correct and if we need to distinguish SubmitPoSt vs OnMissedPoSt
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ChallengeStatus_I</span><span class="p">)</span> <span class="nf">OnChallengeResponse</span><span class="p">(</span><span class="nx">currEpoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">ChallengeStatus</span> <span class="p">{</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">LastChallengeEndEpoch_</span> <span class="p">=</span> <span class="nx">currEpoch</span>
	<span class="k">return</span> <span class="nx">cs</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ChallengeStatus_I</span><span class="p">)</span> <span class="nf">IsChallenged</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// true (isChallenged) when LastChallengeEpoch is later than LastChallengeEndEpoch
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">LastChallengeEpoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">cs</span><span class="p">.</span><span class="nf">LastChallengeEndEpoch</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">IsChallenged</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="c1">// called by CronActor to notify StorageMiner of PoSt Challenge
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">NotifyOfPoStChallenge</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nx">CronActorAddr</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span> <span class="c1">// silent return, dont re-challenge
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">LastChallengeEpoch_</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="nx">sealOnChainInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">StagedCommittedSectors</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sealOnChainInfo</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// empty StagedCommittedSectors
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">StagedCommittedSectors_</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// construct FaultReport
</span><span class="c1">// reset NewTerminatedFaults
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_submitFaultReport</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span>
	<span class="nx">newDeclaredFaults</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span>
	<span class="nx">newDetectedFaults</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span>
	<span class="nx">newTerminatedFaults</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="nx">faultReport</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">power</span><span class="p">.</span><span class="nx">FaultReport_I</span><span class="p">{</span>
		<span class="nx">NewDeclaredFaults_</span><span class="p">:</span>   <span class="nx">newDeclaredFaults</span><span class="p">,</span>
		<span class="nx">NewDetectedFaults_</span><span class="p">:</span>   <span class="nx">newDetectedFaults</span><span class="p">,</span>
		<span class="nx">NewTerminatedFaults_</span><span class="p">:</span> <span class="nx">newTerminatedFaults</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span> <span class="c1">// TODO: Send(SPA, ProcessFaultReport(faultReport))
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">faultReport</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">TerminationFaultCount_</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// construct PowerReport from SectorTable
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">powerReport</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">power</span><span class="p">.</span><span class="nx">PowerReport_I</span><span class="p">{</span>
		<span class="nx">ActivePower_</span><span class="p">:</span>   <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">ActivePower</span><span class="p">(),</span>
		<span class="nx">InactivePower_</span><span class="p">:</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">InactivePower</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span> <span class="c1">// TODO: Send(SPA, ProcessPowerReport(powerReport))
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="nx">powerReport</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_onMissedPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">failingSectorNumbers</span> <span class="o">:=</span> <span class="nf">getSectorNums</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">())</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">failingSectorNumbers</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">newDetectedFaults</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">FailingSectors</span><span class="p">()</span>
	<span class="nx">newTerminatedFaults</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">TerminationFaultCount</span><span class="p">()</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Note: NewDetectedFaults is now the sum of all
</span><span class="c1"></span>	<span class="c1">// previously active, committed, and recovering sectors minus expired ones
</span><span class="c1"></span>	<span class="c1">// and any previously Failing sectors that did not exceed MaxFaultCount
</span><span class="c1"></span>	<span class="c1">// Note: previously declared faults is now treated as part of detected faults
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitFaultReport</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">,</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// NewDeclaredFaults
</span><span class="c1"></span>		<span class="nx">newDetectedFaults</span><span class="p">,</span>
		<span class="nx">newTerminatedFaults</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// end of challenge
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">OnChallengeResponse</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// If a Post is missed (either due to faults being not declared on time or
</span><span class="c1">// because the miner run out of time, every sector is reported as failing
</span><span class="c1">// for the current proving period.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">CheckPoStSubmissionHappened</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// Miner gets out of a challenge when submit a successful PoSt
</span><span class="c1"></span>		<span class="c1">// or when detected by CronActor. Hence, not being in isChallenged means that we are good here
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// oh no -- we missed it. rekt
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_onMissedPoSt</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_verifyPoStSubmission</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 1. A proof must be submitted after the postRandomness for this proving
</span><span class="c1"></span>	<span class="c1">// period is on chain
</span><span class="c1"></span>	<span class="c1">// if rt.ChainEpoch &lt; sm.ProvingPeriodEnd - challengeTime {
</span><span class="c1"></span>	<span class="c1">//   rt.Abort(&#34;too early&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// 2. A proof must be a valid snark proof with the correct public inputs
</span><span class="c1"></span>	<span class="c1">// 2.1 Get randomness from the chain at the right epoch
</span><span class="c1"></span>	<span class="c1">// postRandomness := rt.Randomness(postSubmission.Epoch, 0)
</span><span class="c1"></span>	<span class="c1">// 2.2 Generate the set of challenges
</span><span class="c1"></span>	<span class="c1">// challenges := GenerateChallengesForPoSt(r, keys(sm.Sectors))
</span><span class="c1"></span>	<span class="c1">// 2.3 Verify the PoSt Proof
</span><span class="c1"></span>	<span class="c1">// verifyPoSt(challenges, TODO)
</span><span class="c1"></span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span> <span class="c1">// TODO: finish
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_expirePreCommittedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">preCommitSector</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()</span> <span class="p">{</span>

		<span class="nx">elapsedEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">ReceivedEpoch</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">elapsedEpoch</span> <span class="p">&gt;</span> <span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">{</span>
			<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">(),</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">())</span>
			<span class="c1">// TODO: potentially some slashing if ProveCommitSector comes late
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

<span class="p">}</span>

<span class="c1">// move Sector from Active/Failing
</span><span class="c1">// into Cleared State which means deleting the Sector from state
</span><span class="c1">// remove SectorNumber from all states on chain
</span><span class="c1">// update SectorTable
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sectorState</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
		<span class="c1">// expiration case
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ActiveSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
		<span class="c1">// expiration and termination cases
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// Committed and Recovering should not go to Cleared directly
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;invalid state in clearSector&#34;</span><span class="p">)</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">(),</span> <span class="nx">sectorNo</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorExpirationQueue</span><span class="p">().</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// move Sector from Committed/Recovering into Active State
</span><span class="c1">// reset FaultCount to zero
</span><span class="c1">// update SectorTable
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateActivateSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sectorState</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SectorCommittedSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">case</span> <span class="nx">SectorRecoveringSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">RecoveringSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;invalid state in activateSector&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorActive</span><span class="p">()</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ActiveSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="c1">// failSector moves Sector from Active/Committed/Recovering into Failing State
</span><span class="c1">// and increments FaultCount if asked to do so (DeclareFaults does not increment faultCount)
</span><span class="c1">// move Sector from Failing to Cleared State if increment results in faultCount exceeds MaxFaultCount
</span><span class="c1">// update SectorTable
</span><span class="c1">// remove from ProvingSet
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">,</span> <span class="nx">increment</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newFaultCount</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">().</span><span class="nx">FaultCount</span>

	<span class="k">if</span> <span class="nx">increment</span> <span class="p">{</span>
		<span class="nx">newFaultCount</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">state</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">state</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
		<span class="c1">// wont be terminated from Active
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ActiveSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">SectorCommittedSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">SectorRecoveringSN</span><span class="p">:</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">RecoveringSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
		<span class="c1">// no change to SectorTable but increase in FaultCount
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorFailing</span><span class="p">(</span><span class="nx">newFaultCount</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in CronAction&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">newFaultCount</span> <span class="p">&gt;</span> <span class="nx">MAX_CONSECUTIVE_FAULTS</span> <span class="p">{</span>
		<span class="c1">// TODO: heavy penalization: slash pledge collateral and delete sector
</span><span class="c1"></span>		<span class="c1">// TODO: SendMessage(SPA.SlashPledgeCollateral)
</span><span class="c1"></span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">TerminationFaultCount_</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Decision is to currently account for power based on sector
</span><span class="c1">// with at least one active deals and deals cannot be updated
</span><span class="c1">// an alternative proposal is to account for power based on active deals
</span><span class="c1">// an improvement proposal is to allow storage deal update in a sector
</span><span class="c1"></span>
<span class="c1">// TODO: decide whether declared faults sectors should be
</span><span class="c1">// penalized in the same way as undeclared sectors and how
</span><span class="c1"></span>
<span class="c1">// SubmitPoSt Workflow:
</span><span class="c1">// - Verify PoSt Submission
</span><span class="c1">// - Process ProvingSet.SectorsOn()
</span><span class="c1">//   - State Transitions
</span><span class="c1">//     - Committed -&gt; Active and credit power
</span><span class="c1">//     - Recovering -&gt; Active and credit power
</span><span class="c1">//   - Process Active Sectors (pay miners)
</span><span class="c1">// - Process ProvingSet.SectorsOff()
</span><span class="c1">//     - increment FaultCount
</span><span class="c1">//     - clear Sector and slash pledge collateral if count &gt; MAX_CONSECUTIVE_FAULTS
</span><span class="c1">// - Process Expired Sectors (settle deals and return storage collateral to miners)
</span><span class="c1">//     - State Transition
</span><span class="c1">//       - Failing / Recovering / Active / Committed -&gt; Cleared
</span><span class="c1">//     - Remove SectorNumber from Sectors, ProvingSet
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">SubmitPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;cannot SubmitPoSt when not challenged&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Verify correct PoSt Submission
</span><span class="c1"></span>	<span class="nx">isPoStVerified</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_verifyPoStSubmission</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">postSubmission</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isPoStVerified</span> <span class="p">{</span>
		<span class="c1">// no state transition, just error out and miner should submitPoSt again
</span><span class="c1"></span>		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// The proof is verified, process ProvingSet.SectorsOn():
</span><span class="c1"></span>	<span class="c1">// ProvingSet.SectorsOn() contains SectorCommitted, SectorActive, SectorRecovering
</span><span class="c1"></span>	<span class="c1">// ProvingSet itself does not store states, states are all stored in Sectors.State
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">sectorState</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector state not found in map&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorCommittedSN</span><span class="p">,</span> <span class="nx">SectorRecoveringSN</span><span class="p">:</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateActivateSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
			<span class="c1">// Process payment in all active deals
</span><span class="c1"></span>			<span class="c1">// Note: this must happen before marking sectors as expired.
</span><span class="c1"></span>			<span class="c1">// TODO: Pay miner in a single batch message
</span><span class="c1"></span>			<span class="c1">// SendMessage(sma.ProcessStorageDealsPayment(sm.Sectors()[sectorNumber].DealIDs()))
</span><span class="c1"></span>		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in ProvingSet.SectorsOn()&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// commit state change so that committed and recovering are now active
</span><span class="c1"></span>
	<span class="c1">// Process ProvingSet.SectorsOff()
</span><span class="c1"></span>	<span class="c1">// ProvingSet.SectorsOff() contains SectorFailing
</span><span class="c1"></span>	<span class="c1">// SectorRecovering is Proving and hence will not be in GetZeros()
</span><span class="c1"></span>	<span class="c1">// heavy penalty if Failing for more than or equal to MAX_CONSECUTIVE_FAULTS
</span><span class="c1"></span>	<span class="c1">// otherwise increment FaultCount in Sectors().State
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">SectorsOff</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">sectorState</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in ProvingSet.SectorsOff&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Process Expiration.
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">terminationFaultCount</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">TerminationFaultCount_</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitFaultReport</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">,</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// NewDeclaredFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="c1">// NewDetectedFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">terminationFaultCount</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// TODO: check EnsurePledgeCollateralSatisfied
</span><span class="c1"></span>	<span class="c1">// pledgeCollateralSatisfied
</span><span class="c1"></span>
	<span class="c1">// Reset Proving Period and report power updates
</span><span class="c1"></span>	<span class="c1">// sm.ProvingPeriodEnd_ = PROVING_PERIOD_TIME
</span><span class="c1"></span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">ChallengeStatus</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">OnChallengeResponse</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updateCommittedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_updateExpireSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">currEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>

	<span class="nx">queue</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">SectorExpirationQueue</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Peek</span><span class="p">().</span><span class="nf">Expiration</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="nx">currEpoch</span> <span class="p">{</span>
		<span class="nx">expiredSectorNo</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Pop</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">()</span>

		<span class="nx">state</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">expiredSectorNo</span><span class="p">].</span><span class="nf">State</span><span class="p">()</span>
		<span class="c1">// sc := sm.Sectors()[expiredSectorNo]
</span><span class="c1"></span>		<span class="k">switch</span> <span class="nx">state</span><span class="p">.</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorActiveSN</span><span class="p">:</span>
			<span class="c1">// Note: in order to verify if something was stored in the past, one must
</span><span class="c1"></span>			<span class="c1">// scan the chain. SectorNumber can be re-used.
</span><span class="c1"></span>
			<span class="c1">// Settle deals
</span><span class="c1"></span>			<span class="c1">// SendMessage(sma.SettleExpiredDeals(sc.DealIDs()))
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">expiredSectorNo</span><span class="p">)</span>
		<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
			<span class="c1">// TODO: check if there is any fault that we should handle here
</span><span class="c1"></span>			<span class="c1">// If a SectorFailing Expires, return remaining StorageDealCollateral and remove sector
</span><span class="c1"></span>			<span class="c1">// SendMessage(sma.SettleExpiredDeals(sc.DealIDs()))
</span><span class="c1"></span>
			<span class="c1">// a failing sector expires, no change to FaultCount
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">_updateClearSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">expiredSectorNo</span><span class="p">)</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// Note: SectorCommittedSN, SectorRecoveringSN transition first to SectorFailingSN, then expire
</span><span class="c1"></span>			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in SectorExpirationQueue&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// Return PledgeCollateral for active expirations
</span><span class="c1"></span>	<span class="c1">// SendMessage(spa.Depledge) // TODO
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;TODO: refactor use of this method in order for caller to send this message&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// RecoverFaults checks if miners have sufficent collateral
</span><span class="c1">// and adds SectorFailing into SectorRecovering
</span><span class="c1">// - State Transition
</span><span class="c1">//   - Failing -&gt; Recovering with the same FaultCount
</span><span class="c1">// - Add SectorNumber to ProvingSet
</span><span class="c1">// Note that power is not updated until it is active
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">RecoverFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">recoveringSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;cannot RecoverFaults when sm isChallenged&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// for all SectorNumber marked as recovering by recoveringSet
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">recoveringSet</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">sectorState</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector state not found in map&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">StateNumber</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SectorFailingSN</span><span class="p">:</span>
			<span class="c1">// Check if miners have sufficient balances in sma
</span><span class="c1"></span>
			<span class="c1">// SendMessage(sma.PublishStorageDeals) or sma.ResumeStorageDeals?
</span><span class="c1"></span>			<span class="c1">// throw if miner cannot cover StorageDealCollateral
</span><span class="c1"></span>
			<span class="c1">// Check if miners have sufficient pledgeCollateral
</span><span class="c1"></span>
			<span class="c1">// copy over the same FaultCount
</span><span class="c1"></span>			<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">].</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">State_</span> <span class="p">=</span> <span class="nf">SectorRecovering</span><span class="p">(</span><span class="nx">sectorState</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nx">FaultCount</span><span class="p">)</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>

			<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">FailingSectors_</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">RecoveringSectors_</span> <span class="o">+=</span> <span class="mi">1</span>

		<span class="k">default</span><span class="p">:</span>
			<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>			<span class="c1">// TODO: consider this a no-op (as opposed to a failure), because this is a user
</span><span class="c1"></span>			<span class="c1">// call that may be delayed by the chain beyond some other state transition.
</span><span class="c1"></span>			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Invalid sector state in RecoverFaults&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// DeclareFaults penalizes miners (slashStorageDealCollateral and remove power)
</span><span class="c1">// TODO: decide how much storage collateral to slash
</span><span class="c1">// - State Transition
</span><span class="c1">//   - Active / Commited / Recovering -&gt; Failing
</span><span class="c1">// - Update State in Sectors()
</span><span class="c1">// - Remove Active / Commited / Recovering from ProvingSet
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">DeclareFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">faultSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;cannot DeclareFaults when challenged&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// fail all SectorNumber marked as Failing by faultSet
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">faultSet</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_updateFailSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNo</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">declaredFaults</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">faultSet</span><span class="p">.</span><span class="nf">SectorsOn</span><span class="p">())</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitFaultReport</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">,</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">declaredFaults</span><span class="p">),</span> <span class="c1">// DeclaredFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>              <span class="c1">// DetectedFaults
</span><span class="c1"></span>		<span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>              <span class="c1">// TerminatedFault
</span><span class="c1"></span>	<span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_submitPowerReport</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">_isSealVerificationCorrect</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Info</span><span class="p">()</span>
	<span class="nx">sectorSize</span> <span class="o">:=</span> <span class="nx">info</span><span class="p">.</span><span class="nf">SectorSize</span><span class="p">()</span>
	<span class="nx">dealIDs</span> <span class="o">:=</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">DealIDs</span><span class="p">()</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParam</span><span class="p">,</span> <span class="mi">1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="nx">dealIDs</span><span class="p">))</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span> <span class="c1">// if no modifications made; or
</span><span class="c1"></span>
	<span class="c1">// TODO: serialize method param as {sectorSize,  DealIDs...}.
</span><span class="c1"></span>
	<span class="nx">receipt</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">InvocInput_I</span><span class="p">{</span>
		<span class="nx">To_</span><span class="p">:</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span> <span class="nx">storage_market</span><span class="p">.</span><span class="nx">MethodGetUnsealedCIDForDealIDs</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span> <span class="nx">params</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="k">if</span> <span class="nx">receipt</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">()</span> <span class="o">==</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidSectorPacking</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">receipt</span><span class="p">.</span><span class="nf">ReturnValue</span><span class="p">()</span>

	<span class="nx">pieceInfos</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">PieceInfosFromBytes</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span>

	<span class="c1">// Unless we enforce a minimum padding amount, this totalPieceSize calculation can be removed.
</span><span class="c1"></span>	<span class="c1">// Leaving for now until that decision is entirely finalized.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">totalPieceSize</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pieceInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pieceInfos</span> <span class="p">{</span>
		<span class="nx">pieceSize</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">pieceInfo</span><span class="p">).</span><span class="nf">Size</span><span class="p">()</span>
		<span class="nx">totalPieceSize</span> <span class="o">+=</span> <span class="nx">pieceSize</span>
	<span class="p">}</span>

	<span class="nx">unsealedCID</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">ComputeUnsealedSectorCIDFromPieceInfos</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">pieceInfos</span><span class="p">)</span>

	<span class="nx">sealCfg</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg_I</span><span class="p">{</span>
		<span class="nx">SectorSize_</span><span class="p">:</span>     <span class="nx">sectorSize</span><span class="p">,</span>
		<span class="nx">SubsectorCount_</span><span class="p">:</span> <span class="nx">info</span><span class="p">.</span><span class="nf">SubsectorCount</span><span class="p">(),</span>
		<span class="nx">Partitions_</span><span class="p">:</span>     <span class="nx">info</span><span class="p">.</span><span class="nf">Partitions</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">svInfo</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo_I</span><span class="p">{</span>
		<span class="nx">SectorID_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID_I</span><span class="p">{</span>
			<span class="nx">MinerID_</span><span class="p">:</span> <span class="nx">info</span><span class="p">.</span><span class="nf">Worker</span><span class="p">(),</span> <span class="c1">// TODO: This is actually miner address. MinerID needs to be derived.
</span><span class="c1"></span>			<span class="nx">Number_</span><span class="p">:</span>  <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">(),</span>
		<span class="p">},</span>
		<span class="nx">OnChain_</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">,</span>

		<span class="c1">// TODO: Make SealCfg sector.SealCfg from miner configuration (where is that?)
</span><span class="c1"></span>		<span class="nx">SealCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">sealCfg</span><span class="p">,</span>

		<span class="nx">Randomness_</span><span class="p">:</span>            <span class="nx">sector</span><span class="p">.</span><span class="nf">SealRandomness</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">Randomness</span><span class="p">(</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SealEpoch</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)),</span>
		<span class="nx">InteractiveRandomness_</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">InteractiveSealRandomness</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">Randomness</span><span class="p">(</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">InteractiveEpoch</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)),</span>
		<span class="nx">UnsealedCID_</span><span class="p">:</span>           <span class="nx">unsealedCID</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">sdr</span> <span class="o">:=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">SDRParams</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">filproofs</span><span class="p">.</span><span class="nx">SDRCfg_I</span><span class="p">{</span><span class="nx">SealCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">sealCfg</span><span class="p">})</span>
	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">VerifySeal</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">svInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState_I</span><span class="p">)</span> <span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">sectorNo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">sectorNo</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">found</span>
<span class="p">}</span>

<span class="c1">// Deals must be posted on chain via sma.PublishStorageDeals before PreCommitSector
</span><span class="c1">// TODO(optimization): PreCommitSector could contain a list of deals that are not published yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">PreCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="c1">// no checks needed
</span><span class="c1"></span>	<span class="c1">// can be called regardless of Challenged status
</span><span class="c1"></span>
	<span class="c1">// TODO: might record CurrEpoch for PreCommitSector expiration
</span><span class="c1"></span>	<span class="c1">// in other words, a ProveCommitSector must be on chain X Epoch after a PreCommitSector goes on chain
</span><span class="c1"></span>	<span class="c1">// TODO: might take collateral in case no ProveCommit follows within sometime
</span><span class="c1"></span>	<span class="c1">// TODO: collateral also penalizes repeated precommit to get randomness that one likes
</span><span class="c1"></span>	<span class="c1">// TODO: might be a good place for Treasury
</span><span class="c1"></span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()[</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span>

	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="c1">// TODO: burn some funds?
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector already pre committed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">sectorExists</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">sectorExists</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector already exists.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: verify every DealID has been published and not yet expired
</span><span class="c1"></span>
	<span class="nx">precommittedSector</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">PreCommittedSector_I</span><span class="p">{</span>
		<span class="nx">Info_</span><span class="p">:</span>          <span class="nx">info</span><span class="p">,</span>
		<span class="nx">ReceivedEpoch_</span><span class="p">:</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()[</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">precommittedSector</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActorCode_I</span><span class="p">)</span> <span class="nf">ProveCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorProveCommitInfo</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: validate caller
</span><span class="c1"></span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">preCommitSector</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">()[</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector not pre committed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">sectorExists</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_sectorExists</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">())</span>

	<span class="k">if</span> <span class="nx">sectorExists</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Sector already exists.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// check if ProveCommitSector comes too late after PreCommitSector
</span><span class="c1"></span>	<span class="nx">elapsedEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">ReceivedEpoch</span><span class="p">()</span>

	<span class="c1">// if more than MAX_PROVE_COMMIT_SECTOR_EPOCH has elapsed
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">elapsedEpoch</span> <span class="p">&gt;</span> <span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">{</span>
		<span class="c1">// TODO: potentially some slashing if ProveCommitSector comes late
</span><span class="c1"></span>
		<span class="c1">// expired
</span><span class="c1"></span>		<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">(),</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">())</span>
		<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ErrorReturn</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nf">UserDefinedError</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="c1">// TODO: user dfined error code?
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">onChainInfo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo_I</span><span class="p">{</span>
		<span class="nx">SealedCID_</span><span class="p">:</span>        <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SealedCID</span><span class="p">(),</span>
		<span class="nx">SealEpoch_</span><span class="p">:</span>        <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SealEpoch</span><span class="p">(),</span>
		<span class="nx">InteractiveEpoch_</span><span class="p">:</span> <span class="nx">info</span><span class="p">.</span><span class="nf">InteractiveEpoch</span><span class="p">(),</span>
		<span class="nx">Proof_</span><span class="p">:</span>            <span class="nx">info</span><span class="p">.</span><span class="nf">Proof</span><span class="p">(),</span>
		<span class="nx">DealIDs_</span><span class="p">:</span>          <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">DealIDs</span><span class="p">(),</span>
		<span class="nx">SectorNumber_</span><span class="p">:</span>     <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="nx">isSealVerificationCorrect</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isSealVerificationCorrect</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">onChainInfo</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isSealVerificationCorrect</span> <span class="p">{</span>
		<span class="c1">// TODO: determine proper error here and error-handling machinery
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;Seal verification failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO: check EnsurePledgeCollateralSatisfied
</span><span class="c1"></span>	<span class="c1">// pledgeCollateralSatisfied
</span><span class="c1"></span>
	<span class="c1">// determine lastDealExpiration from sma
</span><span class="c1"></span>	<span class="c1">// TODO: proper onchain transaction
</span><span class="c1"></span>	<span class="c1">// lastDealExpiration := SendMessage(sma, GetLastDealExpirationFromDealIDs(onChainInfo.DealIDs()))
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">lastDealExpiration</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>

	<span class="c1">// Note: in the current iteration, a Sector expires only when all storage deals in it have expired.
</span><span class="c1"></span>	<span class="c1">// This is likely to change but it aims to meet user requirement that users can enter into deals of any size.
</span><span class="c1"></span>	<span class="c1">// add sector expiration to SectorExpirationQueue
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">SectorExpirationQueue</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">SectorExpirationQueueItem_I</span><span class="p">{</span>
		<span class="nx">SectorNumber_</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">(),</span>
		<span class="nx">Expiration_</span><span class="p">:</span>   <span class="nx">lastDealExpiration</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="c1">// no need to store the proof and randomseed in the state tree
</span><span class="c1"></span>	<span class="c1">// verify and drop, only SealCommitment{CommR, DealIDs} on chain
</span><span class="c1"></span>	<span class="nx">sealCommitment</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SealCommitment_I</span><span class="p">{</span>
		<span class="nx">SealedCID_</span><span class="p">:</span>  <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SealedCID</span><span class="p">(),</span>
		<span class="nx">DealIDs_</span><span class="p">:</span>    <span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">DealIDs</span><span class="p">(),</span>
		<span class="nx">Expiration_</span><span class="p">:</span> <span class="nx">lastDealExpiration</span><span class="p">,</span> <span class="c1">// TODO decide if we need this too
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// add SectorNumber and SealCommitment to Sectors
</span><span class="c1"></span>	<span class="c1">// set Sectors.State to SectorCommitted
</span><span class="c1"></span>	<span class="c1">// Note that SectorNumber will only become Active at the next successful PoSt
</span><span class="c1"></span>	<span class="nx">sealOnChainInfo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">SectorOnChainInfo_I</span><span class="p">{</span>
		<span class="nx">SealCommitment_</span><span class="p">:</span> <span class="nx">sealCommitment</span><span class="p">,</span>
		<span class="nx">State_</span><span class="p">:</span>          <span class="nf">SectorCommitted</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isChallenged</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// move PreCommittedSector to StagedCommittedSectors if in Challenged status
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">StagedCommittedSectors</span><span class="p">()[</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">sealOnChainInfo</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// move PreCommittedSector to CommittedSectors if not in Challenged status
</span><span class="c1"></span>		<span class="nx">st</span><span class="p">.</span><span class="nf">Sectors</span><span class="p">()[</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">sealOnChainInfo</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">ProvingSet_</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">onChainInfo</span><span class="p">.</span><span class="nf">SectorNumber</span><span class="p">())</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">SectorTable</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">CommittedSectors_</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="c1">// now remove SectorNumber from PreCommittedSectors (processed)
</span><span class="c1"></span>	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">PreCommittedSectors</span><span class="p">(),</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nf">Info</span><span class="p">().</span><span class="nf">SectorNumber</span><span class="p">())</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getSectorNums</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">l</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_mining__mining_scheduler">

<h4 class="section-header">
  Mining Scheduler
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">mining</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining&#34;</span>
<span class="c1">// import storage_indexer &#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_indexer&#34;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">MiningScheduler</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">getStagedSectors</span><span class="p">()</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>
    <span class="nf">getSealedSectors</span><span class="p">()</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorSet</span>
    <span class="nf">getFaultySectors</span><span class="p">()</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>
    <span class="nf">getRepairedSectors</span><span class="p">()</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>
    <span class="c1">// same as completedSectors/doneSectors
</span><span class="c1"></span>    <span class="nf">getExpiredSectors</span><span class="p">()</span>   <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>

    <span class="nf">ProducePost</span><span class="p">(</span><span class="nx">sectors</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span><span class="p">)</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span>
    <span class="nf">VerifyPost</span><span class="p">(</span><span class="nx">sectors</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span><span class="p">)</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span>

    <span class="nf">ReportFaults</span><span class="p">(</span>
        <span class="nx">actor</span> <span class="o">&amp;</span><span class="nx">StorageMinerActorCode</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">RemoveSectors</span><span class="p">(</span><span class="nx">remove</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">DePledge</span><span class="p">(</span>
        <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// receives from sector storage subsystem
</span><span class="c1"></span>    <span class="nf">SealedSector</span><span class="p">(</span>
        <span class="nx">sealedSector</span> <span class="nx">mining</span><span class="p">.</span><span class="nx">SealedSector</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">AddSector</span><span class="p">(</span>
        <span class="nx">pledge</span>    <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
        <span class="nx">sectorID</span>  <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
        <span class="nx">comm</span>      <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span>
    <span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__sector">

<h3 class="section-header">
  Sector
</h3>

<div class="section-content">




































<p>The <code>Sector</code> is a fundamental &ldquo;storage container&rdquo; abstraction used in Filecoin Storage Mining. It is the basic unit of storage,
and serves to make storage conform to a set of expectations.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">Bytes32</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">MinerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="kd">type</span> <span class="nx">Commitment</span> <span class="nx">Bytes32</span>  <span class="c1">// TODO
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnsealedSectorCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">SealedSectorCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="c1">// SectorNumber is a numeric identifier for a sector. It is usually
</span><span class="c1">// relative to a Miner.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorNumber</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">FaultSet</span> <span class="nx">CompactSectorSet</span>

<span class="c1">// SectorSize indicates one of a set of possible sizes in the network.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorSize</span> <span class="nx">UInt</span>

<span class="c1">// Ideally, SectorSize would be an enum
</span><span class="c1">// type SectorSize enum {
</span><span class="c1">//   1KiB = UInt 1024
</span><span class="c1">//   1MiB = Uint 1048576
</span><span class="c1">//   1GiB = Uint 1073741824
</span><span class="c1">//   1TiB = Uint 1099511627776
</span><span class="c1">//   1PiB = Uint 1125899906842624
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="c1">// TODO make sure this is globally unique
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorID</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">MinerID</span>
    <span class="nx">Number</span> <span class="nx">SectorNumber</span>
<span class="p">}</span>

<span class="c1">// SectorInDetail describes all the bits of information associated
</span><span class="c1">// with each sector.
</span><span class="c1">// - ID   - a unique identifier assigned once the Sector is registered on chain
</span><span class="c1">// - Size - the size of the sector. there are a set of allowable sizes
</span><span class="c1">//
</span><span class="c1">// NOTE: do not use this struct. It is for illustrative purposes only.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorInDetail</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>    <span class="nx">SectorID</span>
    <span class="nx">Size</span>  <span class="nx">SectorSize</span>

    <span class="nx">Unsealed</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">CID</span>     <span class="nx">UnsealedSectorCID</span>
        <span class="nx">Deals</span>   <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">]</span>
        <span class="nx">Pieces</span>  <span class="p">[</span><span class="nx">piece</span><span class="p">.</span><span class="nx">Piece</span><span class="p">]</span>
        <span class="c1">// Pieces Tree&lt;Piece&gt; // some tree for proofs
</span><span class="c1"></span>        <span class="nx">Bytes</span>
    <span class="p">}</span>

    <span class="nx">Sealed</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">CID</span> <span class="nx">SealedSectorCID</span>
        <span class="nx">Bytes</span>
        <span class="nx">SealCfg</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// SectorInfo is an object that gathers all the information miners know about their
</span><span class="c1">// sectors. This is meant to be used for a local index.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>              <span class="nx">SectorID</span>
    <span class="nx">UnsealedInfo</span>    <span class="nx">UnsealedSectorInfo</span>
    <span class="nx">SealedInfo</span>      <span class="nx">SealedSectorInfo</span>
    <span class="nx">SealVerifyInfo</span>
    <span class="nx">ProofAux</span>
<span class="p">}</span>

<span class="c1">// UnsealedSectorInfo is an object that tracks the relevant data to keep in a sector
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnsealedSectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">UnsealedCID</span>  <span class="nx">UnsealedSectorCID</span>  <span class="c1">// CommD
</span><span class="c1"></span>    <span class="nx">Size</span>         <span class="nx">SectorSize</span>
    <span class="nx">PieceCount</span>   <span class="nx">UVarint</span>  <span class="c1">// number of pieces in this sector (can get it from len(Pieces) too)
</span><span class="c1"></span>    <span class="nx">Pieces</span>       <span class="p">[</span><span class="nx">piece</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">]</span>  <span class="c1">// wont get externalized easy, -- it&#39;s big
</span><span class="c1"></span>    <span class="nx">SealCfg</span>  <span class="c1">// this will be here as well. it&#39;s determined.
</span><span class="c1"></span>    <span class="c1">// Deals       [deal.StorageDeal]
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// SealedSectorInfo keeps around information about a sector that has been sealed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealedSectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealedCID</span>  <span class="nx">SealedSectorCID</span>
    <span class="nx">Size</span>       <span class="nx">SectorSize</span>
    <span class="nx">SealCfg</span>
    <span class="nx">SealArgs</span>   <span class="nx">SealArguments</span>
<span class="p">}</span>
</code></pre></div>






<p>TODO:</p>

<ul>
<li>sector illustration</li>
<li>describe how Sectors are used in practice</li>
<li>describe sizing ranges of sectors</li>
<li>describe &ldquo;storage/shipping container&rdquo; analogy</li>
</ul>


</div>


  
    








<div id="systems__filecoin_mining__sector__sectorset">

<h4 class="section-header">
  Sector Set
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sector sets
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorSet</span> <span class="p">[</span><span class="nx">SectorID</span><span class="p">]</span>
<span class="kd">type</span> <span class="nx">UnsealedSectorSet</span> <span class="nx">SectorSet</span>
<span class="kd">type</span> <span class="nx">SealedSectorSet</span> <span class="nx">SectorSet</span>

<span class="c1">// compact sector sets
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Bitfield</span> <span class="nx">Bytes</span>  <span class="c1">// TODO: move to the right place -- a lib?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RLEpBitfield</span> <span class="nx">Bitfield</span>  <span class="c1">// TODO: move to the right place -- a lib?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CompactSectorSet</span> <span class="nx">RLEpBitfield</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__sector__sealing">

<h4 class="section-header">
  Sector Sealing
</h4>

<div class="section-content">

























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">Path</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">SealRandomness</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">InteractiveSealRandomness</span> <span class="nx">Bytes</span>

<span class="c1">// SealSeed is unique to each Sector
</span><span class="c1">// SealSeed is:
</span><span class="c1">//    SealSeedHash(MinerID, SectorNumber, SealRandomness, UnsealedSectorCID)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealSeed</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">SealCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSize</span>      <span class="nx">UInt</span>
    <span class="nx">SubsectorCount</span>  <span class="nx">UInt</span>
    <span class="nx">Partitions</span>      <span class="nx">UInt</span>
<span class="p">}</span>

<span class="c1">// SealVerifyInfo is the structure of all thte information a verifier
</span><span class="c1">// needs to verify a Seal.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealVerifyInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>
    <span class="nx">OnChain</span>                <span class="nx">OnChainSealVerifyInfo</span>
    <span class="nx">SealCfg</span>
    <span class="nx">Randomness</span>             <span class="nx">SealRandomness</span>
    <span class="nx">InteractiveRandomness</span>  <span class="nx">InteractiveSealRandomness</span>
    <span class="nx">UnsealedCID</span>            <span class="nx">UnsealedSectorCID</span>  <span class="c1">// CommD
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// OnChainSealVerifyInfo is the structure of information that must be sent with
</span><span class="c1">// a message to commit a sector. Most of this information is not needed in the
</span><span class="c1">// state tree but will be verified in sm.CommitSector. See SealCommitment for
</span><span class="c1">// data stored on the state tree for each sector.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OnChainSealVerifyInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealedCID</span>         <span class="nx">SealedSectorCID</span>  <span class="c1">// CommR
</span><span class="c1"></span>    <span class="nx">SealEpoch</span>         <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">InteractiveEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">Proof</span>             <span class="nx">SealProof</span>
    <span class="nx">DealIDs</span>           <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
    <span class="nx">SectorNumber</span>
<span class="p">}</span>

<span class="c1">// SealCommitment is the information kept in the state tree about a sector.
</span><span class="c1">// SealCommitment is a subset of OnChainSealVerifyInfo.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealCommitment</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealedCID</span>   <span class="nx">SealedSectorCID</span>  <span class="c1">// CommR
</span><span class="c1"></span>    <span class="nx">DealIDs</span>     <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
    <span class="nx">Expiration</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorPreCommitInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorNumber</span>
    <span class="nx">SealedCID</span>     <span class="nx">SealedSectorCID</span>  <span class="c1">// CommR
</span><span class="c1"></span>    <span class="nx">SealEpoch</span>     <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">DealIDs</span>       <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorProveCommitInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorNumber</span>
    <span class="nx">Proof</span>             <span class="nx">SealProof</span>
    <span class="nx">InteractiveEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="c1">// ProofAux is meta data required to generate certain proofs
</span><span class="c1">// for a sector, for example PoSt.
</span><span class="c1">// These should be stored and indexed somewhere by CommR.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ProofAux</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CommRLast</span>          <span class="nx">Commitment</span>
    <span class="nx">CommC</span>              <span class="nx">Commitment</span>

    <span class="c1">// TODO: This may be a partially-cached tree.
</span><span class="c1"></span>    <span class="c1">// this may be empty
</span><span class="c1"></span>    <span class="nx">CommRLastTreePath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofAuxTmp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PersistentAux</span>   <span class="nx">ProofAux</span>

    <span class="nx">SectorID</span>
    <span class="nx">CommD</span>           <span class="nx">Commitment</span>
    <span class="nx">CommR</span>           <span class="nx">SealedSectorCID</span>
    <span class="nx">CommDTreePaths</span>  <span class="p">[</span><span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span>
    <span class="nx">CommCTreePath</span>   <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>

    <span class="nx">Seeds</span>           <span class="p">[</span><span class="nx">SealSeed</span><span class="p">]</span>
    <span class="nx">SubsectorData</span>   <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
    <span class="nx">Replicas</span>        <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
    <span class="nx">KeyLayers</span>       <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealArguments</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span>        <span class="nx">SealAlgorithm</span>
    <span class="nx">OutputArtifacts</span>  <span class="nx">SealOutputArtifacts</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealProof</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">//&lt;curve, system&gt; {
</span><span class="c1"></span>    <span class="nx">Config</span>      <span class="nx">SealProofConfig</span>
    <span class="nx">ProofBytes</span>  <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealProofConfig</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">// TODO
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// TODO: move into proofs lib
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FilecoinSNARKProof</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">//&lt;bls12-381, Groth16&gt;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">SealAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="c1">// ZigZagPoRep
</span><span class="c1"></span>    <span class="nx">StackedDRG</span>
<span class="p">}</span>

<span class="c1">// TODO
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealOutputArtifacts</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// TODO: PieceInfo is the name used by proofs for this struct, but there also exists a piece.PieceInfo type, which is different.
</span><span class="c1">// We should probably rename one of them, since this is quite confusing. Or, if we can put `PieceCID` into pieces.PieceInfo, we can just use that.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Size</span>      <span class="nx">UVarint</span>  <span class="c1">// Size in nodes. For BLS12-381 (capacity 254 bits), must be &gt;= 16. (16 * 8 = 128)
</span><span class="c1"></span>    <span class="nx">PieceCID</span>  <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span>

    <span class="c1">// Data returns the serialized representation of the PieceInfo.
</span><span class="c1"></span>    <span class="nf">Data</span><span class="p">()</span>    <span class="nx">Bytes</span>
<span class="p">}</span>
</code></pre></div>






<h6 id="drawing-randomness-for-sector-commitments">Drawing randomness for sector commitments</h6>

<p><a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_chain">Tickets</a> are used as input to the SEAL above in order to tie Proofs-of-Replication to a given chain, thereby preventing long-range attacks (from another miner in the future trying to reuse SEALs).</p>

<p>The ticket has to be drawn from a finalized block in order to prevent the miner from potential losing storage (in case of a chain reorg) even though their storage is intact.</p>

<p>Verification should ensure that the ticket was drawn no farther back than necessary by the miner. We note that tickets can uniquely be associated to a given round in the protocol (lest a hash collision be found), but that the round number is explicited by the miner in <code>commitSector</code>.</p>

<p>We present precisely how ticket selection and verification should work. In the below, we use the following notation:</p>

<ul>
<li><code>F</code>&ndash; Finality (number of rounds)</li>
<li><code>X</code>&ndash; round in which SEALing starts</li>
<li><code>Z</code>&ndash; round in which the SEAL appears (in a block)</li>
<li><code>Y</code>&ndash; round announced in the SEAL <code>commitSector</code> (should be X, but a miner could use any Y &lt;= X), denoted by the ticket selection

<ul>
<li><code>T</code>&ndash; estimated time for SEAL, dependent on sector size</li>
<li><code>G = T + variance</code>&ndash; necessary flexibility to account for network delay and SEAL-time variance.</li>
</ul></li>
</ul>

<p>We expect Filecoin will be able to produce estimates for sector commitment time based on sector sizes, e.g.:
<code>(estimate, variance) &lt;--- SEALTime(sectors)</code>
G and T will be selected using these.</p>

<h6 id="picking-a-ticket-to-seal">Picking a Ticket to Seal</h6>

<p>When starting to prepare a SEAL in round X, the miner should draw a ticket from X-F with which to compute the SEAL.</p>

<h6 id="verifying-a-seal-s-ticket">Verifying a Seal&rsquo;s ticket</h6>

<p>When verifying a SEAL in round Z, a verifier should ensure that the ticket used to generate the SEAL is found in the range of rounds [Z-T-F-G, Z-T-F+G].</p>

<h6 id="in-detail">In Detail</h6>

<pre><code>                               Prover
           ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
          ‚îÇ

          ‚ñº
         X-F ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄF‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ X ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄT‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ Z
     -G   .  +G                 .                        .
  ‚îÄ‚îÄ‚îÄ(‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ( )‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ( )‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 '                        '        time
 [Z-T-F-G, Z-T-F+G]
          ‚ñ≤

          ‚îî ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
                              Verifier
</code></pre>

<p>Note that the prover here is submitting a message on chain (i.e. the SEAL). Using an older ticket than necessary to generate the SEAL is something the miner may do to gain more confidence about finality (since we are in a probabilistically final system). However it has a cost in terms of securing the chain in the face of long-range attacks (specifically, by mixing in chain randomness here, we ensure that an attacker going back a month in time to try and create their own chain would have to completely regenerate any and all sectors drawing randomness since to use for their fork&rsquo;s power).</p>

<p>We break this down as follows:</p>

<ul>
<li>The miner should draw from <code>X-F</code>.</li>
<li>The verifier wants to find what <code>X-F</code> should have been (to ensure the miner is not drawing from farther back) even though Y (i.e. the round of the ticket actually used) is an unverifiable value.</li>
<li>Thus, the verifier will need to make an inference about what <code>X-F</code> is likely to have been based on:

<ul>
<li>(known) round in which the message is received (Z)</li>
<li>(known) finality value (F)</li>
<li>(approximate) SEAL time (T)</li>
</ul></li>
<li>Because T is an approximate value, and to account for network delay and variance in SEAL time across miners, the verifier allows for G offset from the assumed value of <code>X-F</code>: <code>Z-T-F</code>, hence verifying that the ticket is drawn from the range <code>[Z-T-F-G, Z-T-F+G]</code>.</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__sector_index">

<h3 class="section-header">
  Sector Index
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>

<span class="c1">// TODO import this from StorageMarket
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorIndex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BySectorID</span>     <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByUnsealedCID</span>  <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">BySealedCID</span>    <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByPieceID</span>      <span class="p">{</span><span class="nx">piece</span><span class="p">.</span><span class="nx">PieceID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByDealID</span>       <span class="p">{</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorIndexerSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Index</span>    <span class="nx">SectorIndex</span>
    <span class="nx">Store</span>    <span class="nx">SectorStore</span>
    <span class="nx">Builder</span>  <span class="nx">SectorBuilder</span>

    <span class="c1">// AddNewDeal is called by StorageMiningSubsystem after the StorageMarket
</span><span class="c1"></span>    <span class="c1">// has made a deal. AddNewDeal returns an error when:
</span><span class="c1"></span>    <span class="c1">// - there is no capacity to store more deals and their pieces
</span><span class="c1"></span>    <span class="nf">AddNewDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">StageDealResponse</span>

    <span class="c1">// bring back if needed.
</span><span class="c1"></span>    <span class="c1">// OnNewTipset(chain Chain, epoch blockchain.Epoch) struct {}
</span><span class="c1"></span>
    <span class="c1">// SectorsExpiredAtEpoch returns the set of sectors that expire
</span><span class="c1"></span>    <span class="c1">// at a particular epoch.
</span><span class="c1"></span>    <span class="nf">SectorsExpiredAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>

    <span class="c1">// removeSectors removes the given sectorIDs from storage.
</span><span class="c1"></span>    <span class="nf">removeSectors</span><span class="p">(</span><span class="nx">sectorIDs</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  

  
    








<div id="systems__filecoin_mining__sector_index__sector_builder">

<h4 class="section-header">
  Sector Builder
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="c1">// import smkt &#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&#34;
</span><span class="c1"></span><span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>

<span class="c1">// SectorBuilder accumulates deals, keeping track of their
</span><span class="c1">// sector configuration requirements and the piece sizes.
</span><span class="c1">// Once there is a sector ready to be sealed, NextSector
</span><span class="c1">// will return a sector.
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">StageDealResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorBuilder</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// DealsToSeal keeps a set of StorageDeal objects.
</span><span class="c1"></span>    <span class="c1">// These include the info for the relevant pieces.
</span><span class="c1"></span>    <span class="c1">// This builder just accumulates deals, keeping track of their
</span><span class="c1"></span>    <span class="c1">// sector configuration requirements, and the piece sizes.
</span><span class="c1"></span>    <span class="nx">DealsToSeal</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">]</span>

    <span class="c1">// StageDeal adds a deal to be packed into a sector.
</span><span class="c1"></span>    <span class="nf">StageDeal</span><span class="p">(</span><span class="nx">d</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">StageDealResponse</span>

    <span class="c1">// NextSector returns an UnsealedSectorInfo, which includes the (ordered) set of
</span><span class="c1"></span>    <span class="c1">// pieces, and the SealCfg. An error may be returned if SectorBuilder is not
</span><span class="c1"></span>    <span class="c1">// ready to produce a Sector.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// TODO: use go channels? or notifications?
</span><span class="c1"></span>    <span class="nf">NextSector</span><span class="p">()</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">i</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__sector_index__sector_store">

<h4 class="section-header">
  SectorStore
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>

<span class="kd">type</span> <span class="nx">SectorStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// FileStore stores all the unsealed and sealed sectors.
</span><span class="c1"></span>    <span class="nx">FileStore</span>   <span class="nx">file</span><span class="p">.</span><span class="nx">FileStore</span>

    <span class="c1">// PieceStore is shared with DataTransfer, and is a way to store or read
</span><span class="c1"></span>    <span class="c1">// pieces temporarily. This may or may not be backed by the FileStore above.
</span><span class="c1"></span>    <span class="nx">PieceStore</span>  <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceStore</span>

    <span class="c1">// GetSectorFile returns the file for a given sector id.
</span><span class="c1"></span>    <span class="c1">// If the SectorID does not have any sector files associated yet, GetSectorFiles
</span><span class="c1"></span>    <span class="c1">// returns an error.
</span><span class="c1"></span>    <span class="nf">GetSectorFiles</span><span class="p">(</span><span class="nx">id</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">SectorFiles</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Get information, including a merkle tree file/path, needed to generate PoSt for a sector.
</span><span class="c1"></span>    <span class="nf">GetSectorProofAux</span><span class="p">(</span><span class="nx">id</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAux</span>

    <span class="nf">StoreSectorProofAux</span><span class="p">(</span><span class="nx">id</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">proofAux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAux</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">proofAux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAux</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// CreateSectorFiles allocates two sector files, one for unsealed and one for
</span><span class="c1"></span>    <span class="c1">// sealed sector.
</span><span class="c1"></span>    <span class="nf">CreateSectorFiles</span><span class="p">(</span><span class="nx">id</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">SectorFiles</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// SectorFiles is a datastructure that groups two file objects and a sectorID.
</span><span class="c1">// These files are where unsealed and sealed sectors should go.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorFiles</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">Unsealed</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">File</span>
    <span class="nx">Sealed</span>    <span class="nx">file</span><span class="p">.</span><span class="nx">File</span>
<span class="p">}</span>
</code></pre></div>






<p>TODO</p>

<ul>
<li>talk about how sectors are stored</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__storage_proving">

<h3 class="section-header">
  Storage Proving
</h3>

<div class="section-content">




































<p>Filecoin Poving Subsystem</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>
<span class="kn">import</span> <span class="nx">sealer</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/sealer&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">StorageProvingSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSealer</span>   <span class="nx">sealer</span><span class="p">.</span><span class="nx">SectorSealer</span>
    <span class="nx">PostGenerator</span>  <span class="nx">poster</span><span class="p">.</span><span class="nx">PostGenerator</span>

    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">,</span> <span class="nx">pieceInfos</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">])</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">ok</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">ComputeUnsealedSectorCID</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">pieceInfos</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">])</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">unsealedSectorCID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span>

    <span class="c1">// TODO: remove this?
</span><span class="c1"></span>    <span class="c1">// GetPieceInclusionProof(pieceRef CID) union { PieceInclusionProofs, error }
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_mining__storage_proving__sealer">

<h4 class="section-header">
  Sector Sealer
</h4>

<div class="section-content">




































<p>Sector Sealer</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>

<span class="kd">type</span> <span class="nx">SealInputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>       <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">SealCfg</span>        <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg</span>
    <span class="nx">MinerID</span>        <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">RandomSeed</span>     <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span>
    <span class="nx">UnsealedPaths</span>  <span class="p">[</span><span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span>
    <span class="nx">SealedPaths</span>    <span class="p">[</span><span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span>
    <span class="nx">DealIDs</span>        <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CreateSealProofInputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>               <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">SealCfg</span>                <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg</span>
    <span class="nx">InteractiveRandomSeed</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
    <span class="nx">SealedPaths</span>            <span class="p">[</span><span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span>
    <span class="nx">SealOutputs</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealOutputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ProofAuxTmp</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CreateSealProofOutputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealInfo</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span>
    <span class="nx">ProofAux</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAux</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorSealer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">SealSector</span><span class="p">()</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">SealOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">CreateSealProof</span><span class="p">(</span><span class="nx">si</span> <span class="nx">CreateSealProofInputs</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">CreateSealProofOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="nf">MaxUnsealedBytesPerSector</span><span class="p">(</span><span class="nx">SectorSize</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_proving__poster">

<h4 class="section-header">
  Sector Poster
</h4>

<div class="section-content">

























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">sectorIndex</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">UInt64</span> <span class="nx">UInt</span>

<span class="c1">// TODO: move this to somewhere the blockchain can import
</span><span class="c1">// candidates:
</span><span class="c1">// - filproofs - may have to learn about Sectors (and if we move Seal stuff, Deals)
</span><span class="c1">// - &#34;blockchain/builtins&#34; or something like that - a component in the blockchain that handles storage verification
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PoStSubmission</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PostProof</span>   <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span>
    <span class="nx">ChainEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PostGenerator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">GeneratePoSt</span><span class="p">(</span>
        <span class="nx">postCfg</span>        <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCfg</span>
        <span class="nx">challengeSeed</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">faults</span>         <span class="nx">sector</span><span class="p">.</span><span class="nx">FaultSet</span>
        <span class="nx">sectors</span>        <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>
        <span class="nx">sectorStore</span>    <span class="nx">sectorIndex</span><span class="p">.</span><span class="nx">SectorStore</span>
    <span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">poster</span>

<span class="kn">import</span> <span class="nx">filproofs</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto/filproofs&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">sectorIndex</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">type</span> <span class="nx">Serialization</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>

<span class="c1">// See &#34;Proof-of-Spacetime Parameters&#34; Section
</span><span class="c1">// TODO: Unify with orient model.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">POST_CHALLENGE_DEADLINE</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">480</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">GeneratePoStCandidates</span><span class="p">(</span><span class="nx">postCfg</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCfg</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">FaultSet</span><span class="p">,</span> <span class="nx">sectors</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sectorIndex</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">)</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">ElectionCandidate</span> <span class="p">{</span>
	<span class="c1">// Question: Should we pass metadata into FilProofs so it can interact with SectorStore directly?
</span><span class="c1"></span>	<span class="c1">// Like this:
</span><span class="c1"></span>	<span class="c1">// PoStReponse := SectorStorageSubsystem.GeneratePoSt(sectorSize, challenge, faults, sectorsMetatada);
</span><span class="c1"></span>
	<span class="c1">// Question: Or should we resolve + manifest trees here and pass them in?
</span><span class="c1"></span>	<span class="c1">// Like this:
</span><span class="c1"></span>	<span class="c1">// trees := sectorsMetadata.map(func(md) { SectorStorage.GetMerkleTree(md.MerkleTreePath) });
</span><span class="c1"></span>	<span class="c1">// Done this way, we redundantly pass the tree paths in the metadata. At first thought, the other way
</span><span class="c1"></span>	<span class="c1">// seems cleaner.
</span><span class="c1"></span>	<span class="c1">// PoStReponse := SectorStorageSubsystem.GeneratePoSt(sectorSize, challenge, faults, sectorsMetadata, trees);
</span><span class="c1"></span>
	<span class="c1">// For now, dodge this by passing the whole SectorStore. Once we decide how we want to represent this, we can narrow the call.
</span><span class="c1"></span>
	<span class="nx">sdr</span> <span class="o">:=</span> <span class="nf">makeStackedDRGForPoSt</span><span class="p">(</span><span class="nx">postCfg</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">GeneratePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectorStore</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GeneratePoStProof</span><span class="p">(</span><span class="nx">postCfg</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCfg</span><span class="p">,</span> <span class="nx">witness</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStWitness</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="nx">sdr</span> <span class="o">:=</span> <span class="nf">makeStackedDRGForPoSt</span><span class="p">(</span><span class="nx">postCfg</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">privateProofs</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PrivatePoStProof</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">witness</span><span class="p">.</span><span class="nf">Candidates</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">privateProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">privateProofs</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">.</span><span class="nf">PrivateProof</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">GeneratePoStProof</span><span class="p">(</span><span class="nx">privateProofs</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// This likely belongs elsewhere, but I&#39;m not exactly sure where and wanted to encapsulate the proofs-related logic here. So this can be thought of as example usage.
</span><span class="c1">// ticketThreshold is lowest non-winning ticket (endianness?) for this PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">postCfg</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCfg</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">FaultSet</span><span class="p">,</span> <span class="nx">sectors</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sectorIndex</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">,</span> <span class="nx">ticketThreshold</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ElectionTicket</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="nx">candidates</span> <span class="o">:=</span> <span class="nf">GeneratePoStCandidates</span><span class="p">(</span><span class="nx">postCfg</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectors</span><span class="p">,</span> <span class="nx">sectorStore</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">winners</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">ElectionCandidate</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">candidates</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">candidate</span><span class="p">.</span><span class="nf">Ticket</span><span class="p">().</span><span class="nf">IsBelow</span><span class="p">(</span><span class="nx">ticketThreshold</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">winners</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">winners</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">witness</span> <span class="o">:=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStWitness_I</span><span class="p">{</span>
		<span class="nx">Candidates_</span><span class="p">:</span> <span class="nx">winners</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">GeneratePoStProof</span><span class="p">(</span><span class="nx">postCfg</span><span class="p">,</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">PoStWitness</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">witness</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">makeStackedDRGForPoSt</span><span class="p">(</span><span class="nx">postCfg</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStCfg</span><span class="p">)</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">filproofs</span><span class="p">.</span><span class="nx">StackedDRG_I</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">cfg</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nx">SDRCfg_I</span>

	<span class="k">switch</span> <span class="nx">postCfg</span><span class="p">.</span><span class="nf">Type</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStType_ElectionPoSt</span><span class="p">:</span>
		<span class="nx">cfg</span> <span class="p">=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nx">SDRCfg_I</span><span class="p">{</span>
			<span class="nx">ElectionPoStCfg_</span><span class="p">:</span> <span class="nx">postCfg</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PoStType_SurprisePoSt</span><span class="p">:</span>
		<span class="nx">cfg</span> <span class="p">=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nx">SDRCfg_I</span><span class="p">{</span>
			<span class="nx">SurprisePoStCfg_</span><span class="p">:</span> <span class="nx">postCfg</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">SDRParams</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">cfg</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>






<h5 id="post-generator-object">PoSt Generator object</h5>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_markets">

<h2 class="section-header">
  Markets in Filecoin
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets">
        

        <strong>Market</strong>

        
            <br /><br /><i class="menuIcon">‚öñÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__order">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Orders

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__deal">
        
            <i class="statusIcon">üîÅ</i>
        

        Deals

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_market_actor">
        

        Storage Market Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_provider">
        

        Storage Provider

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_client">
        

        Storage Client

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__faults">
        

        Faults

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market">
        
            <i class="statusIcon">üõë</i>
        

        Retrieval Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_client">
        

        Retrieval Client

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_provider">
        

        Retrieval Provider (Miner)

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<p>The Filecoin project is a protocol, a platform, and a marketplace. There are two major components to Filecoin markets, storage market and retrieval market. While both markets are expected to happen primarily off the blockchain, storage deals made in storage market will be published on chain and enforced by the protocol. Storage deal negotiation and order matching are expected to happen off chain in the first version of Filecoin. Retrieval deals are also negotiated off chain and executed with micropayments between transacting parties in payment channels.</p>

<p>Even though most of the market actions happen off the blockchain, there are on-chain invariant and structure that create economic structure for network success and allow for positive emergent behavior. Storage Mining in Filecoin can be compared to maintaining a storage cargo container (reference to <code>Sector</code>) with storage deals sitting in them. There must be at least one active deal in a <code>Sector</code> for the <code>Sector</code> to count towards a miner&rsquo;s power. The <code>Sector</code> is only considered Active after submitting it first PoSt successfully (reference to Sector FSM). A<code>Sector</code> no longer counts for power when it leaves the Active state either through fault or expiration. A <code>Sector</code> expires when all the deals in the <code>Sector</code> have expired and all <code>StorageDealCollateral</code> will only be returned then. In the first version of Filecoin, deals are immutable once added to the chain.</p>


</div>


  
    








<div id="systems__filecoin_markets__order">

<h3 class="section-header">
  Market Orders - Asks
</h3>

<div class="section-content">






































<p><em>Asks</em> contain the terms on which a miner is willing to provide its services. They are propogated via gossipsub.</p>

<p>A <code>StorageAsk</code> contains basic storage deal terms of price, collateral, and minimum piece size (size of the smallest piece it is willing to store under these terms). It also contains a <code>Timestamp</code> for its creation in <code>ChainEpoch</code>, a <code>MaxDuration</code> for the max duration in <code>ChainEpoch</code> that a miner is willing to store under these terms, and a <code>MinDuration</code>. If a miner wishes to override an ask, it can issue a new ask with a higher sequence number (<code>SeqNo</code>). Clients look at all the <code>StorageAsks</code> in a gossip network and decide which miner to contact to enter into a deal. The deal negotiation process happens off chain and the client submits a <code>StorageDealProposal</code> to the miner, as detailed in Storage Deals, after an agreement is reached.</p>

<p>TODO:</p>

<ul>
<li>Retrieval asks</li>
</ul>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">StorageAsk</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Price</span>         <span class="nx">BigInt</span>  <span class="c1">// attoFIL per GiB per epoch
</span><span class="c1"></span>    <span class="nx">Collateral</span>    <span class="nx">BigInt</span>  <span class="c1">// attoFIL per GiB per epoch
</span><span class="c1"></span>
    <span class="nx">MinPieceSize</span>  <span class="kt">uint64</span>
    <span class="nx">Miner</span>         <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">Timestamp</span>     <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">MaxDuration</span>   <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">MinDuration</span>   <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">SeqNo</span>         <span class="kt">uint64</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="verifiability">Verifiability</h4>

<p>TODO:</p>

<ul>
<li>write what parts of market orders are verifiable, and how

<ul>
<li>eg: miner storage ask could carry the amount of storage available (which should be at most (pledge - sectors sealed))</li>
<li>eg: client storage bid price could be checked against available money in the StorageMarket</li>
</ul></li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__deal">

<h3 class="section-header">
  Market Deals
</h3>

<div class="section-content">






































<p>There are two types of deals in Filecoin markets, storage deals and retrieval deals. Storage deals are recorded on the blockchain and enforced by the protocol. Retrieval deals are off chain and enabled by micropayment channel by transacting parties. All deal negotiation happen off chain and a request-response style storage deal protocol is in place to submit agreed-upon storage deals onto the network with <code>PublishStorageDeal</code> and <code>CommitSector</code> to gain storage power on chain. Hence, there is a <code>StorageDealProposal</code> and a <code>RetrievalDealProposal</code> that are half-signed contracts submitted by clients to be counter-signed and posted on-chain by the miners.</p>

<p>Filecoin Storage Market Deal Flow</p>

<h4 id="add-storage-deal-and-power">Add Storage Deal and Power</h4>

<ul>
<li>1. <code>StorageClient</code> and <code>StorageProvider</code> call <code>StorageMarketActor.AddBalance</code> to deposit funds into Storage Market. There are two fund states in the Storage Market, <code>Locked</code> and <code>Available</code>.

<ul>
<li><code>StorageClient</code> and <code>StorageProvider</code> can call <code>WithdrawBalance</code> before any deal is made. (move to state X)</li>
</ul></li>
<li>2. <code>StorageClient</code> and <code>StorageProvider</code> negotiate a deal off chain. <code>StorageClient</code> sends a <code>StorageDealProposal</code> to a <code>StorageProvider</code>.

<ul>
<li><code>StorageProvider</code> verifies the <code>StorageDeal</code> by checking address and signature of <code>StorageClient</code>, checking the proposal&rsquo;s <code>StartEpoch</code> is after the current Epoch, checking <code>StorageClient</code> did not call withdraw in the last X Epoch (<code>WithdrawBalance</code> should take at least X Epoch), checking both <code>StorageProvider</code> and <code>StorageClient</code> have sufficient available balances in <code>StorageMarketActor</code>.</li>
</ul></li>
<li>3. <code>StorageProvider</code> signs the <code>StorageDealProposal</code>  by constructing an on-chain message.

<ul>
<li><code>StorageProvider</code> calls <code>PublishStorageDeals</code> in <code>StorageMarketActor</code> to publish this on-chain message which will generate a <code>DealID</code> for each <code>StorageDeal</code> and store a mapping from <code>DealID</code> to <code>StorageDeal</code>. However, the deals are not active at this point.

<ul>
<li>As a backup, <code>StorageClient</code> MAY call <code>PublishStorageDeals</code> with the <code>StorageDeal</code>, to activate the deal if they can obtain the signed on-chain message from <code>StorageProvider</code>.</li>
<li>It is possible for either <code>StorageProvider</code> or <code>StorageClient</code> to try to enter into two deals simultaneously with funds available only for one. Only the first deal to commit to the chain will clear, the second will fail with error <code>errorcode.InsufficientFunds</code>.</li>
</ul></li>
<li><code>StorageProvider</code> calls <code>HandleStorageDeal</code> in <code>StorageMiningSubsystem</code> which will then add the <code>StorageDeal</code> into a <code>Sector</code>.</li>
</ul></li>
<li>4. Once the miner finishes packing a <code>Sector</code>, it generates a Sealed Sector and calls <code>StorageMinerActor.CommitSector</code> to verify the seal, store sector expiration, and record the mapping from <code>SectorNumber</code> to <code>SealCommitment</code>. It will also place this newly added <code>Sector</code> in the list of <code>CommittedSectors</code> in <code>StorageMinerActor</code>. <code>StorageMiner</code> does not earn any power for this newly added sector until its first PoSt has been submitted. Note that <code>CommitSector</code> can be called any time. However, sectors will be added to a staging buffer <code>StagedCommittedSectors</code> when miners are in the <code>Challenged</code> status (see 5 below).</li>
</ul>

<h4 id="receive-challenge">Receive Challenge</h4>

<ul>
<li>5. Miners enter the <code>Challenged</code> status whenever <code>NotifyOfPoStChallenge</code> is called by the chain. Miners will then have X Epoch as the ProvingPeriod to submit a successful PoSt before <code>
CheckPoStSubmissionHappened</code> is called by the chain. Miners can only get out the challenge with <code>SubmitPoSt</code> or <code>onMissedPoSt</code>.</li>
<li>6. Miners are not allowed to call <code>DeclareFaults</code> or <code>RecoverFaults</code> when they are in the <code>Challneged</code> state but <code>CommitSector</code> is allowed and sectors will be added to a <code>StagedCommittedSectors</code> buffer. When miners get out of the <code>Challenged</code> status, <code>StagedCommittedSectors</code> will be copied over to their <code>Sectors</code>, <code>ProvingSet</code> and <code>SectorTable</code> and emptied.</li>
</ul>

<h4 id="declare-and-recover-faults">Declare and Recover Faults</h4>

<ul>
<li>7. Declared faults are penalized to a smaller degree than detected faults by <code>CronActor</code>. Miners declare failing sectors by invoking <code>StorageMinerActor.DeclareFaults</code> and X of the <code>StorageDealCollateral</code> will be slashed and power corresponding to these sectors will be tempororily lost. However, miners can only declare faults when they are not in <code>Challenged</code> status.</li>
<li>8. Miners can then recover faults by invoking <code>StorageMinerActor.RecoverFaults</code> and have sufficient <code>StorageDealCollateral</code> in their available balances. FaultySectors are recommitted and power is only restored at the next PoSt submission. Miners will not be able to invoke <code>RecoverFaults</code> when they are in the <code>Challenged</code> status.</li>
<li>9. Sectors that are failing for <code>storagemining.MaxFaults</code> consecutive ChainEpochs will be cleared and result in <code>StoragePowerActor.SlashPledgeCollateral</code>.

<ul>
<li>TODO: set <code>X</code> parameter</li>
</ul></li>
</ul>

<h4 id="submit-post">Submit PoSt</h4>

<p>(TODO: move into Storage Mining)</p>

<p>On every PoSt Submission, the following steps happen.</p>

<ul>
<li>10. <code>StorageMinerActor</code> first verifies the PoSt Submission. If PoSt is done correctly, all <code>Committed</code> and <code>Recovering</code> sectors will be marked as <code>Active</code> and power is credited to these sectors. Payments will be processed for deals that are <code>Active</code> by invoking <code>StorageMarketActor.ProcessStorageDealsPayment</code>.</li>
<li>11. For all sectors that are off from the <code>ProvingSet</code>, these sectors are failing. Increment <code>FaultCount</code> on these sectors and if any of these sectors are failing for <code>MaxFaultCount</code> consecutive <code>ChainEpoch</code>, these sectors are terminated and cleared from the network.</li>
<li>13. Process sector expiration. Sectors expire when all deals in that sector have expired. Expired sectors will be cleared and <code>StorageDealCollateral</code> for both miners and users returned depending on the state that the sectors are in.</li>
<li>14. Submit <code>FaultReport</code> and <code>PowerReport</code> to <code>StoragePowerActor</code> for slashing and power accounting.</li>
<li>15. Check and ensure that Pledge Collateral is statisfied. TODO: some details are missing here, also related to ProvingPeriod depending on PoSt construction.</li>
<li>16. Update challenge status and add <code>Committed</code> sectors received during the challenge to the <code>Sectors</code>, <code>ProvingSet</code>, and <code>SectorTable</code>.</li>
<li>17. All Sectors will be considered in <code>DetectedFaults</code> when a miner fail to <code>SubmitPoSt</code> in a proving period and detected by <code>onMissedPoSt</code> in <code>CheckPoStSubmissionHappened</code> (move to State 18).</li>
</ul>

<h4 id="detect-faults">Detect Faults</h4>

<p>(TODO: move into Storage Mining)</p>

<ul>
<li>18. <code>CronActor</code> calls <code>StoragePowerActor.EpochTick</code> at every block. This calls <code>StorageMinerActor.CheckPoStSubmissionHappened</code> on all the miners whose <code>ProvingPeriod</code> is up.

<ul>
<li>If no PoSt is submitted by the end of the <code>ProvingPeriod</code>, <code>onMissedPoSt</code> detects the missing PoSt, and sets all sectors to <code>Failing</code>.</li>
<li>TODO: reword in terms of a conditional in the mining cycle</li>
<li>When there are sector faults are detected, some of <code>StorageDealCollateral</code> and <code>PledgeCollateral</code> are slashed, and power is lost.</li>
<li>If the faults persist for <code>storagemining.MaxFaultCount</code> then sectors are removed/cleared from <code>StorageMinerActor</code>.</li>
</ul></li>
</ul>

<h4 id="deal-code">Deal Code</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">DealID</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">DealCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">ProposalCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">PayloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span>
<span class="c1">// Note: Deal Collateral is only released and returned to clients and miners
</span><span class="c1">// when the storage deal stops counting towards power. In the current iteration,
</span><span class="c1">// it will be released when the sector containing the storage deals expires,
</span><span class="c1">// even though some storage deals can expire earlier than the sector does.
</span><span class="c1">// Collaterals are denominated in PerEpoch to incur a cost for self dealing or
</span><span class="c1">// minimal deals that last for a long time.
</span><span class="c1">// TODO: ClientCollateralPerEpoch may not be needed and removed pending future confirmation.
</span><span class="c1">// TODO: StoragePrice is paid out by Epoch duration but the exact mechanics still lacks some details.
</span><span class="c1">// There will be a Minimum value for both client and provider deal collateral.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StorageDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PieceCID</span>                      <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span>  <span class="c1">// 35 bytes CommP
</span><span class="c1"></span>    <span class="nx">PieceSize</span>                     <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceSize</span>
    <span class="nx">Client</span>                        <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">Provider</span>                      <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">ClientSignature</span>               <span class="nx">Signature</span>

    <span class="nx">StartEpoch</span>                    <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>  <span class="c1">// a deal is invalid if it is published to the chain after StartEpoch
</span><span class="c1"></span>    <span class="nx">EndEpoch</span>                      <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">StoragePricePerEpoch</span>          <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">ProviderCollateralPerEpoch</span>    <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">ClientCollateralPerEpoch</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>  <span class="c1">// potentially collapse into one with ProviderDealCollateral
</span><span class="c1"></span>
    <span class="nf">ClientBalanceRequirement</span><span class="p">()</span>    <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>  <span class="c1">// (ClientCollateralPerEpoch + StoragePricePerEpoch) * (EndEpoch - StartEpoch)
</span><span class="c1"></span>    <span class="nf">ProviderBalanceRequirement</span><span class="p">()</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>  <span class="c1">// ProviderCollateralPerEpoch * (EndEpoch - StartEpoch)
</span><span class="c1"></span>    <span class="nf">Duration</span><span class="p">()</span>                    <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>

    <span class="nf">CID</span><span class="p">()</span>                         <span class="nx">ProposalCID</span>
<span class="p">}</span>

<span class="c1">// Everything in this struct will go on chain
</span><span class="c1">// We are enforcing that StorageProvider calls PublishStorageDeal to get back a StorageDeal struct
</span><span class="c1">// Provider&#39;s signature is implicit in the onchain call
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StorageDeal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Proposal</span><span class="p">()</span>       <span class="nx">StorageDealProposal</span>  <span class="c1">// can extract proposal from the message
</span><span class="c1"></span>    <span class="nx">ProposalMessage</span>  <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span>  <span class="c1">// counter signature is implicit in the message
</span><span class="c1"></span>    <span class="nx">ID</span>               <span class="nx">DealID</span>

    <span class="nf">CID</span><span class="p">()</span>            <span class="nx">DealCID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalDealProposal</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RetrievalDeal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Proposal</span>          <span class="nx">RetrievalDealProposal</span>
    <span class="nx">CounterSignature</span>  <span class="nx">Signature</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="deal-flow">Deal Flow</h4>













<div class="diagram">

<span class="diagram-title">Deal Flow Sequence Diagram</span>




(<a href="docs/systems/filecoin_markets/deal/diagrams/deal-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_markets/deal/diagrams/deal-flow.mmd.svg" />




</div>



</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market">

<h3 class="section-header">
  Storage Market in Filecoin
</h3>

<div class="section-content">




































<p><div id="systems__filecoin_markets__storage_market__storage_market"></div>
Storage Market subsystem is the data entry point into the network. Storage miners only earn power from data stored in a storage deal and all deals live on the Filecoin network. Specific deal negotiation process happens off chain, clients and miners enter a storage deal after an agreement has been reached and post storage deals on the Filecoin network to earn block rewards and get paid for storing the data in the storage deal. A deal is only valid when it is posted on chain with signatures from both parties and at the time of posting, there are sufficient balances for both parties in <code>StorageMarketActor</code> to honor the deal in terms of deal price and deal collateral.</p>

<p>Both <code>StorageClient</code> and <code>StorageProvider</code> need to first deposit Filecoin token into <code>StorageMarketActor</code> before participating in the storage market. <code>StorageClient</code> can then send a <code>StorageDealProposal</code> to the <code>StorageProvider</code> along with the data. A partially signed <code>StorageDeal</code> is called a <code>StorageDealProposal</code>. <code>StorageProvider</code> can then put this storage deal in their <code>Sector</code>, countersign the <code>StorageDealProposal</code> and result in a <code>StorageDeal</code>. A <code>StorageDeal</code> is only in effect when it is submitted to and accepted by the <code>StorageMarketActor</code> on chain before the <code>ProposalExpiryEpoch</code>. <code>StorageDeal</code> does not include a <code>StartEpoch</code> as it will come into effect at the block when the deal gets accepted into the network. Hence, <code>StorageProvider</code> should publish the deal as soon as possible.</p>

<p><code>StorageDeal</code> payments are processed at every successful PoSt submission and <code>StorageMarketActor</code> will move locked funds from <code>StorageClient</code> to <code>StorageProvider</code>. <code>SlashStorageDealCollateral</code> is also triggered on PoSt submission when a Sector containing a particular <code>StorageDeal</code> is faulty or miners fail to submit PoSt related to a <code>StorageDeal</code>. Note that <code>StorageProvider</code> does not need to be the same entity as the <code>StorageMinerActor</code> as long as the deal is stored in at least one <code>Sector</code> throughout the life time of the storage deal.</p>

<p>TODO: process <code>StorageDeal</code> payments are larger interval beyond every PoSt submission</p>


</div>


  
    








<div id="systems__filecoin_markets__storage_market__storage_market_actor">

<h4 class="section-header">
  Storage Market Actor
</h4>

<div class="section-content">






































<p><code>StorageMarketActor</code> is responsible for processing and managing on-chain deals. This is also the entry point of all storage deals and data into the system. It maintains a mapping of <code>StorageDealID</code> to <code>StorageDeal</code> and keeps track of locked balances of <code>StorageClient</code> and <code>StorageProvider</code>. When a deal is posted on chain through the <code>StorageMarketActor</code>, it will first check if both transacting parties have sufficient balances locked up and include the deal on chain. On every successful submission of <code>PoStProof</code>, <code>StorageMarketActor</code> will credit the <code>StorageProvider</code> a fraction of the storage fee based on how many blocks have passed since the last <code>PoStProof</code>. In the event that there are sectors included in the <code>FaultSet</code>, <code>StorageMarketActor</code> will fetch deal information from the chain and <code>SlashStorageFault</code> for faulting on those deals. Similarly, when a <code>PoStProof</code> is missed by the end of a <code>ProvingPeriod</code>, <code>SlashStorageFault</code> will also be called by the <code>CronActor</code> to penalize <code>StorageProvider</code> for dropping a <code>StorageDeal</code>.</p>

<p>(You can see the <em>old</em> Storage Market Actor <a href="docs/systems/filecoin_markets/storage_market/storage_market_actor_old">here</a> )</p>

<h5 id="storagemarketactor-interface"><code>StorageMarketActor</code> interface</h5>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>

<span class="kd">type</span> <span class="nx">StorageParticipantBalance</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Locked</span>     <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">Available</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">BalancesHAMT</span> <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">StorageParticipantBalance</span><span class="p">}</span>
<span class="kd">type</span> <span class="nx">DealsAMT</span> <span class="p">{</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">:</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMarketActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Balances</span>  <span class="nx">BalancesHAMT</span>
    <span class="nx">Deals</span>     <span class="nx">DealsAMT</span>

    <span class="c1">// generate storage deal id
</span><span class="c1"></span>    <span class="nf">_generateStorageDealID</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span>

    <span class="c1">// check if StorageDeal is signed before expiry
</span><span class="c1"></span>    <span class="c1">// check if StorageDeal has the right signatures
</span><span class="c1"></span>    <span class="c1">// check if minimum StoragePrice and StorageCollateral are met
</span><span class="c1"></span>    <span class="c1">// check if provider and client have sufficient balances
</span><span class="c1"></span>    <span class="nf">_validateNewStorageDeal</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">_lockFundsForStorageDeal</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span>
    <span class="nf">_processStorageDealPayment</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">,</span> <span class="nx">duration</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span>
    <span class="nf">_settleExpiredStorageDeal</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span>
    <span class="nf">_slashLockedFunds</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>

    <span class="nf">_lockBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">_unlockBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">_transferBalance</span><span class="p">(</span>
        <span class="nx">rt</span>           <span class="nx">Runtime</span>
        <span class="nx">fromLocked</span>   <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">toAvailable</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">amount</span>       <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">)</span>
    <span class="nf">_isBalanceAvailable</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMarketActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">balance</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>  <span class="c1">// amount is in the message
</span><span class="c1"></span>
    <span class="c1">// call by CommitSector in StorageMiningSubsystem
</span><span class="c1"></span>    <span class="c1">// a StorageDeal is only published on chain when it passes verifyStorageDeal
</span><span class="c1"></span>    <span class="c1">// a DealID will be assigned and stored in the mapping of DealID to StorageDeal
</span><span class="c1"></span>    <span class="c1">// PublishStorageDeal should be called before SecotrCommits
</span><span class="c1"></span>    <span class="c1">// an unregistered StorageDeal will not be processed
</span><span class="c1"></span>    <span class="nf">PublishStorageDeals</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deals</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">])</span> <span class="p">[</span><span class="nx">PublishStorageDealResponse</span><span class="p">]</span>

    <span class="c1">// call by CronActor when no PoSt is submitted within a ProvingPeriod
</span><span class="c1"></span>    <span class="c1">// trigger subsequent calls on different SectorSet
</span><span class="c1"></span>    <span class="c1">// pull SectorSet from the run time
</span><span class="c1"></span>    <span class="nf">HandleCronAction</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span>

    <span class="c1">// call by CronActor / onPoStSubmission on ExpiredSet
</span><span class="c1"></span>    <span class="c1">// remove StorageDeal from StorageMarketActor
</span><span class="c1"></span>    <span class="c1">// if no more active deals contain in the sector
</span><span class="c1"></span>    <span class="c1">// return StorageCollateral to miners
</span><span class="c1"></span>    <span class="nf">SettleExpiredDeals</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span>

    <span class="c1">// call by CronActor / onPoStSubmission on ActiveSet to process deal payment
</span><span class="c1"></span>    <span class="c1">// go through StorageDealIDs, if IDs are active in MarketActor
</span><span class="c1"></span>    <span class="c1">// payment will be processed
</span><span class="c1"></span>    <span class="nf">ProcessStorageDealsPayment</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">],</span> <span class="nx">duration</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span>

    <span class="c1">// call by CronActor / on DeclareFault on FaultSet to slash deal collateral
</span><span class="c1"></span>    <span class="c1">// Deals should be slashed for a single proving period
</span><span class="c1"></span>    <span class="nf">SlashStorageDealsCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span>

    <span class="nf">GetLastExpirationFromDealIDs</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>

    <span class="c1">// TODO: StorageDeals should be renewable
</span><span class="c1"></span>    <span class="c1">// UpdateStorageDeal(newStorageDeals [deal.StorageDeal])
</span><span class="c1"></span>
    <span class="nf">GetPieceInfosForDealIDs</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>






<h5 id="storagemarketactor-implementation"><code>StorageMarketActor</code> implementation</h5>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">MethodGetUnsealedCIDForDealIDs</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">MethodNum</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Boilerplate
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>
<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">State</span> <span class="p">=</span> <span class="nx">StorageMarketActorState</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">()</span>
	<span class="nx">stateBytes</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">ipld</span><span class="p">.</span><span class="nf">CID</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">stateBytes</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime_IpldGet_FunRet_Case_Bytes</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;IPLD lookup error&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">state</span> <span class="o">:=</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">stateBytes</span><span class="p">.</span><span class="nf">As_Bytes</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">State</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">DeserializeState</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">State</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_generateStorageDealID</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">storageDeal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span> <span class="p">{</span>
	<span class="c1">// TODO
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">dealID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span>
	<span class="k">return</span> <span class="nx">dealID</span>
<span class="p">}</span>

<span class="c1">// Call by PublishStorageDeals and GetLastDealExpirationFromDealIDs (consider remove this)
</span><span class="c1">// This is the check before a StorageDeal appears onchain
</span><span class="c1">// It checks the following:
</span><span class="c1">//   - verify deal did not expire when it is signed
</span><span class="c1">//   - verify deal hits the chain before StartEpoch
</span><span class="c1">//   - verify client and provider address and signature are correct (TODO may not be needed)
</span><span class="c1">//   - verify StorageDealCollateral match requirements for MinimumStorageDealCollateral
</span><span class="c1">//   - verify client and provider has sufficient balance
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_validateNewStorageDeal</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// TODO verify client and provider signature
</span><span class="c1"></span>	<span class="c1">// TODO verify minimum StoragePrice, ProviderCollateralPerEpoch, and ClientCollateralPerEpoch
</span><span class="c1"></span>	<span class="c1">// TODO: verify deal did not expire when it is signed
</span><span class="c1"></span>
	<span class="nx">currEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nf">Proposal</span><span class="p">()</span>

	<span class="c1">// deal has started before publish
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">StartEpoch</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">currEpoch</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// TODO: verify client and provider address and signature are correct (may not be needed)
</span><span class="c1"></span>
	<span class="c1">// verify StorageDealCollateral match requirements for MinimumStorageDealCollateral
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ProviderCollateralPerEpoch</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">MIN_PROVIDER_DEAL_COLLATERAL_PER_EPOCH</span> <span class="o">||</span>
		<span class="nx">p</span><span class="p">.</span><span class="nf">ClientCollateralPerEpoch</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">MIN_CLIENT_DEAL_COLLATERAL_PER_EPOCH</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// verify client and provider has sufficient balance
</span><span class="c1"></span>	<span class="nx">isClientBalAvailable</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isBalanceAvailable</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">Client</span><span class="p">(),</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ClientBalanceRequirement</span><span class="p">())</span>
	<span class="nx">isProviderBalAvailable</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_isBalanceAvailable</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">Provider</span><span class="p">(),</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ProviderBalanceRequirement</span><span class="p">())</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">isClientBalAvailable</span> <span class="o">||</span> <span class="p">!</span><span class="nx">isProviderBalAvailable</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="c1">// TODO: consider returning a boolean
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_lockBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">amount</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">currBalance</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">addr</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;addr not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">currBalance</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Available_</span> <span class="o">-=</span> <span class="nx">amount</span>
	<span class="nx">currBalance</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Locked_</span> <span class="o">+=</span> <span class="nx">amount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_unlockBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">amount</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">currBalance</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">addr</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;addr not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">currBalance</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Locked_</span> <span class="o">-=</span> <span class="nx">amount</span>
	<span class="nx">currBalance</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Available_</span> <span class="o">+=</span> <span class="nx">amount</span>
<span class="p">}</span>

<span class="c1">// move funds from locked in client to available in provider
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_transferBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">fromLocked</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">toAvailable</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fromB</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">fromLocked</span><span class="p">]</span>
	<span class="nx">toB</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">toAvailable</span><span class="p">]</span>

	<span class="k">if</span> <span class="nx">fromB</span><span class="p">.</span><span class="nf">Locked</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">amount</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;attempt to lock funds greater than actor has&#34;</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fromB</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Locked_</span> <span class="o">-=</span> <span class="nx">amount</span>
	<span class="nx">toB</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Available_</span> <span class="o">+=</span> <span class="nx">amount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_isBalanceAvailable</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">bal</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">a</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">bal</span><span class="p">.</span><span class="nf">Available</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="nx">amount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_lockFundsForStorageDeal</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nf">Proposal</span><span class="p">()</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_lockBalance</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Client</span><span class="p">(),</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ClientBalanceRequirement</span><span class="p">())</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_lockBalance</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Provider</span><span class="p">(),</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ProviderBalanceRequirement</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_processStorageDealPayment</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">,</span> <span class="nx">duration</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nf">Proposal</span><span class="p">()</span>

	<span class="nx">amount</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">StoragePricePerEpoch</span><span class="p">())</span> <span class="o">*</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">duration</span><span class="p">))</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_transferBalance</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Client</span><span class="p">(),</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Provider</span><span class="p">(),</span> <span class="nx">amount</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_settleExpiredStorageDeal</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState_I</span><span class="p">)</span> <span class="nf">_slashLockedFunds</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">balance</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">msgSender</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="c1">// TODO replace this from VM runtime
</span><span class="c1"></span>
	<span class="k">if</span> <span class="nx">balance</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative balance to withdraw.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">senderBalance</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">msgSender</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;sender address not found.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">senderBalance</span><span class="p">.</span><span class="nf">Available</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">balance</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;insufficient balance.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">senderBalance</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Available_</span> <span class="p">=</span> <span class="nx">senderBalance</span><span class="p">.</span><span class="nf">Available</span><span class="p">()</span> <span class="o">-</span> <span class="nx">balance</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">msgSender</span><span class="p">]</span> <span class="p">=</span> <span class="nx">senderBalance</span>

	<span class="c1">// TODO send funds to msgSender with `transferBalance` in VM runtime
</span><span class="c1"></span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">msgSender</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>    <span class="c1">// TODO replace this
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">balance</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="c1">// TODO replace this
</span><span class="c1"></span>
	<span class="c1">// TODO subtract balance from msgSender
</span><span class="c1"></span>	<span class="c1">// TODO add balance to StorageMarketActor
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">balance</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;negative balance to add.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">senderBalance</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">msgSender</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="nx">senderBalance</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nx">Available_</span> <span class="p">=</span> <span class="nx">senderBalance</span><span class="p">.</span><span class="nf">Available</span><span class="p">()</span> <span class="o">+</span> <span class="nx">balance</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">msgSender</span><span class="p">]</span> <span class="p">=</span> <span class="nx">senderBalance</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">Balances</span><span class="p">()[</span><span class="nx">msgSender</span><span class="p">]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">StorageParticipantBalance_I</span><span class="p">{</span>
			<span class="nx">Locked_</span><span class="p">:</span>    <span class="mi">0</span><span class="p">,</span>
			<span class="nx">Available_</span><span class="p">:</span> <span class="nx">balance</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">PublishStorageDeals</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">newStorageDeals</span> <span class="p">[]</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">[]</span><span class="nx">PublishStorageDealResponse</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">l</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newStorageDeals</span><span class="p">)</span>
	<span class="nx">response</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">PublishStorageDealResponse</span><span class="p">,</span> <span class="nx">l</span><span class="p">)</span>

	<span class="c1">// TODO: verify behavior here
</span><span class="c1"></span>	<span class="c1">// some StorageDeal will pass and some will fail
</span><span class="c1"></span>	<span class="c1">// if ealier StorageDeal consumes some balance such that
</span><span class="c1"></span>	<span class="c1">// funds are no longer sufficient for later storage deals
</span><span class="c1"></span>	<span class="c1">// all later storage deals will return error
</span><span class="c1"></span>	<span class="c1">// TODO: confirm st here will be changing
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">newDeal</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newStorageDeals</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_validateNewStorageDeal</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">newDeal</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">_lockFundsForStorageDeal</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">newDeal</span><span class="p">)</span>
			<span class="nx">id</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_generateStorageDealID</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">newDeal</span><span class="p">)</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">Deals</span><span class="p">()[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newDeal</span>
			<span class="nx">response</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">PublishStorageDealSuccess</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nx">response</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nf">PublishStorageDealError</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">response</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">HandleCronAction</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">SettleExpiredDeals</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">storageDealIDs</span> <span class="p">[]</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// for dealID := range storageDealIDs {
</span><span class="c1"></span>	<span class="c1">// Return the storage collateral
</span><span class="c1"></span>	<span class="c1">// storageDeal := sma.Deals()[dealID]
</span><span class="c1"></span>	<span class="c1">// storageCollateral := storageDeal.StorageCollateral()
</span><span class="c1"></span>	<span class="c1">// provider := storageDeal.Provider()
</span><span class="c1"></span>	<span class="c1">// assert(sma.Balances()[provider].Locked() &gt;= storageCollateral)
</span><span class="c1"></span>
	<span class="c1">// // Move storageCollateral from locked to available
</span><span class="c1"></span>	<span class="c1">// balance := sma.Balances()[provider]
</span><span class="c1"></span>
	<span class="c1">// sma.Balances()[provider] = &amp;StorageParticipantBalance_I{
</span><span class="c1"></span>	<span class="c1">// 	Locked_:    balance.Locked() - storageCollateral,
</span><span class="c1"></span>	<span class="c1">// 	Available_: balance.Available() + storageCollateral,
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// // Delete reference to the deal
</span><span class="c1"></span>	<span class="c1">// delete(sma.Deals_, dealID)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">ProcessStorageDealsPayment</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[]</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">,</span> <span class="nx">duration</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_processStorageDealPayment</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Deals</span><span class="p">()[</span><span class="nx">dealID</span><span class="p">],</span> <span class="nx">duration</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">SlashStorageDealsCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[]</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// for _, dealID := range storageDealIDs {
</span><span class="c1"></span>	<span class="c1">// 	faultStorageDeal := sma.Deals()[dealID]
</span><span class="c1"></span>	<span class="c1">// TODO remove locked funds and send slashed fund to TreasuryActor
</span><span class="c1"></span>	<span class="c1">// TODO provider lose power for the FaultSet but not PledgeCollateral
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Call by StorageMinerActor at CommitSector
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">GetLastDealExpirationFromDealIDs</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[]</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">lastDealExpiration</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span> <span class="p">{</span>
		<span class="nx">deal</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Deals</span><span class="p">()[</span><span class="nx">dealID</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="s">&#34;dealID not found.&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// TODO: more checks or be convinced that it&#39;s enough to assume deals are still valid
</span><span class="c1"></span>
		<span class="nx">currExpiration</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nf">Proposal</span><span class="p">().</span><span class="nf">EndEpoch</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">currExpiration</span> <span class="p">&gt;</span> <span class="nx">lastDealExpiration</span> <span class="p">{</span>
			<span class="nx">lastDealExpiration</span> <span class="p">=</span> <span class="nx">currExpiration</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">lastDealExpiration</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">GetPieceInfosForDealIDs</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="p">[]</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">[]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo_I</span> <span class="p">{</span>
	<span class="nx">pieceInfos</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo_I</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">dealIDs</span><span class="p">))</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">deal</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nf">Deals</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">proposal</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nf">Proposal</span><span class="p">()</span>
		<span class="nx">pieceSize</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">PieceSize</span><span class="p">().</span><span class="nf">Total</span><span class="p">())</span>

		<span class="kd">var</span> <span class="nx">pieceInfo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PieceInfo_I</span>
		<span class="nx">pieceInfo</span><span class="p">.</span><span class="nx">PieceCID_</span> <span class="p">=</span> <span class="nx">proposal</span><span class="p">.</span><span class="nf">PieceCID</span><span class="p">()</span>
		<span class="nx">pieceInfo</span><span class="p">.</span><span class="nx">Size_</span> <span class="p">=</span> <span class="nx">pieceSize</span>

		<span class="nx">pieceInfos</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pieceInfo</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">pieceInfos</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActorCode_I</span><span class="p">)</span> <span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>






<div id="systems__filecoin_markets__storage_market__storage_market_actor__storage_deal_collateral"></div>

<h5 id="storage-deal-collateral">Storage Deal Collateral</h5>

<p>Storage Deals have an associated collateral amount. This <code>StorageDealCollateral</code> is held in the <code>StorageMarketActor</code>.
Its value is agreed upon by the storage provider and client off-chain, but must be greater than a protocol-defined minimum in any deal. Storage providers will choose to offer greater collateral to signal high-quality storage to clients.</p>

<p>On <code>SectorFailureTimeout</code> (see <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>), the <code>StorageDealCollateral</code> will be burned. In the future, the Filecoin protocol may be amended to send up to half of the collateral to storage clients as damages in such cases.</p>

<p>Upon graceful deal expiration, storage providers must wait for finality number of epochs (as defined in <a href="./#algorithms__expected_consensus__finality">EC Finality</a>) before being able to withdraw their <code>StorageDealCollateral</code> from the <code>StorageMarketActor</code>.</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_provider">

<h4 class="section-header">
  Storage Provider
</h4>

<div class="section-content">




































<p>Both <code>StorageProvider</code> and <code>StorageClient</code> are <code>StorageMarketParticipant</code>. Any party can be a storage provider or client or both at the same time. Storage deal negotiation is expected to happen completely off chain and the request-response style storage deal protocol is to submit agreed-upon storage deal onto the network and gain storage power on chain. <code>StorageClient</code> will initiate the storage deal protocol by submitting a <code>StorageDealProposal</code> to the <code>StorageProvider</code> who will then add the deal data to a <code>Sector</code> and commit the sector onto the blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">StorageProvider</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// StorageDealProposalCID: StorageDealStatus
</span><span class="c1"></span>    <span class="nx">ProposalStatus</span>  <span class="p">{</span><span class="nx">deal</span><span class="p">.</span><span class="nx">ProposalCID</span><span class="p">:</span> <span class="nx">StorageDealStatus</span><span class="p">}</span>
    <span class="c1">// DealCID: StorageDeal
</span><span class="c1"></span>    <span class="nx">DealStatus</span>      <span class="p">{</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">:</span> <span class="nx">StorageDealStatus</span><span class="p">}</span>

    <span class="c1">// libp2p listener on new StorageDealProposal
</span><span class="c1"></span>    <span class="nf">OnNewStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span>

    <span class="c1">// Call by StorageProvider to sign proposal and construct StorageDeal message
</span><span class="c1"></span>    <span class="nf">signStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span>

    <span class="c1">// Call by StorageProvider to call sma.PublishStorageDeal
</span><span class="c1"></span>    <span class="nf">publishStorageDealMessage</span><span class="p">(</span><span class="nx">message</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>

    <span class="c1">// Call by StorageProvider to accept a StorageDealProposal and notify StorageClient
</span><span class="c1"></span>    <span class="nf">acceptStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span>

    <span class="c1">// Call by StorageProvider to reject a StorageDealProposal and notify StorageClient
</span><span class="c1"></span>    <span class="nf">rejectStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span>

    <span class="c1">// Call by StorageProvider to check client balance and signature
</span><span class="c1"></span>    <span class="nf">verifyStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// Check PieceCID(CommP) provided by StorageClient in StorageDealProposal
</span><span class="c1"></span>    <span class="c1">// Provider needs to verify and reject deal if incorrect.
</span><span class="c1"></span>    <span class="c1">// If on-chain CommP does not match actual piece, Seal proof will not verify.
</span><span class="c1"></span>    <span class="nf">verifyPieceCID</span><span class="p">(</span><span class="nx">pieceCID</span> <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">,</span> <span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// Call by StorageMiningSubsystem
</span><span class="c1"></span>    <span class="nf">NotifyOfOnChainDealStatus</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">,</span> <span class="nx">newStatus</span> <span class="nx">StorageDealStatus</span><span class="p">)</span>

    <span class="c1">// libp2p listener on receiving payload
</span><span class="c1"></span>    <span class="c1">// TODO: take in dt.DataTransferVoucher as an argument
</span><span class="c1"></span>    <span class="nf">OnReceivingPayload</span><span class="p">(</span><span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span>

    <span class="c1">// libp2p listener on storage deal proposal query
</span><span class="c1"></span>    <span class="nf">OnStorageDealProposalQuery</span><span class="p">(</span><span class="nx">proposalCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">ProposalCID</span><span class="p">)</span> <span class="nx">StorageDealStatus</span>

    <span class="c1">// libp2p listener on storage deal query
</span><span class="c1"></span>    <span class="nf">OnStorageDealQuery</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">)</span> <span class="nx">StorageDealStatus</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
	<span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
	<span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
	<span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">OnNewStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">ProposalStatus</span><span class="p">()[</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">CID</span><span class="p">()]</span>
	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="c1">// TODO: return error
</span><span class="c1"></span>		<span class="k">return</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">shouldReject</span> <span class="kt">bool</span> <span class="c1">// specified by StorageProvider
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">shouldReject</span> <span class="p">{</span>
		<span class="nx">provider</span><span class="p">.</span><span class="nf">rejectStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">verifyStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">,</span> <span class="nx">payloadCID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">provider</span><span class="p">.</span><span class="nf">acceptStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">provider</span><span class="p">.</span><span class="nf">rejectStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">signStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span> <span class="p">{</span>
	<span class="c1">// TODO: construct StorageDeal Message
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">storageDealMessage</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span>

	<span class="c1">// TODO: notify StorageClient StorageDealSigned
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">storageDealMessage</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">publishStorageDealMessage</span><span class="p">(</span><span class="nx">message</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span> <span class="p">{</span>
	<span class="c1">// TODO: send message to StorageMarketActor.PublishStorageDeal and get back DealID
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">dealID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span>
	<span class="kd">var</span> <span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span>

	<span class="nx">storageDeal</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal_I</span><span class="p">{</span>
		<span class="nx">ProposalMessage_</span><span class="p">:</span> <span class="nx">message</span><span class="p">,</span>
		<span class="nx">ID_</span><span class="p">:</span>              <span class="nx">dealID</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">provider</span><span class="p">.</span><span class="nf">DealStatus</span><span class="p">()[</span><span class="nx">dealCID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">StorageDealPublished</span>

	<span class="c1">// TODO: notify StorageClient StorageDealPublished
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">storageDeal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">acceptStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">provider</span><span class="p">.</span><span class="nf">ProposalStatus</span><span class="p">()[</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">CID</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">StorageDealProposalAccepted</span>
	<span class="c1">// TODO: notify StorageClient StorageDealAccepted
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">rejectStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">provider</span><span class="p">.</span><span class="nf">ProposalStatus</span><span class="p">()[</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">CID</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">StorageDealProposalRejected</span>
	<span class="c1">// TODO: notify StorageClient StorageDealRejected
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">verifyStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// TODO make call to StorageMarketActor
</span><span class="c1"></span>	<span class="c1">// balance, found := StorageMarketActor.Balances()[address]
</span><span class="c1"></span>
	<span class="c1">// if !found {
</span><span class="c1"></span>	<span class="c1">// 	return false
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// if balance &lt; price {
</span><span class="c1"></span>	<span class="c1">// 	return false
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="nx">isPieceCIDVerified</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">verifyPieceCID</span><span class="p">(</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">PieceCID</span><span class="p">(),</span> <span class="nx">payloadCID</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">isPieceCIDVerified</span> <span class="p">{</span>
		<span class="c1">// TODO: error out
</span><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO Check on Signature
</span><span class="c1"></span>	<span class="c1">// return true
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">verifyPieceCID</span><span class="p">(</span><span class="nx">pieceCID</span> <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">,</span> <span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">NotifyOfOnChainDealStatus</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">,</span> <span class="nx">newStatus</span> <span class="nx">StorageDealStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">DealStatus</span><span class="p">()[</span><span class="nx">dealCID</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="nx">provider</span><span class="p">.</span><span class="nf">DealStatus</span><span class="p">()[</span><span class="nx">dealCID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newStatus</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// the entire payload graph is now in local IPLD store
</span><span class="c1">// TODO: integrate with Data Transfer
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">OnReceivingPayload</span><span class="p">(</span><span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: get proposalCID from local storage
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">proposalCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">ProposalCID</span>

	<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">ProposalStatus</span><span class="p">()[</span><span class="nx">proposalCID</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="c1">// TODO: error here
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// TODO: get client addr from libp2p
</span><span class="c1"></span>	<span class="c1">// TODO: get proposal from local storage
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
	<span class="nx">isProposalVerified</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">verifyStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">,</span> <span class="nx">payloadCID</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">isProposalVerified</span> <span class="p">{</span>
		<span class="nx">provider</span><span class="p">.</span><span class="nf">rejectStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// StorageProvider can decide what to do here
</span><span class="c1"></span>	<span class="nx">provider</span><span class="p">.</span><span class="nf">signStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">)</span>

<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">OnStorageDealProposalQuery</span><span class="p">(</span><span class="nx">proposalCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">ProposalCID</span><span class="p">)</span> <span class="nx">StorageDealStatus</span> <span class="p">{</span>
	<span class="nx">proposalStatus</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">ProposalStatus</span><span class="p">()[</span><span class="nx">proposalCID</span><span class="p">]</span>

	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">proposalStatus</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">StorageDealProposalNotFound</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">OnStorageDealQuery</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">)</span> <span class="nx">StorageDealStatus</span> <span class="p">{</span>
	<span class="nx">dealStatus</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">DealStatus</span><span class="p">()[</span><span class="nx">dealCID</span><span class="p">]</span>

	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">dealStatus</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">StorageDealNotFound</span>
<span class="p">}</span>
</code></pre></div>






<!-- # Storage Provider State Machine -->


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_client">

<h4 class="section-header">
  Storage Client
</h4>

<div class="section-content">




































<p>Both <code>StorageProvider</code> and <code>StorageClient</code> are <code>StorageMarketParticipant</code>. Any party can be a storage provider or client or both at the same time. Storage deal negotiation is expected to happen completely off chain and the request-response style storage deal protocol is to submit agreed-upon storage deal onto the network and gain storage power on chain. <code>StorageClient</code> will initiate the storage deal protocol by submitting a <code>StorageDealProposal</code> to the <code>StorageProvider</code> who will then add the deal data to a <code>Sector</code> and commit the sector onto the blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>

<span class="kd">type</span> <span class="nx">StorageClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// generate PieceCID(CommP) from payload
</span><span class="c1"></span>    <span class="c1">// so that client can identify their deal
</span><span class="c1"></span>    <span class="nf">generatePieceCID</span><span class="p">(</span><span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span>

    <span class="c1">// Call by StorageProvider to pull data with GraphSync
</span><span class="c1"></span>    <span class="nf">PullPayload</span><span class="p">(</span><span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span>

    <span class="c1">// Call by StorageProvider to inform StorageDealProposalStatus
</span><span class="c1"></span>    <span class="nf">NotifyOfStorageDealProposalStatus</span><span class="p">(</span><span class="nx">proposalCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">ProposalCID</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">StorageDealStatus</span><span class="p">)</span>

    <span class="c1">// Call by StorageProvider to inform StorageDealStatus
</span><span class="c1"></span>    <span class="nf">NotifyOfStorageDealStatus</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">StorageDealStatus</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
	<span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
	<span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">client</span> <span class="o">*</span><span class="nx">StorageClient_I</span><span class="p">)</span> <span class="nf">generatePieceCID</span><span class="p">(</span><span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">pieceCID</span> <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span>
	<span class="k">return</span> <span class="nx">pieceCID</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">client</span> <span class="o">*</span><span class="nx">StorageClient_I</span><span class="p">)</span> <span class="nf">PullPayload</span><span class="p">(</span><span class="nx">payloadCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">client</span> <span class="o">*</span><span class="nx">StorageClient_I</span><span class="p">)</span> <span class="nf">NotifyOfStorageDealProposalStatus</span><span class="p">(</span><span class="nx">pieceCID</span> <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">StorageDealStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">client</span> <span class="o">*</span><span class="nx">StorageClient_I</span><span class="p">)</span> <span class="nf">NotifyOfStorageDealStatus</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">,</span> <span class="nx">status</span> <span class="nx">StorageDealStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>






<!-- # Storage Client State Machine -->


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__faults">

<h4 class="section-header">
  Faults
</h4>

<div class="section-content">






































<p><div id="systems__filecoin_markets__storage_market__faults__storage_faults"></div>
There are two main categories of faults in the Filecoin network.</p>

<ul>
<li>ConsensusFaults</li>
<li>StorageDealFaults</li>
</ul>

<p>ConsensusFaults are faults that impact network consensus and StorageDealFaults are faults where data in a <code>StorageDeal</code> is not maintained by the providers pursuant to deal terms.</p>

<p><a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></a> is slashed for ConsensusFaults and <a href="./#systems__filecoin_markets__storage_market__storage_deal_collateral">Storage Deal Collateral</a> for StorageDealFaults.</p>

<p>Any misbehavior may result in more than one fault thus lead to slashing on both collaterals. For example, missing a <code>PoStProof</code> will incur a penalty on both <code>PledgeCollateral</code> and <code>StorageDealCollateral</code> given it impacts both a given <code>StorageDeal</code> and power derived from the sector commitments in <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a>.</p>

<h6 id="storage-faults">Storage Faults</h6>

<p>TODO: complete this.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market">

<h3 class="section-header">
  Retrieval Market in Filecoin
</h3>

<div class="section-content">






































<h4 id="components">Components</h4>

<p>Version 0 of the <code>retrieval market</code> protocol is what we (tentatively) will launch the filecoin network with. It is version zero because it will only be good enough to fit the bill as a way to pay another node for a file.</p>

<p>The main components are as follows:</p>

<ul>
<li>A payment channel actor (See <a href="payment-channels.md">payment channels</a> for details)</li>
<li>&lsquo;retrieval-v0&rsquo; <code>libp2p</code> services</li>
<li>A chain-based content routing interface</li>
<li>A set of commands to interact with the above</li>
</ul>

<h4 id="retrieval-v0-libp2p-services">Retrieval V0 <code>libp2p</code> Services</h4>

<p>The v0 <code>retrieval market</code> will initially be implemented as two <code>libp2p</code> services. It will be request response based, where the client who is requesting a file sends a <code>retrieval deal proposal</code> to the miner. The miner chooses whether or not to accept it, sends their response which (if they accept the proposal) includes a <code>signed retrieval deal</code>, followed by the actual requested content, streamed as a series of bitswap block messages, using a pre-order traversal of the dag. Each block should use the <a href="https://github.com/ipfs/go-bitswap/blob/c980d7ed36f278e93828acf920f3a911e8263265/message/message.go#L228">bitswap block message format</a>. This way, the client should be able to verify the data incrementally as it receives it. Once the client has received all the data, it should then send a payment channel SpendVoucher of the proposed amount to the miner. This protocol may be easily extended to include payments from the client to the miner every N blocks, but for now we omit that feature.</p>


</div>


  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_client">

<h4 class="section-header">
  Retrieval Client
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">RetrievalClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">CreatePaymentChannel</span><span class="p">(</span><span class="nx">provider</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">payment</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">PaymentChannel</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_provider">

<h4 class="section-header">
  Retrieval Provider (Miner)
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">PaymentChannel</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">CID</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// File Retrieval Query
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FileRetrievalAvailable</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">MinPrice</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">Miner</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">FileRetrievalUnavailable</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalQueryResponse</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">FileRetrievalAvailable</span>
    <span class="nx">FileRetrievalUnavailable</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalQuery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">File</span> <span class="nx">CID</span>
<span class="p">}</span>

<span class="c1">// File Retrieval Deal Proposal and Deal
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RetrievalDealProposalError</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposalRejected</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposalAccepted</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CounterParty</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">Payment</span>       <span class="nx">PaymentChannel</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposalResponse</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">RetrievalDealProposalAccepted</span>
    <span class="nx">RetrievalDealProposalRejected</span>
    <span class="nx">RetrievalDealProposalError</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">File</span>      <span class="nx">CID</span>
    <span class="nx">Payment</span>   <span class="nx">PaymentChannel</span>
    <span class="nx">MinPrice</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalProvider</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">NewRetrievalQuery</span><span class="p">(</span><span class="nx">query</span> <span class="nx">RetrievalQuery</span><span class="p">)</span> <span class="nx">RetrievalQueryResponse</span>

    <span class="c1">// NewRetrievalDealProposal is called to propose a retrieval
</span><span class="c1"></span>    <span class="nf">NewRetrievalDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">RetrievalDealProposal</span><span class="p">)</span> <span class="nx">RetrievalDealProposalResponse</span>

    <span class="c1">// AcceptRetrievalDeal is called to accept a retrieval deal
</span><span class="c1"></span>    <span class="nf">AcceptRetrievalDealProposal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">RetrievalDealProposal</span><span class="p">)</span> <span class="nx">RetrievalDealProposalResponse</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  


</div>

  


</div>

  

  
    








<div id="libraries">

<h1 class="section-header">
  Libraries used in Filecoin
</h1>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries">
        

        Libraries

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__fcs">
        

        FCS

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld">
        

        IPLD

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__cid">
        

        CID

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__datamodel">
        

        Data Model

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__selectors">
        

        Selectors

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__graphstore">
        

        GraphStore

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p">
        

        libp2p

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__gossipsub">
        

        gossipsub

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__kad_dht">
        

        kad-dht

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__fil_libp2p_nodes">
        

        fil-libp2p Nodes

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs">
        

        IPFS

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__bitswap">
        

        BitSwap

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__graphsync">
        

        GraphSync

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__unixfs">
        

        UnixFS

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__multiformats">
        

        Multiformats

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  

  
    








<div id="libraries__fcs">

<h2 class="section-header">
  FCS
</h2>

<div class="section-content">




















































<p style="color: #D74848"><b><i>Something's not right. The <code>fcs.id</code> file was not found.</i></b></p>




</div>



</div>

  

  
    








<div id="libraries__ipld">

<h2 class="section-header">
  IPLD - InterPlanetary Linked Data
</h2>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Store</span> <span class="nx">GraphStore</span>

<span class="c1">// imported as ipld.Object
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Object</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">CID</span><span class="p">()</span> <span class="nx">CID</span>

    <span class="c1">// Populate(v interface{}) error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="libraries__ipld__cid">

<h3 class="section-header">
  CIDs - Content IDentifiers
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BytesKey</span> <span class="kt">string</span>  <span class="c1">// so that we can use it in go maps
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">CID</span> <span class="nx">BytesKey</span>  <span class="c1">// TODO: remove util.
</span></code></pre></div>







</div>



</div>

  

  
    








<div id="libraries__ipld__datamodel">

<h3 class="section-header">
  Data Model
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipld__selectors">

<h3 class="section-header">
  Selectors - IPLD Query Language
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// This is a compression of the IPLD Selector Spec
</span><span class="c1">// Full spec: https://github.com/ipld/specs/blob/master/selectors/selectors.md
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Selector</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Matcher</span>
    <span class="nx">ExploreAll</span>
    <span class="nx">ExploreFields</span>
    <span class="nx">ExploreIndex</span>
    <span class="nx">ExploreRange</span>
    <span class="nx">ExploreRecursive</span>
    <span class="nx">ExploreUnion</span>
    <span class="nx">ExploreConditional</span>
    <span class="nx">ExploreRecursiveEdge</span>
<span class="p">}</span>

<span class="c1">// ExploreAll is similar to a `*` -- it traverses all elements of an array,
</span><span class="c1">// or all entries in a map, and applies a next selector to the reached nodes.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreAll</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">next</span> <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// ExploreFields traverses named fields in a map (or equivalently, struct, if
</span><span class="c1">// traversing on typed/schema nodes) and applies a next selector to the
</span><span class="c1">// reached nodes.
</span><span class="c1">//
</span><span class="c1">// Note that a concept of exploring a whole path (e.g. &#34;foo/bar/baz&#34;) can be
</span><span class="c1">// represented as a set of three nexted ExploreFields selectors, each
</span><span class="c1">// specifying one field.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreFields</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">fields</span> <span class="p">{</span><span class="kt">string</span><span class="p">:</span> <span class="nx">Selector</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ExploreIndex traverses a specific index in a list, and applies a next
</span><span class="c1">// selector to the reached node.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreIndex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">index</span>  <span class="nx">UInt</span>
    <span class="nx">next</span>   <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// ExploreIndex traverses a list, and for each element in the range specified,
</span><span class="c1">// will apply a next selector to those reached nodes.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreRange</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">start</span>  <span class="nx">UInt</span>
    <span class="nx">end</span>    <span class="nx">UInt</span>
    <span class="nx">next</span>   <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// ExploreRecursive traverses some structure recursively.
</span><span class="c1">// To guide this exploration, it uses a &#34;sequence&#34;, which is another Selector
</span><span class="c1">// tree; some leaf node in this sequence should contain an ExploreRecursiveEdge
</span><span class="c1">// selector, which denotes the place recursion should occur.
</span><span class="c1">//
</span><span class="c1">// In implementation, whenever evaluation reaches an ExploreRecursiveEdge marker
</span><span class="c1">// in the recursion sequence&#39;s Selector tree, the implementation logically
</span><span class="c1">// produces another new Selector which is a copy of the original
</span><span class="c1">// ExploreRecursive selector, but with a decremented maxDepth parameter, and
</span><span class="c1">// continues evaluation thusly.
</span><span class="c1">//
</span><span class="c1">// It is not valid for an ExploreRecursive selector&#39;s sequence to contain
</span><span class="c1">// no instances of ExploreRecursiveEdge; it *is* valid for it to contain
</span><span class="c1">// more than one ExploreRecursiveEdge.
</span><span class="c1">//
</span><span class="c1">// ExploreRecursive can contain a nested ExploreRecursive!
</span><span class="c1">// This is comparable to a nested for-loop.
</span><span class="c1">// In these cases, any ExploreRecursiveEdge instance always refers to the
</span><span class="c1">// nearest parent ExploreRecursive (in other words, ExploreRecursiveEdge can
</span><span class="c1">// be thought of like the &#39;continue&#39; statement, or end of a for-loop body;
</span><span class="c1">// it is *not* a &#39;goto&#39; statement).
</span><span class="c1">//
</span><span class="c1">// Be careful when using ExploreRecursive with a large maxDepth parameter;
</span><span class="c1">// it can easily cause very large traversals (especially if used in combination
</span><span class="c1">// with selectors like ExploreAll inside the sequence).
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreRecursive</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sequence</span>  <span class="nx">Selector</span>
    <span class="nx">maxDepth</span>  <span class="nx">UInt</span>
    <span class="nx">stopAt</span>    <span class="nx">Condition</span>
<span class="p">}</span>

<span class="c1">// ExploreRecursiveEdge is a special sentinel value which is used to mark
</span><span class="c1">// the end of a sequence started by an ExploreRecursive selector: the recursion
</span><span class="c1">// goes back to the initial state of the earlier ExploreRecursive selector,
</span><span class="c1">// and proceeds again (with a decremented maxDepth value).
</span><span class="c1">//
</span><span class="c1">// An ExploreRecursive selector that doesn&#39;t contain an ExploreRecursiveEdge
</span><span class="c1">// is nonsensical.  Containing more than one ExploreRecursiveEdge is valid.
</span><span class="c1">// An ExploreRecursiveEdge without an enclosing ExploreRecursive is an error.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreRecursiveEdge</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// ExploreUnion allows selection to continue with two or more distinct selectors
</span><span class="c1">// while exploring the same tree of data.
</span><span class="c1">//
</span><span class="c1">// ExploreUnion can be used to apply a Matcher on one node (causing it to
</span><span class="c1">// be considered part of a (possibly labelled) result set), while simultaneously
</span><span class="c1">// continuing to explore deeper parts of the tree with another selector,
</span><span class="c1">// for example.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreUnion</span> <span class="p">[</span><span class="nx">Selector</span><span class="p">]</span>

<span class="c1">// Note that ExploreConditional versus a Matcher with a Condition are distinct:
</span><span class="c1">// ExploreConditional progresses deeper into a tree;
</span><span class="c1">// whereas a Matcher with a Condition may look deeper to make its decision,
</span><span class="c1">// but returns a match for the node it&#39;s on rather any of the deeper values.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreConditional</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">condition</span>  <span class="nx">Condition</span>
    <span class="nx">next</span>       <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// Matcher marks a node to be included in the &#34;result&#34; set.
</span><span class="c1">// (All nodes traversed by a selector are in the &#34;covered&#34; set (which is a.k.a.
</span><span class="c1">// &#34;the merkle proof&#34;); the &#34;result&#34; set is a subset of the &#34;covered&#34; set.)
</span><span class="c1">//
</span><span class="c1">// In libraries using selectors, the &#34;result&#34; set is typically provided to
</span><span class="c1">// some user-specified callback.
</span><span class="c1">//
</span><span class="c1">// A selector tree with only &#34;explore*&#34;-type selectors and no Matcher selectors
</span><span class="c1">// is valid; it will just generate a &#34;covered&#34; set of nodes and no &#34;result&#34; set.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Matcher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">onlyIf</span>  <span class="nx">Condition</span><span class="err">?</span>  <span class="c1">// match is true based on position alone if this is not set.
</span><span class="c1"></span>    <span class="nx">label</span>   <span class="kt">string</span><span class="err">?</span>  <span class="c1">// labels can be used to match multiple different structures in one selection.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Condition is expresses a predicate with a boolean result.
</span><span class="c1">//
</span><span class="c1">// Condition clauses are used several places:
</span><span class="c1">//   - in Matcher, to determine if a node is selected.
</span><span class="c1">//   - in ExploreRecursive, to halt exploration.
</span><span class="c1">//   - in ExploreConditional,
</span><span class="c1">//
</span><span class="c1">//
</span><span class="c1">// TODO -- Condition is very skeletal and incomplete.
</span><span class="c1">// The place where Condition appears in other structs is correct;
</span><span class="c1">// the rest of the details inside it are not final nor even completely drafted.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Condition</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="c1">// We can come back to this and expand it later...
</span><span class="c1"></span>    <span class="c1">// TODO: figure out how to make this recurse correctly, so I can say &#34;hasField{hasField{or{hasValue{1}, hasValue{2}}}}&#34;.
</span><span class="c1"></span>    <span class="nx">Condition_HasField</span>
    <span class="nx">Condition_HasValue</span>
    <span class="nx">Condition_HasKind</span>
    <span class="nx">Condition_IsLink</span>
    <span class="nx">Condition_GreaterThan</span>
    <span class="nx">Condition_LessThan</span>
    <span class="nx">Condition_And</span>
    <span class="nx">Condition_Or</span>
    <span class="c1">// REVIEW: since we introduced &#34;and&#34; and &#34;or&#34; here, we&#39;re getting into dangertown again.  we&#39;ll need a &#34;max conditionals limit&#34; (a la &#39;gas&#39; of some kind) near here.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Condition_HasField</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_HasKind</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_HasValue</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_And</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_GreaterThan</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_IsLink</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_LessThan</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_Or</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="libraries__ipld__graphstore">

<h3 class="section-header">
  GraphStore - IPLD Data Storage
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// imported as ipld.Store
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GraphStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">CID</span><span class="p">)</span>   <span class="p">(</span><span class="nx">Object</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Object</span><span class="p">)</span>  <span class="p">(</span><span class="nx">CID</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="libraries__libp2p">

<h2 class="section-header">
  libp2p
</h2>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">mf</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/multiformats&#34;</span>

<span class="c1">// PeerID is the CID of the public key of this peer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PeerID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="c1">// PeerInfo is a simple datastructure that relates PeerIDs to corresponding partial Multiaddrs.
</span><span class="c1">// This is a convenience struct used in interfaces where we must specify both, or may specify
</span><span class="c1">// either.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PeerInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PeerID</span>
    <span class="nx">Addrs</span> <span class="p">[</span><span class="nx">mf</span><span class="p">.</span><span class="nx">Multiaddr</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// PeerID returns the PeerID associated with this libp2p Node
</span><span class="c1"></span>    <span class="nf">PeerID</span><span class="p">()</span> <span class="nx">PeerID</span>

    <span class="c1">// MountProtocol adds given Protocol under specified protocol id.
</span><span class="c1"></span>    <span class="nf">MountProtocol</span><span class="p">(</span><span class="nx">path</span> <span class="nx">ProtocolPath</span><span class="p">,</span> <span class="nx">protocol</span> <span class="nx">Protocol</span><span class="p">)</span>

    <span class="c1">// ConnectPeerID establishes a connection to peer matching given PeerInfo.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// PeerInfo.Addrs may be empty. If so:
</span><span class="c1"></span>    <span class="c1">// - Libp2pNode will try to use any Multiaddrs it knows (internal PeerStore)
</span><span class="c1"></span>    <span class="c1">// - Libp2pNode may use any `PeerRouting` protocol mounted onto the libp2p node.
</span><span class="c1"></span>    <span class="c1">//     TODO: how to define this.
</span><span class="c1"></span>    <span class="c1">//     NOTE: probably implies using kad-dht or gossipsub for this.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Idempotent. If a connection already exists, this method returns silently.
</span><span class="c1"></span>    <span class="nf">Connect</span><span class="p">(</span><span class="nx">peerInfo</span> <span class="nx">PeerInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProtocolPath</span> <span class="kt">string</span>

<span class="kd">type</span> <span class="nx">Protocol</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">StreamProtocol</span>
    <span class="nx">DatagramProtocol</span>
<span class="p">}</span>

<span class="c1">// Stream is an interface to deal with networked processes, which communicate
</span><span class="c1">// via streams of bytes.
</span><span class="c1">//
</span><span class="c1">// See golang.org/pkg/io -- as this is modelled after io.Reader and io.Writer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Stream</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Read reads bytes from the underlying stream and copies them to buf.
</span><span class="c1"></span>    <span class="c1">// Read returns the number of bytes read (n), and potentially an error
</span><span class="c1"></span>    <span class="c1">// encountered while reading. Read reads at most len(buf) byte.
</span><span class="c1"></span>    <span class="c1">// Read may read 0 bytes.
</span><span class="c1"></span>    <span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Write writes bytes to the underlying stream, copying them from buf.
</span><span class="c1"></span>    <span class="c1">// Write returns the number of bytes written (n), and potentially an error
</span><span class="c1"></span>    <span class="c1">// encountered while writing. Write writes at most len(buf) byte.
</span><span class="c1"></span>    <span class="c1">// Write may read 0 bytes.
</span><span class="c1"></span>    <span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Close terminates client&#39;s use of the stream.
</span><span class="c1"></span>    <span class="c1">// Calling Read or Write after Close is an error.
</span><span class="c1"></span>    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StreamProtocol</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// AcceptStream accepts an incoming stream connection.
</span><span class="c1"></span>    <span class="nf">AcceptStream</span><span class="p">()</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">stream</span>    <span class="nx">Stream</span>
        <span class="nx">peerInfo</span>  <span class="nx">PeerInfo</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="c1">// OpenStream opens a stream to a particular PeerID.
</span><span class="c1"></span>    <span class="nf">OpenStream</span><span class="p">(</span><span class="nx">peerInfo</span> <span class="nx">PeerInfo</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">stream</span>  <span class="nx">Stream</span>
        <span class="nx">err</span>     <span class="kt">error</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Datagram
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Datagram</span> <span class="nx">Bytes</span>

<span class="c1">// Datagrams are &#34;messages&#34; in the network packet sense of the word.
</span><span class="c1">//
</span><span class="c1">// &#34;message-oriented network protocols&#34; should use this interface,
</span><span class="c1">// not the StreamProtocol interface.
</span><span class="c1">//
</span><span class="c1">// We call it &#34;Datagram&#34; here because unfortunately the word &#34;Message&#34;
</span><span class="c1">// is very overloaded in Filecoin.
</span><span class="c1">// Suggestion for libp2p: use datagram too.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DatagramProtocol</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// AcceptDatagram accepts an incoming message.
</span><span class="c1"></span>    <span class="nf">AcceptDatagram</span><span class="p">()</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">datagram</span>  <span class="nx">Datagram</span>
        <span class="nx">peerInfo</span>  <span class="nx">PeerInfo</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="c1">// OpenStream opens a stream to a particular PeerID
</span><span class="c1"></span>    <span class="nf">SendDatagram</span><span class="p">(</span><span class="nx">datagram</span> <span class="nx">Datagram</span><span class="p">,</span> <span class="nx">peerInfo</span> <span class="nx">PeerInfo</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// type StorageDealLibp2pProtocol struct {
</span><span class="c1">//   StreamProtocol StreamProtocol
</span><span class="c1">//   // ---
</span><span class="c1">//   AcceptStream() struct {}
</span><span class="c1">//   OpenStream() struct {}
</span><span class="c1">// }
</span></code></pre></div>







</div>


  
    








<div id="libraries__libp2p__gossipsub">

<h3 class="section-header">
  Gossipsub for broadcasts
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__libp2p__kad_dht">

<h3 class="section-header">
  Kademlia DHT for Peer Routing
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__libp2p__fil_libp2p_nodes">

<h3 class="section-header">
  Filecoin libp2p Nodes
</h3>

<div class="section-content">






































</div>



</div>

  


</div>

  

  
    








<div id="libraries__ipfs">

<h2 class="section-header">
  IPFS - InterPlanetary File System
</h2>

<div class="section-content">






































</div>


  
    








<div id="libraries__ipfs__bitswap">

<h3 class="section-header">
  BitSwap
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipfs__graphsync">

<h3 class="section-header">
  GraphSync
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipfs__unixfs">

<h3 class="section-header">
  UnixFS
</h3>

<div class="section-content">






































</div>



</div>

  


</div>

  

  
    








<div id="libraries__multiformats">

<h2 class="section-header">
  Multiformats - self describing protocol values
</h2>

<div class="section-content">






































<h3 id="multihash-self-describing-hash-values">Multihash - self describing hash values</h3>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Multihash</span> <span class="nx">Bytes</span>
</code></pre></div>






<h3 id="multiaddr-self-describing-network-addresses">Multiaddr - self describing network addresses</h3>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Multiaddr</span> <span class="nx">Bytes</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="algorithms">

<h1 class="section-header">
  Algorithms
</h1>

<div class="section-content">






































</div>


  
    








<div id="algorithms__expected_consensus">

<h2 class="section-header">
  Expected Consensus
</h2>

<div class="section-content">






































<div id="algorithms__expected_consensus__expected_consensus"></div>

<h4 id="algorithm">Algorithm</h4>

<p>Expected Consensus (EC) is a probabilistic Byzantine fault-tolerant consensus protocol. At a high level, it operates by running a leader election every round in which, on expectation, one participant may be eligible to submit a block. EC guarantees that this winner will be anonymous until they reveal themselves by submitting a proof of their election (we call this proof an <code>Election Proof</code>). All valid blocks submitted in a given round form a <code>Tipset</code>. Every block in a Tipset adds weight to its chain. The &lsquo;best&rsquo; chain is the one with the highest weight, which is to say that the fork choice rule is to choose the heaviest known chain. For more details on how to select the heaviest chain, see <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a>.</p>

<p>At a very high level, with every new block generated, a miner will craft a new ticket from the prior one in the chain appended with the current epoch number (i.e. parentTipset.epoch + 1 to start). While on expectation at least one block will be generated at every round, in cases where no one finds a block in a given round, a miner will increment the round number and attempt a new leader election (using the new input) thereby ensuring liveness in the protocol.</p>

<p>The <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem uses access to EC to use the following facilities:
- Access to verifiable randomness for the protocol, derived from <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>.
- Running and verifying <a href="./#algorithms__expected_consensus__leader_election">leader election</a> for block generation.
- Access to a weighting function enabling <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> by the chain manager.
- Access to the most recently <a href="./#algorithms__expected_consensus__finality">finalized tipset</a> available to all protocol participants.</p>

<p>















<p style="color: #D74848"><b><i>Something's not right. The <code>expected_consensus.id</code> file was not found.</i></b></p>


















<p style="color: #D74848"><b><i>Something's not right. The <code>expected_consensus.go</code> file was not found.</i></b></p>

</p>

<h4 id="tickets-in-ec">Tickets in EC</h4>

<p>Within SPC, a miner generates a new ticket in their block for every ticket they use running leader election, thereby ensuring the ticket chain is always as long as the block chain.</p>

<p>Tickets are used to achieve the following:
- Ensure leader secrecy &ndash; meaning a block producer will not be known until they release their block to the network.
- Prove leader election &ndash; meaning a block producer can be verified by any participant in the network.</p>

<p>In practice, EC defines two different fields within a block:</p>

<ul>
<li>A <code>Ticket</code> field ‚Äî this stores the new ticket generated during this block generation attempt. It is from this ticket that miners will sample randomness to run leader election in <code>K</code> rounds (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>).</li>
<li>An <code>ElectionProof</code> ‚Äî this stores a proof that a given miner has won a leader election using the appropriate ticket <code>K</code> rounds back appended with the current epoch number. It proves that the leader was validly elected in this epoch.</li>
</ul>

<p>















<p style="color: #D74848"><b><i>Something's not right. The <code>election.id</code> file was not found.</i></b></p>


















<p style="color: #D74848"><b><i>Something's not right. The <code>election.go</code> file was not found.</i></b></p>

</p>

<pre><code>But why the randomness lookback?

The randomness lookback helps turn independent ticket generation from a block one round back
into a global ticket generation game instead. Rather than having a distinct chance of winning or losing
for each potential fork in a given round, a miner will either win on all or lose on all
forks descended from the block in which the ticket is sampled.

This is useful as it reduces opportunities for grinding, across forks or sybil identities.

However this introduces a tradeoff:
- The randomness lookback means that a miner can know K rounds in advance that they will win,
decreasing the cost of running a targeted attack (given they have local predictability).
- It means electionProofs are stored separately from new tickets on a block, taking up
more space on-chain.

How is K selected?
- On the one end, there is no advantage to picking K larger than finality.
- On the other, making K smaller reduces adversarial power to grind.
</code></pre>

<div id="algorithms__expected_consensus__leader_election"></div>

<h4 id="secret-leader-election">Secret Leader Election</h4>

<p>Expected Consensus is a consensus protocol that works by electing a miner from a weighted set in proportion to their power. In the case of Filecoin, participants and powers are drawn from the <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a>, where power is equivalent to storage provided through time.</p>

<p>Leader Election in Expected Consensus must be Secret, Fair and Verifiable. This is achieved through the use of randomness used to run the election. In the case of Filecoin&rsquo;s EC, the blockchain tracks an independent ticket chain. These tickets are used as randomness inputs for Leader Election. Every block generated references an <code>ElectionProof</code> derived from a past ticket. The ticket chain is extended by the miner who generates a new block for each successful leader election.</p>

<h5 id="running-a-leader-election">Running a leader election</h5>

<p>Now, a miner must also check whether they are eligible to mine a block in this round.</p>

<p>Design goals here include:
- There should be one block per miner per epoch at most (for simplicity)
- Miners should be rewarded proportional to their power in the system
- The system should be able to tune how many blocks are put out per epoch on expectation (hence &ldquo;expected consensus&rdquo;).</p>

<p>To do so, the miner will use tickets from K rounds back as randomness to uniformly draw a value from 0 to 1. Comparing this value to their power, they determine whether they are eligible to mine. A user&rsquo;s <code>power</code> is defined as the ratio of the amount of storage they proved as of their last PoSt submission to the total storage in the network as of the current block.</p>

<p>We use the VRF from <a href="./#algorithms__crypto__vrf">Verifiable Random Function</a> to run leader election in EC.</p>

<p>If the miner wins the election in this round, it can use newEP, along with a newTicket to generate and publish a new block. Otherwise, it waits to hear of another block generated in this round.</p>

<p>In short, the process of crafting a new ElectionProof in round N is as follows in the <code>DrawElectionProof</code> function:
















<p style="color: #D74848"><b><i>Something's not right. The <code>storage_mining_subsystem.go</code> file was not found.</i></b></p>

</p>

<p>It is important to note that every block contains two artifacts: one, a ticket derived from last block&rsquo;s ticket to extend the ticket-chain, and two, an election proof derived from the ticket <code>K</code> rounds back used to run leader election.</p>

<p>Note: Miner power is drawn from the power table, accounting only for power that has been proven over time (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a>).</p>

<p>The miner can then check whether they drew a winning election proof by comparing their power fraction to the <code>ElectionProof</code>s value, as follows:</p>

<p><code>ElectionProof * TotalPower &lt; e * MinerPower * MaxValue</code></p>

<p>with:
- <code>ElectionProof</code>   the election proof&rsquo;s byte output
- <code>TotalPower</code>      the total power in the current power table
- <code>e</code>               the expected number of blocks crafted per epoch
- <code>MinerPower</code>      the current miner&rsquo;s power in the power table
- <code>MaxValue</code>        the maximum possible value for the election proof using SHA-256 with our vdf, we would have <code>maxValue = 2^256</code>.</p>

<p>The above is the integer format of <code>ElectionProof/MaxValue &lt; e * MinerPower/TotalPower</code> which makes it easy to see that a miner should win proportionally to the amount of power they have staked in the system. Note that miners with more than <code>1/e</code> fraction of power will win once at every round, meaning there may be fewer than e blocks per round with many large miners.</p>

<p>If successful, the miner can craft a block, passing it to the block producer. If unsuccessful, it will wait to hear of another block mined this round to try again. In the case no other block was found in this round the miner can increment the epoch number and try leader election again using the same past ticket and new epoch number.</p>

<p>While a miner could try to run through multiple epochs in parallel in order to quickly generate a block, this effort will be futile as the rational majority of miners will reject blocks crafted with ElectionProofs whose epochs prove too high (i.e. in the future &ndash; see below).</p>

<h5 id="election-validation">Election Validation</h5>

<p>In order to determine that the mined block was generated by an eligible miner, one must check its <code>ElectionProof</code>&rsquo;s validity and that its input was generated using the current epoch value as shown in the <code>ValidateElectionProof</code> and <code>IsWinningElectionProof</code> methods above.</p>

<p>It is worth drawing attention to how mining rewards are split among miners. Specifically, for every miner publishing a block in a given round, reward is determined as follows:
<code>
draw = ElectionProof/maxValue
req = e * minerPower/totalPower
rewCount = ceil(req - draw)
reward = rewCount * targetRewardPerEpoch/e
</code></p>

<p>This process, shown in the <code>GetBlockRewards</code> method above, allows all miners to receive their fair share of rewards on expectation (over time), accounting for some miners winning at every round. Read more about design tradeoffs <a href="https://github.com/filecoin-project/specs/issues/603">here</a>.</p>

<div id="algorithms__expected_consensus__chain_selection"></div>

<h4 id="chain-selection">Chain Selection</h4>

<p>Just as there can be 0 miners win in a round, multiple miners can be elected in a given round. This in turn means multiple blocks can be created in a round, as seen above. In order to avoid wasting valid work done by miners, EC makes use of all valid blocks generated in a round.</p>

<h5 id="chain-weighting">Chain Weighting</h5>

<p>It is possible for forks to emerge naturally in Expected Consensus. EC relies on weighted chains in order to quickly converge on &lsquo;one true chain&rsquo;, with every block adding to the chain&rsquo;s weight. This means the heaviest chain should reflect the most amount of work performed, or in Filecoin&rsquo;s case, the most storage provided.</p>

<p>In short, the weight at each block is equal to its <code>ParentWeight</code> plus that block&rsquo;s delta weight. Details of Filecoin&rsquo;s chain weighting function <a href="https://observablehq.com/d/3812cd65c054082d">are included here</a>.</p>

<p>Delta weight is a term composed of a few elements:
- wForkFactor: which seeks to cut the weight derived from rounds in which produced Tipsets do not correspond to what an honest chain is likely to have yielded (pointing to selfish mining or other non-collaborative miner behavior).
- wPowerFactor: which adds weight to the chain proportional to the total power backing the chain, i.e. accounted for in the chain&rsquo;s power table.
- wBlocksFactor: which adds weight to the chain proportional to the number of blocks mined in a given round. Like wForkFactor, it rewards miner cooperation (which will yield more blocks per round on expectation).</p>

<p>The weight should be calculated using big integer arithmetic with order of operations defined above. We use brackets instead of parentheses below for legibility. We have:</p>

<p><code>w[r+1] = w[r] + (wPowerFactor[r+1] + wBlocksFactor[r+1]) * 2^8</code></p>

<p>For a given tipset <code>ts</code> in round <code>r+1</code>, we define:</p>

<ul>
<li><code>wPowerFactor[r+1]  = wFunction(totalPowerAtTipset(ts))</code></li>
<li>wBlocksFactor[r+1] =  <code>wPowerFactor[r+1] * wRatio * b / e</code>

<ul>
<li>with <code>b = |blocksInTipset(ts)|</code></li>
<li><code>e = expected number of blocks per round in the protocol</code></li>
<li>and <code>wRatio in ]0, 1[</code>
Thus, for stability of weight across implementations, we take:</li>
</ul></li>
<li>wBlocksFactor[r+1] =  <code>(wPowerFactor[r+1] * b * wRatio_num) / (e * wRatio_den)</code></li>
</ul>

<p>We get:
- <code>w[r+1] = w[r] + wFunction(totalPowerAtTipset(ts)) * 2^8 + (wFunction(totalPowerAtTipset(ts)) * len(ts.blocks) * wRatio_num * 2^8) / (e * wRatio_den)</code>
 Using the 2^8 here to prevent precision loss ahead of the division in the wBlocksFactor.</p>

<p>The exact value for these parameters remain to be determined, but for testing purposes, you may use:
 - <code>e = 5</code>
 - <code>wRatio = .5, or wRatio_num = 1, wRatio_den = 2</code>
- <code>wFunction = log2b</code> with
  - <code>log2b(X) = floor(log2(x)) = (binary length of X) - 1</code> and <code>log2b(0) = 0</code>. Note that that special case should never be used (given it would mean an empty power table.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Note that <span class="k">if</span> your implementation does not allow <span class="k">for</span> rounding to the fourth decimal, miners should apply the <span class="o">[</span>tie-breaker below<span class="o">](</span><span class="c1">#selecting-between-tipsets-with-equal-weight). Weight changes will be on the order of single digit numbers on expectation, so this should not have an outsized impact on chain consensus across implementations.</span></code></pre></div>
<p><code>ParentWeight</code> is the aggregate chain weight of a given block&rsquo;s parent set. It is calculated as
the <code>ParentWeight</code> of any of its parent blocks (all blocks in a given Tipset should have
the same <code>ParentWeight</code> value) plus the delta weight of each parent. To make the
computation a bit easier, a block&rsquo;s <code>ParentWeight</code> is stored in the block itself (otherwise
potentially long chain scans would be required to compute a given block&rsquo;s weight).</p>

<h5 id="selecting-between-tipsets-with-equal-weight">Selecting between Tipsets with equal weight</h5>

<p>When selecting between Tipsets of equal weight, a miner chooses the one with the smallest final ticket.</p>

<p>In the case where two Tipsets of equal weight have the same min ticket, the miner will compare the next smallest ticket (and select the Tipset with the next smaller ticket). This continues until one Tipset is selected.</p>

<p>The above case may happen in situations under certain block propagation conditions. Assume three blocks B, C, and D have been mined (by miners 1, 2, and 3 respectively) off of block A, with minTicket(B) &lt; minTicket&copy; &lt; minTicket (D).</p>

<p>Miner 1 outputs their block B and shuts down. Miners 2 and 3 both receive B but not each others&rsquo; blocks. We have miner 2 mining a Tipset made of B and C and miner 3 mining a Tipset made of B and D. If both succesfully mine blocks now, other miners in the network will receive new blocks built off of Tipsets with equal weight and the same smallest ticket (that of block B). They should select the block mined atop [B, C] since minTicket&copy; &lt; minTicket(D).</p>

<p>The probability that two Tipsets with different blocks would have all the same tickets can be considered negligible: this would amount to finding a collision between two 256-bit (or more) collision-resistant hashes.</p>

<div id="algorithms__expected_consensus__finality"></div>

<h4 id="finality-in-ec">Finality in EC</h4>

<p>EC enforces a version of soft finality whereby all miners at round N will reject all blocks that fork off prior to round N-F. For illustrative purposes, we can take F to be 500. While strictly speaking EC is a probabilistically final protocol, choosing such an F simplifies miner implementations and enforces a macroeconomically-enforced finality at no cost to liveness in the chain.</p>

<div id="algorithms__expected_consensus__consensus_faults"></div>

<h4 id="consensus-faults">Consensus Faults</h4>

<p>Due to the existence of potential forks in EC, a miner can try to unduly influence protocol fairness. This means they may choose to disregard the protocol in order to gain an advantage over the power they should normally get from their storage on the network. A miner should be slashed if they are provably deviating from the honest protocol.</p>

<p>This is detectable when a given miner submits two blocks that satisfy any of the following &ldquo;consensus faults&rdquo;:</p>

<ul>
<li><p>(1) <code>double-fork mining fault</code>: two blocks mined at the same epoch.












<div class="diagram">

<span class="diagram-title">Double-Fork Mining Fault</span>




(<a href="docs/algorithms/expected_consensus/diagrams/double_fork.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/algorithms/expected_consensus/diagrams/double_fork.dot.svg" />




</div>
</p></li>

<li><p>(2) <code>time-offset mining fault</code>: two blocks mined off of the same Tipset at different epochs (i.e. with different <code>ElectionProof</code>s generated from the same input ticket).












<div class="diagram">

<span class="diagram-title">Time-Offset Mining Fault</span>




(<a href="docs/algorithms/expected_consensus/diagrams/time_offset.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/algorithms/expected_consensus/diagrams/time_offset.dot.svg" />




</div>
</p></li>

<li><p>(3) <code>parent-grinding fault</code>: one block&rsquo;s parent is a Tipset that provably should have included a given block but does not. While it cannot be proven that a missing block was willfully omitted in general (i.e. network latency could simply mean the miner did not receive a particular block), it can when a miner has successfully mined a block two epochs in a row and omitted one. That is, this condition should be evoked when a miner omits their own prior block. When a miner&rsquo;s block at epoch e + 1 references a Tipset that does not include the block they mined at e both blocks can be submitted to prove this fault.












<div class="diagram">

<span class="diagram-title">Parent-Grinding fault</span>




(<a href="docs/algorithms/expected_consensus/diagrams/parent_grinding.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/algorithms/expected_consensus/diagrams/parent_grinding.dot.svg" />




</div>
</p></li>
</ul>

<p>Any node that detects any of the above events should submit both block headers to the <code>StoragePowerActor</code>&rsquo;s <code>ReportConsensusFault</code> method. The &ldquo;slasher&rdquo; will receive a portion (TODO: define how much) of the offending miner&rsquo;s <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></a> as a reward for notifying the network of the fault.
(TODO: FIP of submitting commitments to block headers to prevent miners censoring slashers in order to gain rewards).</p>

<p>It is important to note that there exists a third type of consensus fault directly reported by the <code>CronActor</code> on <code>StorageDeal</code> failures via the <code>ReportUncommittedPowerFault</code> method:
- (4) <code>uncommitted power fault</code> which occurs when a miner fails to submit their <code>PostProof</code> and is thus participating in leader election with undue power (see <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>).</p>


</div>



</div>

  

  
    








<div id="algorithms__porep">

<h2 class="section-header">
  Proof-of-Replication
</h2>

<div class="section-content">




































<p>See <a href="https://filecoin.io/filecoin.pdf">Filecoin Paper</a></p>


</div>


  
    








<div id="algorithms__porep__stacked_drg">

<h3 class="section-header">
  Stacked DRG PoRep
</h3>

<div class="section-content">






































<p>This section describes <em>Stacked DRG PoRep</em> (SDR), the specific Proof-of-Replication (PoRep) used in Filecoin. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.</p>

<p>SDR has been presented by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.</p>

<h4 id="introduction">Introduction</h4>

<h5 id="background-on-proof-of-replication">Background on Proof-of-Replication</h5>

<p><em>Proof-of-Replication</em> enables a prover <em>P</em> to convince a verifier <em>V</em> that <em>P</em> is storing a replica <em>R</em>, a physically independent copy of some data <em>D</em>, unique to <em>P</em>. The scheme is defined by a tuple of polynomial time algorithms (<em>Setup</em>, Replication, <em>Prove</em>, <em>Verify</em>). The assumption is that generation of a replica after <em>Replicate</em>  must be difficult (if not impossible) to generate.</p>

<ul>
<li><em>Setup</em>: On setup, the public parameters of the proving systems are set.</li>
<li><em>Replicate</em>: On replication, either a party or both (depending on the scheme, in our case the prover only!) generate a unique permutation of the original data <em>D</em>, which we call replica <em>R</em>.</li>
<li><em>Prove</em>: On receiving a challenge, the prover must generate a proof that it is in possession of the replica and that it was derived from data <em>D</em>. The prover must only be able to respond to the challenge successfully if it is in possession of the replica, since would be difficult (if not impossible) to generate a replica that can be used to generate the proof at this stage</li>
<li><em>Verify</em>: On receiving the proof, the verifier checks the validity of the proof and accepts or rejects the proof.</li>
</ul>

<div class="mermaid" align="center">
sequenceDiagram
    Note right of Prover: CommD
    Prover-->>Prover: R, CommR ‚Üê Replicate(D)
    Prover->>Verifier: CommR
    Verifier-->>Verifier: Generate random challenge
    Verifier->>Prover: challenge
    Prover-->>Prover: proof ‚Üê Prove(D, R, challenge)
    Prover->>Verifier: proof
</div>

<h5 id="time-bounded-proof-of-replication">Time-bounded Proof-of-Replication</h5>

<p><strong>Timing assumption</strong>. <em>Time-bounded Proof-of-Replication</em> are constructions of PoRep with timing assumptions. The assumption is that generation of the replica (hence the <em>Replication</em>) takes some time <em>t</em> that is substantially larger than the time it takes to produce a proof (hence <em>time(Prove)</em>) and the round-trip time (<em>RTT</em>) for sending a challenge and receiving a proof.</p>

<p><strong>Distinguishing Malicious provers</strong>. A malicious prover that does not have <em>R</em>, must obtain it (or generate it), before the <em>Prove</em> step. A verifier can distinguish an honest prover from a malicious prover, since the malicious one will take too long to answer the challenge. A verifier will reject if receiving the proof from the prover takes longer than a timeout (bounded between proving time and replication time).</p>

<h5 id="background-on-stacked-drg-porep">Background on Stacked DRG PoRep</h5>

<p><em>Stacked DRG PoRep</em> (SDR) is a specific Proof-of-Replication construction that we use in Filecoin. SDR has been designed by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.  At a high level, SDR ensures that the <em>Replicate</em> step is a slow non-parallelizable sequential process by using a special type of graph called Depth Robust Graphs (DRG).</p>

<p><strong>Encoding using DRGs</strong>. A key is generated by sequentially labeling nodes in the graph such that each label depends on the labels of its parents. The depth robustness property of these graphs ensure that the sequential labeling steps are not parallelizable. The final labels are used as a key to encode the original data.</p>

<p>TODO: This probably needs a more thorough rewrite.</p>

<p>** Stacked DRGs**. SDR builds on the above by stacking DRG graphs into <code>LAYERS</code> layers. Each layer is connected to the previous by a Bipartite Expander Graph. The combination of DRGs and expander graphs guarantee the security property of PoRep. As before, the key produced by the final layer is used to encode the original data, yielding the replica.</p>

<p><strong>Generating SDR proofs</strong>. Given the following public parameters:</p>

<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details).</li>
<li><code>CommD</code> is the Merkle tree root hash of the input data to the first layer.</li>
<li><code>CommC</code> is the Merkle tree root hash of the SDR column commitments.</li>
<li><code>CommRLast</code> is the Merkle tree root hash of the replica.</li>
<li><code>CommR</code> is the on-chain commitment to the replica, dervied as the hash of the concatenation of <code>CommC</code> and <code>CommRLast</code>.</li>
</ul>

<p>An SDR proof proves that some data whose committment is <code>CommD</code> has been used to run a <code>Replicate</code> algorithm and generated some data. <code>CommR</code> is the on-chain commitment to both the replicated data and to intermediate stages required to prove <code>Replicate</code> was performed correctly.</p>

<p>An SDR proof consists of a set of challenged DRG nodes for each layer, a set of parent nodes for each challenged node and a Merkle tree inclusion proof for each node provided. The verifier can then verify the correct labeling of each node and that the nodes given were consistent with the prover&rsquo;s commitments.</p>

<p><strong>Making proofs succinct with SNARKs</strong>: The proof size in SDR is too large for blockchain usage (~100MB TODO: check this), mostly due to the large amount of Merkle tree inclusion proofs required to achieve security. We use SNARKs to generate a proof of knowledge of a correct SDR proof. In other words, we implement the SDR proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>

<p>The SNARK circuit proves that given Merkle roots <code>CommD</code>, and <code>CommR</code>, the prover correctly derived the labels at each layer and correctly performed the final encoding.</p>

<h5 id="porep-in-filecoin">PoRep in Filecoin</h5>

<p>Proof-of-Replication proves that a Storage Miner is dedicating unique storage for each <strong><em>sector</em></strong>. Filecoin Storage Miners collect new clients&rsquo; data in a sector, run a slow encoding process (called <code>Seal</code>) and generate a proof (<code>SealProof</code>) that the encoding was generated correctly.</p>

<p>In Filecoin, PoRep provides two guarantees: (1) <em>space-hardness</em>: Storage Miners cannot lie about the amount of space they are dedicating to Filecoin in order to gain more power in the consensus; (2) <em>replication</em>: Storage Miners are dedicating unique storage for each copy of their clients data.</p>

<p>Glossary:</p>

<ul>
<li><strong><em>sector:</em></strong> a fixed-size block of data of <code>SECTOR_SIZE</code> bytes which generally contains clients&rsquo; data.</li>
<li><strong><em>unsealed sector:</em></strong> a concrete representation (on disk or in memory) of a sector&rsquo;s that follows the &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</li>
<li><strong><em>sealed sector:</em></strong>  a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an <strong><em>unsealed sector</em></strong>. A sector contains one or more <strong><em>pieces</em></strong>.</li>
<li><strong><em>piece:</em></strong> a block of data of at most <code>SECTOR_SIZE</code> bytes which is generally a client&rsquo;s file or part of.</li>
</ul>

<h4 id="stacked-drg-construction">Stacked DRG Construction</h4>

<h5 id="public-parameters">Public Parameters</h5>

<p>The following public parameters are used in the Stacked DRG Replication and Proof Generation algorithms:</p>

<p>TODO: the Appendix should explain why we picked those values
TODO: Just interpolate a table of the Orient parameters and reconcile naming.</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>SECTOR_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the DRG in bytes</td>
<td align="right"><code>68,719,476,736</code></td>
</tr>

<tr>
<td><code>LAYERS</code></td>
<td><code>uint</code></td>
<td>Number of Depth Robust Graph stacked layers.</td>
<td align="right"><code>10</code></td>
</tr>

<tr>
<td><code>BASE_DEGREE</code></td>
<td><code>uint</code></td>
<td>In-Degree of each Depth Robust Graph.</td>
<td align="right"><code>6</code></td>
</tr>

<tr>
<td><code>EXPANSION_DEGREE</code></td>
<td><code>uint</code></td>
<td>Degree of each Bipartite Expander Graph to extend dependencies between layers.</td>
<td align="right"><code>8</code></td>
</tr>

<tr>
<td><code>GRAPH_SEED</code></td>
<td><code>uint</code></td>
<td>Seed used for random number generation in <code>baseParents</code>.</td>
<td align="right"><code>TODO</code></td>
</tr>

<tr>
<td><code>NODE_SIZE</code></td>
<td><code>uint</code></td>
<td>Size of each node in bytes.</td>
<td align="right"><code>32B</code></td>
</tr>
</tbody>
</table>

<p>The following constants are computed from the public parameters:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">computation</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>PARENTS_COUNT</code></td>
<td><code>uint</code></td>
<td>Total number of parent nodes</td>
<td align="right"><code>EXPANSION_DEGREE + BASE_DEGREE</code></td>
<td><code>13</code></td>
</tr>

<tr>
<td><code>GRAPH_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the graph</td>
<td align="right"><code>SECTOR_SIZE / NODE_SIZE</code></td>
<td><code>2,147,483,648</code></td>
</tr>

<tr>
<td><code>TREE_DEPTH</code></td>
<td><code>uint</code></td>
<td>Height of the Merkle Tree of a sector</td>
<td align="right"><code>LOG_2(GRAPH_SIZE)</code></td>
<td><code>31</code></td>
</tr>
</tbody>
</table>

<p>The following additional public parameters are required:</p>

<ul>
<li><code>TAPER</code> : <code>Float</code>: Fraction of each layer&rsquo;s challenges by which to reduce next-lowest layer&rsquo;s challenge count.</li>
<li><code>TAPER_LAYERS</code>: <code>uint</code>: Number of layers which should be tapered. FIXME: update for current tapering.
<code>Data</code> is a byte array initialized to the content of <strong><em>unsealed sector</em></strong> and will be mutated in-place by the replication process.</li>
</ul>

<h5 id="hash-functions">Hash Functions</h5>

<p>We have describe three hash functions:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>size of input</th>
<th>size of output</th>
<th>construction</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>KDFHash</code></td>
<td>Hash function used as a KDF to derive the key used to label a single node.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>SHA256</code></td>
</tr>

<tr>
<td><code>ColumnHash</code></td>
<td>Hash function used to hash the labeled leaves of each layer (see SDR Column Commitments).</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>

<tr>
<td><code>RepCompress</code></td>
<td>Collision Resistant Hash function used for the Merkle tree.</td>
<td>2 x <code>32B</code> + integer height</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>

<tr>
<td><code>RepHash</code></td>
<td>Balanced binary Merkle tree based used to generate commitments to sealed sectors, unsealed sectors, piece commitments, and intermediate parts of the Proof-of-Replication.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td>Uses <code>RepCompress</code></td>
</tr>

<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h6 id="rephash">RepHash</h6>

<p><code>RepHash</code> is a vector commitment used to generate commitments to sealed sectors, unsealed sectors, piece commitments and intermediate stepds of the Proof-of-Replication. Filecoin uses a balanced binary Merkle tree for <code>RepHash</code>. The leaves of the Merkle tree are pairs of adjacent nodes.</p>

<p><code>RepHash</code> inputs MUST respect a valid Storage Format. [TODO: What does this mean?]</p>

<h5 id="stacked-drg-graph">Stacked DRG Graph</h5>

<p>The slow sequential encoding required is enforced by the depth robusness property of the SDR graph.</p>

<p><strong>Encoding with SDR</strong>: The data from a sector (of size <code>SECTOR_SIZE</code>) is divided in <code>NODE_SIZE</code> nodes (for a total of <code>GRAPH_SIZE</code> nodes) and arranged in a directed acyclic graph. The structure of the graph is used to label the nodes sequentially to generate a key with which to encode the original data: in order to label a node, its parents must be labeled (see the &ldquo;Layer Labeling&rdquo; section below). We repeat this process for <code>LAYERS</code> layers, where the input to a next layer is the output of the previous one.</p>

<p><strong>Generating the SDR graph</strong>: The SDR graph is divided in <code>LAYERS</code> layers. Each layer is a directed acyclic graph and it combines a Depth Robust Graph (DRG) and a Bipartite Expander graph. [TODO: this isn&rsquo;t quite right.]</p>

<p>We provide an algorithm (<code>SDR</code>) which computes the parents of a node. In high level, the parents of a node are computed by combining two algorithms: some parents (<code>BASE_DEGREE</code> of them) are computed via the <code>BucketSample</code> algorithm extended with a direct ordering of nodes, others (<code>EXPANSION_DEGREE</code> of them) are computed via the <code>Chung</code> algorithm.</p>

<h6 id="sdrgraph-sdr-graph-algorithm"><code>SDRGraph</code>: SDR Graph algorithm</h6>

<p>Overview: Compute the DRG and Bipartite Expander parents using respectively <code>BucketSample</code> and <code>ChungExpander</code>.</p>

<h6 id="inputs">Inputs</h6>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>node</code></td>
<td>The node for which the parents are being computed</td>
<td><code>uint</code></td>
</tr>

<tr>
<td><code>layer</code></td>
<td>The layer of the SDR graph</td>
<td><code>uint</code></td>
</tr>
</tbody>
</table>

<h6 id="outputs">Outputs</h6>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>parents</code></td>
<td>The ordered parents of node <code>node</code> on layer <code>layer</code></td>
<td><code>[PARENTS_COUNT]uint</code></td>
</tr>
</tbody>
</table>

<h6 id="algorithm">Algorithm</h6>

<ul>
<li><p>If <code>layer = 1</code>:</p>

<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Set <code>parents</code> to be <code>drgParents</code>.</li>
</ul></li>

<li><p>If <code>layer &gt; 1</code>:</p>

<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Compute <code>expanderParents = ChungExpander(node)</code></li>
<li>Set <code>parents</code> to be the concatenation of <code>drgParents</code> and <code>expanderParents</code></li>
</ul></li>
</ul>

<p>We provide below a more succinct representation of the algorithm:</p>

<p>TODO: Reference to code in filproofs/algorithms.go  ‚Äî or restructure all this.</p>

<h6 id="time-space-tradeoff">Time-space tradeoff</h6>

<p>Computing the parents using both <code>BucketSample</code> and <code>ChungExpander</code> for every layer can be an expensive operation, however, this can be avoided by caching the parents.</p>

<h6 id="bucketsample-depth-robust-graphs-algorithm"><code>BucketSample</code>: Depth Robust Graphs algorithm</h6>

<p>This section describes how to compute the &ldquo;base parents&rdquo; of the SDR graph, which is the equivalent of computing the parents of a Depth Robust Graph.</p>

<p>The properties of DRG graphs guarantee that a sector has been encoded with a slow, non-parallelizable process. We use the <code>BucketSample</code> algorithm that is based on DRSample (<a href="https://acmccs.github.io/papers/p1001-alwenA.pdf">ABH17</a>) and described in <a href="https://web.stanford.edu/~bfisch/porep_short.pdf">FBGB18</a> and generates a directed acyclic graph of in-degree <code>BASE_DEGREE</code>.</p>

<p><code>BucketSample</code> DRG graphs are random graphs that can be deterministically generated from a seed; different seed lead with high probability to different graphs. In SDR, we use the same seed <code>GRAPH_SEED</code> for each layer of the SDR graph such that they are all based on the same underlying DRG graph.</p>

<p>The parents of any node can be locally computed without computing the entire graph. We call the parents of a node calculated in this way <em>base parents</em>.</p>

<p><code>BucketSample</code> extends <code>BucketSampleInner</code> to include the node&rsquo;s &lsquo;immediate predecessor&rsquo;. Each node except the first in a
DRG generated by <code>BucketSample</code> has the node whose index is one less than its own as a parent. This ensures that
visiting nodes whose indexes are sequential will result in a graph traversal in topological order.</p>

<h6 id="chungexpander-bipartite-expander-graphs"><code>ChungExpander</code>: Bipartite Expander Graphs</h6>

<p>TODO: explain why we link nodes in the current layer</p>

<p>Each node in layers other than the first has <code>EXPANSION_DEGREE</code> parents generated via the <code>ChungExpander</code>
algorithm. Note that the indexes returned refer to labels from the <em>previous</em> layer. TODO: Make this all clearer with explicit notation.</p>

<p>// TODO: link to relevant filproofs/algorithms.go</p>

<h6 id="time-space-tradeoff-1">Time-Space tradeoff</h6>

<p>Computing these parents can be expensive (especially due to the hashing required by the Feistel algorithm). A miner can trade this computation by storing the expansion parents.</p>

<h6 id="feistel-construction">Feistel construction</h6>

<p>We use three rounds of <code>Feistel</code> to generate a permutation to compute the parents of the Bipartite Expander graph.</p>

<p>TODO: link to filproofs/feistel</p>

<h4 id="replication">Replication</h4>

<blockquote>
<p>The Replication phase turns an <em>unsealed sector</em> into a <em>sealed sector</em> by first <em>generating a key</em>, then using the key to <em>encode the orignal data</em>.</p>
</blockquote>

<p>Before running the <code>Replicate</code> algorithm, the prover must ensure that the sector is correctly formatted with a valid &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Filecoin Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</p>

<p>TODO: inputs are missing</p>

<p>The Replication Algorithm  proceeds as follows:</p>

<ul>
<li>Calculate <code>ReplicaID</code> using <code>Hash</code> (SHA256):</li>
</ul>

<p><code>ReplicaID</code> is a 32-byte array constructed by hashing the concatenation of the following values
- <code>ProverId</code> is a 32-byte array uniquely identifying a prover.
- <code>SectorNumber</code> is an unsigned 64-bit integer in little-endian encoding represented as an 8-byte array.
- <code>RandomSeed</code> is a 32-byte array of randomness extracted from the chain.
- <code>CommD</code> is the Merkle root obtained by performing <code>RepHash</code> on the original data represented in <code>paddedfr32v1</code>.</p>

<pre><code>ReplicaID := Hash(ProverID || SectorNumber || RandomSeed || CommD)
</code></pre>

<ul>
<li><p>Perform <code>RepHash</code> on <code>Data</code> to yield <code>CommD</code> and <code>TreeD</code>:</p>

<pre><code>CommD, TreeD = RepHash(data)
</code></pre></li>
</ul>

<h5 id="layer-labeling">Layer Labeling</h5>

<p>TODO: Define <code>Graph</code>. We need to decide if this is an object we&rsquo;ll explicitly define or if its properties (e.g., <code>GRAPH_SIZE</code>) are just part of the replication parameters and all the functions just refer to the <em>same</em> graphs being manipulated across the entire replication process. (At the moment I&rsquo;ve avoided defining a <code>Graph</code> structure as in other specs I didn&rsquo;t see any object methods, just standalone functions.)</p>

<p>// TODO: link to filproofs/algorithms</p>

<h4 id="proof-generation">Proof Generation</h4>

<p>Overview:</p>

<ul>
<li>Challenge Derivation</li>
<li>Proof Generation</li>
<li>Circuit Proof Generation</li>
</ul>

<p>TODO: write a single algorithm which includes the spec below</p>

<h5 id="challenge-generation">Challenge Generation</h5>

<p>TODO: Link to filproofs/algorithms</p>

<p>Calculate <code>LAYER_CHALLENGES : [LAYERS]uint</code>: Number of challenges per layer. (This will be passed to the SDR circuit proof.)</p>

<p>Derive challenges for each layer (call <code>DeriveChallenges()</code>).</p>

<h5 id="witness-generation">Witness Generation</h5>

<p>TODO: link to filproofs/algorithms</p>

<h5 id="layer-challenge-counts">Layer Challenge Counts</h5>

<p>TODO: we should just list current parameters and show this as a calculation for correctness, this should not mandatory to implement.</p>


</div>



</div>

  

  
    








<div id="algorithms__porep__porep_commitments">

<h3 class="section-header">
  PoRep Commitments
</h3>

<div class="section-content">






































</div>


  
    








<div id="algorithms__porep__porep_commitments__sdr_commitments">

<h4 class="section-header">
  Stacked DRG Commitments
</h4>

<div class="section-content">






































</div>


  
    








<div id="algorithms__porep__porep_commitments__sdr_commitments__sdr_commitments">

<h5 class="section-header">
  Stacked DRG Commitments
</h5>

<div class="section-content">






































<p>This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in <a href="https://www.overleaf.com/read/kcdhnxwptxbc">Tight PoS - ZigZag</a>.</p>

<h6 id="graph">Graph</h6>

<p>In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only
to illustrate the nature of the SDR commitment scheme. They accurately represent how parent-child relationships
function between layers, and are accurate for expander parents. However, this is not representative of the DRG parent
selection algorithm.</p>

<p>The following graphs illustrate the positions of challenges, DRG parents, and expander parents between layers. Only a
single DRG parent and a single expander parent are shown. The immediate predecessor parent is shown for graph topology,
but it is not tracked in the tables below.</p>

<p>In order to have a compact and concrete example, we use a graph containing only <code>8</code> nodes replicated in <code>4</code> layers.</p>

<h6 id="legend">Legend</h6>

<figure>
    <img src="./ox-hugo/legend.png"/> 
</figure>


<h6 id="data-layer--comm-d--tree">Data Layer: \(Comm_D\) Tree</h6>

<figure>
    <img src="./ox-hugo/data-layer.png"/> 
</figure>


<h6 id="replica-column-layers--comm-c--tree">Replica Column Layers: \(Comm_C\) Tree</h6>

<figure>
    <img src="./ox-hugo/layer-1.png"/> 
</figure>


<figure>
    <img src="./ox-hugo/layer-2.png"/> 
</figure>


<figure>
    <img src="./ox-hugo/layer-3.png"/> 
</figure>


<figure>
    <img src="./ox-hugo/layer-4.png"/> 
</figure>


<h6 id="final-layer--comm-r-last--tree">Final Layer: \(Comm_{R_{LAST}}\) Tree</h6>

<figure>
    <img src="./ox-hugo/replica-layer.png"/> 
</figure>


<h6 id="commitment-algorithm">Commitment Algorithm</h6>

<h6 id="goal">Goal</h6>

<p>We will generate two commitments \(Comm_R, Comm_D\) to be placed on chain.</p>

<p>\(Comm_D\) is the merkle root of the original data.</p>

<p>\(Comm_R = H(Comm_C || Comm_{R_{LAST}})\).</p>

<p>Their construction is described below.</p>

<h6 id="definitions-and-notation">Definitions and Notation</h6>

<p>We will perform \(L\) layers of SDR key generation over \(N\) labeled nodes.</p>

<p>In the running example, \(L\) is <code>4</code> and \(N\) is <code>8</code>.</p>

<p>Merkle roots (commitments) are generated with the vector-commitment function \(VC(‚Ä¶)\).</p>

<p>Hashes are produced with a hash function \(H(‚Ä¶)\), which is not necessarily that used by \(VC(‚Ä¶)\).</p>

<p>\(Comm = VC(l_1||‚Ä¶||l_N)\), where the \(l_i\) are the data (labels or hashes) to be committed.</p>

<p>Generated trees are retained until the proving phase, when merkle proofs of a given label&rsquo;s inclusion in \(Comm\) will be
created. We will designate such proofs \(l_i \rightarrow Comm\).</p>

<p>We use the notation \(e{_i}^{(l)}\), correlated in the table below with the \((l, i)\) notation used in the graphs above,
where \(l\) indexes layers, and \(i\) indexes labels or columns.</p>

<table>
<thead>
<tr>
<th>Graph</th>
<th>\((1, 1)\)</th>
<th>\((1, 2)\)</th>
<th>\((1, 3)\)</th>
<th>\((1, 4)\)</th>
<th>\((1, 5)\)</th>
<th>\((1, 6)\)</th>
<th>\((1, 7)\)</th>
<th>\((1, 8)\)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Notation</td>
<td>\(e_1^{(1)}\)</td>
<td>\(e_2^{(1)}\)</td>
<td>\(e_3^{(1)}\)</td>
<td>\(e_4^{(1)}\)</td>
<td>\(e_5^{(1)}\)</td>
<td>\(e_6^{(1)}\)</td>
<td>\(e_7^{(1)}\)</td>
<td>\(e_8^{(1)}\)</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Graph</th>
<th>\((2, 1)\)</th>
<th>\((2, 2)\)</th>
<th>\((2, 3)\)</th>
<th>\((2, 4)\)</th>
<th>\((2, 5)\)</th>
<th>\((2, 6)\)</th>
<th>\((2, 7)\)</th>
<th>\((2, 8)\)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Notation</td>
<td>\(e_1^{(2)}\)</td>
<td>\(e_2^{(2)}\)</td>
<td>\(e_3^{(2)}\)</td>
<td>\(e_4^{(2)}\)</td>
<td>\(e_5^{(2)}\)</td>
<td>\(e_6^{(2)}\)</td>
<td>\(e_7^{(2)}\)</td>
<td>\(e_8^{(2)}\)</td>
</tr>
</tbody>
</table>

<p>‚Ä¶</p>

<table>
<thead>
<tr>
<th>Graph</th>
<th>\((4, 1)\)</th>
<th>\((4, 2)\)</th>
<th>\((4, 3)\)</th>
<th>\((4, 4)\)</th>
<th>\((4, 5)\)</th>
<th>\((4, 6)\)</th>
<th>\((4, 7)\)</th>
<th>\((4, 8)\)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Notation</td>
<td>\(e_1^{(4)}\)</td>
<td>\(e_2^{(4)}\)</td>
<td>\(e_3^{(4)}\)</td>
<td>\(e_4^{(4)}\)</td>
<td>\(e_5^{(4)}\)</td>
<td>\(e_6^{(4)}\)</td>
<td>\(e_7^{(4)}\)</td>
<td>\(e_8^{(4)}\)</td>
</tr>
</tbody>
</table>

<h6 id="initial-data-layer">Initial Data Layer</h6>

<table>
<thead>
<tr>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th>Challenge</th>
<th><code>~~~~</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>\((0, 1)\)</td>
<td>\((0, 2)\)</td>
<td>\((0, 3)\)</td>
<td>\((0, 4)\)</td>
<td>\((0, 5)\)</td>
<td>\((0, 6)\)</td>
<td>\((0, 7)\)</td>
<td>\((0, 8)\)</td>
</tr>
</tbody>
</table>

<ul>
<li><p>Vector Commitment</p>

<p>Generate Merkle root for data leaves.</p>

<p>\(Comm_D = VC(D_1 || D_2 || ‚Ä¶ || D_N)\), where \(D_i = e_i^{(0)}\).</p>

<p>This example: \(Comm_D = VC(e_1^{(0)}, e_2^{(0)}, e_3^{(0)}, e_4^{(0)}, e_5^{(0)}, e_6^{(0)}, e_7^{(0)}, e_8^{(0)})\).</p></li>

<li><p>Opening</p>

<p>To open \(D_i\), provide a merkle proof \(D_i \rightarrow Comm_D\).</p></li>
</ul>

<h6 id="sdr-replica-columns">SDR Replica Columns</h6>

<ul>
<li><p>Columns</p>

<table>
<thead>
<tr>
<th><code>~~~~</code></th>
<th>DRG Parents</th>
<th><code>~~~~</code></th>
<th>Expander Parents</th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th>Challenges</th>
<th><code>~~~~</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>\((1, 1)\)</td>
<td>\((1, 2)\)</td>
<td>\((1, 3)\)</td>
<td>\((1, 4)^{*}\)</td>
<td>\((1, 5)\)</td>
<td>\((1, 6)\)</td>
<td>\((1, 7)\)</td>
<td>\((1, 8)\)</td>
</tr>

<tr>
<td>\((2, 1)\)</td>
<td>\((2, 2)\)</td>
<td>\((2, 3)\)</td>
<td>\((2, 4)\)</td>
<td>\((2, 5)\)</td>
<td>\((2, 6)\)</td>
<td>\((2, 7)\)</td>
<td>\((2, 8)\)</td>
</tr>

<tr>
<td>\((3, 1)\)</td>
<td>\((3, 2)\)</td>
<td>\((3, 3)\)</td>
<td>\((3, 4)\)</td>
<td>\((3, 5)\)</td>
<td>\((3, 6)\)</td>
<td>\((3, 7)\)</td>
<td>\((3, 8)\)</td>
</tr>

<tr>
<td>\((4, 1)\)</td>
<td>\((4, 2)\)</td>
<td>\((4, 3)\)</td>
<td>\((4, 4)\)</td>
<td>\((4, 5)\)</td>
<td>\((4, 6)\)</td>
<td>\((4, 7)\)</td>
<td>\((4, 8)\)</td>
</tr>
</tbody>
</table>

<p>\(^{*}\) Indicates labels which must be hashed for column commitments but need not be opened for label checks.</p>

<p>Concatenate and hash rows of column \(i\) to construct \(O_i\).</p>

<p>Column hash \(C_i = H(e_i^{(1)} || e_i^{(2)} || ‚Ä¶ || e_i^{(L)})\).</p></li>

<li><p>Vector Commitment</p>

<p>Generate Merkle tree for column leaves, \(C_i\):</p>

<p>\(Comm_C = VC(C_1 || C_2 || ‚Ä¶ || C_N)\).</p></li>

<li><p>Opening</p>

<ul>
<li><p>To open labels for column \(i\):</p>

<ul>
<li>Reveal all labels and prove they hash to \(C_i\) as above. (\(L\) hash proofs).</li>
<li>Provide a merkle proof \(C_i \rightarrow Comm_C\).</li>
</ul></li>

<li><p>Then once, reusable for all columns,</p>

<ul>
<li>Reveal \(Comm_{R_{LAST}}\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_R\).</li>
</ul></li>
</ul></li>
</ul>

<h6 id="final-replica-layer">Final Replica Layer</h6>

<table>
<thead>
<tr>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th>Challenge</th>
<th><code>~~~~</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>\((5, 1)\)</td>
<td>\((5, 2)\)</td>
<td>\((5, 3)\)</td>
<td>\((5, 4)\)</td>
<td>\((5, 5)\)</td>
<td>\((5, 6)\)</td>
<td>\((5, 7)\)</td>
<td>\((5, 8)\)</td>
</tr>
</tbody>
</table>

<ul>
<li><p>Vector Commitment</p>

<p>Generate Merkle tree for replica leaves.</p>

<p>\(R_{LAST_i} = e_i^{(L+1)}\).</p>

<p>\(Comm_{R_{LAST}} = VC(R_{LAST_1} || R_{LAST_2} || ‚Ä¶ || R_{LAST_N})\).</p></li>

<li><p>Opening</p>

<ul>
<li><p>To open \(R_{LAST_i}\),</p>

<ul>
<li>Provide a merkle proof \(R_{LAST_i} \rightarrow Comm_{R_{LAST}}\).</li>
</ul></li>

<li><p>Then once (shared with Replica Columns ‚Äî see above):</p>

<ul>
<li>Reveal \(Comm_C\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_pR\).</li>
</ul></li>
</ul></li>
</ul>

<h6 id="replica-commitment">Replica Commitment</h6>

<ul>
<li><p>Commitment</p>

<ul>
<li><p>Produce \(Comm_R\) from its constituents.</p></li>

<li><p>\(Comm_R = H(Comm_C || Comm_{R_{LAST}})\).</p></li>
</ul></li>

<li><p>Opening (performed once per PoRep)</p>

<ul>
<li>Reveal \(Comm_C\) and \(Comm_{R_{LAST}}\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_R\).</li>
</ul></li>
</ul>

<h6 id="challenge-selection">Challenge Selection</h6>

<p>For each challenge \(\chi\), we challenge each node \(e_{\chi}^{(l)}\) for \(l = 1, 2, .. L\).</p>

<h6 id="opening-commitments-for-offline-proof">Opening Commitments for Offline Proof</h6>

<p>For use in all challenge proofs, reveal \(Comm_C\) and \(Comm_{R_{LAST}}\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) =
Comm_R\).</p>

<p>To prove encoding for a challenged label \(\chi\):</p>

<ul>
<li>Initial data layer openings

<ul>
<li>Open label for challenged data node \(e_\chi^{(0)} ‚Äî using Comm_D\).</li>
</ul></li>
<li>SDR replica column openings

<ul>
<li>Open all labels in \(C_\chi\) containing challenged label&rsquo;s &lsquo;replica node&rsquo;, (\(C_\chi\)) ‚Äî using \(Comm_C\).</li>
<li>Open all labels in the columns containing challenged label&rsquo;s DRG parents ‚Äî using \(Comm_C\).</li>
<li>Open all labels in the columns containing challenged label&rsquo;s expander parents ‚Äî using \(Comm_C\).</li>
</ul></li>

<li><p>Final replica layer openings</p>

<ul>
<li>Open all challenged labels (\(e_{\chi}^{(L+1)}\)) using \(Comm_{R_{LAST}}\).</li>
</ul></li>

<li><p>Prove labeling for all challenged labels $e{_&chi;}<sup>(l))</sup> for \(l = 1, 2, .. L\).</p></li>

<li><p>Prove encoding for all challenged nodes \(e{_\chi}^{(L+1))}\).</p></li>
</ul>

<h6 id="opening-commitments-for-online-proof">Opening Commitments for Online Proof</h6>

<p>To prove encoding for a challenged label \(C\) in the replica:</p>

<ul>
<li>Reveal \(Comm_C\) (which must have been stored along with the replica).</li>
<li>Open \(Comm_{R_{LAST}}\) from provided \(Comm_R\) by proving that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_R\).</li>
<li>Provide a merkle proof \(e_C^{(L)} \rightarrow Comm_{R_{LAST}}\).</li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="algorithms__porep__stacked_drg_circuit">

<h3 class="section-header">
  
</h3>

<div class="section-content">






































<h5 id="stacked-drg-offline-porep-circuit-spec">Stacked DRG: Offline PoRep Circuit Spec</h5>

<h6 id="stacked-drg-overview">Stacked DRG Overview</h6>

<p>Stacked DRG PoRep is based on layering DRG graphs <code>LAYERS</code> times. The data represented in each DRG layer is a labeling based on previously labeled nodes. The final labeled layer is the SDR key, and the &lsquo;final layer&rsquo; of replication the replica, an encoding of the original data using the generated key.</p>

<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details).</li>
<li><code>CommD</code> is the Merkle tree root hash of the input data to the first layer.</li>
<li><code>CommC</code> is the Merkle tree root hash of the SDR column commitments.</li>
<li><code>CommRLast</code> is the Merkle tree root hash of the replica.</li>
<li><code>CommR</code> is the on-chain commitment to the replica, dervied as the hash of the concatenation of <code>CommC</code> and <code>CommRLast</code>.</li>
</ul>

<p>The (offline) proof size in SDR is too large for blockchain usage (~3MB). We use SNARKs to generate a proof of knowledge of a correct SDR proof. In other words, we implement the SDR proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>

<p>This circuit proves that given a Merkle root <code>CommD</code>, <code>CommRLast</code>, and <code>commRStar</code>, that the prover knew the correct replicated data at each layer.</p>

<h6 id="spec-notation">Spec notation</h6>

<ul>
<li><strong>Fr</strong>: Field element of BLS12-381</li>
<li><strong>UInt</strong>: Unsigned integer</li>
<li><strong>{0..x}</strong>: From <code>0</code> (included) to <code>x</code> (not included) (e.g. <code>[0,x)</code> )</li>
<li><strong>Check</strong>:

<ul>
<li>If there is an equality, create a constraint</li>
<li>otherwise, execute the function</li>
</ul></li>
<li><strong>Inclusion path</strong>: Binary representation of the Merkle tree path that must be proven packed into a single <code>Fr</code> element.</li>
</ul>

<h4 id="offline-porep-circuit">Offline PoRep circuit</h4>

<h5 id="public-parameters">Public Parameters</h5>

<p><em>Parameters that are embeded in the circuits or used to generate the circuit</em></p>

<ul>
<li><code>LAYERS : UInt</code>: Number of DRG layers.</li>
<li><code>LAYER_CHALLENGES : [LAYERS]UInt</code>: Number of challenges per layer.</li>
<li><code>EXPANSION_DEGREE: UInt</code>: Degree of each bipartite expander graph to extend dependencies between layers.</li>
<li><code>BASE_DEGREE: UInt</code>: Degree of each Depth Robust Graph.</li>
<li><code>TREE_DEPTH: UInt</code>: Depth of the Merkle tree. Note, this is (log_2(Size of original data in bytes/32 bytes per leaf)).</li>
<li><code>PARENT_COUNT : UInt</code>: Defined as <code>EXPANSION_DEGREE+BASE_DEGREE</code>.</li>
</ul>

<h5 id="public-inputs">Public Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof and that the verifier uses to verify it</em></p>

<ul>
<li><code>ReplicaId : Fr</code>: A unique identifier for the replica.</li>
<li><code>CommD : Fr</code>: the Merkle tree root hash of the original data (input to the first layer).</li>
<li><code>CommR : Fr</code>: The Merkle tree root hash of the final replica (output of the last layer).</li>
<li><code>InclusionPath : [LAYERS][]Fr</code>: Inclusion path for the challenged data and replica leaf.</li>
<li><code>ParentInclusionPath : [LAYERS][][PARENT_COUNT]Fr</code>:  Inclusion path for the parents of the corresponding <code>InclusionPath[l][c]</code>.</li>
</ul>

<p>Design notes:</p>

<ul>
<li><code>CommRLast</code> is a private input used during during Proof-of-Spacetime.
To enable this, the prover must store <code>CommC</code> and use it to prove that <code>CommRLast</code> is included in <code>CommR</code> [TODO: define &lsquo;included&rsquo; language.]</li>
<li><code>InclusionPath</code> and <code>ParentInclusionPath</code>: Each layer <code>l</code> has <code>LAYER_CHALLENGES[l]</code> inclusion paths.</li>
</ul>

<h5 id="private-inputs">Private Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof, these are not needed by the verifier to verify the proof</em></p>

<ul>
<li><code>CommR : [LAYERS-1]Fr</code>: Commitment of the the encoded data at each layer.</li>
</ul>

<p>Note: Size is <code>LAYERS-1</code> since the commitment to the last layer is <code>CommRLast</code></p>

<ul>
<li><p><code>DataProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer unencoded challenged leaf.</p></li>

<li><p><code>ReplicaProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer encoded challenged leaves.</p></li>

<li><p><code>ParentProof : [LAYERS][][PARENT_COUNT][TREE_DEPTH]Fr</code>: Pedersen hashes of the Merkle inclusion proofs of the parent leaves for each challenged leaf at layer <code>l</code>.</p></li>

<li><p><code>DataValue : [LAYERS][]Fr</code>: Value of the unencoded challenged leaves at layer <code>l</code>.</p></li>

<li><p><code>ReplicaValue : [LAYERS][]Fr</code>: Value of the encoded leaves for each challenged leaf at layer <code>l</code>.</p></li>

<li><p><code>ParentValue : [LAYERS][][PARENT_COUNT]Fr</code>: Value of the parent leaves for each challenged leaf at layer <code>l</code>.</p></li>
</ul>

<h5 id="circuit">Circuit</h5>

<p>In high level, we do 4 checks:</p>

<ol>
<li><strong>ReplicaId Check</strong>: Check the binary representation of the ReplicaId</li>
<li><strong>Inclusion Proofs Checks</strong>: Check the inclusion proofs</li>
<li><strong>Encoding Checks</strong>: Check that the data has been correctly encoding into a replica</li>
<li><strong>CommRStar Check</strong>: Check that CommRStar has been generated correctly</li>
</ol>

<p>Detailed</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 1: ReplicaId Check - Check ReplicaId is equal to its bit representation
</span><span class="c1"></span><span class="nx">let</span> <span class="nx">ReplicaIdBits</span> <span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">ReplicaId</span><span class="p">)</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">replica_id_bits</span><span class="p">)</span> <span class="o">==</span> <span class="nx">ReplicaId</span><span class="p">)</span>

<span class="nx">let</span> <span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">ReplicaRoot</span> <span class="nx">Fr</span>

<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span> <span class="p">{</span>

  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommD</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommRLast</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS_CHALLENGES</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// 2: Inclusion Proofs Checks
</span><span class="c1"></span>    <span class="c1">// 2.1: Check inclusion proofs for data leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.2: Check inclusion proofs for replica leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.3: Check inclusion proofs for parent leaves are correct
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">ParentInclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">],</span> <span class="nx">ParentProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]))</span>
    <span class="p">}</span>

    <span class="c1">// 3: Encoding checks - Check that replica leaves have been correctly encoded
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">ParentBits</span> <span class="p">[</span><span class="nx">PARENT_COUNT</span><span class="p">][</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span>
    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="c1">// 3.1: Check that each ParentValue is equal to its bit representation
</span><span class="c1"></span>      <span class="nx">let</span> <span class="nx">parent</span> <span class="p">=</span> <span class="nx">ParentValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]</span>
      <span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">])</span> <span class="o">==</span> <span class="nx">parent</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 3.2: KDF check - Check that each key has generated correctly
</span><span class="c1"></span>    <span class="c1">// PreImage = ReplicaIdBits || ParentBits[1] .. ParentBits[PARENT_NODES]
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">PreImage</span> <span class="p">=</span> <span class="nx">ReplicaIdBits</span>
    <span class="k">for</span> <span class="nx">parentbits</span> <span class="nx">in</span> <span class="nx">ParentBits</span> <span class="p">{</span>
      <span class="nx">PreImage</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">parentbits</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">let</span> <span class="nx">key</span> <span class="nx">Fr</span> <span class="p">=</span> <span class="nf">SHA256</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span>
    <span class="nf">assert</span><span class="p">(</span><span class="nf">SHA256</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span><span class="p">)</span>

    <span class="c1">// 3.3: Check that the data has been encoded to a replica with the right key
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">==</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">+</span> <span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// 4: CommRStar check - Check that the CommRStar constructed correctly
</span><span class="c1"></span>  <span class="nx">let</span> <span class="nx">hash</span> <span class="p">=</span> <span class="nx">ReplicaId</span>
  <span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommRLast</span><span class="p">)</span>

  <span class="nf">assert</span><span class="p">(</span><span class="nx">CommRStar</span> <span class="o">==</span> <span class="nf">PedersenHash</span><span class="p">(</span><span class="nx">hash</span><span class="p">))</span>
  <span class="c1">// TODO check if we need to do packing/unpacking
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h5 id="verification-of-offline-porep-proof">Verification of offline porep proof</h5>

<ul>
<li>SNARK proof check: <strong>Check</strong> that given the SNARK proof and the public inputs, the SNARK verification outputs true</li>
<li>Parent checks: For each <code>leaf = InclusionPath[l][c]</code>:

<ul>
<li><strong>Check</strong> that all <code>ParentsInclusionPaths_[l][c][0..PARENT_COUNT}</code> are the correct parent leaves of <code>leaf</code> in the DRG graph, if a leaf has less than <code>PARENT_COUNT</code>, repeat the leaf with the highest label in the graph.</li>
<li><strong>Check</strong> that the parent leaves are in ascending numerical order.</li>
</ul></li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="algorithms__post">

<h2 class="section-header">
  Proof-of-Spacetime
</h2>

<div class="section-content">




































<p>See <a href="https://filecoin.io/filecoin.pdf">Filecoin Paper</a></p>


</div>


  
    








<div id="algorithms__post__rational_post">

<h3 class="section-header">
  Rational-PoSt
</h3>

<div class="section-content">






































<p>This document describes Rational-PoSt, the Proof-of-Spacetime used in Filecoin.</p>

<h4 id="high-level-api">High Level API</h4>

<h5 id="fault-detection">Fault Detection</h5>

<p>Fault detection happens over the course of the life time of a sector. When the sector is for some reason unavailable, the miner is responsible to submit the known <code>faults</code>, before the PoSt challenge begins. (Using the <code>AddFaults</code> message to the chain).
Only faults which have been reported at challenge time, will be accounted for. If any other faults have occured the miner can not submit a valid PoSt for this proving period.</p>

<p>The PoSt generation then takes the latest available <code>faults</code> of the miner to generate a PoSt matching the committed sectors and faults.</p>

<p>When a PoSt is successfully submitted all faults are reset and assumed to be recovered. A miner must either (1) resolve a faulty sector and accept challenges against it in the next proof submission, (2) report a sector faulty again if it persists but is eventually recoverable, (3) report a sector faulty <em>and done</em> if the fault cannot be recovered.</p>

<p>If the miner knows that the sectors are permanently lost, they can submit them as part of the <code>doneSet</code>, to ensure they are removed from the proving set.</p>

<div class="notices note" ><strong>Note</strong>: It is important that all faults are known (i.e submitted to the chain) prior to challenge generation, because otherwise it would be possible to know the challenge set, before the actual challenge time. This would allow a miner to report only faults on challenged sectors, with a gurantee that other faulty sectors would not be detected.</div>

<div class="notices todo" ><strong>TODO</strong>: The penalization for faults is not clear yet.</div>

<h5 id="fault-penalization">Fault Penalization</h5>

<p>Each reported fault carries a penality with it.</p>

<div class="notices todo" ><strong>TODO</strong>: Define the exact penality structure for this.</div>

<h5 id="generation">Generation</h5>

<p><code>GeneratePoSt</code> generates a <strong><em>Proof of Spacetime</em></strong> over all  <strong><em>sealed sectors</em></strong> of a single miner‚Äî identified by their <code>commR</code> commitments. This is accomplished by performing a series of merkle inclusion proofs (<strong><em>Proofs of Retrievability</em></strong>). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo-randomly, based on the provided <code>seed</code>. At each time step, a number of <strong><em>Proofs of Retrievability</em></strong> are performed.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Generate a new PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="nx">SectorSet</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">)</span> <span class="nx">PoStProof</span> <span class="p">{</span>
    <span class="c1">// Generate the Merkle Inclusion Proofs + Faults
</span><span class="c1"></span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nf">SortAsc</span><span class="p">(</span><span class="nf">GetSectorIds</span><span class="p">(</span><span class="nx">sectors</span><span class="p">)))</span>
    <span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="p">[]</span>
    <span class="nx">inclusionProofs</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">challenges</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">challenge</span> <span class="o">:=</span> <span class="nx">challenges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="c1">// Leaf index of the selected sector
</span><span class="c1"></span>        <span class="nx">inclusionProof</span><span class="p">,</span> <span class="nx">isFault</span> <span class="o">:=</span> <span class="nf">GenerateMerkleInclusionProof</span><span class="p">(</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Leaf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">isFault</span> <span class="p">{</span>
            <span class="c1">// faulty sector, need to post a fault to the chain and try to recover from it
</span><span class="c1"></span>            <span class="k">return</span> <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Detected late fault&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">inclusionProofs</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">inclusionProof</span>
        <span class="nx">challengedSectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectors</span><span class="p">[</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">// Generate the snark
</span><span class="c1"></span>    <span class="nx">snarkProof</span> <span class="o">:=</span> <span class="nf">GeneratePoStSnark</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">challenges</span><span class="p">,</span> <span class="nx">challengedSectors</span><span class="p">,</span> <span class="nx">inclusionProofs</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">snarkProof</span>
<span class="p">}</span></code></pre></div>
<h5 id="verification">Verification</h5>

<p><code>VerifyPoSt</code> is the functional counterpart to <code>GeneratePoSt</code>. It takes all of <code>GeneratePoSt</code>&rsquo;s output, along with those of <code>GeneratePost</code>&rsquo;s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Verify a PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">VerifyPoSt</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="nx">SectorSet</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">PoStProof</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nf">SortAsc</span><span class="p">(</span><span class="nf">GetSectorIds</span><span class="p">(</span><span class="nx">sectors</span><span class="p">)))</span>
    <span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="c1">// Match up commitments with challenges
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">challenges</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">challengedSectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectors</span><span class="p">[</span><span class="nx">challenges</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Sector</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">// Verify snark
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">VerifyPoStSnark</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">challenges</span><span class="p">,</span> <span class="nx">challengedSectors</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h5 id="types">Types</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The random challenge seed, provided by the chain.
</span><span class="c1"></span><span class="nx">Seed</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Challenge</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Sector</span> <span class="nx">SectorID</span>
    <span class="nx">Leaf</span> <span class="nx">Uint</span>
<span class="p">}</span></code></pre></div>
<h5 id="challenge-derivation">Challenge Derivation</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Derive the full set of challenges for PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sortedSectors</span> <span class="p">[]</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">[</span><span class="nx">POST_CHALLENGES_COUNT</span><span class="p">]</span><span class="nx">Challenge</span> <span class="p">{</span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">POST_CHALLENGES_COUNT</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">attemptedSectors</span> <span class="o">:=</span> <span class="p">{</span><span class="nx">SectorID</span><span class="p">:</span><span class="kt">bool</span><span class="p">}</span>
        <span class="nx">while</span> <span class="nx">challenges</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">challenge</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenge</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">attempt</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">sortedSectors</span><span class="p">)</span>

            <span class="c1">// check if we landed in a faulty sector
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">faults</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Valid challenge
</span><span class="c1"></span>                <span class="nx">challenges</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">challenge</span>
            <span class="p">}</span>

            <span class="c1">// invalid challenge, regenerate
</span><span class="c1"></span>            <span class="nx">attemptedSectors</span><span class="p">[</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">attemptedSectors</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sortedSectors</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;All sectors are faulty&#34;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">challenges</span>
<span class="p">}</span>

<span class="c1">// Derive a single challenge for PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DerivePoStChallenge</span><span class="p">(</span><span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">n</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">attempt</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sortedSectors</span> <span class="p">[]</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">Challenge</span> <span class="p">{</span>
    <span class="nx">nBytes</span> <span class="o">:=</span> <span class="nf">WriteUintToLittleEndian</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="nf">concat</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">nBytes</span><span class="p">,</span> <span class="nf">WriteUintToLittleEndian</span><span class="p">(</span><span class="nx">attempt</span><span class="p">))</span>
    <span class="nx">challengeBytes</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="nx">sectorChallenge</span> <span class="o">:=</span> <span class="nf">ReadUintLittleEndian</span><span class="p">(</span><span class="nx">challengeBytes</span><span class="p">[</span><span class="mf">0..8</span><span class="p">])</span>
    <span class="nx">leafChallenge</span> <span class="o">:=</span> <span class="nf">ReadUintLittleEndian</span><span class="p">(</span><span class="nx">challengeBytes</span><span class="p">[</span><span class="mf">8..16</span><span class="p">])</span>

    <span class="nx">sectorIdx</span> <span class="o">:=</span> <span class="nx">sectorChallenge</span> <span class="o">%</span> <span class="nx">sectorCount</span>

    <span class="k">return</span> <span class="nx">Challenge</span> <span class="p">{</span>
        <span class="nx">Sector</span><span class="p">:</span> <span class="nx">sortedSectors</span><span class="p">[</span><span class="nx">sectorIdx</span><span class="p">],</span>
        <span class="nx">Leaf</span><span class="p">:</span> <span class="nx">leafChallenge</span> <span class="o">%</span> <span class="p">(</span><span class="nx">sectorSize</span> <span class="o">/</span> <span class="nx">NODE_SIZE</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="post-circuit">PoSt Circuit</h4>

<h5 id="public-parameters">Public Parameters</h5>

<p><em>Parameters that are embeded in the circuits or used to generate the circuit</em></p>

<ul>
<li><code>POST_CHALLENGES_COUNT: UInt</code>: Number of challenges.</li>
<li><code>POST_TREE_DEPTH: UInt</code>: Depth of the Merkle tree. Note, this is <code>(log_2(Size of original data in bytes/32 bytes per leaf))</code>.</li>
<li><code>SECTOR_SIZE: UInt</code>: The size of a single sector in bytes.</li>
</ul>

<h5 id="public-inputs">Public Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof and that the verifier uses to verify it</em></p>

<ul>
<li><code>CommRs: [POST_CHALLENGES_COUNT]Fr</code>: The Merkle tree root hashes of all replicas, ordered to match the inclusion paths and challenge order.</li>
<li><code>InclusionPaths: [POST_CHALLENGES_COUNT]Fr</code>: Inclusion paths for the replica leafs, ordered to match the <code>CommRs</code> and challenge order. (Binary packed bools)</li>
</ul>

<h5 id="private-inputs">Private Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof, these are not needed by the verifier to verify the proof</em></p>

<ul>
<li><code>InclusionProofs: [POST_CHALLENGES_COUNT][TREE_DEPTH]Fr</code>: Merkle tree inclusion proofs, ordered to match the challenge order.</li>
<li><code>InclusionValues: [POST_CHALLENGES_COUNT]Fr</code>: Value of the encoded leaves for each challenge, ordered to match challenge order.</li>
</ul>

<h5 id="circuit">Circuit</h5>

<h6 id="high-level">High Level</h6>

<p>In high level, we do 1 check:</p>

<ol>
<li><strong>Inclusion Proofs Checks</strong>: Check the inclusion proofs</li>
</ol>

<h6 id="details">Details</h6>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">POST_CHALLENGES_COUNT</span> <span class="p">{</span>
  <span class="c1">// Inclusion Proofs Checks
</span><span class="c1"></span>  <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">CommRs</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionProof</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionValue</span><span class="p">[</span><span class="nx">c</span><span class="p">]))</span>
<span class="p">}</span></code></pre></div>
<h5 id="verification-of-post-proof">Verification of PoSt proof</h5>

<ul>
<li>SNARK proof check: <strong>Check</strong> that given the SNARK proof and the public inputs, the SNARK verification outputs true</li>
</ul>


</div>



</div>

  

  
    








<div id="algorithms__post__proof_of_spacetime_parameters">

<h3 class="section-header">
  PoSt Parameters
</h3>

<div class="section-content">




































<p>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>POST-CHALLENGE-BLOCKS</td>
<td>BLOCKS</td>
<td>480</td>
<td>The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.</td>
</tr>

<tr>
<td>POST-CHALLENGE-HOURS</td>
<td>HOURS</td>
<td>2</td>
<td>PoSt challenge time (see POST_CHALLENGE_BLOCKS).</td>
</tr>

<tr>
<td>POST-PROVING-PERIOD</td>
<td>BLOCKS</td>
<td>5760</td>
<td>The time interval in which a PoSt has to be submitted</td>
</tr>
</tbody>
</table>

<div class="notices todo" ><strong>TODO</strong>: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</div>


</div>



</div>

  


</div>

  

  
    








<div id="algorithms__payment_channels">

<h2 class="section-header">
  Payment Channels
</h2>

<div class="section-content">






































<h3 id="payment-channels">Payment Channels</h3>

<p>In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.</p>

<p>The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&rdquo;. Once that money is locked up, user A can send user B signed transactions that user B can cash out at any time.</p>

<p>For example:</p>

<ul>
<li>User A locks up 10 FIL to B</li>
<li>User B does something for A</li>
<li>User A sends <code>SignedVoucher{Channel, 1 FIL}</code> to B</li>
<li>User B does something for user A</li>
<li>User A sends <code>SignedVoucher{Channel, 2 FIL}</code> to B</li>
</ul>

<p>At this point, B has two signed messages from A, but the contract is set up such that it can only be cashed out once. So if B decided to cash out, they would obviously select the message with the higher value. Also, once B cashes out, they must not accept any more payments from A on that same channel.</p>

<h4 id="multi-lane-payment-channel">Multi-Lane Payment Channel</h4>

<p>The filecoin storage market may require a way to do incremental payments between two parties, over time, for multiple different transactions. The primary motivating usecase for this is to provide payment for file storage over time, for each file stored. An additional requirement is the ability to have less than one message on chain per transaction &lsquo;lane&rsquo;, meaning that payments for multiple files should be aggregateable (Note: its okay if this aggregation is an interactive process).</p>

<p>Let&rsquo;s say that <code>A</code> wants to make such an arrangement with <code>B</code>. <code>A</code> should create the payment channel with enough funds to cover all potential transactions. Then <code>A</code> decides to start the first transaction, so they send a signed voucher for the payment channel on &lsquo;lane 1&rsquo;, for 2 FIL. They can then send more updates on lane 1 as needed. Then, at some point <code>A</code> decides to start another independent transaction to <code>B</code>, so they send a voucher on &lsquo;lane 2&rsquo;. The voucher for lane 2 can be cashed out independently of lane 1. However, <code>B</code> can ask <code>A</code> to &lsquo;reconcile&rsquo; the two payment channels for them into a single update. This update could contain a value, and a list of lanes to close. Cashing out that reconciled update would invalidate the other lanes, meaning <code>B</code> couldnt also cash in those. The single update would be much smaller, and therefore cheaper to close out.</p>

<p>Lane state can be easily tracked on-chain with a compact bitfield.</p>

<h4 id="payment-channel-reconciliation">Payment Channel Reconciliation</h4>

<p>In a situation where peers A and B  have several different payment channels between them, the scenario may frequently come up where A has multiple payment channel updates from B to apply. Submitting each of these individually would cost a noticeable amount in fees, and put excess unnecessary load on the chain. To remedy this, A can contact B and ask them for a single payment channel update for the combined value of all the updates they have (minus some fee to incent B to actually want to do this). This aggregated update would contain a list of the IDs of the other payment channels that it is superceding so that A cannot also cash out on the originals.</p>

<h3 id="payment-reconciliation">Payment Reconciliation</h3>

<p>The filecoin storage market will (likely) have many independent payments between the same parties. These payments will be secured through payment channels, set up initially on chain, but utilized almost entirely off-chain. The point at which they need to touch the chain is when miners wish to cash out their earnings. A naive solution to this problem would have miners perform one on-chain action per file stored for a particular client. This would not scale well. Instead, we need a system where the miner and client can have some additional off-chain communication and end up with the miner submitting only a single message to the chain.</p>

<p>To accomplish this, we introduce the Payment Reconciliation Protocol.</p>

<p>This is a libp2p service run by all participants wanting to participate in payment reconciliation. When Alice has a set of payments from Bob that she is ready to cash out, Alice can send a <code>ReconcileRequest</code> to Bob, containing the following information:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileRequest struct <span class="o">{</span>
	vouchers <span class="o">[</span>Vouchers<span class="o">]</span>
	reqVal TokenAmount
<span class="o">}</span></code></pre></div>
<p>The Vouchers should all be valid vouchers from Bob to Alice, on the same payment channel, and they should all be ready to be cashed in. <code>ReqVal</code> is a token amount less than or equal to the sum of all the values in the given vouchers. Generally, this value will be between the total sum of the vouchers, and that total sum minus the fees it would cost to submit them all to the chain.</p>

<p>Bob receives this request, and checks that all the fields are correct, and then ensures that the difference between ReqVal and the vouchers sum is sufficient (this is a parameter that the client can set).  Then, he sends back a response which either contains the requested voucher, or an error status and message.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileResponse struct <span class="o">{</span>
	combined Voucher
	status  Status
	message optional String
<span class="o">}</span>

<span class="c1">## TODO: what are the possible status cases?</span>
<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="p">|</span> Success
    <span class="p">|</span> Failure
<span class="o">}</span></code></pre></div>
<p>Open Questions:</p>

<ul>
<li>In a number of usecases, this protocol will require the miner look up and connect to a client to propose reconciliation. How does a miner look up and connect to a client over libp2p given only their filecoin address?</li>
<li>Without repair miners, this protocol will likely not be used that much. Should that be made clear? Should there be other considerations added to compensate?</li>
</ul>


</div>



</div>

  

  
    








<div id="algorithms__block_sync">

<h2 class="section-header">
  BlockSync
</h2>

<div class="section-content">






































<ul>
<li><strong>Name</strong>: Block Sync</li>
<li><strong>Protocol ID</strong>: <code>/fil/sync/blk/0.0.1</code></li>
</ul>

<p>The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol.</p>

<p>The request requests a chain of a given length by the hash of its highest block. The <code>Options</code> allow the requester to specify whether or not blocks and messages to be included.</p>

<p>The response contains the requested chain in reverse iteration order. Each item in the <code>Chain</code> array contains the blocks for that tipset if the <code>Blocks</code> option bit in the request was set, and if the <code>Messages</code> bit was set, the messages across all blocks in that tipset. The <code>MsgIncludes</code> array contains one array of integers for each block in the <code>Blocks</code> array. Each of the arrays in <code>MsgIncludes</code> contains a list of indexes of messages from the <code>Messages</code> array that are in each <code>Block</code> in the blocks array.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BlockSyncRequest struct <span class="o">{</span>
    <span class="c1">## The TipSet being synced from</span>
	start <span class="o">[</span><span class="p">&amp;</span>Block<span class="o">]</span>
    <span class="c1">## How many tipsets to sync</span>
	requestLength UInt
    <span class="c1">## Query options</span>
    options Options
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Options enum <span class="o">{</span>
    <span class="c1"># Include only blocks</span>
    <span class="p">|</span> Blocks <span class="m">0</span>
    <span class="c1"># Include only messages</span>
    <span class="p">|</span> Messages <span class="m">1</span>
    <span class="c1"># Include messages and blocks</span>
    <span class="p">|</span> BlocksAndMessages <span class="m">2</span>
<span class="o">}</span>

<span class="nb">type</span> BlockSyncResponse struct <span class="o">{</span>
	chain <span class="o">[</span>TipSetBundle<span class="o">]</span>
	status Status
<span class="o">}</span>

<span class="nb">type</span> TipSetBundle struct <span class="o">{</span>
  blocks <span class="o">[</span>Blocks<span class="o">]</span>
  secpMsgs <span class="o">[</span>SignedMessage<span class="o">]</span>
  secpMsgIncludes <span class="o">[[</span>UInt<span class="o">]]</span>

  blsMsgs <span class="o">[</span>Message<span class="o">]</span>
  blsMsgIncludes <span class="o">[[</span>Uint<span class="o">]]</span>
<span class="o">}</span>

<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="c1">## All is well.</span>
    <span class="p">|</span> Success <span class="m">0</span>
    <span class="c1">## Sent back fewer blocks than requested.</span>
    <span class="p">|</span> PartialResponse <span class="m">101</span>
    <span class="c1">## Request.Start not found.</span>
    <span class="p">|</span> BlockNotFound <span class="m">201</span>
    <span class="c1">## Requester is making too many requests.</span>
    <span class="p">|</span> GoAway <span class="m">202</span>
    <span class="c1">## Internal error occured.</span>
    <span class="p">|</span> InternalError <span class="m">203</span>
    <span class="c1">## Request was bad</span>
    <span class="p">|</span> BadRequest <span class="m">204</span>
<span class="o">}</span></code></pre></div>
<h4 id="example">Example</h4>

<p>The TipSetBundle</p>

<pre><code>Blocks: [b0, b1]
secpMsgs: [mA, mB, mC, mD]
secpMsgIncludes: [[0, 1, 3], [1, 2, 0]]
</code></pre>

<p>corresponds to:</p>

<pre><code>Block 'b0': [mA, mB, mD]
Block 'b1': [mB, mC, mA]
</code></pre>


</div>



</div>

  

  
    








<div id="algorithms__gossip_sub">

<h2 class="section-header">
  GossipSub
</h2>

<div class="section-content">






































<div id="algorithms__gossip_sub__gossip_sub"></div>

<p>Messages and block headers along side the message references are propagated using the <a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">gossipsub libp2p pubsub router</a>. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be <a href="./validation.md#syntactical-validation">syntactically validated</a> before being propagated further.</p>

<p>Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it. This allows any node to fetch missing pieces (e.g. <code>Message</code>) from any node it is connected to. However, the node should fan out these requests to multiple nodes and not bombard any single node with too many requests at a time. A node may implement throttling and DDoS protection to prevent such a bombardment.</p>

<h3 id="bitswap">Bitswap</h3>

<p>Run bitswap to fetch and serve data (such as blockdata and messages) to and from other filecoin nodes. This is used to fill in missing bits during block propagation, and also to fetch data during sync.</p>

<p>There is not yet an official spec for bitswap, but <a href="https://github.com/ipfs/go-bitswap/blob/master/message/pb/message.proto">the protobufs</a> should help in the interim.</p>


</div>



</div>

  

  
    








<div id="algorithms__crypto">

<h2 class="section-header">
  Cryptographic Primitives
</h2>

<div class="section-content">




































<ul>
<li>Merkle tree/DAG</li>
<li>Vector commitment scheme</li>
<li>zkSNARK</li>
<li>Verifiable random function (VRF)</li>

<li><p>Reliable broadcast channel (libp2p)</p></li>

<li><div class="notices todo">
<strong>TODO</strong>:  Add more detail and include references to relevant papers. 
</div></li>
</ul>


</div>


  
    








<div id="algorithms__crypto__signatures">

<h3 class="section-header">
  Signatures
</h3>

<div class="section-content">






































<p>Signatures are cryptographic functions that attest to the origin of a particular
message. In the context of Filecoin, signatures are used to send and receive
messages with the assurance that each message was generated by a specific
entity. In other words, it is infeasible for an entity i to
generate a signed message that appears to have been generated by j, with j != i.</p>

<p>Filecoin uses signatures to associate an action to a given party. For
example, Filecoin uses signatures in order to validate deal messages which represent an
action like a storage deal.
Filecoin uses signatures to verify the authenticity of the following objects (non
exhaustive list):
- Messages: Users authenticate their transactions to the blockchain.
- Tickets: Miner authenticates its ticket (see <a href="mining.md">mining</a>).
- Blocks: Block leader signs over all data in the block.</p>

<h5 id="messages">Messages</h5>

<p>To generate a signature for the <a href="data-structures.md#message"><code>Message</code></a> type,
first serialize it, then hash the serialized bytes with blake2b-256. Then, take
the 32 byte digest output the hash and compute the signature over it.
<strong>Note</strong>: for each specific use of a signature scheme, it is recommended to use
a domain separation tag to treat the hash function as an independent random
oracle. These tags are indicated in the relevant places throughout the specs.</p>

<h5 id="signature-types">Signature Types</h5>

<p>Filecoin currently uses two types of signatures:
- ECDSA signatures over the Secp256k1 elliptic curve to authenticate user
  transactions, mainly for compatibility with external blockchain systems.
- BLS signatures over the BLS12-381 group of curves</p>

<p>Both signature types fulfill the <code>Signature</code> interface
and each type have additional functionality as explained below.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Message</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">SecretKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">PublicKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">SignatureBytes</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">SigKeyPair</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PublicKey</span>
    <span class="nx">SecretKey</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Sig</span>   <span class="nx">SignatureBytes</span>  <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>
    <span class="nx">Type</span>  <span class="nx">SigType</span>         <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SigType</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">BLSSigType</span>
    <span class="nx">ECDSASigType</span>
<span class="p">}</span>
</code></pre></div>






<h6 id="ecdsa-signatures">ECDSA Signatures</h6>

<p>Filecoin uses the ECDSA signature algorithm over the secp256k1 curve to
authenticate the blockchain transactions. The main reason is to be able to
validate transactions from other blockchain systems that uses secp256k1 (such as
Bitcoin or exchanges in general). ECDSA signatures offer an additional
useful functionality as well: to recover the public key from a given signature.
That feature can allow to save space on the blockchain by extracting the public
key locally from the signature rather than specify an ID of the public key.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ECDSA implements the Signature interface using the ECDSA algorithm with
</span><span class="c1">// the Secp256k1 elliptic curve.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ECDSA</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The Signature object is the one returned from SigKeyPair.Sign(). It can
</span><span class="c1"></span>    <span class="c1">// be casted to ECDSA to get the additional functionality described below.
</span><span class="c1"></span>    <span class="nx">Signature</span>

    <span class="c1">// Recover recovers a public key associated with a particular signature.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Out:
</span><span class="c1"></span>    <span class="c1">//    pk - the public key associated with `M` who signed `m`
</span><span class="c1"></span>    <span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>    <span class="c1">//    **
</span><span class="c1"></span>    <span class="c1">// In:
</span><span class="c1"></span>    <span class="c1">//    m - a series of bytes representing the signed message
</span><span class="c1"></span>    <span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="nf">Recover</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Message</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>






<p><strong>Wire Format</strong>: Filecoin uses the standard secp256k1 signature serialization,
as described below. For more details on how the Filecoin <code>Signature</code> type is
serialized, see the relevant section in <a href="data-structures.md#signature">the data structures
spec</a></p>

<pre><code>SignatureBytes = [0x30][len][0x02][r][indicator][s][indicator][recovery]
</code></pre>

<p><code>s</code> = Scalar of size 32 bytes</p>

<p><code>r</code> = Compressed elliptic curve point (x-coordinate) of size 32 bytes</p>

<p><code>recovery</code> = Information needed to recover a public key from <code>sig</code>.</p>

<ul>
<li>LSB(0) = parity of y-coordinate of r</li>
<li>LSB(1) = overflow indicator</li>
</ul>

<p><code>indicator</code> = a 2 byte formatting indicator</p>

<p><strong>External References</strong>: <a href="http://www.secg.org/sec1-v2.pdf">Elliptic Curve Cryptography Paper</a></p>

<h6 id="bls-signatures">BLS Signatures</h6>

<p>Filecoin uses the <a href="https://datatracker.ietf.org/doc/draft-boneh-bls-signature/">BLS signature scheme</a> over the <a href="BLS12-381](https://electriccoin.co/blog/new-snark-curve/) group of elliptic curves. You can find the default Rust implementation in [Filecoin's repo](https://github.com/filecoin-project/bls-signatures/">BLS12-381</a>.</p>

<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BLS implements the Signature interface using the BLS signature scheme
</span><span class="c1">// with the BLS12-381 group of elliptic curves.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BLS</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// This signature is the one returned from SigKeyPair.Sign(). It can be
</span><span class="c1"></span>    <span class="c1">// casted to a BLS signature struct to get the additional functionalities.
</span><span class="c1"></span>    <span class="nx">Signature</span>

    <span class="c1">// This represents the largest potential value for a BLS signature in Bytes
</span><span class="c1"></span>    <span class="nf">MaxSigValue</span><span class="p">()</span> <span class="nx">Bytes</span>

    <span class="c1">// Aggregates this BLS signature and `sig` into one BLS signature that can
</span><span class="c1"></span>    <span class="c1">// be verified against the aggregation of the two public key that signed
</span><span class="c1"></span>    <span class="c1">// the aggregated signatures.
</span><span class="c1"></span>    <span class="nf">Aggregate</span><span class="p">(</span><span class="nx">sig2</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="nx">SignatureBytes</span>

    <span class="c1">// VerifyAggregate verifies the aggregate signature with the aggregate
</span><span class="c1"></span>    <span class="c1">// public key over all the distinct messages given. Note that if all
</span><span class="c1"></span>    <span class="c1">// messages are the same, it is sufficient and correct to only call
</span><span class="c1"></span>    <span class="c1">// `Verify` since it is a subset of `VerifyAggregate`.
</span><span class="c1"></span>    <span class="nf">VerifyAggregate</span><span class="p">(</span><span class="nx">messages</span> <span class="p">[</span><span class="nx">Message</span><span class="p">],</span> <span class="nx">aggPk</span> <span class="nx">BLSPublicKey</span><span class="p">,</span> <span class="nx">aggSig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// BLSPublicKey is a PublicKey with an addition method to aggregate public keys
</span><span class="c1">// together.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BLSPublicKey</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PublicKey</span>

    <span class="c1">// Aggregate this public key with p2 into one public key. This aggregated
</span><span class="c1"></span>    <span class="c1">// public key can 
</span><span class="c1"></span>    <span class="c1">// - verify aggregated signatures signed by the two BLSPublicKey
</span><span class="c1"></span>    <span class="c1">// - be aggregated further down with other (aggregated or not) BLSPublicKey.
</span><span class="c1"></span>    <span class="nf">Aggregate</span><span class="p">(</span><span class="nx">p2</span> <span class="nx">BLSPublicKey</span><span class="p">)</span> <span class="nx">BLSPublicKey</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">crypto</span>

<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// blsPk := pk.(*BLSPublicKey)
</span><span class="c1"></span>	<span class="c1">// 1. Verify public key according to string_to_curve section 2.6.2.1. in
</span><span class="c1"></span>	<span class="c1">// 	https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-12
</span><span class="c1"></span>	<span class="c1">// 2. Verify signature according to section 2.3
</span><span class="c1"></span>	<span class="c1">// 	https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-8
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bls.Verify TODO&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">MaxSigValue</span><span class="p">()</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">Sign</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">sk</span> <span class="o">*</span><span class="nx">SecretKey</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;see 2.3 in https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-8&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">Aggregate</span><span class="p">(</span><span class="nx">sig2</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;see 2.5 in https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-8&#34;</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">ret</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">VerifyAggregate</span><span class="p">(</span><span class="nx">messages</span> <span class="p">[]</span><span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">aggPk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">aggSig</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;see 2.5.2 in https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-9&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div>




</p>

<p><strong>Choice of group</strong>: The BLS signature requires the use of a pairing-equipped
curve which generally yield three groups: G_1, G_2 and G_T. In the BLS signature
scheme, there is a choice on which group to define the public key and the
signature:
- Public key is on G_1 and signature on G_2
- Public key is on G_2 and signature on G_1
The group G_1 is &ldquo;smaller&rdquo; and hence offer faster arithmetic operations and
smaller byte representation of its elements. Filecoin currently uses the group
<strong>G_1 for representing public keys</strong> and the group <strong>G_2 for representing
signatures</strong>.</p>

<p><strong>Wire Format</strong>: Filecoin uses the standard way to serialize BLS signatures as
explained in the <a href="https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.6.1">RFC Section
2.6.1</a>.</p>

<p><strong>Rationale</strong>:
BLS signatures have two main characteristics that are making them ideal
candidates in recent blockchain systems:
- BLS signatures are deterministic: for a given message and a given secret key,
  the signature is always the same.  That feature removes an important security
  weakness of most randomized signature schemes: signer must never re-use the
  same randomness twice otherwise this reveals its private key. As well,
  deterministic signature are ideal candidate to reduce the attack surface in
  terms of grinding, which is a real concern in recent proof of stake systems.
- BLS signatures are aggregatable: one can aggregate signatures from different
  signers into one single signature. That feature allows to drastically save
  space on the blockchain, especially when aggregating user transactions.</p>

<p><strong>Aggregation Functionality</strong>: The aggregation functionality is commutative and
associative, enabling to perform <em>partial</em> aggregation. For example, given
<code>(PK1, sig1), (PK2, sig2), (PK3, sig3)</code>, one can first aggregate <code>(PK12 = PK1 +
PK2, sig12 = sig1 + sig2)</code> then aggregate with the third tuple to produce
<code>(PK123 = PK12 + PK3, sig123 = sig12 + sig3)</code>.</p>

<p><strong>Aggregation Security</strong>: The naive BLS signature aggregation scheme is
vulnerable to rogue-key attacks where the attacker can freely choose its public
key. To prevent against this class of attacks there exists three different kind
of measures, as explained <a href="https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html">here</a>:
- Enforce distinct messages
- Prove knowledge of the secret key
- Use a modified scheme (such as <a href="https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html">BLS Multi Sig</a>)</p>

<p>Fortunately, Filecoin can enforce the second condition to safely use the
aggregation property:
Filecoin uses aggregation only for aggregating the transaction&rsquo;s signature of a
block. since Filecoin uses the account model to represent the state of the
chain, each message for a given signer is used in combination of a nonce to
avoid replay attacks. As a direct consequence, every transaction&rsquo;s message is
unique thereby the aggregation is done on distinct messages.  Obviously, the
<strong>assumption</strong> here is that the block producer <strong>enforces that distinction</strong> and
the other miners will <strong>check every transactions</strong> to make sure they are valid.
The validity of a transaction in Filecoin&rsquo;s context implies that the signature
is correctly formed over the message with the correct nonce.</p>


</div>



</div>

  

  
    








<div id="algorithms__crypto__vrf">

<h3 class="section-header">
  Verifiable Random Function
</h3>

<div class="section-content">




































<div id="algorithms__crypto__vrf__vrf"></div>

<p>Filecoin uses the notion of a <a href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Pseudo%20Randomness/Verifiable_Random_Functions.pdf">Verifiable Random
Function</a>
(VRF). A VRF uses a private key to produce a digest of
an arbitrary message such that the output is unique per signer and per message.
Any third party in possession of the corresponding public key, the message and
the VRF output can verify if the digest has been computed correctly and from the
correct signer. Using a VRF in the ticket generation process allows anyone to
verify if a block comes from an eligible block producer (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Ticket Generation</a> for more details).</p>

<p>BLS signature can be used as the basis to construct a VRF. Filecoin transforms
the BLS signature scheme it uses (see <a href="./#algorithms__crypto__signatures">Signatures</a> into a
VRF, Filecoin uses the random oracle model and deterministically hash the
signature to produce the final digest. Filecoin uses
<a href="https://blake2.net/">Blake2b-256</a> (Blake2b with an output size of 256 bits) as
the hash function. The algorithm is the following:</p>

<pre><code>VRFOutput = Blake2b-256(DST || BLSSignature(message))
</code></pre>

<p>where <code>DST</code> is a domain separation tag in order to treat the hash
function as an independent random oracle in the VRF output. The tag for VRF is
set to</p>

<pre><code>DST = &quot;VRF&quot; // encoded as an ASCII string
</code></pre>

<p><strong>Note</strong>: The message given to the BLS signature scheme for using it in the VRF
context should also contain a domain separation tag. The relevant separation tag
are mentionned in the relevant places throughout the specs.</p>

<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">VRFPublicKey</span> <span class="nx">PublicKey</span>
<span class="kd">type</span> <span class="nx">VRFSecretKey</span> <span class="nx">SecretKey</span>

<span class="c1">// VRFKeyPair holds the private key and respectively the public key to create 
</span><span class="c1">// and respectively verify a VRF output.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VRFKeyPair</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">VRFPublicKey</span>
    <span class="nx">VRFSecretKey</span>

    <span class="c1">// Generate a VRF from the given input with the SecretKey that can be
</span><span class="c1"></span>    <span class="c1">// verified with the PublicKey
</span><span class="c1"></span>    <span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">VRFResult</span> <span class="err">@</span><span class="p">(</span><span class="nx">static</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">VRFResult</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Output</span>            <span class="nx">Bytes</span>  <span class="c1">// @(internal)
</span><span class="c1"></span>    <span class="nf">MaxValue</span><span class="p">()</span>        <span class="nx">Bytes</span>
    <span class="nf">ValidateSyntax</span><span class="p">()</span>  <span class="kt">bool</span>

    <span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">crypto</span>

<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFResult_I</span><span class="p">)</span> <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFResult_I</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// return new(BLS).Verify(self.Output, pk.(*BLSPublicKey), input)
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFResult_I</span><span class="p">)</span> <span class="nf">MaxValue</span><span class="p">()</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// return new(BLS).MaxSigValue()
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFKeyPair_I</span><span class="p">)</span> <span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">VRFResult</span> <span class="p">{</span>
	<span class="c1">// sig := new(BLS).Sign(input, self.SecretKey)
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">blsSig</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">VRFResult_I</span><span class="p">{</span>
		<span class="nx">Output_</span><span class="p">:</span> <span class="nx">blsSig</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div>




</p>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="listings">

<h1 class="section-header">
  Listings
</h1>

<div class="section-content">






































</div>


  
    








<div id="listings__actors">

<h2 class="section-header">
  Filecoin VM Actors
</h2>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="listings__data_structures">

<h2 class="section-header">
  Data Structures
</h2>

<div class="section-content">






































<h3 id="address">Address</h3>

<p>An address is an identifier that refers to an actor in the Filecoin state. All <a href="actors.md">actors</a> (miner actors, the storage market actor, account actors) have an address. An address encodes information about:</p>

<ul>
<li>Network this address belongs to</li>
<li>Type of data the address contains</li>
<li>The data itself</li>
<li>Checksum (depending on the type of address)</li>
</ul>

<p>For more detail, see the full <a href="./#appendix__address">address spec</a>.</p>

<h3 id="block">Block</h3>

<p>A block header contains information relevant to a particular point in time over which the network may achieve consensus. The block header contains:</p>

<ul>
<li>The address of the miner that mined the block</li>
<li>A ticket associated to this block&rsquo;s creation to be used as randomness elsewhere in the protocol (see
<a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> for more details)</li>
<li>An electionProof showing this miner was eligible to mine</li>
<li>The set of parent blocks and aggregate <a href="./#algorithms__expected_consensus__chain_selection">chain weight</a> of the parents</li>
<li>This block&rsquo;s height</li>
<li>Merkle root of the state tree (after applying the messages &ndash; state transitions &ndash; included in this block)</li>
<li>Merkle root of the messages (state transitions) in this block</li>
<li>Merkle root of the message receipts in this block</li>
<li>Timestamp</li>
</ul>

<div class="notices note" ><strong>Note:</strong> A block is functionally the same as a block header in the Filecoin protocol. While a block header contains Merkle links to the full system state, messages, and message receipts, a block can be thought of as the full set of this information (not just the Merkle roots, but rather the full data of the state tree, message tree, receipts tree, etc.). Because a full block is quite large, our chain consists of block headers rather than full blocks. We often use the terms <code>block</code> and <code>block header</code> interchangeably.</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Miner is the address of the miner actor that mined this block.
</span><span class="c1"></span>    <span class="nx">miner</span> <span class="nx">Address</span>

    <span class="c1">// Tickets is a chain (possibly singleton) of tickets ending with a winning ticket
</span><span class="c1"></span>    <span class="c1">// submitted with this block.
</span><span class="c1"></span>    <span class="nx">tickets</span> <span class="p">[</span><span class="nx">Ticket</span><span class="p">]</span>

    <span class="c1">// ElectionProof is generated from a past ticket and proves this miner is a leader
</span><span class="c1"></span>    <span class="c1">// in this block&#39;s round.
</span><span class="c1"></span>    <span class="nx">electionProof</span> <span class="nx">ElectionProof</span>

    <span class="c1">// Parents is an array of distinct CIDs of parents on which this block was based.
</span><span class="c1"></span>    <span class="c1">// Typically one, but can be several in the case where there were multiple winning
</span><span class="c1"></span>    <span class="c1">// ticket-holders for a given round. The order of parent CIDs is not defined.
</span><span class="c1"></span>    <span class="nx">parents</span> <span class="p">[</span><span class="o">&amp;</span><span class="nx">Block</span><span class="p">]</span>

    <span class="c1">// ParentWeight is the aggregate chain weight of the parent set.
</span><span class="c1"></span>    <span class="nx">parentWeight</span> <span class="nx">UInt</span>

    <span class="c1">// Height is the chain height of this block.
</span><span class="c1"></span>    <span class="nx">height</span> <span class="nx">UInt</span>

    <span class="c1">// StateRoot is a CID pointer to the VM state tree after application of the state
</span><span class="c1"></span>    <span class="c1">// transitions corresponding to this block&#39;s messages.
</span><span class="c1"></span>    <span class="nx">stateRoot</span> <span class="o">&amp;</span><span class="nx">StateTree</span>

    <span class="c1">// Messages is the set of messages included in this block. This field is the CID
</span><span class="c1"></span>    <span class="c1">// of the TxMeta object that contains the bls and secpk signed message trees.
</span><span class="c1"></span>    <span class="nx">messages</span> <span class="o">&amp;</span><span class="nx">TxMeta</span>

    <span class="c1">// BLSAggregate is an aggregated BLS signature for all the messages in this block
</span><span class="c1"></span>    <span class="c1">// that were signed using BLS signatures.
</span><span class="c1"></span>    <span class="nx">blsAggregate</span> <span class="nx">Signature</span>

    <span class="c1">// MessageReceipts is a set of receipts matching to the sending of the `Messages`.
</span><span class="c1"></span>    <span class="c1">// This field is the CID of the root of a sharray of MessageReceipts.
</span><span class="c1"></span>    <span class="nx">messageReceipts</span> <span class="o">&amp;</span><span class="p">[</span><span class="nx">MessageReceipt</span><span class="p">]</span>

    <span class="c1">// The block Timestamp is used to enforce a form of block delay by honest miners.
</span><span class="c1"></span>    <span class="c1">// Unix time UTC timestamp (in seconds) stored as an unsigned integer.
</span><span class="c1"></span>    <span class="nx">timestamp</span> <span class="nx">Timestamp</span>

    <span class="c1">// BlockSig is a signature over the hash of the entire block with the miners
</span><span class="c1"></span>    <span class="c1">// worker key to ensure that it is not tampered with after creation
</span><span class="c1"></span>    <span class="nx">blockSig</span> <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TxMeta</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">blsMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">Message</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
    <span class="nx">secpkMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">SignedMessage</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<h3 id="tipset">Tipset</h3>

<p>For more on Tipsets, see <a href="./#algorithms__expected_consensus___index">the Expected Consensus spec</a>. Implementations may choose not to create a Tipset data structure, instead representing its operations in terms of the underlying blocks.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TipSet</span> <span class="p">[</span><span class="o">&amp;</span><span class="nx">Block</span><span class="p">]</span>
</code></pre></div>
  
</div>


<h3 id="vrf-personalization">VRF Personalization</h3>

<p>We define VRF personalizations as follow, to enable domain separation across operations that make use of the same VRF (e.g. <code>Ticket</code> and
<code>ElectionProof</code>).</p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Prefix</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ticket</td>
<td><code>0x01</code></td>
</tr>

<tr>
<td>ElectionProof</td>
<td><code>0x02</code></td>
</tr>
</tbody>
</table>

<h3 id="ticket">Ticket</h3>

<p>A ticket contains a shared random value referenced by a particular <code>Block</code> in the Filecoin blockchain.
Every miner must produce a new <code>Ticket</code> for each ticket used in a leader election attempt.</p>

<p>To produce the ticket values,
we use a <a href="./#algorithms__crypto__vrf">Verifiable Random Function</a> to obtain a deterministic, pseudorandom output.</p>

<h4 id="ticket-comparison">Ticket Comparison</h4>

<p>The ticket is represented concretely by the <code>Ticket</code> data structure.
Whenever the Filecoin protocol refers to ticket values
(notably in crafting <a href="./#algorithms__post___index">PoSTs</a> or running leader election),
what is meant is that the bytes of the <code>VRFResult</code> field in the <code>Ticket</code> struct are used.
Specifically, tickets are compared lexicographically,
interpreting the bytes of the <code>VRFResult.Output</code> as an unsigned integer value (little-endian).</p>

<h3 id="electionproof">ElectionProof</h3>

<p>An election proof is generated from a past ticket (chosen based on public network parameters)
and a given epoch number (or height) by a miner during the leader election process.
Its output value determines whether the miner is elected as one of the leaders,
and hence is eligible to produce a block for the current epoch.
The inclusion of the <code>ElectionProof</code> in the block allows other network participants
to verify that the block was mined by a valid leader. With every leader election attempt for a given ticket,
(in cases where no blocks are found in a round) a miner increments the epoch value thus increasing
block height with every leader election attempt.</p>

<h3 id="message">Message</h3>

<p><code>Message</code> data structures in Filecoin describe operations that can be performed on the Filecoin VM state
(e.g., FIL transactions between accounts).
To facilitate the process of producing secure protocol implementations,
we explicitly distinguish between
<a href="./#algorithms__crypto__signatures">signed and unsigned</a> <code>Message</code> structures.</p>

<p><div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Message</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">UnsignedMessage</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">SignedMessage</span> <span class="mi">1</span>
<span class="p">}</span> <span class="c1">// representation keyed
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UnsignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">to</span> <span class="nx">Address</span>
    <span class="nx">from</span> <span class="nx">Address</span>

    <span class="c1">// When receiving a message from a user account the nonce in the message must match
</span><span class="c1"></span>    <span class="c1">// the expected nonce in the &#34;from&#34; actor. This prevents replay attacks.
</span><span class="c1"></span>    <span class="nx">nonce</span> <span class="nx">UInt</span>
    <span class="nx">value</span> <span class="nx">UInt</span>

    <span class="nx">gasPrice</span> <span class="nx">UInt</span>
    <span class="nx">gasLimit</span> <span class="nx">UInt</span>

    <span class="nx">method</span> <span class="nx">Uint</span>
    <span class="nx">params</span> <span class="nx">Bytes</span>  <span class="c1">// Serialized parameters to the method.
</span><span class="c1"></span><span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">message</span>   <span class="nx">UnsignedMessage</span>
    <span class="nx">signature</span> <span class="nx">Signature</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MessageReceipt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">exitCode</span> <span class="nx">UInt</span>
    <span class="nx">returnValue</span> <span class="nx">Bytes</span>
    <span class="nx">gasUsed</span> <span class="nx">UInt</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>
</p>

<h3 id="state-tree">State Tree</h3>

<p>The state tree keeps track of the entire state of the <a href="./#systems__filecoin_vm">VM - Virtual Machine</a> at any given point.
It is a map from <code>Address</code> structures to <code>Actor</code> structures, where each <code>Actor</code>
may also contain some additional <code>ActorState</code> that is specific to a given actor
type.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StateTree</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Address</span><span class="p">]</span><span class="nx">Actor</span>
</code></pre></div>
  
</div>


<h3 id="actor">Actor</h3>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Actor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// CID of the code object for this actor
</span><span class="c1"></span>    <span class="nx">code</span> <span class="nx">CID</span>

    <span class="c1">// Reference to the root of this actor&#39;s state
</span><span class="c1"></span>    <span class="nx">head</span> <span class="o">&amp;</span><span class="nx">ActorState</span>

    <span class="c1">// Counter of the number of messages this actor has sent
</span><span class="c1"></span>    <span class="nx">nonce</span> <span class="nx">UInt</span>

    <span class="c1">// Current Filecoin balance of this actor
</span><span class="c1"></span>    <span class="nx">balance</span> <span class="nx">UInt</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<h3 id="signature">Signature</h3>

<p><a href="./#algorithms__crypto__signatures">Cryptographic signatures</a> in Filecoin are represented
as byte arrays, and come with a tag that signifies what key type was used to create
the signature.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Signature</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">Secp256k1Signature</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">Bls12_381Signature</span> <span class="mi">1</span>
<span class="p">}</span> <span class="c1">// representation byteprefix
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Secp256k1Signature</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">Bls12_381Signature</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<h3 id="faultset">FaultSet</h3>

<p><code>FaultSet</code> data structures are used to denote which sectors failed at which block heights.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FaultSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">index</span>    <span class="nx">UInt</span>
    <span class="nx">bitField</span> <span class="nx">BitField</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<p>In order to make the serialization more compact,
the <code>index</code> field denotes a block height offset from the start of the corresponding
miner&rsquo;s proving period.</p>

<h3 id="basic-types">Basic Types</h3>

<h4 id="cid">CID</h4>

<p>For most objects referenced by Filecoin, a Content Identifier (CID for short) is used.
This is effectively a hash value, prefixed with its hash function (multihash)
as well as extra labels to inform applications about how to deserialize the given data.
For a more detailed specification, we refer the reader to the
<a href="https://github.com/ipld/cid">IPLD repository</a>.</p>

<h4 id="timestamp">Timestamp</h4>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timestamp</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>


<h4 id="publickey">PublicKey</h4>

<p>The public key type is simply an array of bytes.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PublicKey</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="bytesamount">BytesAmount</h4>

<p>BytesAmount is just a re-typed Integer.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BytesAmount</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>
</p>

<h4 id="peerid">PeerId</h4>

<p>The serialized bytes of a libp2p peer ID.
<div class="notices todo">
  <strong>TODO</strong>:  Spec incomplete; take a look at <a href="https://github.com/libp2p/specs/pull/100">this PR</a>.
</div></p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PeerId</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<h4 id="bitfield">Bitfield</h4>

<p>Bitfields are a set encoded using a custom run length encoding: RLE+.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Bitfield</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="sectorset">SectorSet</h4>

<p>A sector set stores a mapping of sector IDs to the respective <code>commR</code>s.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SectorSet</span> <span class="kd">map</span><span class="p">[</span><span class="nx">SectorID</span><span class="p">]</span><span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<div class="notices todo">
  <strong>TODO</strong>: 
Improve on this; see https://github.com/filecoin-project/specs/issues/116.

</div>

<h4 id="sealproof">SealProof</h4>

<p>SealProof is an opaque, dynamically-sized array of bytes.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SealProof</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="postproof">PoSTProof</h4>

<p>PoSTProof is an opaque, dynamically-sized array of bytes.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PoSTProof</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="tokenamount">TokenAmount</h4>

<p>A type to represent an amount of Filecoin tokens.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TokenAmount</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>
</p>

<h4 id="sectorid">SectorID</h4>

<p>Uniquely identifies a miner&rsquo;s sector.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SectorID</span> <span class="kt">uint64</span>
</code></pre></div>
  
</div>
</p>

<h3 id="rle-bitset-encoding">RLE+ Bitset Encoding</h3>

<p>RLE+ is a lossless compression format based on <a href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE</a>.
Its primary goal is to reduce the size in the case of many individual bits, where RLE breaks down quickly,
while keeping the same level of compression for large sets of contiugous bits.</p>

<p>In tests it has shown to be more compact than RLE itself, as well as <a href="https://arxiv.org/pdf/1004.0403.pdf">Concise</a> and <a href="https://roaringbitmap.org/">Roaring</a>.</p>

<h4 id="format">Format</h4>

<p>The format consists of a header, followed by a series of blocks, of which there are three different types.</p>

<p>The format can be expressed as the following <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> grammar.</p>

<pre><code>    &lt;encoding&gt; ::= &lt;header&gt; &lt;blocks&gt;
      &lt;header&gt; ::= &lt;version&gt; &lt;bit&gt;
     &lt;version&gt; ::= &quot;00&quot;
      &lt;blocks&gt; ::= &lt;block&gt; &lt;blocks&gt; | &quot;&quot;
       &lt;block&gt; ::= &lt;block_single&gt; | &lt;block_short&gt; | &lt;block_long&gt;
&lt;block_single&gt; ::= &quot;1&quot;
 &lt;block_short&gt; ::= &quot;01&quot; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt;
  &lt;block_long&gt; ::= &quot;00&quot; &lt;unsigned_varint&gt;
         &lt;bit&gt; ::= &quot;0&quot; | &quot;1&quot;
</code></pre>

<p>An <code>&lt;unsigned_varint&gt;</code> is defined as specified <a href="https://github.com/multiformats/unsigned-varint">here</a>.</p>

<h5 id="header">Header</h5>

<p>The header indicates the very first bit of the bit vector to encode. This means the first bit is always
the same for the encoded and non-encoded form.</p>

<h5 id="blocks">Blocks</h5>

<p>The blocks represent how many bits, of the current bit type there are. As <code>0</code> and <code>1</code> alternate in a bit vector
the inital bit, which is stored in the header, is enough to determine if a length is currently referencing
a set of <code>0</code>s, or <code>1</code>s.</p>

<h6 id="block-single">Block Single</h6>

<p>If the running length of the current bit is only <code>1</code>, it is encoded as a single set bit.</p>

<h6 id="block-short">Block Short</h6>

<p>If the running length is less than <code>16</code>, it can be encoded into up to four bits, which a short block
represents. The length is encoded into a 4 bits, and prefixed with <code>01</code>, to indicate a short block.</p>

<h6 id="block-long">Block Long</h6>

<p>If the running length is <code>16</code> or larger, it is encoded into a varint, and then prefixed with <code>00</code> to indicate
a long block.</p>

<blockquote>
<p><strong>Note:</strong> The encoding is unique, so no matter which algorithm for encoding is used, it should produce
the same encoding, given the same input.</p>
</blockquote>

<h6 id="bit-numbering">Bit Numbering</h6>

<p>For Filecoin, byte arrays representing RLE+ bitstreams are encoded using <a href="https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering">LSB 0</a> bit numbering.</p>

<h3 id="other-considerations">Other Considerations</h3>

<ul>
<li>The maximum size of an Object should be 1MB (2^20 bytes). Objects larger than this are invalid.</li>
<li>Hashes should use a blake2b-256 multihash.</li>
</ul>


</div>



</div>

  

  
    








<div id="listings__system_map">

<h2 class="section-header">
  Components
</h2>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="listings__libp2p_protocols">

<h2 class="section-header">
  libp2p Protocols
</h2>

<div class="section-content">






































</div>


  
    








<div id="listings__libp2p_protocols__data_transfer_protocol">

<h3 class="section-header">
  Data Transfer Protocol
</h3>

<div class="section-content">




































<ul>
<li><strong>Name</strong>: Data Transfer Protocol</li>
<li><strong>Protocol ID</strong>: <code>/fil/data-transfer/0.0.1</code></li>
</ul>

<p>Message Protobuf</p>

<pre><code>
message DataTransferMessage {
  message Request {
    int32 transferID = 1
    bool isPull = 2
    bytes voucher = 3
    bytes pieceID = 4
    bytes selector = 5
    bool isPartial = 6
    bool isCancel = 7
  }

  message Response {
    int32 transferID = 1
    boolean accepted = 2
  }

  bool isResponse = 1
  Request request = 2
  Response response = 3
}

</code></pre>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="glossary">

<h1 class="section-header">
  Glossary
</h1>

<div class="section-content">






































<h2 id="updates-to-definitions">Updates to definitions</h2>

<p>To make any updates to these definitions please submit a pull request with the changes, or open an issue and one of the maintainers will do it for you.</p>

<h2 id="notes">Notes</h2>

<ul>
<li>Want to split all repair stuff to separate doc</li>
<li>Let&rsquo;s refer to Filecoin system rather than network. In a sense, the network is an instantiation of the system (this protocol). We can however refer to the Filecoin VM separately which means the system by which we apply changes to the state of the system at a point in time.</li>
<li>Asterisks indicate that the definition requires updating by any affected party.</li>
</ul>

<h2 id="definitions">Definitions</h2>

<h3 id="actor">Actor</h3>

<p>An actor is an on-chain object with its own state and set of methods. An actors state is persisted on-chain in the state tree, keyed by its address. All actors (miner actors, the storage market actor, account actors) have an address. Actors methods are invoked by crafting messages and getting miners to include them in blocks.</p>

<p>Actors are very similar to smart contracts in Ethereum.</p>

<h3 id="address">Address</h3>

<p>An address is an identifier that refers to an actor in the Filecoin state.</p>

<h3 id="ask">Ask</h3>

<p>An ask contains the terms on which a miner is willing to provide services. Storage asks, for example, contain price and other terms under which a given miner is willing to sell its storage. The word comes from stock market usage of ask, shortened from asking price.</p>

<h3 id="block">Block</h3>

<p>A block in the Filecoin blockchain is a chunk of data appended to the shared history of the network including transactions, messages, etc. and representing the state of the storage network at a given point in time.</p>

<p>See [Data Structures]()</p>

<h3 id="bootstrapping">Bootstrapping</h3>

<h3 id="chain-weight">Chain weight</h3>

<h3 id="challenge-sampling">Challenge sampling</h3>

<h3 id="cid">Cid</h3>

<p>CID is short for Content Identifier, a self describing content address used throughout the ipfs ecosystem. For more detailed information, see <a href="https://github.com/ipld/cid">the github documentation for it</a>.</p>

<h3 id="client">Client</h3>

<p>A client is any user with an account who wishes to store data with a miner. A client&rsquo;s account is used to pay for the storage, and helps to prove the clients ability to pay.</p>

<h3 id="collateral">Collateral</h3>

<p>Collateral is Filecoin tokens pledged by an actor as a commitment to a promise. If the promise is respected, the collateral is returned. If the promise is broken, the collateral is not returned in full. For instance:</p>

<ul>
<li>In becoming a Filecoin storage miner: the miner will put up collateral alongside their SEAL to</li>
<li>In a Filecoin deal: both the miner and client put up collateral to ensure their respect of deal terms.</li>
</ul>

<h3 id="commitment">Commitment</h3>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h3 id="confirmation">Confirmation</h3>

<h3 id="consensus">Consensus</h3>

<h3 id="deal">Deal</h3>

<p>*** *A deal in a Filecoin market is made when a bid and ask are matched, corresponding to an agreement on a service and price between a miner and client.</p>

<h3 id="election-proof">Election Proof</h3>

<p>An <code>ElectionProof</code> is derived from a past <code>ticket</code> and is included in every block header. The <code>ElectionProof</code> proves that the miner was eligible to mine a block at that <code>height</code>.</p>

<h3 id="erasure-coding">Erasure coding</h3>

<p>Erasure coding is a strategy through which messages can be lengthened so as to be made recoverable in spite of errors.</p>

<p>See <a href="https://en.wikipedia.org/wiki/Erasure_code">Wikipedia</a></p>

<h3 id="fault">Fault</h3>

<p>A fault occurs when a proof is not posted in the Filecoin system within the proving period, denoting another malfunction such as loss of network connectivity, storage malfunction, malicious miner, etc.</p>

<h3 id="fair">Fair</h3>

<h3 id="file">File</h3>

<p>Files are what clients bring to the filecoin system to store. A file is split up into <code>pieces</code>, which are what is actually stored by the network.</p>

<h3 id="finality">Finality</h3>

<h3 id="piece-inclusion-proof">Piece Inclusion Proof</h3>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h3 id="gas-fees-prices">Gas, Fees, Prices</h3>

<h3 id="generation-attack-threshold">Generation Attack Threshold</h3>

<p>Security parameter. Number of rounds within which a new Proof-of-Storage must be submitted in order for a miner to retain power in the network (and avoid getting slashed). This number must be be smaller than the minimum time it takes for an adversarial miner to generate a replica of the data (thereby not storing it undetectably for some period of time).</p>

<p>The Generation Attack Threshold is equal to the Polling Time + some Grace Period after which miners get slashed.</p>

<h3 id="ghost">GHOST</h3>

<p><a href="https://eprint.iacr.org/2013/881.pdf">GHOST</a> is an acronym for <code>Greedy Heaviest Observable SubTree</code>, a class of blockchain structures in which multiple blocks can validly be included in the chain at any given height or round. GHOSTy protocols produce blockDAGs rather than blockchains and use a weighting function for fork selection, rather than simply picking the longest chain.</p>

<h3 id="height">Height</h3>

<p><code>Height</code> and <code>round</code> are synonymous and used interchangeably in this spec.</p>

<p><code>Height</code> refers to the number of tickets generated between this <code>TipSet</code> and the genesis block (height 0), counting only the tickets of the block in a TipSet whose final ticket &ndash; the one generated alongside the <code>ElectionProof</code> &ndash; is the smallest.</p>

<p>If a <code>TipSet</code> contains multiple blocks, each block in the TipSet will have the same <code>height</code>. Put another way, there is a new <code>round</code> of leader election attempts at each <code>height</code>. Typically, such an attempt will find a single leader. If a single leader is found, that leader can generate a single block. If multiple leaders are found, they can each generate multiple blocks in the given round. If no leader is found, no block is generated (but a ticket is).</p>

<h3 id="leader">Leader</h3>

<p>A leader, in the context of Filecoin consensus, is a node that is chosen to propose the next block in the blockchain.</p>

<h3 id="leader-election">Leader election</h3>

<p>Leader election is the process by which the Filecoin network agrees who gets to create the next block.</p>

<h3 id="message">Message</h3>

<p>A message is a call to an actor in the Filecoin VM.</p>

<h3 id="miner">Miner</h3>

<p>A miner is an actor in the Filecoin system performing a service in the network for a reward.</p>

<p>There are multiple types of miners in Filecoin:</p>

<ul>
<li>Storage miners - storage miners</li>
<li>Retrieval miners:</li>
<li>Repair miners (to be split out):</li>
</ul>

<h3 id="node">Node</h3>

<p>*** *A node is a communication endpoint that implements the Filecoin protocol. (also mention IPLD Node?)</p>

<h3 id="on-chain-off-chain">On-chain/off-chain</h3>

<h3 id="online-offline">Online/offline</h3>

<h3 id="payment-channel">Payment Channel</h3>

<p>A payment channel is set up between actors in the Filecoin system to enable off-chain payments with on-chain guarantees, making settlement more efficient.</p>

<h3 id="piece">Piece</h3>

<p>A piece is a portion of a file that gets fitted into a sector.</p>

<h3 id="pledge">Pledge</h3>

<p>****The initial commitment of a storage miner to provide a number of sectors to the system.</p>

<h3 id="polling-time">Polling Time</h3>

<p>Security Parameter. Polling time is the time between two online PoReps in a PoSt proof.</p>

<h3 id="power">Power</h3>

<p>See <code>Power Fraction</code>.</p>

<h3 id="power-fraction">Power Fraction</h3>

<p>A miner&rsquo;s <code>Power Fraction</code> or <code>Power</code> is the ratio of their committed storage as of their last PoSt submission over Filecoin&rsquo;s total committed storage as of the current block. It is used in leader election.</p>

<h3 id="power-table">Power table</h3>

<p>The <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a> is an abstraction provided by the Filecoin storage market that lists the <code>power</code> of every miner in the system.</p>

<h3 id="protocol">Protocol</h3>

<h3 id="proving-period">Proving Period</h3>

<p>The period of time during which storage miners must compute Proofs of Spacetime. At the end of the period they must submit their PoSt. Put another way, it is the duration of a PoSt.</p>

<h3 id="proving-set">Proving Set</h3>

<p>The elements used as input by a proof of Spacetime to enable a proof to be generated.</p>

<p>**** elements necessary to generate a SEAL, or elements necessary to generate a proof</p>

<h3 id="proof-of-replication">Proof of Replication</h3>

<p>Proof that a unique encoding of data exists in physical storage.</p>

<p>Used in the Filecoin system to generate SEALed sectors through which storage miners prove they hold client data.</p>

<h3 id="proof-of-spacetime">Proof of Spacetime</h3>

<p>Proof that a given encoding of data existed in physical storage continuously over a period of time.</p>

<p>Used in the Filecoin system by a storage miner to prove that client data was kept over the contract duration.</p>

<h3 id="random-ness">Random(ness)</h3>

<p>****Source of unpredictability used in the Filecoin system to ensure fairness and prevent malicious actors from gaining an advantage over the system.</p>

<p>TODO add a note to distinguish predictability from randomness</p>

<h3 id="election-randomness-lookback">Election Randomness Lookback</h3>

<p>Security parameter. A number of rounds to sample back from when choosing randomness for use in leader election. A higher number turns a more localized lottery into a more global one since a miner wins or loses on all descendants of a given randomness, but enables miners to look-ahead and know whether they will be elected in the future.</p>

<p>Also referred to as <code>K</code> in consensus settings.</p>

<h3 id="repair">Repair</h3>

<p>Repair refers to the processes and protocols by which the Filecoin network ensures that data that is partially lost (by, for example, a miner disappearing) can be re-constructed and re-added to the network.</p>

<h3 id="round">Round</h3>

<p>See <code>Height</code> for definition. They are synonymous.</p>

<h3 id="seal-unseal">SEAL/UNSEAL</h3>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h3 id="sector">Sector</h3>

<p>A sector is a contiguous array of bytes that a miner puts together, seals, and performs Proofs of Spacetime on.</p>

<h3 id="slashing">Slashing</h3>

<h3 id="smart-contracts">Smart contracts</h3>

<h3 id="storage">Storage</h3>

<p>Storage widely refers to a place in which to store data in a given system.</p>

<p>In the context of:</p>

<ul>
<li>The Filecoin miner: sotrage refers to disk sectors made available to the network.</li>
<li>The Filecoin chain: storage refers to the way in which system state is tracked through time on-chain through blocks.</li>
<li>Actor: the struct that defines an actor.</li>
</ul>

<h3 id="state">State</h3>

<p>****Refers to The shared history of the Filecoin system contains actors and their storage, deals, etc. State is deterministically generated from the initial state and the set of messages generated by the system.</p>

<h3 id="ticket">Ticket</h3>

<p>A <code>ticket</code> is used as a source of randomness in EC leader election. Every block depends on an <code>ElectionProof</code> derived from a <code>ticket</code>. At least one new <code>ticket</code> is produced with every new block. Ticket creation is described <a href="./expected-consensus.md#Ticket-generation">here</a>.</p>

<h3 id="ticket-chain">Ticket Chain</h3>

<p>Each chain in Filecoin can be associated to a given <code>ticket chain</code>. The <code>ticket chain</code> is assembled by taking the tickets (usually one) contained by the block with the smallest final ticket in each of the chain&rsquo;s <code>TipSet</code>s.</p>

<p>Ticket comparison is done by interpreting the tickets&rsquo; Bytes as unsigned integers (little endian representation).</p>

<h3 id="tipset">TipSet</h3>

<p>A <code>TipSet</code> is a set of blocks that have the same parent set and same number of <code>tickets</code>, which implies they will have been mined at the same <code>height</code>. A <code>TipSet</code> can contain multiple blocks if more than one miner successfully mines a block at the same <code>height</code> as another miner.</p>

<h3 id="verifiable">Verifiable</h3>

<p>Something that is verifiable can be checked for correctness by a third party.</p>

<h3 id="vdf">VDF</h3>

<p>A verifiable function that guarantees a time delay given some hardware assumptions and a small set of requirements. These requirements are efficient proof verification, random output, and strong sequentiality. Verifiable delay functions are formally defined by [[BBBF]](<a href="https://eprint.iacr.org/2018/601">https://eprint.iacr.org/2018/601</a>).</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;‚Äî- VDF(public parameters, seed)</code></pre></div>
<h3 id="vm">VM</h3>

<p>Virtual Machine. The Filecoin VM refers to the system by which changes are applied to the Filecoin system&rsquo;s state. The VM takes messages as input, and outputs state.</p>

<h3 id="voucher">Voucher</h3>

<p>Held by an actor as part of a payment channel to complete settlement when the counterparty defaults.</p>

<h3 id="vrf">VRF</h3>

<p>A verifiable random function that receives {Secret Key (SK), seed} and outputs {proof of correctness, output value}. VRFs must yield a proof of correctness and a unique &amp; efficiently verifiable output.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;-- VRF(SK, seed)</code></pre></div>
<h3 id="weight">Weight</h3>

<p>Every mined block has a computed <code>weight</code>. Together, the <code>weights</code> of all the blocks in a branch of the chain determines the cumulative <code>weight</code> of that branch. Filecoin&rsquo;s Expected Consensus is a GHOSTy or heaviest-chain protocol, where chain selection is done on the basis of an explicit weighting function. Filecoin‚Äôs <code>weight</code> function currently seeks to incentivize collaboration amongst miners as well as the addition of storage to the network. The specific weighting function is defined in <a href="expected-consensus.md#chain-weighting">Chain Weighting</a>.</p>

<h3 id="zksnark">zkSNARK</h3>

<p>Zero Knowledge Succinct ARguments of Knowledge. A way of producing a small &lsquo;proof&rsquo; that convinces a &lsquo;verifier&rsquo; that some computation was done correctly.</p>


</div>



</div>

  

  
    








<div id="appendix">

<h1 class="section-header">
  Appendix
</h1>

<div class="section-content">






































</div>


  
    








<div id="appendix__sharray">

<h2 class="section-header">
  Sharded IPLD Array
</h2>

<div class="section-content">






































<p>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.</p>

<h3 id="ipld-representation">IPLD Representation</h3>

<p>Each sharray node is represented by an IPLD node of the following schema:</p>

<pre><code>type Node struct {
  height Int
  items [Item]
} representation tuple
</code></pre>

<p><code>Item</code> may be either a direct value, if <code>height == 0</code>, or the Cid of a child node if <code>height &gt; 0</code>.</p>

<p>(For details on IPLD Schemas, see the <a href="https://github.com/ipld/specs/blob/dcbfb25468092be796bab90e90e3f2535fdeddc7/schema/representations.md">IPLD Schema Spec (draft)</a>)</p>

<p>We use DAG-CBOR for serialization, and blake2b-256 for hashing.</p>

<h3 id="construction">Construction</h3>

<p>The tree must not be sparse.
Given an array of size <code>N</code> and a fixed width of <code>W</code>.
- The left <code>floor(N/W)</code> leaves contain the first <code>N</code> items.
- If <code>N % W != 0</code> the final leaf contains the final remainder.
- The tree is perfectly balanced.
- The height is the distance from the leaves, not the root.
- Leaves (nodes with a height of 0) contain array values.
- Inner nodes (nodes with height greater than zero) contain the cids of their child nodes.</p>

<h3 id="operations">Operations</h3>

<h4 id="create-items"><code>create(items)</code></h4>

<blockquote>
<p>Create a sharray from a given set of items</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">create</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="nx">Item</span><span class="p">)</span> <span class="nx">Cid</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">layer</span> <span class="nx">cidQueue</span>

	<span class="nx">itemQ</span> <span class="o">:=</span> <span class="nf">queue</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">!</span><span class="nx">itemQ</span><span class="p">.</span><span class="nf">Empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// get the next &#39;Width&#39; items from the input items
</span><span class="c1"></span>		<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">itemQ</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

		<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
			<span class="nx">height</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="c1">// persist the node to the datastore
</span><span class="c1"></span>		<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

		<span class="nx">layer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">nextLayer</span> <span class="nx">cidQueue</span>
	<span class="k">for</span> <span class="nx">height</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">height</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

			<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
				<span class="nx">height</span><span class="p">:</span> <span class="nx">height</span><span class="p">,</span>
				<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
			<span class="p">}</span>

			<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

			<span class="nx">nextLayer</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">layer</span> <span class="p">=</span> <span class="nx">nextLayer</span>
		<span class="nx">nextLayer</span><span class="p">.</span><span class="nf">ClearItems</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nextLayer</span><span class="p">.</span><span class="nf">First</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="get-i"><code>get(i)</code></h4>

<blockquote>
<p>Get the element at index <code>i</code></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">node</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">childWidth</span> <span class="o">:=</span> <span class="nf">Pow</span><span class="p">(</span><span class="nx">Width</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>

	<span class="nx">child</span> <span class="o">:=</span> <span class="nf">loadNode</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="nx">childWidth</span><span class="p">])</span>
	<span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="nx">childWidth</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

</div>



</div>

  

  
    








<div id="appendix__address">

<h2 class="section-header">
  Address
</h2>

<div class="section-content">






































<p>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</p>

<h3 id="design-criteria">Design criteria</h3>

<ol>
<li><strong>Identifiable</strong>: The address must be easily identifiable as a Filecoin address.</li>
<li><strong>Reliable</strong>: Addresses must provide a mechanism for error detection when they might be transmitted outside the network.</li>
<li><strong>Upgradable</strong>: Addresses must be versioned to permit the introduction of new address formats.</li>
<li><strong>Compact</strong>: Given the above constraints, addresses must be as short as possible.</li>
</ol>

<h3 id="specification">Specification</h3>

<p>There are 2 ways a filecoin address can be represented. An address appearing on chain will always be formatted as raw bytes. An address may also be encoded to a string, this encoding includes a checksum and network prefix. An address encoded as a string will never appear on chain, this format is used for sharing among humans.</p>

<h4 id="bytes">Bytes</h4>

<p>When represented as bytes a filecoin address contains the following:</p>

<ul>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>

<li><p>The <strong>payload</strong> used to uniquely identify the actor according to the protocol.</p>

<pre><code>|----------|---------|
| protocol | payload |
|----------|---------|
|  1 byte  | n bytes |
</code></pre></li>
</ul>

<h4 id="string">String</h4>

<p>When encoded to a string a filecoin address contains the following:</p>

<ul>
<li>A <strong>network prefix</strong> character that identifies the network the address belongs to.</li>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>
<li>A <strong>payload</strong> used to uniquely identify the actor according to the protocol.</li>

<li><p>A <strong>checksum</strong> used to validate the address.</p>

<pre><code>|------------|----------|---------|----------|
|  network   | protocol | payload | checksum |
|------------|----------|---------|----------|
| 'f' or 't' |  1 byte  | n bytes | 4 bytes  |
</code></pre></li>
</ul>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Address</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">AddressId</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">AddressSecp256k1</span> <span class="mi">1</span>
    <span class="p">|</span> <span class="nx">AddressActor</span> <span class="mi">2</span>
    <span class="p">|</span> <span class="nx">AddressBLS12_381</span> <span class="mi">3</span>
<span class="p">}</span> <span class="c1">// representation byteprefix
</span><span class="c1"></span>
<span class="c1">// ID
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressId</span> <span class="nx">UInt</span>

<span class="c1">// Blake2b-160 Hash
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressSecp256k1</span> <span class="nx">Bytes</span>

<span class="c1">// Blake2b-160 Hash
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressActor</span> <span class="nx">Bytes</span>

<span class="c1">// 48 byte PublicKey
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressBLS12_381</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<h4 id="network-prefix">Network Prefix</h4>

<p>The <strong>network prefix</strong> is prepended to an address when encoding to a string. The network prefix indicates which network an address belongs in. The network prefix may either be <code>f</code> for filecoin mainnet or <code>t</code> for filecoin testnet. It is worth noting that a network prefix will never appear on chain and is only used when encoding an address to a human readable format.</p>

<h4 id="protocol-indicator">Protocol Indicator</h4>

<p>The <strong>protocol indicator</strong> byte describes how a method should interpret the information in the payload field of an address. Any deviation for the algorithms and data types specified by the protocol must be assigned a new protocol number. In this way, protocols also act as versions.</p>

<ul>
<li><code>0</code> : ID</li>
<li><code>1</code> : SECP256K1 Public Key</li>
<li><code>2</code> : Actor</li>
<li><code>3</code> : BLS Public Key</li>
</ul>

<p>An example description in golang:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Protocol byte
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kt">byte</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">ID</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">SECP256K1</span>
	<span class="nx">Actor</span>
	<span class="nx">BLS</span>
<span class="p">)</span></code></pre></div>
<h5 id="protocol-0-ids">Protocol 0: IDs</h5>

<p><strong>Protocol 0</strong> addresses are simple IDs.  All actors have a numeric ID even if they don&rsquo;t have public keys. The payload of an ID address is base10 encoded. IDs are not hashed and do not have a checksum.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------|
| protocol |    payload    |
|----------|---------------|
|    0     | leb128-varint |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------|
|  network   | protocol |    payload    |
|------------|----------|---------------|
| 'f' or 't' |    '0'   | leb128-varint |
                  base10[...............]
</code></pre>

<h5 id="protocol-1-libsecpk1-elliptic-curve-public-keys">Protocol 1: libsecpk1 Elliptic Curve Public Keys</h5>

<p><strong>Protocol 1</strong> addresses represent secp256k1 public encryption keys. The payload field contains the <a href="https://blake2.net/">Blake2b 160</a> hash of the public key.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    1     | blake2b-160(PubKey) |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '1'   | blake2b-160(PubKey) |  4 bytes |
                  base32[................................]
</code></pre>

<h5 id="protocol-2-actor">Protocol 2: Actor</h5>

<p><strong>Protocol 2</strong> addresses representing an Actor. The payload field contains the <a href="https://blake2.net/">Blake2b 160</a> hash of meaningful data produced as a result of creating the actor.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    2     | blake2b-160(Random) |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|-----------------------|----------|
|  network   | protocol |         payload       | checksum |
|------------|----------|-----------------------|----------|
| 'f' or 't' |    '2'   |  blake2b-160(Random)  |  4 bytes |
                  base32[..................................]
</code></pre>

<h5 id="protocol-3-bls">Protocol 3: BLS</h5>

<p><strong>Protocol 3</strong> addresses represent BLS public encryption keys. The payload field contains the BLS public key.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    3     | 48 byte BLS PubKey  |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '3'   |  48 byte BLS PubKey |  4 bytes |
                  base32[................................]
</code></pre>

<h4 id="payload">Payload</h4>

<p>The payload represents the data specified by the protocol. All payloads except the payload of the ID protocol are <a href="https://tools.ietf.org/html/rfc4648#section-6">base32</a> encoded using the lowercase alphabet when seralized to their human readable format.</p>

<h4 id="checksum">Checksum</h4>

<p>Filecoin checksums are calculated over the address protocol and payload using blake2b-4. Checksums are base32 encoded and only added to an address when encoding to a string. Addresses following the ID Protocol do not have a checksum.</p>

<h4 id="expected-methods">Expected Methods</h4>

<p>All implementations in Filecoin must have methods for creating, encoding, and decoding addresses in addition to checksum creation and validation. The follwing is a golang version of the Address Interface:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span>

<span class="kd">type</span> <span class="nx">Address</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="nx">Network</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Adress</span><span class="p">)</span> <span class="kt">string</span>
	<span class="nf">Decode</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span>
	<span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span></code></pre></div>
<h5 id="new">New()</h5>

<p>New returns an Address for the specified protocol encapsulating corresponding payload. New fails for unknown protocols.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="p">&lt;</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="p">&gt;</span> <span class="nx">BLS</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownType</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="encode">Encode()</h5>

<p>Software encoding a Filecoin address must:</p>

<ul>
<li>produce an address encoded to a known network</li>
<li>produce an address encoded to a known protocol</li>
<li>produce an address with a valid checksum (if applicable)</li>
</ul>

<p>Encodes an Address as a string, prepending the network prefix, calculating the checksum, and encoding the payload and checksum to <a href="https://tools.ietf.org/html/rfc4648">base32</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Invalid Network&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SECP256K1</span><span class="p">,</span> <span class="nx">Actor</span><span class="p">,</span> <span class="nx">BLS</span><span class="p">:</span>
		<span class="nx">cksm</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="o">+</span><span class="nx">cksm</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">ID</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base10</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">leb128</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid address protocol&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="decode">Decode()</h5>

<p>Software decoding a Filecoin address must:
* verify the network is a known network.
* verify the protocol is a number of a known protocol.
* verify the checksum is valid</p>

<p>Decode an Address from a string by removing the network prefix, validating the address is of a know protocol, decoding the payload and checksum, and validating the checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">3</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidLength</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownNetwork</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">protocol</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">raw</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">ID</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
			<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
			<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">leb128</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">base10</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">raw</span> <span class="p">=</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span>
	<span class="nx">payload</span> <span class="p">=</span> <span class="nx">raw</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">Actor</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidBytes</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">cksm</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">:]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">cksm</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidChecksum</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="checksum-1">Checksum()</h5>

<p>Checksum produces a byte array by taking the blake2b-4 hash of an address protocol and payload.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nf">blake2b4</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h5 id="validatechecksum">ValidateChecksum()</h5>

<p>ValidateChecksum returns true if the Checksum of data matches the expected checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">expected</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">digest</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">digest</span> <span class="o">==</span> <span class="nx">expected</span>
<span class="p">}</span></code></pre></div>
<h3 id="test-vectors">Test Vectors</h3>

<p>These are a set of test vectors that can be used to test an implementation of
this address spec. Test vectors are presented as newline-delimited address/hex
fields. The &lsquo;address&rsquo; field, when parsed, should produce raw bytes that match
the corresponding item in the &lsquo;hex&rsquo; field. For example:</p>

<pre><code>address1
hex1

address2
hex2
</code></pre>

<h4 id="id-type-addresses">ID Type Addresses</h4>

<pre><code>f00
0000

f0150
009601

f01024
008008

f01729
00c10d

f018446744073709551615
00ffffffffffffffffff01
</code></pre>

<h4 id="secp256k1-type-addresses">Secp256k1 Type Addresses</h4>

<pre><code>f17uoq6tp427uzv7fztkbsnn64iwotfrristwpryy
01fd1d0f4dfcd7e99afcb99a8326b7dc459d32c628

f1xcbgdhkgkwht3hrrnui3jdopeejsoatkzmoltqy
01b882619d46558f3d9e316d11b48dcf211327026a

f1xtwapqc6nh4si2hcwpr3656iotzmlwumogqbuaa
01bcec07c05e69f92468e2b3e3bf77c874f2c5da8c

f1wbxhu3ypkuo6eyp6hjx6davuelxaxrvwb2kuwva
01b06e7a6f0f551de261fe3a6fe182b422ee0bc6b6

f12fiakbhe2gwd5cnmrenekasyn6v5tnaxaqizq6a
01d1500504e4d1ac3e89ac891a4502586fabd9b417
</code></pre>

<h4 id="actor-type-addresses">Actor Type Addresses</h4>

<pre><code>f24vg6ut43yw2h2jqydgbg2xq7x6f4kub3bg6as6i
02e54dea4f9bc5b47d261819826d5e1fbf8bc5503b

f25nml2cfbljvn4goqtclhifepvfnicv6g7mfmmvq
02eb58bd08a15a6ade19d0989674148fa95a8157c6

f2nuqrg7vuysaue2pistjjnt3fadsdzvyuatqtfei
026d21137eb4c4814269e894d296cf6500e43cd714

f24dd4ox4c2vpf5vk5wkadgyyn6qtuvgcpxxon64a
02e0c7c75f82d55e5ed55db28033630df4274a984f

f2gfvuyh7v2sx3patm5k23wdzmhyhtmqctasbr23y
02316b4c1ff5d4afb7826ceab5bb0f2c3e0f364053
</code></pre>

<h4 id="bls-type-addresses">BLS Type Addresses</h4>

<p>To aid in readability, these addresses are line-wrapped. Address and hex pairs
are separated by <code>---</code>.</p>

<pre><code>f3vvmn62lofvhjd2ugzca6sof2j2ubwok6cj4xxbfzz
4yuxfkgobpihhd2thlanmsh3w2ptld2gqkn2jvlss4a
---
03ad58df696e2d4e91ea86c881e938ba4ea81b395e12
797b84b9cf314b9546705e839c7a99d606b247ddb4f9
ac7a3414dd

f3wmuu6crofhqmm3v4enos73okk2l366ck6yc4owxwb
dtkmpk42ohkqxfitcpa57pjdcftql4tojda2poeruwa
---
03b3294f0a2e29e0c66ebc235d2fedca5697bf784af
605c75af608e6a63d5cd38ea85ca8989e0efde9188b
382f9372460d

f3s2q2hzhkpiknjgmf4zq3ejab2rh62qbndueslmsdz
ervrhapxr7dftie4kpnpdiv2n6tvkr743ndhrsw6d3a
---
0396a1a3e4ea7a14d49985e661b22401d44fed402d1
d0925b243c923589c0fbc7e32cd04e29ed78d15d37d
3aaa3fe6da33

f3q22fijmmlckhl56rn5nkyamkph3mcfu5ed6dheq53
c244hfmnq2i7efdma3cj5voxenwiummf2ajlsbxc65a
---
0386b454258c589475f7d16f5aac018a79f6c1169d2
0fc33921dd8b5ce1cac6c348f90a3603624f6aeb91b
64518c2e8095

f3u5zgwa4ael3vuocgc5mfgygo4yuqocrntuuhcklf4
xzg5tcaqwbyfabxetwtj4tsam3pbhnwghyhijr5mixa
---
03a7726b038022f75a384617585360cee629070a2d9
d28712965e5f26ecc40858382803724ed34f2720336
f09db631f074
</code></pre>


</div>



</div>

  

  
    








<div id="appendix__orient">

<h2 class="section-header">
  Filecoin Parameters
</h2>

<div class="section-content">






































<h4 id="all-parameters">All Parameters</h4>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ACTOR-METHOD</td>
<td>BYTES</td>
<td>8</td>
<td>The size required to represent an actor method.</td>
</tr>

<tr>
<td>ACTORS-MESSAGES-FRACTION</td>
<td></td>
<td>0.30000004</td>
<td></td>
</tr>

<tr>
<td>ACTORS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>32.661842</td>
<td></td>
</tr>

<tr>
<td>ADDRESS-SIZE</td>
<td>BYTES</td>
<td>35</td>
<td>The size of an address.</td>
</tr>

<tr>
<td>ALL-POST-MESSAGES-PER-YEAR</td>
<td></td>
<td>122557560.0</td>
<td></td>
</tr>

<tr>
<td>ALL-SEAL-MESSAGES-PER-YEAR</td>
<td></td>
<td>335544320</td>
<td></td>
</tr>

<tr>
<td>ALL-SEAL-SIZE-PER-YEAR</td>
<td></td>
<td>335544320</td>
<td></td>
</tr>

<tr>
<td>AVG-POSTS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>11.650845</td>
<td></td>
</tr>

<tr>
<td>AVG-PROOFS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>43.549118</td>
<td></td>
</tr>

<tr>
<td>AVG-SEALS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>31.898273</td>
<td></td>
</tr>

<tr>
<td>AVG-TICKETS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>BLOCK-FRAMING-SIZE</td>
<td>BYTES</td>
<td>14709.481</td>
<td>The total amount of block framing.</td>
</tr>

<tr>
<td>BLOCK-HEADER-FIXED-SIZE</td>
<td></td>
<td>420</td>
<td></td>
</tr>

<tr>
<td>BLOCK-HEADER-SIZE</td>
<td></td>
<td>1427</td>
<td></td>
</tr>

<tr>
<td>BLOCK-HEADER-VARIABLE-SIZE</td>
<td></td>
<td>1007</td>
<td></td>
</tr>

<tr>
<td>BLOCK-HEIGHT-SIZE</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>BLOCK-SIG-SIZE</td>
<td></td>
<td>96</td>
<td></td>
</tr>

<tr>
<td>BLOCK-SIZE</td>
<td></td>
<td>37265.1</td>
<td></td>
</tr>

<tr>
<td>BLOCK-SIZE-KIB</td>
<td></td>
<td>36.3917</td>
<td></td>
</tr>

<tr>
<td>BLOCK-TIME</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>BLOCKS-IN-A-YEAR</td>
<td></td>
<td>10519200.0</td>
<td></td>
</tr>

<tr>
<td>BLOCKS-IN-TEN-YEARS</td>
<td></td>
<td>105192000.0</td>
<td></td>
</tr>

<tr>
<td>BLS-AGG-SIZE</td>
<td></td>
<td>96</td>
<td></td>
</tr>

<tr>
<td>CHAIN-SIZE-YEAR</td>
<td></td>
<td>391999060000.0</td>
<td></td>
</tr>

<tr>
<td>CHAIN-SIZE-YEAR-GIB</td>
<td></td>
<td>365.07758</td>
<td></td>
</tr>

<tr>
<td>CID-SIZE</td>
<td>BYTES</td>
<td>35</td>
<td>The size of a CID.</td>
</tr>

<tr>
<td>COMM-C-CONSTRAINTS</td>
<td></td>
<td>218221140.0</td>
<td></td>
</tr>

<tr>
<td>COMM-C-OPENINGS</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>COMM-C-TIME</td>
<td></td>
<td>12924.399</td>
<td></td>
</tr>

<tr>
<td>COMM-D-CONSTRAINTS</td>
<td></td>
<td>11011791.0</td>
<td></td>
</tr>

<tr>
<td>COMM-D-OPENINGS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>COMM-D-TIME</td>
<td></td>
<td>652.18604</td>
<td></td>
</tr>

<tr>
<td>COMM-P-SIZE</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>COMM-R-CONSTRAINTS</td>
<td></td>
<td>66070744.0</td>
<td></td>
</tr>

<tr>
<td>COMM-R-OPENINGS</td>
<td></td>
<td>6</td>
<td></td>
</tr>

<tr>
<td>COMM-R-TIME</td>
<td></td>
<td>3913.1165</td>
<td></td>
</tr>

<tr>
<td>COMMIT-SIZE</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>COMMIT-TIME</td>
<td></td>
<td>14042.3955</td>
<td></td>
</tr>

<tr>
<td>CORES</td>
<td></td>
<td>16</td>
<td></td>
</tr>

<tr>
<td>DEGREE</td>
<td></td>
<td>14</td>
<td></td>
</tr>

<tr>
<td>DEGREE-BASE</td>
<td></td>
<td>6</td>
<td></td>
</tr>

<tr>
<td>DEGREE-EXPANDER</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>DELTA</td>
<td></td>
<td>0.02425</td>
<td></td>
</tr>

<tr>
<td>DRG-D</td>
<td></td>
<td><sup>1</sup>&frasl;<sub>4</sub></td>
<td></td>
</tr>

<tr>
<td>DRG-E</td>
<td></td>
<td>0.8</td>
<td></td>
</tr>

<tr>
<td>EIX</td>
<td></td>
<td>1152921504606846976</td>
<td></td>
</tr>

<tr>
<td>ELECTION-PROOF-SIZE</td>
<td></td>
<td>64</td>
<td></td>
</tr>

<tr>
<td>ENCODING-AMAX</td>
<td></td>
<td>2</td>
<td></td>
</tr>

<tr>
<td>ENCODING-TIME</td>
<td></td>
<td>6605.1006</td>
<td></td>
</tr>

<tr>
<td>ENCODING-TIME-MINS</td>
<td></td>
<td>110.08501</td>
<td></td>
</tr>

<tr>
<td>EPSILON</td>
<td></td>
<td>0.0505</td>
<td></td>
</tr>

<tr>
<td>EXIT-CODE</td>
<td>BYTES</td>
<td>4</td>
<td>The size of an exit code.</td>
</tr>

<tr>
<td>EXPECTED-WINNING-MINERS</td>
<td></td>
<td>5</td>
<td></td>
</tr>

<tr>
<td>FROM-ADDRESS</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>GAS-LIMIT</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>GAS-PRICE</td>
<td>BYTES</td>
<td>8</td>
<td>The size required to represent the gas limit.</td>
</tr>

<tr>
<td>GAS-USED</td>
<td>BYTES</td>
<td>8</td>
<td>The size required to represent the amount of gas used by a message.</td>
</tr>

<tr>
<td>GIB</td>
<td></td>
<td>1073741824</td>
<td></td>
</tr>

<tr>
<td>INCLUSION-CIRCUIT-TIME</td>
<td></td>
<td>2.3098202</td>
<td></td>
</tr>

<tr>
<td>INCLUSION-CONSTRAINTS</td>
<td></td>
<td>39000.0</td>
<td></td>
</tr>

<tr>
<td>KDF-CONTENT</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>KDF-HASH-SIZE</td>
<td></td>
<td>32</td>
<td></td>
</tr>

<tr>
<td>KDF-HASH-TIME</td>
<td></td>
<td>4.5608e-08</td>
<td></td>
</tr>

<tr>
<td>KIB</td>
<td>BYTES</td>
<td>1024</td>
<td>The number of bytes in one KiB.</td>
</tr>

<tr>
<td>LAMBDA</td>
<td></td>
<td>10</td>
<td></td>
</tr>

<tr>
<td>LAYERS</td>
<td></td>
<td>9.634086</td>
<td></td>
</tr>

<tr>
<td>LAYERS-A</td>
<td></td>
<td>6.8276772</td>
<td></td>
</tr>

<tr>
<td>LAYERS-B</td>
<td></td>
<td>9.634086</td>
<td></td>
</tr>

<tr>
<td>LEAF-CIRCUIT-TIME</td>
<td></td>
<td>0.7417668</td>
<td></td>
</tr>

<tr>
<td>LEAF-CONSTRAINTS</td>
<td></td>
<td>12524.312</td>
<td></td>
</tr>

<tr>
<td>LEAF-HASH-CIRCUIT-TIME</td>
<td></td>
<td>0.076994</td>
<td></td>
</tr>

<tr>
<td>LEAF-HASH-CONSTRAINTS</td>
<td></td>
<td>1300</td>
<td></td>
</tr>

<tr>
<td>LEAF-HASH-TIME</td>
<td></td>
<td>4.5608e-08</td>
<td></td>
</tr>

<tr>
<td>LEAF-TIME</td>
<td></td>
<td>4.3939139e-07</td>
<td></td>
</tr>

<tr>
<td>MALICIOUS-ENCODING</td>
<td></td>
<td>3302.5503</td>
<td></td>
</tr>

<tr>
<td>MAX-TICKETS</td>
<td></td>
<td>19.07985</td>
<td></td>
</tr>

<tr>
<td>MERKLE-HASH-CONSTRAINTS</td>
<td></td>
<td>1300</td>
<td></td>
</tr>

<tr>
<td>MERKLE-HASH-TIME</td>
<td></td>
<td>1.3078e-05</td>
<td></td>
</tr>

<tr>
<td>MERKLE-HASH-TIME-CIRCUIT</td>
<td></td>
<td>0.076994</td>
<td></td>
</tr>

<tr>
<td>MESSAGE-NONCE</td>
<td>BYTES</td>
<td>4</td>
<td>The size of a message&rsquo;s nonce.</td>
</tr>

<tr>
<td>MESSAGE-RECEIPT</td>
<td>BYTES</td>
<td>16</td>
<td>The size of one message receipt.</td>
</tr>

<tr>
<td>MESSAGE-RECEIPTS-CID</td>
<td>BYTES</td>
<td>35</td>
<td>The size of one message receipt&rsquo;s CID.</td>
</tr>

<tr>
<td>MESSAGE-SIZE</td>
<td>BYTES</td>
<td>106</td>
<td>The size of a single message.</td>
</tr>

<tr>
<td>MESSAGES</td>
<td></td>
<td>108.872795</td>
<td></td>
</tr>

<tr>
<td>MESSAGES-ROOT-CID</td>
<td>BYTES</td>
<td>35</td>
<td>Size of the CID of the root merkle tree of the messages.</td>
</tr>

<tr>
<td>MESSAGES-SIZE</td>
<td>BYTES</td>
<td>11540.517</td>
<td>The total size of the messages in a block.</td>
</tr>

<tr>
<td>MIB</td>
<td>BYTES</td>
<td>1048576</td>
<td>The number of bytes in one EiX.</td>
</tr>

<tr>
<td>MIN-TICKETS</td>
<td></td>
<td>0</td>
<td></td>
</tr>

<tr>
<td>MINER-ADDRESS-SIZE</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>MINERS</td>
<td></td>
<td>1000</td>
<td></td>
</tr>

<tr>
<td>NODE-SIZE</td>
<td></td>
<td>32</td>
<td></td>
</tr>

<tr>
<td>NODES</td>
<td></td>
<td>1073741824</td>
<td></td>
</tr>

<tr>
<td>OFFLINE-CHALLENGES</td>
<td></td>
<td>282.3536</td>
<td></td>
</tr>

<tr>
<td>ONE-BLOCK-IN-TEN-YEARS</td>
<td></td>
<td>9.506427e-09</td>
<td></td>
</tr>

<tr>
<td>ONLINE-CHALLENGES</td>
<td></td>
<td>136.53467</td>
<td></td>
</tr>

<tr>
<td>OPENING-PER-CHALLENGE</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>OPENINGS</td>
<td></td>
<td>4235.304</td>
<td></td>
</tr>

<tr>
<td>P-SIZE</td>
<td></td>
<td>35.0</td>
<td></td>
</tr>

<tr>
<td>PARALLEL-SEAL-TIME</td>
<td></td>
<td>8575.856</td>
<td></td>
</tr>

<tr>
<td>PARENT-WEIGHT-SIZE</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>PARENTS</td>
<td></td>
<td>5</td>
<td></td>
</tr>

<tr>
<td>PARENTS-CIDS</td>
<td></td>
<td>175</td>
<td></td>
</tr>

<tr>
<td>PIB</td>
<td></td>
<td>1125899906842624</td>
<td></td>
</tr>

<tr>
<td>POLLING-TIME</td>
<td></td>
<td>825.6376</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-CONSTRAINTS</td>
<td></td>
<td>295303680.0</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-PARTITIONS</td>
<td></td>
<td>2.9530368</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-PROOF-SIZE</td>
<td></td>
<td>566.98303</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-TIME</td>
<td></td>
<td>17489.703</td>
<td></td>
</tr>

<tr>
<td>POST-CHALLENGE-BLOCKS</td>
<td>BLOCKS</td>
<td>480</td>
<td>The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.</td>
</tr>

<tr>
<td>POST-CHALLENGE-HOURS</td>
<td>HOURS</td>
<td>2</td>
<td>PoSt challenge time (see POST_CHALLENGE_BLOCKS).</td>
</tr>

<tr>
<td>POST-CHALLENGE-TIME</td>
<td>SECONDS</td>
<td>7200</td>
<td>PoSt challenge time (see POST_CHALLENGE_BLOCKS).</td>
</tr>

<tr>
<td>POST-CHALLENGES</td>
<td></td>
<td>136.53467</td>
<td></td>
</tr>

<tr>
<td>POST-PROOF-SIZE</td>
<td></td>
<td>192</td>
<td></td>
</tr>

<tr>
<td>POST-PROVING-PERIOD</td>
<td>BLOCKS</td>
<td>5760</td>
<td>The time interval in which a PoSt has to be submitted</td>
</tr>

<tr>
<td>POST-SIZE-PER-BLOCK</td>
<td></td>
<td>2236.9622</td>
<td></td>
</tr>

<tr>
<td>POST-SNARK-CIRCUIT</td>
<td></td>
<td>5324852.0</td>
<td></td>
</tr>

<tr>
<td>POST-SNARK-PROOF-PARTITIONS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>POST-SNARK-PROOF-SIZE</td>
<td></td>
<td>192</td>
<td></td>
</tr>

<tr>
<td>POSTS-PER-SECTOR-PER-YEAR</td>
<td></td>
<td>365.25</td>
<td></td>
</tr>

<tr>
<td>PROOF-MESSAGES-FRACTION</td>
<td></td>
<td>0.4</td>
<td></td>
</tr>

<tr>
<td>PROOFGEN-TIME</td>
<td></td>
<td>17489.703</td>
<td></td>
</tr>

<tr>
<td>PROOFS-SIZE-PER-BLOCK</td>
<td></td>
<td>22555.621</td>
<td></td>
</tr>

<tr>
<td>PROOFS-SIZE-PER-BLOCK-KIB</td>
<td></td>
<td>22.026974</td>
<td></td>
</tr>

<tr>
<td>PROVING-PERIOD-HOURS</td>
<td></td>
<td>24</td>
<td></td>
</tr>

<tr>
<td>PROVING-PERIOD-SECONDS</td>
<td></td>
<td>86400</td>
<td></td>
</tr>

<tr>
<td>RECEIPTS</td>
<td></td>
<td>108.872795</td>
<td></td>
</tr>

<tr>
<td>RECEIPTS-SIZE</td>
<td></td>
<td>1741.9647</td>
<td>The total size of all message receipts, in bytes.</td>
</tr>

<tr>
<td>REPLICA-COMMIT-TIME</td>
<td></td>
<td>42598.98</td>
<td></td>
</tr>

<tr>
<td>RESEAL</td>
<td></td>
<td>0</td>
<td></td>
</tr>

<tr>
<td>RETURN</td>
<td>BYTES</td>
<td>4</td>
<td>The size of a message&rsquo;s return value.</td>
</tr>

<tr>
<td>RSA-ELEMENT</td>
<td>BYTES</td>
<td>256</td>
<td>The size of an RSA element.</td>
</tr>

<tr>
<td>SEAL-COMMITMENTS-SIZE</td>
<td></td>
<td>70</td>
<td></td>
</tr>

<tr>
<td>SEAL-PROOF-SIZE</td>
<td></td>
<td>636.98303</td>
<td></td>
</tr>

<tr>
<td>SEAL-SIZE-PER-BLOCK</td>
<td></td>
<td>20318.658</td>
<td></td>
</tr>

<tr>
<td>SEAL-TIME</td>
<td></td>
<td>66693.78</td>
<td></td>
</tr>

<tr>
<td>SEALS-PER-SECTOR-PER-YEAR</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>SECTOR-SIZE</td>
<td></td>
<td>34359738368</td>
<td></td>
</tr>

<tr>
<td>SECTOR-SIZE-GIB</td>
<td></td>
<td>32</td>
<td></td>
</tr>

<tr>
<td>SECTORS-COUNT</td>
<td></td>
<td>335544320</td>
<td></td>
</tr>

<tr>
<td>SNARK-MAX-CONSTRAINTS</td>
<td></td>
<td>100000000</td>
<td></td>
</tr>

<tr>
<td>SNARK-SINGLE-PROOF-SIZE</td>
<td></td>
<td>192</td>
<td></td>
</tr>

<tr>
<td>SPACEGAP</td>
<td></td>
<td>0.1</td>
<td></td>
</tr>

<tr>
<td>STATE-ROOT-CID</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>STORAGE-NETWORK-CAPACITY</td>
<td></td>
<td>1.152921504606847e+19</td>
<td></td>
</tr>

<tr>
<td>TIB</td>
<td></td>
<td>1099511627776</td>
<td></td>
</tr>

<tr>
<td>TICKET-SIZE</td>
<td></td>
<td>832</td>
<td></td>
</tr>

<tr>
<td>TICKETS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>TICKETS-SIZE</td>
<td></td>
<td>832</td>
<td></td>
</tr>

<tr>
<td>TIMESTAMP-SIZE</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>TO-ADDRESS</td>
<td>BYTES</td>
<td>35</td>
<td>The size of a message&rsquo;s &lsquo;from address&rsquo;.</td>
</tr>

<tr>
<td>TREE-DEPTH</td>
<td></td>
<td>30.0</td>
<td></td>
</tr>

<tr>
<td>TX-MESSAGES-FRACTION</td>
<td></td>
<td>0.3</td>
<td></td>
</tr>

<tr>
<td>TX-MESSAGES-PER-BLOCK</td>
<td></td>
<td>32.66184</td>
<td></td>
</tr>

<tr>
<td>U64</td>
<td></td>
<td>8</td>
<td>The size of a U64, in bytes.</td>
</tr>

<tr>
<td>VALUE</td>
<td>BYTES</td>
<td>8</td>
<td>The size of a &lsquo;value&rsquo; element.</td>
</tr>

<tr>
<td>VARINT</td>
<td>BYTES</td>
<td>4</td>
<td>The size of a VarInt.</td>
</tr>

<tr>
<td>VDF-OUTPUT-SIZE</td>
<td></td>
<td>0</td>
<td></td>
</tr>

<tr>
<td>VDF-PROOF-SIZE</td>
<td></td>
<td>768</td>
<td></td>
</tr>

<tr>
<td>YEAR-IN-SECONDS</td>
<td>SECONDS</td>
<td>31557600.0</td>
<td>The number of seconds in one year.</td>
</tr>
</tbody>
</table>

<h4 id="effect-of-space-gap-and-sector-size-on-block-size-dot">Effect of Space Gap and Sector Size on Block Size.</h4>

<table>
<thead>
<tr>
<th>LAMBDA</th>
<th>SPACEGAP</th>
<th>BLOCK-SIZE-KIB</th>
<th>SECTOR-SIZE-GIB</th>
</tr>
</thead>

<tbody>
<tr>
<td>10</td>
<td>0.2</td>
<td>2.0183308</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>2.1250708</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>2.2424922</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>2.2729497</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>2.5627122</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>2.6715527</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>2.7350836</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>2.847705</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>3.0063488</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>3.2539802</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>3.589003</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>3.8169022</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>3.9404943</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>4.2021575</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>4.3927507</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>4.730614</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>4.7323604</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>4.7720346</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>5.3342724</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>5.501524</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>5.57777</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>5.829611</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>5.94944</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>6.9545097</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>7.102623</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>7.638206</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>7.960858</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>8.008982</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>8.787309</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>8.827972</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>9.263679</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>9.3208065</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>10.384581</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>10.399412</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>10.503603</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>12.190317</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>12.920809</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>13.331349</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>13.4014015</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>13.676332</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>15.2998495</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>15.598608</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>16.252815</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>17.561655</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>17.942131</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>20.070072</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>22.549423</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>22.671417</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>23.978535</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>24.036263</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>24.376612</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>25.470312</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>27.385735</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>28.776114</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>29.061607</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>30.596579</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>32.48009</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>34.33397</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>36.181545</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>36.3917</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>42.983322</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>46.211964</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>46.80707</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>48.038197</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>48.872463</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>54.612484</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>55.240646</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>58.89311</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>62.670723</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>69.31734</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>72.59843</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>82.51584</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>87.89453</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>87.977234</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>94.63942</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>107.03619</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>107.64613</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>114.18173</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>131.21773</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>140.30208</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>160.02498</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>175.19678</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>176.24756</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>177.6102</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>209.20566</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>238.65137</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>259.8711</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>340.8757</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>357.2812</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>406.86823</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>434.17523</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>529.018</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>695.79944</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>794.4138</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>1293.6443</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>2639.3792</td>
<td>32</td>
</tr>
</tbody>
</table>

<h4 id="parameter-definitions">Parameter Definitions</h4>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Assumptions:
  CID [CRH]:
    declare(cid_size, bytes)
    describe(cid_size, &#34;The size of a CID.&#34;, bytes)
    cid_size = 32 + 1 + 1 + 1

  SLE [VRF]:
    declare(vrf_proof_size) // TODO
    describe(vrf_proof_size, &#34;The size of a VRF proof.&#34;, bytes)

Primitives:
  declare(varint, bytes)
  describe(varint, &#34;The size of a VarInt.&#34;, bytes)
  varint = 4

  u64 = 8
  describe(u64, &#34;The size of a U64, in bytes.&#34;)

  Dimensions:
    Size:
      kib = 1024
      describe (kib, &#34;The number of bytes in one KiB.&#34;, bytes)

      mib = 1024 * kib
      describe (mib, &#34;The number of bytes in one MiB.&#34;, bytes)

      gib = 1024 * mib
      describe (mib, &#34;The number of bytes in one GiB.&#34;, bytes)

      tib = 1024 * gib
      describe (mib, &#34;The number of bytes in one TiB.&#34;, bytes)

      pib = 1024 * tib
      describe (mib, &#34;The number of bytes in one PiB.&#34;, bytes)

      eix = 1024 * pib
      describe (mib, &#34;The number of bytes in one EiX.&#34;, bytes)
    Time:
      year_in_seconds = 365.25 * 24 * 60 * 60
      describe(year_in_seconds, &#34;The number of seconds in one year.&#34;, seconds)

VDFRSA:
  declare(rsa_element, bytes)
  describe(rsa_element, &#34;The size of an RSA element.&#34;, bytes)
  rsa_element = (2048/8)

Blockchain:
  declare(block_time, seconds)
  Address:
    address_size = cid_size
    describe(address_size, &#34;The size of an address.&#34;, bytes)

  Block:
    block_framing_size = block_header_size + messages_size + receipts_size
    describe(block_framing_size, &#34;The total amount of block framing.&#34;, bytes)

    Messages:
      // declare(messages, integer) // TODO
      messages_size = messages * message_size
      describe(messages_size, &#34;The total size of the messages in a block.&#34;, bytes)

      messages_root_cid = cid_size
      describe(messages_root_cid, &#34;Size of the CID of the root merkle tree of the messages.&#34;, bytes)

      Message:
        message_size = to_address + from_address + message_nonce + value + gas_price + gas_limit + actor_method
        describe(message_size, &#34;The size of a single message.&#34;, bytes)

        to_address = address_size
        describe(to_address, &#34;The size of a message&#39;s &#39;to address&#39;.&#34;, bytes)

        from_address = address_size
        describe(to_address, &#34;The size of a message&#39;s &#39;from address&#39;.&#34;, bytes)

        Nonce:
          declare(message_nonce, bytes) // TODO
          describe(message_nonce, &#34;The size of a message&#39;s nonce.&#34;, bytes)
          message_nonce = varint

        Value:
          declare(value, bytes)
          describe(value, &#34;The size of a &#39;value&#39; element.&#34;, bytes)
          value = u64

        Gas:
          declare(gas_price, bytes)
          describe(gas_price, &#34;The size required to represent the gas price.&#34;, bytes)
          gas_price = u64

          declare(gas_limit, bytes)
          describe(gas_price, &#34;The size required to represent the gas limit.&#34;, bytes)
          gas_limit = u64

        ActorMethod:
          declare(actor_method, bytes) // TODO: actor_method what is it? how big is it?
          actor_method = u64
          describe(actor_method, &#34;The size required to represent an actor method.&#34;, bytes)

    Receipts:
      receipts = messages // TODO check
      // declare(receipts, integer) // TODO
      receipts_size = receipts * message_receipt
      describe(receipts_size, &#34;The total size of all message receipts, in bytes.&#34;)
      message_receipts_cid = cid_size
      describe(message_receipts_cid, &#34;The size of one message receipt&#39;s CID.&#34;, bytes)

      Receipt:
        message_receipt = exit_code + return + gas_used
        describe(message_receipt, &#34;The size of one message receipt.&#34;, bytes)

        // declare(exit_code, bytes) // TODO
        exit_code = varint
        describe(exit_code, &#34;The size of an exit code.&#34;, bytes)
        // declare(return, bytes) // TODO
        return = varint
        describe(return, &#34;The size of a message&#39;s return value.&#34;, bytes)

        // declare(gas_used, bytes) // TODO
        gas_used = u64
        describe(gas_used, &#34;The size required to represent the amount of gas used by a message.&#34;, bytes)

    BlockHeader (EC):
      declare(block_header_size, bytes)
      assume(block_header_size &gt; 0)
      assume(block_header_size &lt; 1024*1024*10) // assume max is 10MB

      block_header_size = block_header_fixed_size + block_header_variable_size
      block_header_fixed_size = miner_address_size + election_proof_size + parent_weight_size + block_height_size + state_root_cid + messages_root_cid + bls_agg_size + message_receipts_cid + timestamp_size + block_sig_size
      block_header_variable_size = tickets_size + parents_cids

      StateTree:
        state_root_cid = cid_size

      Weight:
        declare(parent_weight_size, bytes) // TODO
        parent_weight_size = u64

      Height:
        declare(block_height_size, bytes) // TODO
        block_height_size = u64

      MinerAddress [CID]:
        miner_address_size = address_size

      ElectionProof (VRFBls) [SLE, BLSSig]:
        declare(election_proof_size, bytes) // TODO
        election_proof_size = 64

      // ElectionProof (VRFSecpk) [SLE, Secpk]:
      //   declare(election_proof_size, bytes) // TODO
      //   election_proof_size = 80

      Parents [CID]:
        // declare(parents, integer) // TODO
        parents = expected_winning_miners
        parents_cids = parents * cid_size

      BLSSignatures (BLSSigAgg) [BLSSigAgg]:
        declare(bls_agg_size, bytes) // TODO
        bls_agg_size = 96

      Timestamp:
        // declare(timestamp_size, integer) // TODO
        timestamp_size = u64

      // BlockSig (BlockSigSecpk):
        // declare(block_sig_size, integer) // TODO
        // block_sig_size = 80

      BlockSig (BlockSigBls):
        declare(block_sig_size, integer) // TODO
        block_sig_size = 96

      Tickets:
        // declare(tickets, integer)
        declare(tickets_size, bytes)
        tickets_size = ticket_size * tickets
        ticket_size = election_proof_size + vdf_proof_size + vdf_output_size

SNARK [SNARKAssumptions]:
  declare(snark_single_proof_size, bytes)
  snark_single_proof_size = 192
  snark_max_constraints = 100000000

// VDF (VDFStorageBased):
//   vdf_proof_size = (vdf_snark_circuit / snark_max_constraints) * snark_single_proof_size
//   vdf_output_size = hash_size

VDF (VDFRSA):
  vdf_proof_size = 3 * rsa_element
  vdf_output_size = 0

Proofs:
  ProofOfReplication:
    Graph:
      // declare(node_size, integer)
      // declare(sector_size, integer)
      // declare(nodes, integer)
      nodes = sector_size / node_size
      degree = degree_base + degree_expander
      sector_size_gib = sector_size / gib

      DRG (DRSample) [DRGAssumption]:
        // declare(degree_base, integer)
        drg_e = 0.80
        drg_d = 1/4

      ExpanderParents (Chung) [ChungAssumption]:
        // declare(degree_expander, integer)

      Layers:
        // declare(layers, integer)
        assume(layers &gt; 0)

    Soundness:
      // declare(lambda, integer)
      assume(soundness &gt; 0)
      assume(soundness &lt; 0.5)
      soundness = 1/(2^lambda)

    SpaceGap:
      assume(spacegap &gt; 0)
      assume(spacegap &lt; 0.5)

    Challenges:
      OfflineChallenges:
        // declare(offline_challenges, integer)
        // declare(offline_challenges_all, integer)
        assume(offline_challenges &gt; 0)

      OnlineChallenges:
        // declare(online_challenges, integer)
        assume(online_challenges &gt; 0)

    Seal:
      Encoding [KDFTiming]:
        assume(kdf_content &gt; 0)
        assume(encoding_time &gt; 0)
        assume(polling_time &gt; 0)
        kdf_content = degree + 1
        encoding_time = layers * nodes * (kdf_content - 1) * kdf_hash_time * (node_size / kdf_hash_size)
        encoding_time_mins = encoding_time / 60
        malicious_encoding = encoding_time / encoding_amax
        polling_time = malicious_encoding * drg_d

    Commitment (ColumnCommitments) [CRH]:
      commit_size = cid_size
      assume(replica_commit_time &gt; 0)
      replica_commit_time = commit_time * 3 + leaf_time * nodes
      seal_commitments_size = commit_size * 2 // 1 commD, 1 CommR

    ProofGeneration (ColumnCommitments):
      assume(opening_time &gt; 0)
      openings = offline_challenges * opening_per_challenge

      Leaf:
        leaf_constraints =  layers * leaf_hash_constraints
        leaf_circuit_time = layers * leaf_hash_circuit_time
        leaf_time = layers * leaf_hash_time

      Inclusion (MerkleVC) [CRH]:
        // declare(tree_depth, integer)
        tree_depth = (log2(nodes))
        inclusion_circuit_time = tree_depth * merkle_hash_time_circuit
        inclusion_constraints = tree_depth * merkle_hash_constraints
        commit_time = nodes * merkle_hash_time

      SNARK [SNARKAssumptions]:
        comm_d_openings = 1
        comm_d_time = offline_challenges * (comm_d_openings * inclusion_circuit_time)
        comm_d_constraints = offline_challenges * (comm_d_openings * inclusion_constraints)

        comm_r_openings = degree_base
        comm_r_time = offline_challenges * (comm_r_openings * inclusion_circuit_time)
        comm_r_constraints = offline_challenges * (comm_r_openings * inclusion_constraints)

        comm_c_openings = opening_per_challenge
        comm_c_time = offline_challenges * (comm_c_openings * (inclusion_circuit_time + leaf_circuit_time))
        comm_c_constraints = offline_challenges * (comm_c_openings * (inclusion_constraints + leaf_constraints))

        porep_snark_time = comm_d_time + comm_r_time + comm_c_time
        porep_snark_constraints = comm_d_constraints + comm_r_constraints + comm_c_constraints

        porep_snark_partitions = porep_snark_constraints / snark_max_constraints
        porep_snark_proof_size = porep_snark_partitions * snark_single_proof_size

        proofgen_time = porep_snark_time

    Size:
      seal_proof_size = porep_snark_proof_size + seal_commitments_size

    Time:
      seal_time = replica_commit_time + proofgen_time + encoding_time
      parallel_seal_time = (porep_snark_time + commit_time)/cores + encoding_time
      declare(unseal_time) // TODO

    Cost:
      seal_cost = seal_time * (cpu_cost_per_second + memory_cost_per_second)
      declare(unseal_cost) // TODO

  ProofOfReplication (SDR):
    Graph:
      Layers:
        layers = layers_b // TODO max(layers_a, layers_b) + 1
        layers_a = (0.68 - epsilon + delta) / (0.12 - delta)
        layers_b = (log2(1 / (3 * (epsilon - 2 * delta)))) + 0.12 / (0.12 - delta) + 1

    SpaceGap:
      assume(epsilon &lt;= 0.24)
      // delta &lt; epsilon/2
      // delta = epsilon/2 + 0.001
      // spacegap = epsilon + 2 * delta
      spacegap = 2 * epsilon - 0.001
      delta = epsilon/2 - 0.001

    Challenges:
      OfflineChallenges:
        offline_challenges = (- lambda) / (log2(1 - delta))

      OnlineChallenges:
        online_challenges = (- lambda) / (log2(2 - epsilon - 2 * delta) - 1)

    ProofGeneration (ColumnCommitments):
      opening_per_challenge = degree_base + degree_expander + 1

  ProofOfSpacetime:
    Randomness [RandomBeacon]:
      declare(post_randomness_lookback)

    Parameters:
      declare(proving_period_hours)
      declare(max_proving_sectors)

      declare(post_challenge_blocks)
      describe(post_challenge_blocks, &#34;The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.&#34;, blocks)

      describe(post_challenge_time, &#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;, seconds)
      post_challenge_time = post_challenge_blocks * block_time
      post_challenge_time = post_challenge_hours * 60 * 60
      describe(post_challenge_hours &#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;, hours)

  ProofOfSpacetime (RationalPoSt):
    Parameters:
      post_challenges = online_challenges
      post_proving_period = proving_period_seconds / block_time
      describe(post_proving_period, &#34;The time interval in which a PoSt has to be submitted&#34;, blocks)

    Cost:
      declare(post_proving_cost)

    SNARK:
      post_snark_circuit = online_challenges * inclusion_constraints

    Size:
      post_proof_size = post_snark_proof_size
      post_snark_proof_partitions = 1 // TODO post_snark_circuit / snark_max_constraints
      post_snark_proof_size = post_snark_proof_partitions * snark_single_proof_size


Consensus [ProofOfReplication, ProofOfSpacetime]:
  // declare(expected_winning_miners, integer)
  // declare(finality_height, integer)
  Tickets:
    tickets = avg_tickets
    avg_tickets = 1
    min_tickets = 0
    max_tickets = log(one_block_in_ten_years)/log(0.36) + 1 // 0.36^(max_tickets-1) = one_block_in_ten_years
    blocks_in_a_year = (year_in_seconds / block_time) * expected_winning_miners
    blocks_in_ten_years = blocks_in_a_year * 10
    one_block_in_ten_years = 1/blocks_in_ten_years

StorageMarket:
  declare(min_storing_time)
  Deals (OnChainDeals):
    comm_p_size = cid_size
    declare(p_size, 1)
    p_size = (log2(sector_size))
    sector_manifest_size = pieces * comm_p_size + p_size
    max_sector_manifest_hashes = sector_size / min_piece_size


Mining:
  proving_period_seconds = proving_period_hours * 60 * 60

  seals_per_sector_per_year = reseal+1
  posts_per_sector_per_year = year_in_seconds / proving_period_seconds

ScalingRequirements:
  storage_network_capacity = 10 * eix

ChainBandwidth:
  sectors_count = storage_network_capacity / sector_size
  all_seal_size_per_year = all_seal_messages_per_year
  all_seal_messages_per_year = sectors_count * seals_per_sector_per_year
  all_post_messages_per_year = sectors_count * posts_per_sector_per_year / miners

  Chain Size:

  Block Size:
    chain_size_year = block_size * blocks_in_a_year
    chain_size_year_gib = chain_size_year / gib
    block_size_kib = block_size / kib

  Block Content:
    block_size = block_framing_size + proofs_size_per_block
    messages = avg_proofs_messages_per_block + tx_messages_per_block + actors_messages_per_block // TODO messages dont include deals

    Proofs:
      avg_proofs_messages_per_block = avg_seals_messages_per_block + avg_posts_messages_per_block
      avg_seals_messages_per_block = all_seal_messages_per_year / blocks_in_a_year
      avg_posts_messages_per_block = all_post_messages_per_year / blocks_in_a_year

      seal_size_per_block = avg_seals_messages_per_block * seal_proof_size
      post_size_per_block = avg_posts_messages_per_block * post_proof_size
      proofs_size_per_block = seal_size_per_block + post_size_per_block
      proofs_size_per_block_kib = proofs_size_per_block / kib

    Composition:
      avg_proofs_messages_per_block = proof_messages_fraction * messages
      tx_messages_per_block = tx_messages_fraction * messages
      actors_messages_per_block = actors_messages_fraction * messages</code></pre></div>
<h4 id="parsed-parameter-definitions">Parsed Parameter Definitions</h4>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Assumptions&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;cid&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;cidSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a CID.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">},</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;cidSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ 32 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;cidSize.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ cid-size.tmp1% 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;cidSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ cid-size.tmp2% 1)&#34;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;sle&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;vrfProofSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a VRF proof.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Primitives&#34;</span><span class="p">,</span>
      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;u64&#34;</span><span class="p">,</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a U64, in bytes.&#34;</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;varint&#34;</span><span class="p">,</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a VarInt.&#34;</span><span class="p">,</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">},</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;varint&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 4)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;u64&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 8)&#34;</span>
      <span class="p">},</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Dimensions&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Size&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one EiX.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one PiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one TiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one GiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one MiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;kib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one KiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;kib&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1024)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;mib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 kib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;gib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 mib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;tib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 gib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;pib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 tib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;eix&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 pib)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Time&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;yearInSeconds&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of seconds in one year.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;seconds&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;yearInSeconds.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 365.25 24)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;yearInSeconds.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* year-in-seconds.tmp1% 60)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;yearInSeconds&#34;</span><span class="p">:</span> <span class="s2">&#34;(* year-in-seconds.tmp2% 60)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;vdfrsa&#34;</span><span class="p">,</span>
      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;rsaElement&#34;</span><span class="p">,</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of an RSA element.&#34;</span><span class="p">,</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">},</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;rsaElement&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 2048 8)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Blockchain&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Address&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;addressSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of an address.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">},</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;addressSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Block&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;blockFramingSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The total amount of block framing.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">},</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;blockFramingSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-size messages-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blockFramingSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-framing-size.tmp1% receipts-size)&#34;</span>
          <span class="p">},</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Messages&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messagesRootCid&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;Size of the CID of the root merkle tree of the messages.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messagesSize&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The total size of the messages in a block.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;messagesSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* messages message-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;messagesRootCid&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Message&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                    <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;toAddress&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s &#39;from address&#39;.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;toAddress&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s &#39;to address&#39;.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageSize&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a single message.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">}</span>
                    <span class="p">]</span>
                  <span class="p">},</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;messageSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ to-address from-address)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp1% message-nonce)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp2% value)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp3% gas-price)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp4% gas-limit)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp5% actor-method)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;toAddress&#34;</span><span class="p">:</span> <span class="s2">&#34;(== address-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;fromAddress&#34;</span><span class="p">:</span> <span class="s2">&#34;(== address-size)&#34;</span>
                  <span class="p">},</span>
                  <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Nonce&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageNonce&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s nonce.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;messageNonce&#34;</span><span class="p">:</span> <span class="s2">&#34;(== varint)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">},</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Value&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;value&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a &#39;value&#39; element.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;value&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">},</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Gas&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gasPrice&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent the gas limit.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">},</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gasPrice&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent the gas price.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;gasPrice&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;gasLimit&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">},</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ActorMethod&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;actorMethod&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent an actor method.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;actorMethod&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">}</span>
                  <span class="p">]</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Receipts&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageReceiptsCid&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of one message receipt&#39;s CID.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;receiptsSize&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The total size of all message receipts, in bytes.&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;receipts&#34;</span><span class="p">:</span> <span class="s2">&#34;(== messages)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;receiptsSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* receipts message-receipt)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;messageReceiptsCid&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Receipt&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                    <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gasUsed&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent the amount of gas used by a message.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;return&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s return value.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;exitCode&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of an exit code.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageReceipt&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of one message receipt.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">}</span>
                    <span class="p">]</span>
                  <span class="p">},</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;messageReceipt.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ exit-code return)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageReceipt&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-receipt.tmp1% gas-used)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;exitCode&#34;</span><span class="p">:</span> <span class="s2">&#34;(== varint)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;return&#34;</span><span class="p">:</span> <span class="s2">&#34;(== varint)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;gasUsed&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;BlockHeader&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;blockHeaderSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size block-header-variable-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ miner-address-size election-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp1% parent-weight-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp2% block-height-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp3% state-root-cid)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp4% messages-root-cid)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp5% bls-agg-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp7%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp6% message-receipts-cid)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp8%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp7% timestamp-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp8% block-sig-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderVariableSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ tickets-size parents-cids)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;StateTree&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;stateRootCid&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Weight&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;parentWeightSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Height&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;blockHeightSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;MinerAddress&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;minerAddressSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== address-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ElectionProof&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;electionProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Parents&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;parents&#34;</span><span class="p">:</span> <span class="s2">&#34;(== expected-winning-miners)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;parentsCids&#34;</span><span class="p">:</span> <span class="s2">&#34;(* parents cid-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;blsSignatures&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;blsAggSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 96)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Timestamp&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;timestampSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;BlockSig&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;blockSigSizeInteger%&#34;</span><span class="p">:</span> <span class="s2">&#34;(integer block-sig-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;blockSigSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 96)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Tickets&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;ticketsSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* ticket-size tickets)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;ticketSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ election-proof-size vdf-proof-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;ticketSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ ticket-size.tmp1% vdf-output-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;snark&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;snarkSingleProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 192)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;snarkMaxConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 100000000)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;vdf&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;vdfProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 3 rsa-element)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;vdfOutputSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 0)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Proofs&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfReplication&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Graph&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;nodes&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ sector-size node-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;degree&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ degree-base degree-expander)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sectorSizeGib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ sector-size gib)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;drg&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;drgE&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 0.8)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;drgD&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 4)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ExpanderParents&#34;</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Layers&#34;</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Soundness&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;soundness&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 soundness.tmp1%)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;SpaceGap&#34;</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Challenges&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OfflineChallenges&#34;</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OnlineChallenges&#34;</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Seal&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Encoding&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;kdfContent&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ degree 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- kdf-content 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ node-size kdf-hash-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers nodes)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* encoding-time.tmp4% encoding-time.tmp1%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* encoding-time.tmp5% kdf-hash-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* encoding-time.tmp6% encoding-time.tmp2%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTimeMins&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ encoding-time 60)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;maliciousEncoding&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ encoding-time encoding-amax)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;pollingTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* malicious-encoding drg-d)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Commitment&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;commitSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;replicaCommitTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* commit-time 3)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;replicaCommitTime.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* leaf-time nodes)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;replicaCommitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ replica-commit-time.tmp1% replica-commit-time.tmp2%)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealCommitmentsSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* commit-size 2)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofGeneration&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;openings&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges opening-per-challenge)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Leaf&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;leafConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers leaf-hash-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;leafCircuitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers leaf-hash-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;leafTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers leaf-hash-time)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Inclusion&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;treeDepth&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 nodes)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;inclusionCircuitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* tree-depth merkle-hash-time-circuit)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;inclusionConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* tree-depth merkle-hash-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* nodes merkle-hash-time)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;snark&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;commDOpenings&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-d-openings inclusion-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-d-time.tmp1%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDConstraints.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-d-openings inclusion-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-d-constraints.tmp2%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commROpenings&#34;</span><span class="p">:</span> <span class="s2">&#34;(== degree-base)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRTime.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-r-openings inclusion-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-r-time.tmp3%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRConstraints.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-r-openings inclusion-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-r-constraints.tmp4%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCOpenings&#34;</span><span class="p">:</span> <span class="s2">&#34;(== opening-per-challenge)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCTime.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ inclusion-circuit-time leaf-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCTime.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-c-openings comm-c-time.tmp6%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-c-time.tmp5%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCConstraints.tmp8%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ inclusion-constraints leaf-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCConstraints.tmp7%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-c-openings comm-c-constraints.tmp8%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-c-constraints.tmp7%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkTime.tmp9%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ comm-d-time comm-r-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-time.tmp9% comm-c-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkConstraints.tmp10%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ comm-d-constraints comm-r-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-constraints.tmp10% comm-c-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkPartitions&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ porep-snark-constraints snark-max-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* porep-snark-partitions snark-single-proof-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;proofgenTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(== porep-snark-time)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Size&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;sealProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-proof-size seal-commitments-size)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Time&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;sealTime.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ replica-commit-time proofgen-time)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ seal-time.tmp3% encoding-time)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;parallelSealTime.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-time commit-time)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;parallelSealTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ parallel-seal-time.tmp2% cores)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;parallelSealTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ parallel-seal-time.tmp1% encoding-time)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Cost&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;sealCost.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ cpu-cost-per-second memory-cost-per-second)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealCost&#34;</span><span class="p">:</span> <span class="s2">&#34;(* seal-time seal-cost.tmp1%)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfReplication&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Graph&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Layers&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;layers&#34;</span><span class="p">:</span> <span class="s2">&#34;(== layers-b)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0.68 epsilon)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ layers-a.tmp2% delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0.12 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ layers-a.tmp1% layers-a.tmp3%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp8%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 2 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp7%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- epsilon layers-b.tmp8%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 3 layers-b.tmp7%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 layers-b.tmp6%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 layers-b.tmp5%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp10%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0.12 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp9%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 0.12 layers-b.tmp10%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp15%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ layers-b.tmp4% layers-b.tmp9%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ layers-b.tmp15% 1)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;SpaceGap&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;spacegap.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 2 epsilon)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;spacegap&#34;</span><span class="p">:</span> <span class="s2">&#34;(- spacegap.tmp1% 0.001)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;delta.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ epsilon 2)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;delta&#34;</span><span class="p">:</span> <span class="s2">&#34;(- delta.tmp2% 0.001)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Challenges&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OfflineChallenges&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;offlineChallenges.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0 lambda)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;offlineChallenges.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 1 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;offlineChallenges.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 offline-challenges.tmp3%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;offlineChallenges&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ offline-challenges.tmp1% offline-challenges.tmp2%)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OnlineChallenges&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;onlineChallenges.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0 lambda)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 2 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp4%.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 2 epsilon)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- online-challenges.tmp4%.tmp6% online-challenges.tmp5%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 online-challenges.tmp4%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- online-challenges.tmp3% 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ online-challenges.tmp1% online-challenges.tmp2%)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofGeneration&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;openingPerChallenge.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ degree-base degree-expander)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;openingPerChallenge&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ opening-per-challenge.tmp1% 1)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfSpacetime&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Randomness&#34;</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Parameters&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postChallengeHours&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;hours&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postChallengeTime&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;seconds&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postChallengeBlocks&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;blocks&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postChallengeTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* post-challenge-time.tmp1% 60)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postChallengeTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* post-challenge-hours 60)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfSpacetime&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Parameters&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postProvingPeriod&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The time interval in which a PoSt has to be submitted&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;blocks&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postChallenges&#34;</span><span class="p">:</span> <span class="s2">&#34;(== online-challenges)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postProvingPeriod&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ proving-period-seconds block-time)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Cost&#34;</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;snark&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postSnarkCircuit&#34;</span><span class="p">:</span> <span class="s2">&#34;(* online-challenges inclusion-constraints)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Size&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== post-snark-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postSnarkProofPartitions&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postSnarkProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* post-snark-proof-partitions snark-single-proof-size)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Consensus&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Tickets&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;tickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(== avg-tickets)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;avgTickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;minTickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 0)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log one-block-in-ten-years)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log 0.36)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ max-tickets.tmp2% max-tickets.tmp3%)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ max-tickets.tmp1% 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blocksInAYear.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ year-in-seconds block-time)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blocksInAYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(* blocks-in-a-year.tmp4% expected-winning-miners)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blocksInTenYears&#34;</span><span class="p">:</span> <span class="s2">&#34;(* blocks-in-a-year 10)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;oneBlockInTenYears&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 blocks-in-ten-years)&#34;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;StorageMarket&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Deals&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;commPSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;pSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 sector-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;sectorManifestSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* pieces comm-p-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;sectorManifestSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ sector-manifest-size.tmp1% p-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxSectorManifestHashes&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ sector-size min-piece-size)&#34;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Mining&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;provingPeriodSeconds.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* proving-period-hours 60)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;provingPeriodSeconds&#34;</span><span class="p">:</span> <span class="s2">&#34;(* proving-period-seconds.tmp1% 60)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;sealsPerSectorPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ reseal 1)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;postsPerSectorPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ year-in-seconds proving-period-seconds)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ScalingRequirements&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;storageNetworkCapacity&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 10 eix)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ChainBandwidth&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;sectorsCount&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ storage-network-capacity sector-size)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allSealSizePerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(== all-seal-messages-per-year)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allSealMessagesPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(* sectors-count seals-per-sector-per-year)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allPostMessagesPerYear.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* sectors-count posts-per-sector-per-year)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allPostMessagesPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ all-post-messages-per-year.tmp1% miners)&#34;</span>
      <span class="p">},</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Chain&#34;</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Block&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;chainSizeYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(* block-size blocks-in-a-year)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;chainSizeYearGib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ chain-size-year gib)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blockSizeKib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ block-size kib)&#34;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Block&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;blockSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-framing-size proofs-size-per-block)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;messages.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ avg-proofs-messages-per-block tx-messages-per-block)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;messages&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ messages.tmp1% actors-messages-per-block)&#34;</span>
          <span class="p">},</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Proofs&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;avgProofsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ avg-seals-messages-per-block avg-posts-messages-per-block)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;avgSealsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ all-seal-messages-per-year blocks-in-a-year)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;avgPostsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ all-post-messages-per-year blocks-in-a-year)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealSizePerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* avg-seals-messages-per-block seal-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postSizePerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* avg-posts-messages-per-block post-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;proofsSizePerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ seal-size-per-block post-size-per-block)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;proofsSizePerBlockKib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ proofs-size-per-block kib)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Composition&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;avgProofsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* proof-messages-fraction messages)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;txMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* tx-messages-fraction messages)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;actorsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* actors-messages-fraction messages)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span></code></pre></div>

</div>



</div>

  


</div>

  


</div>

</div>

</article>

      

      
    </div>

    
  



  </main>

  
  
</body>

</html>
