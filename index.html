<!DOCTYPE html>
<html lang="en">

<head>
	<meta name="generator" content="Hugo 0.58.2" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Filecoin Specification | Filecoin Spec</title>



<link rel="stylesheet" href="./book.min.3d86abdf7c40450032cdf5d2102c7d79cf825523eec169b72903b5e161959bff.css">
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=EB+Garamond" />


<link rel="icon" href="./favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="./index.xml" title="Filecoin Spec" />

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="./gumshoe.polyfills.min.js"></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="./css/syntax.css">
<link href="./mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="./mermaid/mermaid.js"></script>
<script src="./spec.js"></script>

</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href=""><span>Filecoin Spec</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  
    
    
  

  <style>
  nav ul a[href="\2f "] {
      color: #0b3a53;
  }
  </style>


  <div id="menu-toc">

  <div>
    
    <input id="menu-detail-slider" type="range" onchange="onMenuDetailChange();"
      min="1" value="3" max="5" step="1" />

    <span id="menu-detail-slider-label">3</span>
  </div>

  
  
  <ul class="menu-item-section depth-0">
  
      <li>
      
        











<a href="./#intro" class="menu-item depth-1">
    
    
    <strong>
    
        Introduction
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#intro__arch" class="menu-item depth-2">
    
    
        Architecture Diagrams
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__concepts" class="menu-item depth-2">
    
    
        Key Concepts
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__filecoin_vm" class="menu-item depth-2">
    
    
        Filecoin VM
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process" class="menu-item depth-2">
    
    
        Process
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#intro__process__about" class="menu-item depth-3">
    
    
        About
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process__fip" class="menu-item depth-3">
    
    
        FIPs
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process__contributing" class="menu-item depth-3">
    
    
        Contributing
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources" class="menu-item depth-3">
    
    
        Related Resources
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#intro__process__related_resources__research_portal" class="menu-item depth-4">
    
    
        Research portal
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources__network_tooling" class="menu-item depth-4">
    
    
        Network tooling
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources__testing" class="menu-item depth-4">
    
    
        Testing and implementation compliance
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__system" class="menu-item depth-2">
    
    
        System Decomposition
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#intro__system__why_systems" class="menu-item depth-3">
    
    
        What are Systems?
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__system__impl_systems" class="menu-item depth-3">
    
    
        Implementing Systems
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#systems" class="menu-item depth-1">
    
    
    <strong>
    
        Systems
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#systems__filecoin_nodes" class="menu-item depth-2">
    ‚öôÔ∏è
    
        <strong>Filecoin Nodes</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types" class="menu-item depth-3">
    
    
        Node Types
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__node" class="menu-item depth-4">
    
    
        Node Interface
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__node_types" class="menu-item depth-4">
    
    
        Examples
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__verifier_node" class="menu-item depth-4">
    
    
        Chain Verifier Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__client_node" class="menu-item depth-4">
    
    
        Client Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__storage_miner_node" class="menu-item depth-4">
    
    
        Storage Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__retrieval_miner_node" class="menu-item depth-4">
    
    
        Retrieval Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__relayer_node" class="menu-item depth-4">
    
    
        Relayer Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository" class="menu-item depth-3">
    
    
        Repository
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository__config" class="menu-item depth-4">
    
    
        Config
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__repository__key" class="menu-item depth-4">
    
    
        KeyStore &amp; user keys
    
</a>



<ul class="menu-item-section depth-4">

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository__ipldstore" class="menu-item depth-4">
    
    
        IpldStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__repository__usage" class="menu-item depth-4">
    
    
        Usage in Systems
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__network" class="menu-item depth-3">
    
    
        Network Interface
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__clock" class="menu-item depth-3">
    
    
        Clock
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files" class="menu-item depth-2">
    üìë
    
        <strong>Files &amp; Data</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_files__file" class="menu-item depth-3">
    
    
        File
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_files__file__filestore" class="menu-item depth-4">
    
    
        FileStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files__piece" class="menu-item depth-3">
    
    
        Piece
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_files__piece__piece_store" class="menu-item depth-4">
    
    
        PieceStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files__data_transfer" class="menu-item depth-3">
    
    
        Data Transfer
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm" class="menu-item depth-2">
    üíª
    
        <strong>Virtual Machine</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_vm__actor" class="menu-item depth-3">
    
    
        Actor
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_vm__actor__address" class="menu-item depth-4">
    
    
        Address
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__state_tree" class="menu-item depth-3">
    
    
        State Tree
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__message" class="menu-item depth-3">
    
    
        Message
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime" class="menu-item depth-3">
    
    
        Runtime
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime__exitcode" class="menu-item depth-4">
    
    
        Exit Codes
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime__gascost" class="menu-item depth-4">
    
    
        Gas Costs
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors" class="menu-item depth-3">
    
    
        System Actors
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__init_actor" class="menu-item depth-4">
    
    
        InitActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__cron_actor" class="menu-item depth-4">
    
    
        CronActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__account_actor" class="menu-item depth-4">
    
    
        AccountActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__interpreter" class="menu-item depth-3">
    
    
        Interpreter
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

    <li>
    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain" class="menu-item depth-2">
    üì¶
    
        <strong>Blockchain</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct" class="menu-item depth-3">
    
    
        Blocks
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block" class="menu-item depth-4">
    
    
        Block
    
</a>



<ul class="menu-item-section depth-4">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block__tipset" class="menu-item depth-5">
    
    
        Tipset
    
</a>



<ul class="menu-item-section depth-5">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__chain" class="menu-item depth-4">
    
    
        Chain
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__chain_manager" class="menu-item depth-4">
    
    
        Chain Manager
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block_producer" class="menu-item depth-4">
    
    
        Block Producer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool" class="menu-item depth-3">
    
    
        Message Pool
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool__message_syncer" class="menu-item depth-4">
    
    
        Message Syncer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool__message_storage" class="menu-item depth-4">
    
    
        Message Storage
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__chainsync" class="menu-item depth-3">
    
    
        Block Syncer
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__storage_power_consensus" class="menu-item depth-3">
    
    
        Storage Power Consensus
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#algorithms__expected_consensus" class="menu-item depth-2">
    
    
        Expected Consensus
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor" class="menu-item depth-4">
    
    
        Storage Power Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_token" class="menu-item depth-2">
    üìÄ
    
        <strong>Token</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_token__wallets" class="menu-item depth-3">
    
    
        Wallet
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__payments" class="menu-item depth-3">
    
    
        Payments
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__payment_channels" class="menu-item depth-3">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_token__payment_channels__payment_channel_actor" class="menu-item depth-4">
    
    
        Payment Channel Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__multisig" class="menu-item depth-3">
    
    
        Multisig Wallet
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_token__multisig__multisig_actor" class="menu-item depth-4">
    
    
        Multisig Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_mining" class="menu-item depth-2">
    ‚õè
    
        <strong>Storage Mining</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_mining" class="menu-item depth-3">
    
    
        Storage Miner
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__mining_cycle" class="menu-item depth-4">
    
    
        Storage Mining Cycle
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor" class="menu-item depth-4">
    
    
        Storage Miner Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__mining_scheduler" class="menu-item depth-4">
    
    
        Mining Scheduler
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector" class="menu-item depth-3">
    
    
        Sector
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_mining__sector__sectorset" class="menu-item depth-4">
    
    
        Sector Set
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector__sealing" class="menu-item depth-4">
    
    
        Sector Sealing
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index" class="menu-item depth-3">
    
    
        Sector Index
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index__sector_builder" class="menu-item depth-4">
    
    
        Sector Builder
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index__sector_store" class="menu-item depth-4">
    
    
        SectorStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_proving" class="menu-item depth-3">
    
    
        Storage Proving
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_proving__sealer" class="menu-item depth-4">
    
    
        Sector Sealer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_proving__poster" class="menu-item depth-4">
    
    
        Sector Poster
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets" class="menu-item depth-2">
    ‚öñÔ∏è
    
        <strong>Market</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_markets__order" class="menu-item depth-3">
    
    
        Orders
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__deal" class="menu-item depth-3">
    
    
        Deals
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__storage_market" class="menu-item depth-3">
    
    
        Storage Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_market_actor" class="menu-item depth-4">
    
    
        Storage Market Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_provider" class="menu-item depth-4">
    
    
        Storage Provider
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_client" class="menu-item depth-4">
    
    
        Storage Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__faults" class="menu-item depth-4">
    
    
        Faults
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__retrieval_market" class="menu-item depth-3">
    
    
        Retrieval Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_client" class="menu-item depth-4">
    
    
        Retrieval Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_provider" class="menu-item depth-4">
    
    
        Retrieval Provider (Miner)
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        










  


<a href="./#libraries" class="menu-item depth-1">
    
    
    <strong>
    
        Libraries
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      










  


<a href="./#libraries__filcrypto" class="menu-item depth-2">
    
    
        filcrypto
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__filcrypto__filproofs" class="menu-item depth-3">
    
    
        filproofs
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__fcs" class="menu-item depth-2">
    
    
        FCS
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipld" class="menu-item depth-2">
    
    
        IPLD
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__ipld__cid" class="menu-item depth-3">
    
    
        CID
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipld__datamodel" class="menu-item depth-3">
    
    
        Data Model
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipld__selectors" class="menu-item depth-3">
    
    
        Selectors
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipld__graphstore" class="menu-item depth-3">
    
    
        GraphStore
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p" class="menu-item depth-2">
    
    
        libp2p
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__libp2p__gossipsub" class="menu-item depth-3">
    
    
        gossipsub
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p__kad_dht" class="menu-item depth-3">
    
    
        kad-dht
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p__fil_libp2p_nodes" class="menu-item depth-3">
    
    
        fil-libp2p Nodes
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipfs" class="menu-item depth-2">
    
    
        IPFS
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#libraries__ipfs__bitswap" class="menu-item depth-3">
    
    
        BitSwap
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipfs__graphsync" class="menu-item depth-3">
    
    
        GraphSync
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipfs__unixfs" class="menu-item depth-3">
    
    
        UnixFS
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__multiformats" class="menu-item depth-2">
    
    
        Multiformats
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#algorithms" class="menu-item depth-1">
    
    
    <strong>
    
        Algorithms
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#algorithms__expected_consensus" class="menu-item depth-2">
    
    
        Expected Consensus
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__porep" class="menu-item depth-2">
    
    
        Proof-of-Replication
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#algorithms__porep__stacked_drg" class="menu-item depth-3">
    
    
        Stacked DRG PoRep
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__porep__porep_commitments" class="menu-item depth-3">
    
    
        PoRep Commitments
    
</a>




    
    </li>

    <li>
    
      











<a href="./#algorithms__porep__stacked_drg_circuit" class="menu-item depth-3">
    
    
        
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__post" class="menu-item depth-2">
    
    
        Proof-of-Spacetime
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#algorithms__post__rational_post" class="menu-item depth-3">
    
    
        Rational-PoSt
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__post__proof_of_spacetime_parameters" class="menu-item depth-3">
    
    
        PoSt Parameters
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__payment_channels" class="menu-item depth-2">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__block_sync" class="menu-item depth-2">
    
    
        BlockSync
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__gossip_sub" class="menu-item depth-2">
    
    
        GossipSub
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__crypto" class="menu-item depth-2">
    
    
        Cryptographic Primitives
    
</a>




    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#listings" class="menu-item depth-1">
    
    
    <strong>
    
        Listings
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#listings__actors" class="menu-item depth-2">
    
    
        Filecoin VM Actors
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__data_structures" class="menu-item depth-2">
    
    
        Data Structures
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__system_map" class="menu-item depth-2">
    
    
        Components
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__libp2p_protocols" class="menu-item depth-2">
    
    
        libp2p Protocols
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#glossary" class="menu-item depth-1">
    
    
    <strong>
    
        Glossary
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#appendix" class="menu-item depth-1">
    
    
    <strong>
    
        Appendix
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#appendix__sharray" class="menu-item depth-2">
    
    
        Sharded IPLD Array
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#appendix__address" class="menu-item depth-2">
    
    
        Address
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#appendix__orient" class="menu-item depth-2">
    
    
        Filecoin Parameters
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
  </ul>
  
</div>










</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="./svg/menu.svg" alt="Menu" />
  </label>
  <strong>Filecoin Specification</strong>
</header>

      
<article class="markdown"><script>
  structSet = new Set([
    "Actor",
    "Address",
    "Bitfield",
    "Block",
    "BytesAmount",
    "ElectionProof",
    "FaultSet",
    "Message",
    "MessageReceipt",
    "PeerId",
    "PoSTProof",
    "PublicKey",
    "SealProof",
    "SectorID",
    "SectorSet",
    "Signature",
    "SignedMessage",
    "StateTree",
    "Ticket",
    "TipSet",
    "TokenAmount",
    "UnsignedMessage",
  ]);

  structRefs = {
    "AddressId":               "Address",
    "AddressSecp256k1":        "Address",
    "AddressActor":            "Address",
    "AddressBLS12_381":        "Address",
    "Bls12_381Signature":      "Signature",
    "Secp256k1Signature":      "Signature",
    "TxMeta":                  "Block",
    "VDFProof":                "Ticket",
    "VDFResult":               "Ticket",
    "VRFProof":                "Ticket",
  };

  fillSingleCodeRef = (x, isTokenDef) => {
    let origKey = x.innerText;
    let key = origKey;
    let newKey = structRefs[key];
    if (newKey !== undefined) {
      key = newKey;
    }
    if (structSet.has(key)) {
      if (x.className == "nx" && isTokenDef) {
        x.innerHTML = "<span id=go__" + origKey + "><a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a></div>";
      } else {
        x.innerHTML = "<a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a>";
      }
    }
  };

  fillCodeRefs = (xs, parent) => {
    if (xs.length == 0 && parent.innerText.length != 0) {
      fillSingleCodeRef(parent);
      return;
    }

    let isTokenDef = false;

    for (let x of xs) {
      if (x.className == "kd" && x.innerHTML == "type") {
        isTokenDef = true;
        continue;
      }

      if (x.className != "nx" && x.className != "codeRef") {
        isTokenDef = false;
        continue;
      }

      fillSingleCodeRef(x, isTokenDef);
      isTokenDef = false;
    }
  };

  window.onload = (event) => {
    let codeBlocks = document.getElementsByTagName("code");
    for (let codeBlock of codeBlocks) {
      fillCodeRefs(codeBlock.children, codeBlock);
    }

    let hashPrev = location.hash;
    if ((typeof hashPrev) == "string" && hashPrev != "") {
      location.hash = "";
      location.hash = hashPrev;
    }
  };
</script>


<div>
  
  








<div id="">

<h0 class="section-header">
  
</h0>

<div class="section-content">




































<style type="text/css">
 
#spec-splash {
  text-align: center;
  margin: 50px auto;
}
#spec-splash #spec-title {
  font-family: EB Garamond;
  font-size: 70px;
}
#spec-splash #spec-logo {
  height: 256px;
  width: 256px;
}
#spec-splash #spec-version {
  margin: 10px auto;
  font-family: Monaco, Menlo;
}
</style>

<div id="spec-splash">
  <div id="spec-title">Filecoin Specification</div>
  <img id="spec-logo" src="./docs/filspeclogo.png" />
  <div id="spec-version">
    protocol version: <span id="protocol-version-number">v0.1.0</span><br />
    spec doc version: <span id="spec-version-number">v1.0</span>-<span id="spec-version-hash">69d3ee9</span>
    <br /><span id="spec-version-date">2019-10-22_03:00:40Z</span>
  </div>
</div>


</div>


  
    








<div id="intro">

<h1 class="section-header">
  Introduction
</h1>

<div class="section-content">




































<p><center><img src="./docs/intro/underconstruction.gif" height="128px" /></center></p>

<div class="notices warning" ><strong>Warning:</strong> This draft of the Filecoin protocol specification is a work in progress.
It is intended to establish the rough overall structure of the document,
enabling experts to fill in different sections in parallel.
However, within each section, content may be out-of-order, incorrect, and/or incomplete.
The reader is advised to refer to the
<a href="https://filecoin-project.github.io/specs/">official Filecoin spec document</a>
for specification and implementation questions.</div>

<p>Filecoin is a distributed storage network based on a blockchain mechanism.
Filecoin <em>miners</em> can elect to provide storage capacity for the network, and thereby
earn units of the Filecoin cryptocurrency (FIL) by periodically producing
cryptographic proofs that certify that they are providing the capacity specified.
In addition, Filecoin enables parties to exchange FIL currency
through transactions recorded in a shared ledger on the Filecoin blockchain.
Rather than using Nakamoto-style proof of work to maintain consensus on the chain, however,
Filecoin uses proof of storage itself: a miner&rsquo;s power in the consensus protocol
is proportional to the amount of storage it provides.</p>

<p>The Filecoin blockchain not only maintains the ledger for FIL transactions and
accounts, but also implements the Filecoin VM, a replicated state machine which executes
a variety of cryptographic contracts and market mechanisms among participants
on the network.
These contracts include <em>storage deals</em>, in which clients pay FIL currency to miners
in exchange for storing the specific file data that the clients request.
Via the distributed implementation of the Filecoin VM, storage deals
and other contract mechanisms recorded on the chain continue to be processed
over time, without requiring further interaction from the original parties
(such as the clients who requested the data storage).</p>


</div>


  
    








<div id="intro__arch">

<h2 class="section-header">
  Architecture Diagrams
</h2>

<div class="section-content">






































<h3 id="filecoin-systems">Filecoin Systems</h3>


<div class="tocMap colorful">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems">
            Systems


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes">
            <strong>Filecoin Nodes</strong>


        
            <br /><br /><i class="menuIcon">‚öôÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__node_types">
            Node Types


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__repository">
            Repository


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__network">
            Network Interface


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__clock">
            Clock


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files">
            <strong>Files &amp; Data</strong>


        
            <br /><br /><i class="menuIcon">üìë</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file">
            File


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece">
            Piece


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__data_transfer">
            Data Transfer


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm">
            <strong>Virtual Machine</strong>


        
            <br /><br /><i class="menuIcon">üíª</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor">
            Actor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__state_tree">
            State Tree


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__message">
            Message


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime">
            Runtime


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors">
            System Actors


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__interpreter">
            Interpreter


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain">
            <strong>Blockchain</strong>


        
            <br /><br /><i class="menuIcon">üì¶</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct">
            Blocks


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool">
            Message Pool


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__chainsync">
            Block Syncer


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus">
            Storage Power Consensus


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token">
            <strong>Token</strong>


        
            <br /><br /><i class="menuIcon">üìÄ</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__wallets">
            Wallet


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payments">
            Payments


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels">
            Payment Channels


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig">
            Multisig Wallet


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining">
            <strong>Storage Mining</strong>


        
            <br /><br /><i class="menuIcon">‚õè</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining">
            Storage Miner


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector">
            Sector


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index">
            Sector Index


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving">
            Storage Proving


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets">
            <strong>Market</strong>


        
            <br /><br /><i class="menuIcon">‚öñÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__order">
            Orders


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__deal">
            Deals


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market">
            Storage Market


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market">
            Retrieval Market


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<h3 id="overview-diagram">Overview Diagram</h3>

<p>TODO:</p>

<ul>
<li>cleanup / reorganize

<ul>
<li>this diagram is accurate, and helps lots to navigate, but it&rsquo;s still a bit confusing</li>
<li>the arrows and lines make it a bit hard to follow. We should have a much cleaner version (maybe based on <a href="https://c4model.com">C4</a>)</li>
</ul></li>
<li>reflect addition of Token system

<ul>
<li>move data_transfers into Token</li>
</ul></li>
</ul>













<div class="diagram">

<span class="diagram-title">Protocol Overview Diagram</span>




(<a href="docs/intro/../diagrams/overview1/overview.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/overview1/overview.dot.svg" />




</div>


<h3 id="protocol-flow-diagram-deals-off-chain">Protocol Flow Diagram &ndash; deals off chain</h3>













<div class="diagram">

<span class="diagram-title">Protocol Sequence Diagram - Deals off Chain</span>




(<a href="docs/intro/../diagrams/sequence/full-deals-off-chain.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/sequence/full-deals-off-chain.mmd.svg" />




</div>


<h3 id="protocol-flow-diagram-deals-on-chain">Protocol Flow Diagram &ndash; deals on chain</h3>













<div class="diagram">

<span class="diagram-title">Protocol Sequence Diagram - Deals on Chain</span>




(<a href="docs/intro/../diagrams/sequence/full-deals-on-chain.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/sequence/full-deals-on-chain.mmd.svg" />




</div>


<h3 id="parameter-calculation-dependency-graph">Parameter Calculation Dependency Graph</h3>

<p>This is a diagram of the model for parameter calculation. This is made with <a href="https://github.com/filecoin-project/orient">orient</a>, our tool for modeling and solving for constraints.</p>













<div class="diagram">

<span class="diagram-title">Parameter Calculation Dependency Graph</span>




(<a href="docs/intro/../diagrams/orient/filecoin.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/orient/filecoin.dot.svg" />




</div>



</div>



</div>

  

  
    








<div id="intro__concepts">

<h2 class="section-header">
  Key Concepts
</h2>

<div class="section-content">




































<p>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:</p>

<ul>
<li><p><strong><em>Data structures</em></strong> are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).</p></li>

<li><p><strong><em>Functions</em></strong> are computational procedures that do not depend on external state (i.e., mathematical functions,
or programming language functions that do not refer to global variables).</p></li>

<li><p><strong><em>Components</em></strong> are sets of functionality that are intended to be represented as single software units
in the implementation structure.
Depending on the choice of language and the particular component, this might
correspond to a single software module,
a thread or process running some main loop, a disk-backed database, or a variety of other design choices.
For example, the <a href="./#systems__filecoin_blockchain__chainsync___index"></a> is a component: it could be implemented
as a process or thread running a single specified main loop, which waits for network messages
and responds accordingly by recording and/or forwarding block data.</p></li>

<li><p><strong><em>APIs</em></strong> are messages that can be sent to components.
A client&rsquo;s view of a given sub-protocol, such as a request to a miner node&rsquo;s
{% {<sref storage_provider>} %} component to store files in the storage market,
may require the execution of a series of APIs.</p></li>

<li><p><strong><em>Nodes</em></strong> are complete software and hardware systems that interact with the protocol.
A node might be constantly running several of the above <em>components</em>, participating in several <em>subsystems</em>,
and exposing <em>APIs</em> locally and/or over the network,
depending on the node configuration.
The term <em>full node</em> refers to a system that runs all of the above components, and supports all of the APIs detailed in the spec.</p></li>

<li><p><strong><em>Subsystems</em></strong> are conceptual divisions of the entire Filecoin protocol, either in terms of complete protocols
(such as the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> or <a href="./#systems__filecoin_markets__retrieval_market___index">Retrieval Market</a>), or in terms of functionality
(such as the <a href="./#systems__filecoin_vm">VM - Virtual Machine</a>). They do not necessarily correspond to any particular node or software component.</p></li>

<li><p><strong><em>Actors</em></strong> are virtual entities embodied in the state of the Filecoin VM.
Protocol actors are analogous to participants in smart contracts;
an actor carries a FIL currency balance and can interact with other actors
via the operations of the VM, but does not necessarily correspond to any particular node or software component.</p></li>
</ul>


</div>



</div>

  

  
    








<div id="intro__filecoin_vm">

<h2 class="section-header">
  Filecoin VM
</h2>

<div class="section-content">




































<p>The majority of Filecoin&rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &lsquo;chain&rsquo; of blocks is the correct one. Each block contains a series of state transitions called <code>messages</code>, and a checkpoint of the current <code>global state</code> after the application of those <code>messages</code>.</p>

<p>The <code>global state</code> here consists of a set of <code>actors</code>, each with their own private <code>state</code>.</p>

<p>An <code>actor</code> is the Filecoin equivalent of Ethereum&rsquo;s smart contracts, it is essentially an &lsquo;object&rsquo; in the filecoin network with state and a set of methods that can be used to interact with it. Every actor has a Filecoin balance attributed to it, a <code>state</code> pointer, a <code>code</code> CID which tells the system what type of actor it is, and a <code>nonce</code> which tracks the number of messages sent by this actor. (TODO: the nonce is really only needed for external user interface actors, AKA <code>account actors</code>. Maybe we should find a way to clean that up?)</p>

<p>There are two routes to calling a method on an <code>actor</code>. First, to call a method as an external participant of the system (aka, a normal user with Filecoin) you must send a signed <code>message</code> to the network, and pay a fee to the miner that includes your <code>message</code>.  The signature on the message must match the key associated with an account with sufficient Filecoin to pay for the messages execution. The fee here is equivalent to transaction fees in Bitcoin and Ethereum, where it is proportional to the work that is done to process the message (Bitcoin prices messages per byte, Ethereum uses the concept of &lsquo;gas&rsquo;. We also use &lsquo;gas&rsquo;).</p>

<p>Second, an <code>actor</code> may call a method on another actor during the invocation of one of its methods.  However, the only time this may happen is as a result of some actor being invoked by an external users message (note: an actor called by a user may call another actor that then calls another actor, as many layers deep as the execution can afford to run for).</p>

<p>For full implementation details, see the <a href="./#systems__filecoin_vm">VM subsystem</a>.</p>


</div>



</div>

  

  
    








<div id="intro__process">

<h2 class="section-header">
  Filecoin Spec Process (v1)
</h2>

<div class="section-content">






































<h3 id="pre-launch-mode">üöÄ Pre-launch mode</h3>

<p>Until we launch, we are making lots of changes to the spec to finish documenting the current version of the protocol. Changes will be made to the spec by a simple PR process, with approvals by key stakeholders. Some refinements are still to happen and testnet is expected to bring a few significant fixes/improvements. Most changes now are changing <em>the document</em>, <strong>NOT</strong> changing <em>the protocol</em>, at least not in a major way.</p>

<p>Until we launch, if something is missing, PR it in. If something is wrong, PR a fix. If something needs to be elaborated, PR in updates. What is in the top level of this repo, in master, is the spec, is the Filecoin Protocol. Nothing else matters (ie. no other documents, issues contain &ldquo;the protocol&rdquo;).</p>

<h3 id="new-proposals-drafts-spec">New Proposals -&gt; Drafts -&gt; Spec</h3>

<div class="notices warning" >‚ö†Ô∏è <strong>WARNING:</strong> Filecoin is in pre-launch mode, and we are finishing protocol spec and implementations of the <em>current</em> construction/version of the protocol only. We are highly unlikely to merge anything new into the Filecoin Protocol until after mainnet. Feel free to explore ideas anyway and propeare improvements for the future.</div>

<p>For anything that is not part of the currently speced systems (like &lsquo;repair&rsquo;, for example) the process we will use is:</p>

<ul>
<li><strong>(1) First, discuss the problem(s) and solution(s) in an issue</strong>

<ul>
<li>Or several issues, if the space is large and multithreaded enough.</li>
<li>Work out all the details required to make this proposal work.</li>
</ul></li>
<li><strong>(2) Write a draft with all the details.</strong>

<ul>
<li>When you feel like a solution is near, write up a draft document that contains all the details, and includes what changes would need to happen to the spec</li>
<li>E.g. &ldquo;Add a System called X with &hellip;&rdquo;, or &ldquo;Add a library called Y, &hellip;&rdquo;, or &ldquo;Modify vm/state_tree to include &hellip;&rdquo;</li>
<li>Place this document inside the <code>src/drafts/</code> directory.</li>
<li>Anybody is welcome to contribute well-reasoned and detailed drafts.</li>
<li>(Note: these drafts will give way to FIPs in the future)</li>
</ul></li>
<li><strong>(3) Seek approval to merge this into the specification.</strong>

<ul>
<li>To seek approval, open an issue and discuss it.</li>
<li>If the draft approved by the owners of the filecoin-spec, then the changes to the spec will need to be made in a PR.</li>
<li>Once changes make it into the spec, remove the draft.</li>
</ul></li>
</ul>

<p>It is acceptable for a PR for a draft to stay open for quite a while, as thought and discussion on the topic happens. At some point, if the reviewers and the author feel that the current state of the draft is stable enough (though not &lsquo;done&rsquo;) then it should be merged into the repo. Further changes to the draft are additional PRs, which may generate more discussion. Comments on these drafts are welcome from anyone, but if you wish to be involved in the actual research process, you will need to devote very considerable time and energy to the process.</p>

<h3 id="on-merging">On merging</h3>

<p>For anything in the drafts or notes folder, merge yourself after a review from a relevant person. For anything in the top level (canonical spec), @whyrusleeping or @jbenet will merge after proper review.</p>

<h3 id="issues">Issues</h3>

<p>Issues in the specs repo will be high signal, they will either be proposals, or issues directly relating to problems in the spec. More speculative research questions and discussion will happen in the research repo.</p>


</div>


  
    








<div id="intro__process__about">

<h3 class="section-header">
  About this specification
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__fip">

<h3 class="section-header">
  FIPs - Filecoin Improvement Proposals
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__contributing">

<h3 class="section-header">
  Contributing to the Filecoin spec
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources">

<h3 class="section-header">
  Related Resources
</h3>

<div class="section-content">




































<p>TODO</p>


</div>


  
    








<div id="intro__process__related_resources__research_portal">

<h4 class="section-header">
  Research portal
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources__network_tooling">

<h4 class="section-header">
  Network tooling
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources__testing">

<h4 class="section-header">
  Testing and implementation compliance
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="intro__system">

<h2 class="section-header">
  System Decomposition
</h2>

<div class="section-content">






































</div>


  
    








<div id="intro__system__why_systems">

<h3 class="section-header">
  What are Systems? How do they work?
</h3>

<div class="section-content">






































<p>Filecoin decouples and modularizes functionality into loosely-joined <code>systems</code>.
Each system adds significant functionality, usually to achieve a set of important and tightly related goals.</p>

<p>For example, the Blockchain System provides structures like Block, Tipset, and Chain, and provides functionality
like Block Sync, Block Propagation, Block Validation, Chain Selection, and Chain Access. This is
separated from the Files, Pieces, Piece Preparation, and Data Transfer. Both of these systems are separated from
the Markets, which provide Orders, Deals, Market Visibility, and Deal Settlement.</p>

<h4 id="why-is-system-decoupling-useful">Why is System decoupling useful?</h4>

<p>This decoupling is useful for:</p>

<ul>
<li><strong>Implementation Boundaries:</strong> it is possible to build implementations of Filecoin that only implement a
subset of systems. This is especially useful for <em>Implementation Diversity</em>: we want many implementations
of security critical systems (eg Blockchain), but do not need many implementations of Systems that can be
decoupled.</li>
<li><strong>Runtime Decoupling:</strong> system decoupling makes it easier to build and run Filecoin Nodes that isolate
Systems into separate programs, and even separate physical computers.</li>
<li><strong>Security Isolation:</strong> some systems require higher operational security than others. System decoupling allows
implementations to meet their security and functionality needs. A good example of this is separating Blockchain
processing from Data Transfer.</li>
<li><strong>Scalability:</strong> systems and various use cases may drive different performance requirements for different opertators.
System decoupling makes it easier for operators to scale their deployments along system boundaries.</li>
</ul>

<h4 id="filecoin-nodes-don-t-need-all-the-systems">Filecoin Nodes don&rsquo;t need all the systems</h4>

<p>Filecoin Nodes vary significantly, and do not need all the systems.
Most systems are only needed for a subset of use cases.</p>

<p>For example, the Blockchain System is required for synchronizing the chain, participating in secure consensus,
storage mining, and chain validation.
Many Filecoin Nodes do not need the chain and can perform their work by just fetching content from the latest
StateTree, from a node they trust. Of course, such nodes</p>

<p>Note: Filecoin does not use the &ldquo;full node&rdquo; or &ldquo;light client&rdquo; terminology, in wide use in Bitcoin and other blockchain
networks. In filecoin, these terms are not well defined. It is best to define nodes in terms of their capabilities,
and therefore, in terms of the Systems they run. For example:</p>

<ul>
<li><strong>Chain Verifier Node:</strong> Runs the Blockchain system. Can sync and validate the chain. Cannot mine or produce blocks.</li>
<li><strong>Client Node:</strong> Runs the Blockchain, Market, and Data Transfer systems. Can sync and validate the chain. Cannot mine or produce blocks.</li>
<li><strong>Retrieval Miner Node:</strong> Runs the Market and Data Transfer systems. Does not need the chain. Can make Retrieval Deals
(Retrieval Provider side). Can send Clients data, and get paid for it.</li>
<li><strong>Storage Miner Node:</strong> Runs the Blockchain, Storage Market, Storage Mining systems. Can sync and validate the chain.
Can make Storage Deals (Storage Provider side). Can seal stored data into sectors. Can acquire
storage consensus power. Can mine and produce blocks.</li>
</ul>

<h4 id="separating-systems">Separating Systems</h4>

<blockquote>
<p>How do we determine what functionality belongs in one system vs another?</p>
</blockquote>

<p>Drawing boundaries between systems is the art of separating tightly related functionality from unrelated parts.
In a sense, we seek to keep tightly integrated components in the same system, and away from other unrelated
components. This is sometimes straightforward, the boundaries naturally spring from the data structures or
functionality. For example, it is straightforward to observe that Clients and Miners negotiating a deal
with each other is very unrelated to VM Execution.</p>

<p>Sometimes this is harder, and it requires detangling, adding, or removing abstractions. For
example, the <code>StoragePowerActor</code> and the <code>StorageMarketActor</code> were a single <code>Actor</code> previously. This caused
a large coupling of functionality across <code>StorageDeal</code> making, the <code>StorageMarket</code>, markets in general, with
Storage Mining, Sector Sealing, PoSt Generation, and more. Detangling these two sets of related functionality
requried breaking apart the one actor into two.</p>

<h4 id="decomposing-within-a-system">Decomposing within a System</h4>

<p>Systems themselves decompose into smaller subunits. These are sometimes called &ldquo;subsystems&rdquo; to avoid confusion
with the much larger, first-class Systems. Subsystems themselves may break down further. The naming here is not
strictly enforced, as these subdivisions are more related to protocol and implementation engineering concerns
than to user capabilities.</p>


</div>



</div>

  

  
    








<div id="intro__system__impl_systems">

<h3 class="section-header">
  Implementing Systems
</h3>

<div class="section-content">






































<h4 id="system-requirements">System Requirements</h4>

<p>In order to make it easier to decouple functionality into systems, the Filecoin Protocol assumes
a set of functionality available to all systems. This functionality can be achieved by implementations
in a variety of ways, and should take the guidance here as a recommendation (SHOULD).</p>

<p>All Systems, as defined in this document, require the following:</p>

<ul>
<li><strong>Repository:</strong>

<ul>
<li><strong>Local <code>IpldStore</code>.</strong> Some amount of persistent local storage for data structures (small structured objects).
Systems expect to be initialized with an IpldStore in which to store data structures they expect to persist across crashes.</li>
<li><strong>User Configuration Values.</strong> A small amount of user-editable configuration values.
These should be easy for end-users to access, view, and edit.</li>
<li><strong>Local, Secure <code>KeyStore</code>.</strong> A facility to use to generate and use cryptographic keys, which MUST remain secret to the
Filecoin Node. Systems SHOULD NOT access the keys directly, and should do so over an abstraction (ie the <code>KeyStore</code>) which
provides the ability to Encrypt, Decrypt, Sign, SigVerify, and more.</li>
</ul></li>
<li><strong>Local <code>FileStore</code>.</strong> Some amount of persistent local storage for files (large byte arrays).
Systems expect to be initialized with a FileStore in which to store large files.
Some systems (like Markets) may need to store and delete large volumes of smaller files (1MB - 10GB).
Other systems (like Storage Mining) may need to store and delete large volumes of large files (1GB - 1TB).</li>
<li><strong>Network.</strong> Most systems need access to the network, to be able to connect to their counterparts in other Filecoin Nodes.
Systems expect to be initialized with a libp2p.Node on which they can mount their own protocols.</li>
<li><strong>Clock.</strong> Some systems need access to current network time, some with low tolerance for drift.
Systems expect to be initialized with a Clock from which to tell network time. Some systems (like Blockchain)
require very little clock drift, and require <em>secure</em> time.</li>
</ul>

<p>For this purpose, we use the <code>FilecoinNode</code> data structure, which is passed into all systems at initialization:</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">repo</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository&#34;</span>
<span class="kn">import</span> <span class="nx">filestore</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>

<span class="kd">type</span> <span class="nx">FilecoinNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Node</span>        <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>

    <span class="nx">Repository</span>  <span class="nx">repo</span><span class="p">.</span><span class="nx">Repository</span>
    <span class="nx">FileStore</span>   <span class="nx">filestore</span><span class="p">.</span><span class="nx">FileStore</span>
    <span class="nx">Clock</span>       <span class="nx">clock</span><span class="p">.</span><span class="nx">WallClock</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">key</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/key&#34;</span>
<span class="kn">import</span> <span class="nx">config</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/config&#34;</span>

<span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">config</span>          <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
    <span class="nx">ipldStore</span>       <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nx">keyStore</span>        <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>

    <span class="c1">// CreateRepository(config Config, ipldStore IPLDDagStore, keyStore KeyStore) &amp;Repository
</span><span class="c1"></span>    <span class="nf">GetIPLDStore</span><span class="p">()</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetKeyStore</span><span class="p">()</span>   <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetConfig</span><span class="p">()</span>     <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="system-limitations">System Limitations</h4>

<p>Further, Systems MUST abide by the following limitations:</p>

<ul>
<li><strong>Random crashes.</strong> A Filecoin Node may crash at any moment. Systems must be secure and consistent through crashes.
This is primarily achived by limiting the use of persistent state, persisting such state through Ipld data structures,
and through the use of initialization routines that check state, and perhaps correct errors.</li>
<li><strong>Isolation.</strong> Systems must communicate over well-defined, isolated interfaces. They must not build their critical
functionality over a shared memory space. (Note: for performance, shared memory abstractions can be used to power
IpldStore, FileStore, and libp2p, but the systems themselves should not require it). This is not just an operational
concern; it also significantly simplifies the protocol and makes it easier to understand, analyze, debug, and change.</li>
<li><strong>No direct access to host OS Filesystem or Disk.</strong> Systems cannot access disks directly &ndash; they do so over the FileStore
and IpldStore abstractions. This is to provide a high degree of portability and flexibility for end-users, especially
storage miners and clients of large amounts of data, which need to be able to easily replace how their Filecoin Nodes
access local storage.</li>
<li><strong>No direct access to host OS Network stack or TCP/IP.</strong> Systems cannot access the network directly &ndash; they do so over the
libp2p library. There must not be any other kind of network access. This provides a high degree of portability across
platforms and network protocols, enabling Filecoin Nodes (and all their critical systems) to run in a wide variety of
settings, using all kinds of protocols (eg Bluetooth, LANs, etc).</li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems">

<h1 class="section-header">
  Systems
</h1>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes">

<h2 class="section-header">
  <strong>Filecoin Nodes</strong>
</h2>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes__node_types">

<h3 class="section-header">
  Node Types
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes__node_types__node">

<h4 class="section-header">
  Node Interface
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">repo</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository&#34;</span>
<span class="kn">import</span> <span class="nx">filestore</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>

<span class="kd">type</span> <span class="nx">FilecoinNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Node</span>        <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>

    <span class="nx">Repository</span>  <span class="nx">repo</span><span class="p">.</span><span class="nx">Repository</span>
    <span class="nx">FileStore</span>   <span class="nx">filestore</span><span class="p">.</span><span class="nx">FileStore</span>
    <span class="nx">Clock</span>       <span class="nx">clock</span><span class="p">.</span><span class="nx">WallClock</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__node_types">

<h4 class="section-header">
  Examples
</h4>

<div class="section-content">




































<p>There are many kinds of Filecoin Nodes &hellip;</p>

<p>This section should contain:</p>

<ul>
<li>what all nodes must have, and why</li>
<li>examples of using different systems</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__verifier_node">

<h4 class="section-header">
  Chain Verifier Node
</h4>

<div class="section-content">




































<pre><code>type ChainVerifierNode interface {
  FilecoinNode

  systems.Blockchain
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__client_node">

<h4 class="section-header">
  Client Node
</h4>

<div class="section-content">




































<pre><code>type ClientNode struct {
  FilecoinNode

  systems.Blockchain
  markets.StorageMarketClient
  markets.RetrievalMarketClient
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__storage_miner_node">

<h4 class="section-header">
  Storage Miner Node
</h4>

<div class="section-content">




































<pre><code>type StorageMinerNode interface {
  FilecoinNode

  systems.Blockchain
  systems.Mining
  markets.StorageMarketProvider
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__retrieval_miner_node">

<h4 class="section-header">
  Retrieval Miner Node
</h4>

<div class="section-content">




































<pre><code>type RetrievalMinerNode interface {
  FilecoinNode

  blockchain.Blockchain
  markets.RetrievalMarketProvider
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__relayer_node">

<h4 class="section-header">
  Relayer Node
</h4>

<div class="section-content">




































<pre><code>type RelayerNode interface {
  FilecoinNode

  blockchain.MessagePool
  markets.MarketOrderBook
}
</code></pre>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_nodes__repository">

<h3 class="section-header">
  Repository - Local Storage for Chain Data and Systems
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">key</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/key&#34;</span>
<span class="kn">import</span> <span class="nx">config</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/config&#34;</span>

<span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">config</span>          <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
    <span class="nx">ipldStore</span>       <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nx">keyStore</span>        <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>

    <span class="c1">// CreateRepository(config Config, ipldStore IPLDDagStore, keyStore KeyStore) &amp;Repository
</span><span class="c1"></span>    <span class="nf">GetIPLDStore</span><span class="p">()</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetKeyStore</span><span class="p">()</span>   <span class="nx">key</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nf">GetConfig</span><span class="p">()</span>     <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_nodes__repository__config">

<h4 class="section-header">
  Config - Local Storage for ConfigurationValues
</h4>

<div class="section-content">




































<p>Filecoin Node configuration</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ConfigKey</span> <span class="kt">string</span>
<span class="kd">type</span> <span class="nx">ConfigVal</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">c</span> <span class="nx">ConfigVal</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">ConfigVal</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">Subconfig</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">)</span> <span class="nx">Config</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__repository__key">

<h4 class="section-header">
  KeyStore &amp; user keys
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Key</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">//  Algo Algorithm
</span><span class="c1"></span>    <span class="nx">Data</span> <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// key.Name
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Name</span> <span class="kt">string</span>

<span class="c1">// key.Store
</span><span class="c1">// TODO: redo this providing access to enc, dec, sign, sigverify operations, and not the keys.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Store</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">n</span> <span class="nx">Name</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">Key</span><span class="p">)</span> <span class="kt">error</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">n</span> <span class="nx">Name</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">k</span> <span class="nx">Key</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="c1">//  Sign(n Name, data Bytes) Signature
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Algorithm</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Sig</span> <span class="nx">SignatureAlgorithm</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SignatureAlgoC</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Sign</span><span class="p">(</span><span class="nx">b</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">s</span> <span class="nx">Signature</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Verify</span><span class="p">(</span><span class="nx">b</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">s</span> <span class="nx">Signature</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">EdDSASignatureAlgorithm</span> <span class="nx">SignatureAlgoC</span>
<span class="kd">type</span> <span class="nx">Secp256k1SignatureAlgorithm</span> <span class="nx">SignatureAlgoC</span>
<span class="kd">type</span> <span class="nx">BLSAggregateSignatureAlgorithm</span> <span class="nx">SignatureAlgoC</span>

<span class="kd">type</span> <span class="nx">SignatureAlgorithm</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">EdDSASigAlgo</span>      <span class="nx">EdDSASignatureAlgorithm</span>
    <span class="nx">Secp256k1SigAlgo</span>  <span class="nx">Secp256k1SignatureAlgorithm</span>
    <span class="nx">BLSSigAlgo</span>        <span class="nx">BLSAggregateSignatureAlgorithm</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algo</span>           <span class="nx">SignatureAlgorithm</span>
    <span class="nx">Data</span>           <span class="nx">Bytes</span>

    <span class="nf">Verify</span><span class="p">(</span><span class="nx">k</span> <span class="nx">Key</span><span class="p">)</span>  <span class="nx">union</span> <span class="p">{</span><span class="nx">b</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  

  

  


</div>

  

  
    








<div id="systems__filecoin_nodes__repository__ipldstore">

<h4 class="section-header">
  IpldStore - Local Storage for hash-linked data
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Store</span> <span class="nx">GraphStore</span>

<span class="c1">// imported as ipld.Object
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Object</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">CID</span><span class="p">()</span> <span class="nx">CID</span>

    <span class="c1">// Populate(v interface{}) error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>






<p>TODO:</p>

<ul>
<li>What is IPLD

<ul>
<li>hash linked data</li>
<li>from IPFS</li>
</ul></li>
<li>Why is it relevant to filecoin

<ul>
<li>all network datastructures are definitively IPLD</li>
<li>all local datastructures can be IPLD</li>
</ul></li>
<li>What is an IpldStore

<ul>
<li>local storage of dags</li>
</ul></li>
<li>How to use IpldStores in filecoin

<ul>
<li>pass it around</li>
</ul></li>
<li>One ipldstore or many

<ul>
<li>temporary caches</li>
<li>intermediately computed state</li>
</ul></li>
<li>Garbage Collection</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__repository__usage">

<h4 class="section-header">
  Usage in Systems
</h4>

<div class="section-content">




































<p>TODO:
- Explain how repo is used with systems and subsystems
- compartmentalized local storage
- store ipld datastructures of stateful objects</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_nodes__network">

<h3 class="section-header">
  Network Interface
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>
</code></pre></div>






<p>Filecoin nodes use the libp2p protocol for peer discovery, peer routing, and message multicast, and so on. Libp2p is a set of modular protocols common to the peer-to-peer networking stack. Nodes open connections with one another and mount different protocols or streams over the same connection. In the initial handshake, nodes exchange the protocols that each of them supports and all Filecoin related protcols will be mounted under <code>/filecoin/...</code> protocol identifiers.</p>

<p>Here is the list of libp2p protocols used by Filecoin.</p>

<ul>
<li>Graphsync: TODO</li>
<li>Bitswap:  TODO</li>
<li>Gossipsub: block headers and messages are broadcasted through a Gossip PubSub protocol where nodes can subscribe to topics such as <code>NewBlock</code>, <code>BlockHeader</code>, <code>BlockMessage</code>, etc and receive messages in those topics. When receiving messages related to a topic, nodes processes the message and forwards it to its peers who also subscribed to the same topic.</li>
<li>Kad-DHT: Kademlia DHT is a distributed hash table with a logarithmic bound on the maximum number of lookups for a particular node. Kad DHT is used primarily for peer routing as well as peer discovery in the Filecoin protocol.</li>
<li>Bootstrap: Bootstrap is a list of nodes that a new node attempts to connect upon joining the network. The list of bootstrap nodes and their addresses are defined by the users.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__clock">

<h3 class="section-header">
  Clock
</h3>

<div class="section-content">




































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Time</span> <span class="kt">string</span> <span class="c1">// ISO nano timestamp
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnixTime</span> <span class="kt">int</span> <span class="c1">// unix timestamp
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Round</span> <span class="kt">int</span> <span class="c1">// Blockchain round
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Clock</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nf">UTCTime</span><span class="p">()</span> <span class="nx">Time</span>
  <span class="nf">UnixNano</span><span class="p">()</span> <span class="nx">UnixTime</span>

  <span class="nf">CurrentRound</span><span class="p">()</span> <span class="nx">Round</span>
  <span class="nf">LastRoundObserved</span><span class="p">()</span> <span class="nx">Round</span>
<span class="p">}</span></code></pre></div>
<p>TODO:</p>

<ul>
<li>explain why we need a system clock</li>
<li>explain where it is used

<ul>
<li>for rejecting/accepting blocks</li>
</ul></li>
<li>explain synchrony requirements

<ul>
<li>small clock drift &ndash; &lt;2s</li>
<li>very important to have accurate time</li>
</ul></li>
<li>explain how we can resync

<ul>
<li>Network</li>
<li>recommend various NTP servers</li>
<li>Cesium clocks</li>
</ul></li>
<li>Future work:

<ul>
<li>VDF Clocks</li>
</ul></li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files">

<h2 class="section-header">
  Files &amp; Data
</h2>

<div class="section-content">




































<p>Filecoin&rsquo;s primary aim is to store client&rsquo;s Files and Data.
This section details data structures and tooling related to working with files,
chunking, encoding, graph representations, <code>Pieces</code>, storage abstractions, and more.</p>


<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files">
            <strong>Files &amp; Data</strong>


        
            <br /><br /><i class="menuIcon">üìë</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file">
            File


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file__filestore">
            FileStore


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece">
            Piece


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece__piece_store">
            PieceStore


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__data_transfer">
            Data Transfer


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="systems__filecoin_files__file">

<h3 class="section-header">
  File
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Path is an opaque locator for a file (e.g. in a unix-style filesystem).
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Path</span> <span class="kt">string</span>

<span class="c1">// File is a variable length data container.
</span><span class="c1">// The File interface is modeled after a unix-style file, but abstracts the 
</span><span class="c1">// underlying storage system.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">File</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Path</span><span class="p">()</span>            <span class="nx">Path</span>
    <span class="nf">Size</span><span class="p">()</span>            <span class="kt">int</span>
    <span class="nf">Seek</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">)</span>  <span class="kt">error</span>
    <span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span>   <span class="kd">struct</span> <span class="p">{</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span>  <span class="kd">struct</span> <span class="p">{</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Close</span><span class="p">()</span>           <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_files__file__filestore">

<h4 class="section-header">
  FileStore - Local Storage for Files
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FileStore is an object that can store and retrieve files by path.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FileStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Open</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>           <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Create</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>         <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Store</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">,</span> <span class="nx">f</span> <span class="nx">File</span><span class="p">)</span>  <span class="kt">error</span>
    <span class="nf">Delete</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>         <span class="kt">error</span>

    <span class="c1">// maybe add:
</span><span class="c1"></span>    <span class="c1">// Copy(SrcPath, DstPath)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>






<p>TODO:</p>

<ul>
<li>explain why this abstraction is needed</li>
<li>explain OS filesystem as basic impl</li>
<li>explain that users can replace w/ other systems</li>
<li>give examples:

<ul>
<li>networked filesystems</li>
<li>raw disk sectors - like haystack</li>
<li>databases</li>
</ul></li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files__piece">

<h3 class="section-header">
  Piece - a part of a file
</h3>

<div class="section-content">




































<p>A <code>Piece</code> is an object that represents a whole or part of a <code>File</code>,
and is used by <code>Clients</code> and <code>Miners</code> in <code>Deals</code>. <code>Clients</code> hire <code>Miners</code>
to store <code>Pieces</code>.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="c1">// PieceID is the main reference to pieces in Filecoin. It is the CID
</span><span class="c1">// of the Piece.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="kd">type</span> <span class="nx">NumBytes</span> <span class="nx">UVarint</span>  <span class="c1">// TODO: move into util
</span><span class="c1"></span>
<span class="c1">// PieceSize is the size of a piece, in bytes
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceSize</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PayloadSize</span>   <span class="nx">NumBytes</span>
    <span class="nx">OverheadSize</span>  <span class="nx">NumBytes</span>

    <span class="nf">Total</span><span class="p">()</span>       <span class="nx">NumBytes</span>
<span class="p">}</span>

<span class="c1">// PieceInfo is an object that describes details about a piece, and allows
</span><span class="c1">// decoupling storage of this information from the piece itself.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>    <span class="nx">PieceID</span>
    <span class="nx">Size</span>  <span class="nx">UVarint</span>
    <span class="c1">// TODO: store which algorithms were used to construct this piece.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Piece represents the basic unit of tradeable data in Filecoin. Clients
</span><span class="c1">// break files and data up into Pieces, maybe apply some transformations,
</span><span class="c1">// and then hire Miners to store the Pieces.
</span><span class="c1">//
</span><span class="c1">// The kinds of transformations that may ocurr include erasure coding,
</span><span class="c1">// encryption, and more.
</span><span class="c1">//
</span><span class="c1">// Note: pieces are well formed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Piece</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Info</span>       <span class="nx">PieceInfo</span>

    <span class="c1">// tree is the internal representation of Piece. It is a tree
</span><span class="c1"></span>    <span class="c1">// formed according to a sequence of algorithms, which make the
</span><span class="c1"></span>    <span class="c1">// piece able to be verified.
</span><span class="c1"></span>    <span class="nx">tree</span>       <span class="nx">PieceTree</span>

    <span class="c1">// Payload is the user&#39;s data.
</span><span class="c1"></span>    <span class="nf">Payload</span><span class="p">()</span>  <span class="nx">Bytes</span>

    <span class="c1">// Data returns the serialized representation of the Piece.
</span><span class="c1"></span>    <span class="c1">// It includes the payload data, and intermediate tree objects,
</span><span class="c1"></span>    <span class="c1">// formed according to relevant storage algorithms.
</span><span class="c1"></span>    <span class="nf">Data</span><span class="p">()</span>     <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// // LocalPieceRef is an object used to refer to pieces in local storage.
</span><span class="c1">// // This is used by subsystems to store and locate pieces.
</span><span class="c1">// type LocalPieceRef struct {
</span><span class="c1">//   ID   PieceID
</span><span class="c1">//   Path file.Path
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="c1">// PieceTree is a data structure used to form pieces. The algorithms involved
</span><span class="c1">// in the storage proofs determine the shape of PieceTree and how it must be
</span><span class="c1">// constructed.
</span><span class="c1">//
</span><span class="c1">// Usually, a node in PieceTree will include either Children or Data, but not
</span><span class="c1">// both.
</span><span class="c1">//
</span><span class="c1">// TODO: move this into filproofs -- use a tree from there, as that&#39;s where
</span><span class="c1">// the algorightms are defined. Or keep this as an interface, met by others.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Children</span>  <span class="p">[</span><span class="nx">PieceTree</span><span class="p">]</span>
    <span class="nx">Data</span>      <span class="nx">Bytes</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_files__piece__piece_store">

<h4 class="section-header">
  PieceStore - storing and indexing pieces
</h4>

<div class="section-content">




































<p>A <code>PieceStore</code> is an object that can store and retrieve pieces
from some local storage. The <code>PieceStore</code> additionally keeps
an index of pieces.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="c1">// PieceStore is an object that stores pieces into some local storage.
</span><span class="c1">// it is internally backed by an IpldStore.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Store</span>              <span class="nx">ipld</span><span class="p">.</span><span class="nx">Store</span>
    <span class="nx">Index</span>              <span class="p">{</span><span class="nx">PieceID</span><span class="p">:</span> <span class="nx">Piece</span><span class="p">}</span>

    <span class="nf">Get</span><span class="p">(</span><span class="nx">i</span> <span class="nx">PieceID</span><span class="p">)</span>     <span class="kd">struct</span> <span class="p">{</span><span class="nx">p</span> <span class="nx">Piece</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Piece</span><span class="p">)</span>       <span class="kt">error</span>
    <span class="nf">Delete</span><span class="p">(</span><span class="nx">i</span> <span class="nx">PieceID</span><span class="p">)</span>  <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files__data_transfer">

<h3 class="section-header">
  Data Transfer in Filecoin
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Address</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Storage</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">StorageDealID</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Function</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Piece</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">DataTransferSubsystem</span> <span class="kd">struct</span> <span class="err">@</span><span class="p">(</span><span class="nx">mutable</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dataTransfers</span>  <span class="p">{</span><span class="nx">UInt</span><span class="p">:</span> <span class="nx">DataTransferChannel</span><span class="p">}</span>
    <span class="nx">volumes</span>        <span class="p">[</span><span class="nx">Storage</span><span class="p">]</span>

    <span class="nf">OpenDataTransferChannel</span><span class="p">(</span><span class="nx">x</span> <span class="nx">StorageDealID</span><span class="p">)</span> <span class="nx">UInt</span>
    <span class="nf">CloseDataTransferChannel</span><span class="p">(</span><span class="nx">x</span> <span class="nx">UInt</span><span class="p">)</span>
    <span class="nf">TransferChannelStatus</span><span class="p">(</span><span class="nx">x</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">DataTransferStatus</span>
    <span class="nf">ReportDataTransferEvent</span><span class="p">(</span><span class="nx">x</span> <span class="nx">Function</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">Ret</span> <span class="nx">DataTransferStatus</span><span class="p">,</span> <span class="nx">Err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="nf">findData</span><span class="p">(</span><span class="nx">x</span> <span class="nx">CID</span><span class="p">)</span> <span class="nx">Piece</span>
<span class="p">}</span>

<span class="c1">// Assumes access to error-checked, ordered, reliable transmission protocol
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Scheduler</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ScheduleTransfer</span><span class="p">(</span><span class="nx">x</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">Piece</span><span class="p">)</span>
    <span class="nf">requestData</span><span class="p">(</span><span class="nx">x</span> <span class="nx">DataTransferChannel</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">Ret</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">Err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">sendData</span><span class="p">(</span><span class="nx">x</span> <span class="nx">DataTransferChannel</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="kt">error</span><span class="err">?</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DataTransferChannel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">channelID</span>      <span class="nx">UInt</span>
    <span class="nx">contentID</span>      <span class="nx">CID</span>
    <span class="nx">dataIncrement</span>  <span class="nx">UVarint</span>
    <span class="nx">sender</span>         <span class="nx">Address</span>
    <span class="nx">recipient</span>      <span class="nx">Address</span>
    <span class="nx">totalSize</span>      <span class="nx">UVarint</span>
    <span class="nx">sent</span>           <span class="nx">UVarint</span>
    <span class="nx">received</span>       <span class="nx">UVarint</span>

    <span class="nf">channelType</span><span class="p">()</span>  <span class="nx">DataTransferType</span>  <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nf">transferNum</span><span class="p">()</span>  <span class="nx">Float</span>             <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DataTransferParams</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">channelType</span>    <span class="nx">DataTransferType</span>
    <span class="nx">contentID</span>      <span class="nx">CID</span>
    <span class="nx">dataIncrement</span>  <span class="nx">UVarint</span>
    <span class="nx">sender</span>         <span class="nx">Address</span>
    <span class="nx">recipient</span>      <span class="nx">Address</span>
    <span class="nx">totalSize</span>      <span class="nx">Address</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DataTransferType</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Sender</span>
    <span class="nx">Recipient</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Sender</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO: remove this
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Recipient</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO: remove this
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Ongoing</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Completed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Failed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ChannelNotFoundError</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DataTransferStatus</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Ongoing</span>
    <span class="nx">Completed</span>
    <span class="nx">Failed</span>
    <span class="nx">ChannelNotFoundError</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm">

<h2 class="section-header">
  VM - Virtual Machine
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm">
            <strong>Virtual Machine</strong>


        
            <br /><br /><i class="menuIcon">üíª</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor">
            Actor


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor__address">
            Address


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__state_tree">
            State Tree


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__message">
            Message


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime">
            Runtime


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime__exitcode">
            Exit Codes


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime__gascost">
            Gas Costs


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors">
            System Actors


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__init_actor">
            InitActor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__cron_actor">
            CronActor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__account_actor">
            AccountActor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__interpreter">
            Interpreter


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>





















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>

<span class="c1">// VM is the object that controls execution.
</span><span class="c1">// It is a stateless, pure function. It uses no local storage.
</span><span class="c1">//
</span><span class="c1">// TODO: make it just a function: VMExec(...) ?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VM</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Execute computes and returns outTree, a new StateTree which is the
</span><span class="c1"></span>    <span class="c1">// application of msgs to inTree.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// *Important:* Execute is intended to be a pure function, with no side-effects.
</span><span class="c1"></span>    <span class="c1">// however, storage of the new parts of the computed outTree may exist in
</span><span class="c1"></span>    <span class="c1">// local storage.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// *TODO:* define whether this should take 0, 1, or 2 IpldStores:
</span><span class="c1"></span>    <span class="c1">// - (): storage of IPLD datastructures is assumed implicit
</span><span class="c1"></span>    <span class="c1">// - (store): get and put to same IpldStore
</span><span class="c1"></span>    <span class="c1">// - (inStore, outStore): get from inStore, put new structures into outStore
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// This decision impacts callers, and potentially impacts how we reason about
</span><span class="c1"></span>    <span class="c1">// local storage, and intermediate storage. It is definitely the case that
</span><span class="c1"></span>    <span class="c1">// implementations may want to operate on this differently, depending on
</span><span class="c1"></span>    <span class="c1">// how their IpldStores work.
</span><span class="c1"></span>    <span class="nf">Execute</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msgs</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">])</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_vm__actor">

<h3 class="section-header">
  VM Actor Interface
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// This contains actor things that are _outside_ of VM exection.
</span><span class="c1">// The VM uses this to execute actors.
</span><span class="c1"></span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="c1">// TokenAmount is an amount of Filecoin tokens. This type is used within
</span><span class="c1">// the VM in message execution, to account movement of tokens, payment
</span><span class="c1">// of VM gas, and more.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TokenAmount</span> <span class="nx">UVarint</span>  <span class="c1">// TODO: bigint or varint?
</span><span class="c1"></span>
<span class="c1">// MethodNum is an integer that represents a particular method
</span><span class="c1">// in an actor&#39;s function table. These numbers are used to compress
</span><span class="c1">// invocation of actor code, and to decouple human language concerns
</span><span class="c1">// about method names from the ability to uniquely refer to a particular
</span><span class="c1">// method.
</span><span class="c1">//
</span><span class="c1">// Consider MethodNum numbers to be similar in concerns as for
</span><span class="c1">// offsets in function tables (in programming languages), and for
</span><span class="c1">// tags in ProtocolBuffer fields. Tags in ProtocolBuffers recommend
</span><span class="c1">// assigning a unique tag to a field and never reusing that tag.
</span><span class="c1">// If a field is no longer used, the field name may change but should
</span><span class="c1">// still remain defined in the code to ensure the tag number is not
</span><span class="c1">// reused accidentally. The same should apply to the MethodNum
</span><span class="c1">// associated with methods in Filecoin VM Actors.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MethodNum</span> <span class="nx">UVarint</span>

<span class="c1">// MethodParams is an array of objects to pass into a method. This
</span><span class="c1">// is the list of arguments/parameters.
</span><span class="c1">//
</span><span class="c1">// TODO: serialized or deserialized? (serialized for now)
</span><span class="c1">// TODO: force CIDs or by value is fine?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MethodParams</span> <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>

<span class="c1">// CallSeqNum is an invocation (Call) sequence (Seq) number (Num).
</span><span class="c1">// This is a value used for securing against replay attacks:
</span><span class="c1">// each AccountActor (user) invocation must have a unique CallSeqNum
</span><span class="c1">// value. The sequenctiality of the numbers is used to make it
</span><span class="c1">// easy to verify, and to order messages.
</span><span class="c1">//
</span><span class="c1">// Q&amp;A
</span><span class="c1">// - &gt; Does it have to be sequential?
</span><span class="c1">//   No, a random nonce could work against replay attacks, but
</span><span class="c1">//   making it sequential makes it much easier to verify.
</span><span class="c1">// - &gt; Can it be used to order events?
</span><span class="c1">//   Yes, a user may submit N separate messages with increasing
</span><span class="c1">//   sequence number, causing them to execute in order.
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CallSeqNum</span> <span class="nx">UVarint</span>

<span class="c1">// Code is a serialized object that contains the code for an Actor.
</span><span class="c1">// Until we accept external user-provided contracts, this is the
</span><span class="c1">// serialized code for the actor in the Filecoin Specification.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Code</span> <span class="nx">Bytes</span>

<span class="c1">// CodeCID represents a CID for a Code object.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CodeCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="c1">// Actor is a base computation object in the Filecoin VM. Similar
</span><span class="c1">// to Actors in the Actor Model (programming), or Objects in Object-
</span><span class="c1">// Oriented Programming, or Ethereum Contracts in the EVM.
</span><span class="c1">//
</span><span class="c1">// Questions for id language:
</span><span class="c1">// - we should not do inheritance, we should do composition.
</span><span class="c1">//   but we should make including actor state nicer.
</span><span class="c1">//
</span><span class="c1">// TODO: do we need this type? what is the difference between this and
</span><span class="c1">// ActorState
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Actor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">State</span> <span class="nx">ActorState</span>
<span class="p">}</span>

<span class="c1">// ActorState represents the on-chain storage actors keep.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// common fields for all actors
</span><span class="c1"></span>
    <span class="nx">CodeCID</span>
    <span class="c1">// use a CID here, load it in interpreter.
</span><span class="c1"></span>    <span class="c1">// Alternative is to use ActorState here but tricky w/ the type system
</span><span class="c1"></span>    <span class="nx">State</span>       <span class="nx">ActorSubstateCID</span>

    <span class="nx">Balance</span>     <span class="nx">TokenAmount</span>
    <span class="nx">CallSeqNum</span>  <span class="c1">// FKA Nonce
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// ActorID is a sequential number assigned to actors in a Filecoin Chain.
</span><span class="c1">// ActorIDs are assigned by the InitActor, when an Actor is introduced into
</span><span class="c1">// the Runtime.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorID</span> <span class="nx">UVarint</span>

<span class="kd">type</span> <span class="nx">ActorSubstateCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="c1">// ActorState represents the on-chain storage actors keep. This type is a
</span><span class="c1">// union of concrete types, for each of the Actors:
</span><span class="c1">// - InitActor
</span><span class="c1">// - CronActor
</span><span class="c1">// - AccountActor
</span><span class="c1">// - PaymentChannelActor
</span><span class="c1">// - StoragePowerActor
</span><span class="c1">// - StorageMinerActor
</span><span class="c1">// - StroageMarketActor
</span><span class="c1">//
</span><span class="c1">// TODO: move this into a directory inside the VM that patches in all
</span><span class="c1">// the actors from across the system. this will be where we declare/mount
</span><span class="c1">// all actors in the VM.
</span><span class="c1">// type ActorState union {
</span><span class="c1">//     Init struct {
</span><span class="c1">//         AddressMap  {addr.Address: ActorID}
</span><span class="c1">//         NextID      ActorID
</span><span class="c1">//     }
</span><span class="c1">// }
</span></code></pre></div>







</div>


  
    








<div id="systems__filecoin_vm__actor__address">

<h4 class="section-header">
  Address
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Address is defined here because this is where addresses start to make sense.
</span><span class="c1">// Addresses refer to actors defined in the StateTree, so Addresses are defined
</span><span class="c1">// on top of the StateTree.
</span><span class="c1">//
</span><span class="c1">// TODO: potentially move into a library, or its own directory.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Address</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">NetworkID</span> <span class="nx">enum</span> <span class="p">{</span>
        <span class="nx">Testnet</span>
        <span class="nx">Mainnet</span>
    <span class="p">}</span>

    <span class="nx">Type</span> <span class="nx">enum</span> <span class="p">{</span>
        <span class="nx">ID</span>
        <span class="nx">Secp256k1</span>
        <span class="nx">Actor</span>
        <span class="nx">BLS</span>
    <span class="p">}</span>

    <span class="nf">VerifySyntax</span><span class="p">(</span><span class="nx">addrType</span> <span class="nx">Address_Type</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">String</span><span class="p">()</span> <span class="nx">AddressString</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">AddressString</span> <span class="kt">string</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__state_tree">

<h3 class="section-header">
  State Tree
</h3>

<div class="section-content">




































<p>The State Tree is the output of applying operations on the Filecoin Blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="c1">// Epoch is an epoch in time in the StateTree.
</span><span class="c1">// It corresponds to rounds in the blockchain, but it
</span><span class="c1">// is defined here as actors need a notion of time.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Epoch</span> <span class="nx">UVarint</span>

<span class="c1">// TODO: move this into a directory w/ all the actors + states
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorName</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">StoragePowerActor</span>
    <span class="nx">StorageMarketActor</span>
    <span class="nx">StorageMinerActor</span>
    <span class="nx">PaymentChannelActor</span>
    <span class="nx">InitActor</span>
    <span class="nx">AccountActor</span>
    <span class="nx">CronActor</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StateTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SystemActors</span>              <span class="p">{</span><span class="nx">ActorName</span><span class="p">:</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">}</span>
    <span class="nx">ActorStates</span>               <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState</span><span class="p">}</span>

    <span class="c1">// TODO: API ConvenienceAPI
</span><span class="c1"></span>
    <span class="nf">GetActor</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span>
<span class="p">}</span>
</code></pre></div>






<p>TODO</p>

<ul>
<li>Add ConvenienceAPI state to provide more user-friendly views.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_vm__message">

<h3 class="section-header">
  VM Message - Actor Method Invocation
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="c1">// GasAmount is a quantity of gas.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GasAmount</span> <span class="nx">UVarint</span>

<span class="c1">// GasPrice is a Gas-to-FIL cost
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GasPrice</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

<span class="kd">type</span> <span class="nx">Message</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">UnsignedMessage</span>
    <span class="nx">SignedMessage</span>
<span class="p">}</span>  <span class="c1">// representation keyed
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">UnsignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">From</span>        <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">To</span>          <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="nx">Method</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span>
    <span class="nx">Params</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span>  <span class="c1">// Serialized parameters to the method.
</span><span class="c1"></span>
    <span class="c1">// When receiving a message from a user account the nonce in the message must match
</span><span class="c1"></span>    <span class="c1">// the expected nonce in the &#34;from&#34; actor. This prevents replay attacks.
</span><span class="c1"></span>    <span class="nx">CallSeqNum</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>
    <span class="nx">Value</span>       <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

    <span class="nx">GasPrice</span>
    <span class="nx">GasLimit</span>    <span class="nx">GasAmount</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">SignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Message</span>    <span class="nx">UnsignedMessage</span>
    <span class="nx">Signature</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">ExitCode</span> <span class="nx">UVarint</span>

<span class="kd">type</span> <span class="nx">MessageReceipt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ExitCode</span>
    <span class="nx">ReturnValue</span>  <span class="nx">Bytes</span>
    <span class="nx">GasUsed</span>      <span class="nx">GasAmount</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span></code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__runtime">

<h3 class="section-header">
  VM Runtime Environment (Inside the VM)
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="c1">// Randomness is a string of random bytes
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Randomness</span> <span class="nx">Bytes</span>

<span class="c1">// Runtime is the VM&#39;s internal runtime object.
</span><span class="c1">// this is everything that is accessible to actors, beyond parameters.
</span><span class="c1">// FKA as vm.Context
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Runtime</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Invocation is the inputs for the current invocation
</span><span class="c1"></span>    <span class="nx">Invocation</span>     <span class="nx">InvocInput</span>
    <span class="nx">State</span>          <span class="nx">VMState</span>

    <span class="c1">// Fatal is a fatal error, and halts VM execution.
</span><span class="c1"></span>    <span class="c1">// This is the normal error condition of actor execution.
</span><span class="c1"></span>    <span class="c1">// On Fatal errors, the VM simply does not apply the state transition.
</span><span class="c1"></span>    <span class="c1">// This is atomic across the entire contract execution.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// TODO: @why wants to get rid of this.
</span><span class="c1"></span>    <span class="nf">Fatal</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span>

    <span class="c1">// Send allows the current execution context to invoke methods on other actors in the system
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// TODO: this should change to async -- put the message on the queue.
</span><span class="c1"></span>    <span class="c1">//       do definied callback methods, with maybe a glue closure to align params or carry intermediate state.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// TODO: what are the return values here?
</span><span class="c1"></span>    <span class="nf">Send</span><span class="p">(</span>
        <span class="nx">to</span>      <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">method</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span>
        <span class="nx">params</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span>
        <span class="nx">value</span>   <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span>
<span class="p">}</span>

<span class="c1">// VMState is Chain state accessible to all contracts via the VM interface
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VMState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// StateTree returns the current state tree
</span><span class="c1"></span>    <span class="nx">StateTree</span>  <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>

    <span class="c1">// Storage provides access to the VM storage layer
</span><span class="c1"></span>    <span class="nx">Storage</span>    <span class="nx">VMStorage</span>

    <span class="c1">// BlockHeight returns the height of the block this message was added to the chain in
</span><span class="c1"></span>    <span class="nf">Epoch</span><span class="p">()</span>    <span class="nx">st</span><span class="p">.</span><span class="nx">Epoch</span>

    <span class="c1">// Balance returns the balance of a given actor
</span><span class="c1"></span>    <span class="nf">Balance</span><span class="p">(</span><span class="nx">id</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

    <span class="c1">// Randomness returns the randomness (ticket) for a particular epoch, and offset.
</span><span class="c1"></span>    <span class="nf">Randomness</span><span class="p">(</span><span class="nx">e</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Epoch</span><span class="p">,</span> <span class="nx">offset</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">Randomness</span>

    <span class="c1">// ComputeActorAddress computes the address of the contract,
</span><span class="c1"></span>    <span class="c1">// based on the creator (invoking address) and nonce given.
</span><span class="c1"></span>    <span class="c1">// TODO: why is this needed? -- InitActor
</span><span class="c1"></span>    <span class="c1">// TODO: this has to be the origin call. and it&#39;s broken: could yield the same address
</span><span class="c1"></span>    <span class="c1">//       need a truly unique way to assign an address.
</span><span class="c1"></span>    <span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">nonce</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">VMStorage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Put writes the given object to the storage staging area and returns its CID
</span><span class="c1"></span>    <span class="nf">Put</span><span class="p">(</span><span class="nx">o</span> <span class="nx">IpldObject</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">c</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Get fetches the given object from storage (either staging, or local) and returns
</span><span class="c1"></span>    <span class="c1">// the serialized data.
</span><span class="c1"></span>    <span class="nf">Get</span><span class="p">(</span><span class="nx">c</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">o</span> <span class="nx">IpldObject</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Commit updates the actual stored state for the actor. This is a compare and swap
</span><span class="c1"></span>    <span class="c1">// operation, and will fail if &#39;old&#39; is not equal to the current return value of `Head`.
</span><span class="c1"></span>    <span class="c1">// This functionality is used to prevent issues with re-entrancy
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// TODO: YIKES i dont think we need commit to prevent re-entrancy. if we do, the model
</span><span class="c1"></span>    <span class="c1">// is wrong.
</span><span class="c1"></span>    <span class="nf">Commit</span><span class="p">(</span><span class="nx">old</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// Head returns the CID of the current actor state
</span><span class="c1"></span>    <span class="nf">Head</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">IpldObject</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">gascost</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/gascost&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>

<span class="c1">// InvocInput represents inputs to a particular actor invocation.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">InvocInput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Runtime</span>     <span class="nx">Runtime</span>
	<span class="nx">InTree</span>      <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
	<span class="nx">OriginActor</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span>
	<span class="nx">CallSeqNum</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>
	<span class="nx">FromActor</span>   <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span>
	<span class="nx">ToActor</span>     <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span>
	<span class="nx">Method</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span>
	<span class="nx">Params</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span>
	<span class="nx">Value</span>       <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">GasLimit</span>    <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span>
	<span class="nx">GasUsed</span>     <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span>
	<span class="c1">// GasPrice    GasPrice
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">OutTree</span>     <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
	<span class="nx">ExitCode</span>    <span class="nx">msg</span><span class="p">.</span><span class="nx">ExitCode</span>
	<span class="nx">ReturnValue</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">GasUsed</span>     <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ErrorInvocOutput</span><span class="p">(</span><span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ec</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">InvocOutput</span><span class="p">{</span>
		<span class="nx">OutTree</span><span class="p">:</span>     <span class="nx">tree</span><span class="p">,</span>
		<span class="nx">GasUsed</span><span class="p">:</span>     <span class="nx">gascost</span><span class="p">.</span><span class="nx">CodeLookupFail</span><span class="p">,</span>
		<span class="nx">ExitCode</span><span class="p">:</span>    <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidMethod</span><span class="p">,</span>
		<span class="nx">ReturnValue</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Runtime_I</span><span class="p">)</span> <span class="nf">Fatal</span><span class="p">(</span><span class="kt">string</span><span class="p">)</span> <span class="nx">Runtime_Fatal_FunRet</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Runtime_I</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span><span class="nx">to</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMState_I</span><span class="p">)</span> <span class="nf">Epoch</span><span class="p">()</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Epoch</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMState_I</span><span class="p">)</span> <span class="nf">Balance</span><span class="p">(</span><span class="nx">id</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMState_I</span><span class="p">)</span> <span class="nf">Randomness</span><span class="p">(</span><span class="nx">e</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Epoch</span><span class="p">,</span> <span class="nx">offset</span> <span class="kt">uint64</span><span class="p">)</span> <span class="nx">Randomness</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMState_I</span><span class="p">)</span> <span class="nf">ComputeActorAddress</span><span class="p">(</span><span class="nx">creator</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">nonce</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMStorage_I</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">o</span> <span class="nx">IpldObject</span><span class="p">)</span> <span class="nx">VMStorage_Put_FunRet</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMStorage_I</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">c</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="nx">VMStorage_Get_FunRet</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMStorage_I</span><span class="p">)</span> <span class="nf">Commit</span><span class="p">(</span><span class="nx">old</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">VMStorage_I</span><span class="p">)</span> <span class="nf">Head</span><span class="p">()</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_vm__runtime__exitcode">

<h4 class="section-header">
  VM Exit Code Constants
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="c1">// TODO: assign all of these.
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// OK is the success return value, similar to unix exit code 0.
</span><span class="c1"></span>	<span class="nx">OK</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// ActorNotFound represents a failure to find an actor.
</span><span class="c1"></span>	<span class="nx">ActorNotFound</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// ActorCodeNotFound represents a failure to find the code for a
</span><span class="c1"></span>	<span class="c1">// particular actor in the VM registry.
</span><span class="c1"></span>	<span class="nx">ActorCodeNotFound</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

	<span class="c1">// InvalidMethod represents a failure to find a method in
</span><span class="c1"></span>	<span class="c1">// an actor
</span><span class="c1"></span>	<span class="nx">InvalidMethod</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

	<span class="c1">// InsufficientFunds represents a failure to apply a message, as
</span><span class="c1"></span>	<span class="c1">// it did not carry sufficient funds for its application.
</span><span class="c1"></span>	<span class="nx">InsufficientFunds</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

	<span class="c1">// InvalidCallSeqNum represents a message invocation out of sequence.
</span><span class="c1"></span>	<span class="c1">// This happens when message.CallSeqNum is not exactly actor.CallSeqNum + 1
</span><span class="c1"></span>	<span class="nx">InvalidCallSeqNum</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">ExitCode</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__runtime__gascost">

<h4 class="section-header">
  VM Gas Cost Constants
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="c1">// TODO: assign all of these.
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// SimpleValueSend is the amount of gas charged for sending value from one
</span><span class="c1"></span>	<span class="c1">// contract to another, without executing any other code.
</span><span class="c1"></span>	<span class="nx">SimpleValueSend</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// // ActorLookupFail is the amount of gas charged for a failure to lookup
</span><span class="c1"></span>	<span class="c1">// // an actor
</span><span class="c1"></span>	<span class="c1">// ActorLookupFail = msg.GasAmount(1)
</span><span class="c1"></span>
	<span class="c1">// CodeLookupFail is the amount of gas charged for a failure to lookup
</span><span class="c1"></span>	<span class="c1">// code in the VM&#39;s code registry.
</span><span class="c1"></span>	<span class="nx">CodeLookupFail</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

	<span class="c1">// ApplyMessageFail represents the gas cost for failures to apply message.
</span><span class="c1"></span>	<span class="c1">// These failures are basic failures encountered at first application.
</span><span class="c1"></span>	<span class="nx">ApplyMessageFail</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__sysactors">

<h3 class="section-header">
  System Actors
</h3>

<div class="section-content">




































<ul>
<li>There are two system actors required for VM processing:

<ul>
<li><a href="#CronActor">CronActor</a> - runs critical functions at every epoch</li>
<li><a href="#InitActor">InitActor</a> - initializes new actors</li>
</ul></li>
<li>There is one more VM level actor:

<ul>
<li><a href="#AccountActor">AccountActor</a> - for user accounts.</li>
</ul></li>
</ul>


</div>


  
    








<div id="systems__filecoin_vm__sysactors__init_actor">

<h4 class="section-header">
  InitActor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> InitActor <a href="docs/systems/filecoin_vm/actors/init_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">type</span> <span class="nx">InitActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// responsible for create new actors
</span><span class="c1"></span>    <span class="nx">AddressMap</span>  <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">}</span>
    <span class="nx">IDMap</span>       <span class="p">{</span><span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">:</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">}</span>
    <span class="nx">NextID</span>      <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InitActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 0
</span><span class="c1"></span>    <span class="nf">Constructor</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span>

    <span class="c1">// 1
</span><span class="c1"></span>    <span class="nf">Exec</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">code</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// 2
</span><span class="c1"></span>    <span class="nf">GetActorIDForAddress</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">sysactors</span>

<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>

<span class="c1">// import st &#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;
</span><span class="c1">// import util &#34;github.com/filecoin-project/specs/util&#34;
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">InitActorState</span><span class="p">,</span> <span class="nx">codeCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="c1">// Make sure that only the actors defined in the spec can be launched.
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">a</span><span class="p">.</span><span class="nf">_isBuiltinActor</span><span class="p">(</span><span class="nx">codeCID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch actor instance that is not a builtin actor&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Get the actor ID for this actor.
</span><span class="c1"></span>	<span class="nx">actorID</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_assignNextID</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span>

	<span class="c1">// Ensure that singeltons can only be launched once.
</span><span class="c1"></span>	<span class="c1">// TODO: do we want to enforce this? If so how should actors be marked as such?
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_isSingletonActor</span><span class="p">(</span><span class="nx">codeCID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;cannot launch another actor of this type&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// This generates a unique address for this actor that is stable across message
</span><span class="c1"></span>	<span class="c1">// reordering
</span><span class="c1"></span>	<span class="c1">// TODO: where do `creator` and `nonce` come from?
</span><span class="c1"></span>	<span class="c1">// TODO: CallSeqNum is not related to From -- it&#39;s related to Origin
</span><span class="c1"></span>	<span class="c1">// addr := rt.ComputeActorAddress(rt.Invocation().FromActor(), rt.Invocation().CallSeqNum())
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="c1">// TODO
</span><span class="c1"></span>
	<span class="c1">// Set up the actor itself
</span><span class="c1"></span>	<span class="nx">actorState</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState_I</span><span class="p">{</span>
		<span class="nx">CodeCID_</span><span class="p">:</span> <span class="nx">codeCID</span><span class="p">,</span>
		<span class="c1">// State_:   nil, // TODO: do we need to init the state? probably not
</span><span class="c1"></span>		<span class="nx">Balance_</span><span class="p">:</span>    <span class="nx">rt</span><span class="p">.</span><span class="nf">Invocation</span><span class="p">().</span><span class="nx">Value</span><span class="p">,</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// The call to the actors constructor will set up the initial state
</span><span class="c1"></span>	<span class="c1">// from the given parameters, setting `actor.Head` to a new value when successfull.
</span><span class="c1"></span>	<span class="c1">// TODO: can constructors fail?
</span><span class="c1"></span>	<span class="c1">// TODO: this needs to be written such that the specific type Constructor is called.
</span><span class="c1"></span>	<span class="c1">//       right now actor.Constructor(p) calls the Actor type, not the concrete type.
</span><span class="c1"></span>	<span class="c1">// a.Constructor(params) // TODO: uncomment this.
</span><span class="c1"></span>
	<span class="c1">// TODO: where is this VM.GlobalState?
</span><span class="c1"></span>	<span class="c1">// TODO: do we need this?
</span><span class="c1"></span>	<span class="c1">// runtime.State().Storage().Set(actorID, actor)
</span><span class="c1"></span>
	<span class="c1">// Store the mappings of address to actor ID.
</span><span class="c1"></span>	<span class="nx">state</span><span class="p">.</span><span class="nf">AddressMap</span><span class="p">()[</span><span class="nx">addr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actorID</span>
	<span class="nx">state</span><span class="p">.</span><span class="nf">IDMap</span><span class="p">()[</span><span class="nx">actorID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">addr</span>

	<span class="c1">// TODO: adjust this to be proper state setting.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nf">StateTree</span><span class="p">().</span><span class="nf">ActorStates</span><span class="p">()[</span><span class="nx">addr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actorState</span> <span class="c1">// atm it&#39;s nil
</span><span class="c1"></span>
	<span class="k">return</span> <span class="nx">addr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">_assignNextID</span><span class="p">(</span><span class="nx">state</span> <span class="nx">InitActorState</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span> <span class="p">{</span>
	<span class="nx">stateI</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">Impl</span><span class="p">()</span> <span class="c1">// TODO: unwrapping like this is ugly.
</span><span class="c1"></span>	<span class="nx">actorID</span> <span class="o">:=</span> <span class="nx">stateI</span><span class="p">.</span><span class="nx">NextID_</span>
	<span class="nx">stateI</span><span class="p">.</span><span class="nx">NextID_</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">actorID</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">GetActorIDForAddress</span><span class="p">(</span><span class="nx">state</span> <span class="nx">InitActorState</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorID</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nf">AddressMap</span><span class="p">()[</span><span class="nx">address</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// TODO: derive this OR from a union type
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">_isSingletonActor</span><span class="p">(</span><span class="nx">codeCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">true</span>
	<span class="c1">// TODO: uncomment this
</span><span class="c1"></span>	<span class="c1">// return codeCID == StorageMarketActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == StoragePowerActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == CronActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == InitActor
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// TODO: derive this OR from a union type
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">_isBuiltinActor</span><span class="p">(</span><span class="nx">codeCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">true</span>
	<span class="c1">// TODO: uncomment this
</span><span class="c1"></span>	<span class="c1">// return codeCID == StorageMarketActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == StoragePowerActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == CronActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == InitActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == StorageMinerActor ||
</span><span class="c1"></span>	<span class="c1">// 	codeCID == PaymentChannelActor
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// TODO
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActorCode_I</span><span class="p">)</span> <span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">input</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="c1">// TODO: load state
</span><span class="c1"></span>	<span class="c1">// var state InitActorState
</span><span class="c1"></span>	<span class="c1">// storage := input.Runtime().State().Storage()
</span><span class="c1"></span>	<span class="c1">// err := loadActorState(storage, input.ToActor().State(), &amp;state)
</span><span class="c1"></span>
	<span class="k">switch</span> <span class="nx">method</span> <span class="p">{</span>
	<span class="c1">// case 0: -- disable: value send
</span><span class="c1"></span>	<span class="c1">// case 1: -- disable: cron. init has no cron action
</span><span class="c1"></span>	<span class="c1">// case 2:
</span><span class="c1"></span>	<span class="c1">// 	return a.InitConstructor(input, state)
</span><span class="c1"></span>	<span class="c1">// case 3:
</span><span class="c1"></span>	<span class="c1">// 	return a.Exec(input, state, params[0], params[1])
</span><span class="c1"></span>	<span class="c1">// case 4:
</span><span class="c1"></span>	<span class="c1">// 	return a.GetActorIDForAddress(input, state, params[0])
</span><span class="c1"></span>	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">ErrorInvocOutput</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">InTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidMethod</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__sysactors__cron_actor">

<h4 class="section-header">
  CronActor
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">type</span> <span class="nx">CronActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Cron has no internal state
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">CronActorCode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// actors is a set of actors to call during EpochTick.
</span><span class="c1"></span>    <span class="c1">// This can be done a bunch of ways. We do it this way here to make it easy to add
</span><span class="c1"></span>    <span class="c1">// a handler to Cron elsewhere in the spec code. How to do this is implementation
</span><span class="c1"></span>    <span class="c1">// specific.
</span><span class="c1"></span>    <span class="nx">Actors</span> <span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>

    <span class="c1">// EpochTick executes built-in periodic actions, run at every Epoch.
</span><span class="c1"></span>    <span class="c1">// EpochTick(r) is called after all other messages in the epoch have been applied.
</span><span class="c1"></span>    <span class="c1">// This can be seen as an implicit last message.
</span><span class="c1"></span>    <span class="nf">EpochTick</span><span class="p">(</span><span class="nx">r</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__sysactors__account_actor">

<h4 class="section-header">
  AccountActor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> AccountActor <a href="docs/systems/filecoin_vm/actors/account_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="kd">type</span> <span class="nx">AccountActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// normal keypair backed accounts
</span><span class="c1"></span>    <span class="nx">Address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">AccountActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">actorState</span>    <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState</span>
    <span class="nx">accountState</span>  <span class="nx">AccountActorState</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__interpreter">

<h3 class="section-header">
  VM Interpreter - Message Invocation (Outside VM)
</h3>

<div class="section-content">




































<p>(You can see the <em>old</em> VM interpreter <a href="docs/systems/filecoin_vm/vm_interpreter_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">MessageRef</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Message</span>  <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span>
    <span class="nx">Miner</span>    <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">VMInterpreter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ApplyMessageBatch</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msgs</span> <span class="p">[</span><span class="nx">MessageRef</span><span class="p">])</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">]}</span>
    <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msg</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">interpreter</span>

<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">gascost</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/gascost&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">vmi</span> <span class="o">*</span><span class="nx">VMInterpreter_I</span><span class="p">)</span> <span class="nf">ApplyMessageBatch</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msgs</span> <span class="p">[]</span><span class="nx">MessageRef</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="p">[]</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">compTree</span> <span class="o">:=</span> <span class="nx">inTree</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">m</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgs</span> <span class="p">{</span>
		<span class="nx">oT</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nx">vmi</span><span class="p">.</span><span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Message</span><span class="p">(),</span> <span class="nx">m</span><span class="p">.</span><span class="nf">Miner</span><span class="p">())</span>
		<span class="nx">compTree</span> <span class="p">=</span> <span class="nx">oT</span>        <span class="c1">// assign the current tree. (this call always succeeds)
</span><span class="c1"></span>		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span> <span class="c1">// add message receipt
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">compTree</span><span class="p">,</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">vmi</span> <span class="o">*</span><span class="nx">VMInterpreter_I</span><span class="p">)</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">compTree</span> <span class="o">:=</span> <span class="nx">inTree</span>
	<span class="nx">fromActor</span> <span class="o">:=</span> <span class="nx">compTree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">fromActor</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidMethod</span><span class="p">,</span> <span class="nx">gascost</span><span class="p">.</span><span class="nx">ApplyMessageFail</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// make sure fromActor has enough money to run the max invocation
</span><span class="c1"></span>	<span class="nx">maxGasCost</span> <span class="o">:=</span> <span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">(),</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">())</span>
	<span class="nx">totalCost</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">()</span> <span class="o">+</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nx">maxGasCost</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nf">Balance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">totalCost</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InsufficientFunds</span><span class="p">,</span> <span class="nx">gascost</span><span class="p">.</span><span class="nx">ApplyMessageFail</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// make sure this is the right message order for fromActor
</span><span class="c1"></span>	<span class="c1">// (this is protection against replay attacks, and useful sequencing)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nf">CallSeqNum</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidCallSeqNum</span><span class="p">,</span> <span class="nx">gascost</span><span class="p">.</span><span class="nx">ApplyMessageFail</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// may return a different tree on succeess.
</span><span class="c1"></span>	<span class="c1">// this MUST get rolled back if the invocation fails.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">toActor</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span>
	<span class="kd">var</span> <span class="nx">err</span> <span class="kt">error</span>
	<span class="nx">compTree</span><span class="p">,</span> <span class="nx">toActor</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nf">treeGetOrCreateAccountActor</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">To</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorNotFound</span><span class="p">,</span> <span class="nx">gascost</span><span class="p">.</span><span class="nx">ApplyMessageFail</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// deduct maximum expenditure gas funds first
</span><span class="c1"></span>	<span class="c1">// TODO: use a single &#34;transfer&#34;
</span><span class="c1"></span>	<span class="nx">compTree</span> <span class="p">=</span> <span class="nf">treeDeductFunds</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">fromActor</span><span class="p">,</span> <span class="nx">maxGasCost</span><span class="p">)</span>

	<span class="c1">// transfer funds fromActor -&gt; toActor
</span><span class="c1"></span>	<span class="c1">// (yes deductions can be combined, spelled out here for clarity)
</span><span class="c1"></span>	<span class="c1">// TODO: use a single &#34;transfer&#34;
</span><span class="c1"></span>	<span class="nx">compTree</span> <span class="p">=</span> <span class="nf">treeDeductFunds</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">fromActor</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">())</span>
	<span class="nx">compTree</span> <span class="p">=</span> <span class="nf">treeDepositFunds</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">toActor</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">())</span>

	<span class="c1">// Prepare invocInput.
</span><span class="c1"></span>	<span class="nx">invocInput</span> <span class="o">:=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">{</span>
		<span class="nx">InTree</span><span class="p">:</span>    <span class="nx">compTree</span><span class="p">,</span>
		<span class="nx">FromActor</span><span class="p">:</span> <span class="nx">fromActor</span><span class="p">,</span>
		<span class="nx">ToActor</span><span class="p">:</span>   <span class="nx">toActor</span><span class="p">,</span>
		<span class="nx">Method</span><span class="p">:</span>    <span class="nx">message</span><span class="p">.</span><span class="nf">Method</span><span class="p">(),</span>
		<span class="nx">Params</span><span class="p">:</span>    <span class="nx">message</span><span class="p">.</span><span class="nf">Params</span><span class="p">(),</span>
		<span class="nx">Value</span><span class="p">:</span>     <span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">(),</span>
		<span class="nx">GasLimit</span><span class="p">:</span>  <span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="c1">// TODO: this is mega jank. need to rework invocationInput + runtime boundaries.
</span><span class="c1"></span>	<span class="nx">invocInput</span><span class="p">.</span><span class="nx">Runtime</span> <span class="p">=</span> <span class="nf">makeRuntime</span><span class="p">(</span><span class="nx">compTree</span><span class="p">,</span> <span class="nx">invocInput</span><span class="p">)</span>

	<span class="c1">// perform the method call to the actor
</span><span class="c1"></span>	<span class="c1">// TODO: eval if we should lift gas tracking and calc to the beginning of invocation
</span><span class="c1"></span>	<span class="c1">// (ie, include account creation, gas accounting itself)
</span><span class="c1"></span>	<span class="nx">out</span> <span class="o">:=</span> <span class="nf">invocationMethodDispatch</span><span class="p">(</span><span class="nx">invocInput</span><span class="p">)</span>

	<span class="c1">// var outTree StateTree
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">out</span><span class="p">.</span><span class="nx">ExitCode</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// error -- revert all state changes -- ie drop updates. burn used gas.
</span><span class="c1"></span>		<span class="nx">outTree</span> <span class="p">=</span> <span class="nx">inTree</span> <span class="c1">// wipe!
</span><span class="c1"></span>		<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">treeDeductFunds</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">fromActor</span><span class="p">,</span> <span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">GasUsed</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">()))</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// success -- refund unused gas
</span><span class="c1"></span>		<span class="nx">outTree</span> <span class="p">=</span> <span class="nx">out</span><span class="p">.</span><span class="nx">OutTree</span> <span class="c1">// take the state from the invocation output
</span><span class="c1"></span>		<span class="nx">refundGas</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">()</span> <span class="o">-</span> <span class="nx">out</span><span class="p">.</span><span class="nx">GasUsed</span>
		<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">treeDepositFunds</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">fromActor</span><span class="p">,</span> <span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">refundGas</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">()))</span>
		<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">treeIncrementActorSeqNo</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">fromActor</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// reward miner gas fees
</span><span class="c1"></span>	<span class="nx">minerActor</span> <span class="o">:=</span> <span class="nx">compTree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">)</span> <span class="c1">// TODO: may be nil.
</span><span class="c1"></span>	<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">treeDepositFunds</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">minerActor</span><span class="p">,</span> <span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">out</span><span class="p">.</span><span class="nx">GasUsed</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">()))</span>

	<span class="k">return</span> <span class="nx">outTree</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt_I</span><span class="p">{</span>
		<span class="nx">ExitCode_</span><span class="p">:</span>    <span class="nx">out</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span>
		<span class="nx">ReturnValue_</span><span class="p">:</span> <span class="nx">out</span><span class="p">.</span><span class="nx">ReturnValue</span><span class="p">,</span>
		<span class="nx">GasUsed_</span><span class="p">:</span>     <span class="nx">out</span><span class="p">.</span><span class="nx">GasUsed</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">invocationMethodDispatch</span><span class="p">(</span><span class="nx">input</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Method</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// just sending money. move along.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span><span class="p">{</span>
			<span class="nx">OutTree</span><span class="p">:</span>     <span class="nx">input</span><span class="p">.</span><span class="nx">InTree</span><span class="p">,</span>
			<span class="nx">GasUsed</span><span class="p">:</span>     <span class="nx">gascost</span><span class="p">.</span><span class="nx">SimpleValueSend</span><span class="p">,</span>
			<span class="nx">ExitCode</span><span class="p">:</span>    <span class="nx">exitcode</span><span class="p">.</span><span class="nx">OK</span><span class="p">,</span>
			<span class="nx">ReturnValue</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//TODO: actually invoke the funtion here.
</span><span class="c1"></span>	<span class="c1">// put any vtable lookups in this function.
</span><span class="c1"></span>
	<span class="nx">actorCode</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">loadActorCode</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">ToActor</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nf">CodeCID</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span><span class="p">{</span>
			<span class="nx">OutTree</span><span class="p">:</span>     <span class="nx">input</span><span class="p">.</span><span class="nx">InTree</span><span class="p">,</span>
			<span class="nx">GasUsed</span><span class="p">:</span>     <span class="nx">gascost</span><span class="p">.</span><span class="nx">ApplyMessageFail</span><span class="p">,</span>
			<span class="nx">ExitCode</span><span class="p">:</span>    <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorCodeNotFound</span><span class="p">,</span>
			<span class="nx">ReturnValue</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="c1">// TODO: maybe: err
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">actorCode</span><span class="p">.</span><span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Params</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">treeIncrementActorSeqNo</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;todo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">treeDeductFunds</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span><span class="p">,</span> <span class="nx">amt</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: turn this into a single transfer call.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;todo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">treeDepositFunds</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span><span class="p">,</span> <span class="nx">amt</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: turn this into a single transfer call.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;todo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">treeGetOrCreateAccountActor</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">toActor</span> <span class="o">:=</span> <span class="nx">inTree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">toActor</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span> <span class="c1">// found
</span><span class="c1"></span>		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="nx">toActor</span><span class="p">,</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">a</span><span class="p">.</span><span class="nf">Type</span><span class="p">().</span><span class="nf">Which</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address_Type_Case_BLS</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">treeNewBLSAccountActor</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address_Type_Case_Secp256k1</span><span class="p">:</span>
		<span class="k">return</span> <span class="nf">treeNewSecp256k1AccountActor</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address_Type_Case_ID</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;no actor with given ID&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address_Type_Case_Actor</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;no such actor&#34;</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">inTree</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;unknown address type&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">treeNewBLSAccountActor</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;todo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">treeNewSecp256k1AccountActor</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">_</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">Actor</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;todo&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">applyError</span><span class="p">(</span><span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">exitCode</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">gasUsed</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">outTree</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt_I</span><span class="p">{</span>
		<span class="nx">ExitCode_</span><span class="p">:</span>    <span class="nx">exitCode</span><span class="p">,</span>
		<span class="nx">ReturnValue_</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">GasUsed_</span><span class="p">:</span>     <span class="nx">gasUsed</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">gasToFIL</span><span class="p">(</span><span class="nx">gas</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">price</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasPrice</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">gas</span><span class="p">)</span> <span class="o">*</span> <span class="nx">util</span><span class="p">.</span><span class="nf">UVarint</span><span class="p">(</span><span class="nx">price</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">makeRuntime</span><span class="p">(</span><span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">input</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime_I</span><span class="p">{</span>
		<span class="nx">Invocation_</span><span class="p">:</span> <span class="nx">input</span><span class="p">,</span>
		<span class="nx">State_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">VMState_I</span><span class="p">{</span>
			<span class="nx">StateTree_</span><span class="p">:</span> <span class="nx">tree</span><span class="p">,</span> <span class="c1">// TODO: also in input.InTree.
</span><span class="c1"></span>			<span class="nx">Storage_</span><span class="p">:</span>   <span class="o">&amp;</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">VMStorage_I</span><span class="p">{},</span>
		<span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">interpreter</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">runtime</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>

<span class="kd">func</span> <span class="nf">loadActorCode</span><span class="p">(</span><span class="nx">input</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">,</span> <span class="nx">codeCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">)</span> <span class="p">(</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// load the code from StateTree.
</span><span class="c1"></span>	<span class="c1">// TODO: this is going to be enabled in the future.
</span><span class="c1"></span>	<span class="c1">// code, err := loadCodeFromStateTree(input.InTree, codeCID)
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">staticActorCodeRegistry</span><span class="p">.</span><span class="nf">LoadActor</span><span class="p">(</span><span class="nx">codeCID</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">interpreter</span>

<span class="kn">import</span> <span class="s">&#34;errors&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime&#34;</span>
<span class="kn">import</span> <span class="nx">sysactors</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/sysactors&#34;</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">ErrActorNotFound</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Actor Not Found&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">staticActorCodeRegistry</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">actorCodeRegistry</span><span class="p">{}</span>

<span class="c1">// CodeCIDs for system actors
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">InitActorCodeCID</span>           <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeCID</span><span class="p">(</span><span class="s">&#34;filecoin/1.0/InitActor&#34;</span><span class="p">)</span>
	<span class="nx">CronActorCodeCID</span>           <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeCID</span><span class="p">(</span><span class="s">&#34;filecoin/1.0/CronActor&#34;</span><span class="p">)</span>
	<span class="nx">AccountActorCodeCID</span>        <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeCID</span><span class="p">(</span><span class="s">&#34;filecoin/1.0/AccountActor&#34;</span><span class="p">)</span>
	<span class="nx">StoragePowerActorCodeCID</span>   <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeCID</span><span class="p">(</span><span class="s">&#34;filecoin/1.0/StoragePowerActor&#34;</span><span class="p">)</span>
	<span class="nx">StorageMinerActorCodeCID</span>   <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeCID</span><span class="p">(</span><span class="s">&#34;filecoin/1.0/StorageMinerActor&#34;</span><span class="p">)</span>
	<span class="nx">StorageMarketActorCodeCID</span>  <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeCID</span><span class="p">(</span><span class="s">&#34;filecoin/1.0/StorageMarketActor&#34;</span><span class="p">)</span>
	<span class="nx">PaymentChannelActorCodeCID</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">CodeCID</span><span class="p">(</span><span class="s">&#34;filecoin/1.0/PaymentChannelActor&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">// Addresses for singleton system actors
</span><span class="c1"></span><span class="kd">var</span> <span class="p">(</span>
	<span class="nx">InitActorAddr</span>           <span class="p">=</span> <span class="o">&amp;</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address_I</span><span class="p">{}</span> <span class="c1">// TODO
</span><span class="c1"></span>	<span class="nx">CronActorAddr</span>           <span class="p">=</span> <span class="o">&amp;</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address_I</span><span class="p">{}</span> <span class="c1">// TODO
</span><span class="c1"></span>	<span class="nx">StoragePowerActorAddr</span>   <span class="p">=</span> <span class="o">&amp;</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address_I</span><span class="p">{}</span> <span class="c1">// TODO
</span><span class="c1"></span>	<span class="nx">StorageMarketActorAddr</span>  <span class="p">=</span> <span class="o">&amp;</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address_I</span><span class="p">{}</span> <span class="c1">// TODO
</span><span class="c1"></span>	<span class="nx">PaymentChannelActorAddr</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address_I</span><span class="p">{}</span> <span class="c1">// TODO
</span><span class="c1"></span><span class="p">)</span>

<span class="c1">// init is called in Go during initialization of a program.
</span><span class="c1">// this is an idiomatic way to do this. Implementations should approach this
</span><span class="c1">// howevery they wish. The point is to initialize a static registry with
</span><span class="c1">// built in pure types that have the code for each actor. Once we have
</span><span class="c1">// a way to load code from the StateTree, use that instead.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">registerBuiltinActors</span><span class="p">(</span><span class="nx">staticActorCodeRegistry</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">registerBuiltinActors</span><span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">actorCodeRegistry</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO
</span><span class="c1"></span>
	<span class="nx">cron</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sysactors</span><span class="p">.</span><span class="nx">CronActorCode_I</span><span class="p">{}</span>

	<span class="nx">r</span><span class="p">.</span><span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">InitActorCodeCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">sysactors</span><span class="p">.</span><span class="nx">InitActorCode_I</span><span class="p">{})</span>
	<span class="nx">r</span><span class="p">.</span><span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">CronActorCodeCID</span><span class="p">,</span> <span class="nx">cron</span><span class="p">)</span>

	<span class="c1">// wire in CRON actions.
</span><span class="c1"></span>	<span class="c1">// TODO: there&#39;s probably a better place to put this, but for now, do it here.
</span><span class="c1"></span>	<span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span><span class="p">,</span> <span class="nx">StoragePowerActorAddr</span><span class="p">)</span>
	<span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cron</span><span class="p">.</span><span class="nx">Actors_</span><span class="p">,</span> <span class="nx">StorageMarketActorAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ActorCode is the interface that all actor code types should satisfy.
</span><span class="c1">// It is merely a method dispatch interface.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorCode</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">input</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">actorCodeRegistry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="kd">map</span><span class="p">[</span><span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">]</span><span class="nx">ActorCode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">actorCodeRegistry</span><span class="p">)</span> <span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">,</span> <span class="nx">actor</span> <span class="nx">ActorCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">[</span><span class="nx">cid</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actor</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">actorCodeRegistry</span><span class="p">)</span> <span class="nf">LoadActor</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">CodeCID</span><span class="p">)</span> <span class="p">(</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">[</span><span class="nx">cid</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrActorNotFound</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain">

<h2 class="section-header">
  <strong>Blockchain</strong>
</h2>

<div class="section-content">







































<div class="tocMap ">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain">
            <strong>Blockchain</strong>


        
            <br /><br /><i class="menuIcon">üì¶</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct">
            Blocks


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__block">
            Block


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__chain">
            Chain


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__chain_manager">
            Chain Manager


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__block_producer">
            Block Producer


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool">
            Message Pool


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool__message_syncer">
            Message Syncer


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool__message_storage">
            Message Storage


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__chainsync">
            Block Syncer


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus">
            Storage Power Consensus


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#algorithms__expected_consensus">
            Expected Consensus


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">
            Storage Power Actor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<p>The Filecoin Blockchain is a distributed virtual machine that achieves consensus, processes messages, accounts for storage, and maintains security in the Filecoin Protocol.</p>

<p>It includes:</p>

<ul>
<li>A <a href="./#systems__filecoin_blockchain__message_pool___index">Message Pool</a> subsystem that nodes use to track and propagate messages related to the storage market throughout a gossip network.</li>
<li>A <a href="./#systems__filecoin_blockchain__chainsync___index"></a> susbystem that tracks and propagates validated message blocks, assembling them into subchains corresponding to versions of the system state.</li>
<li>A <a href="./#systems__filecoin_vm">VM - Virtual Machine</a> subsystem used to interpret and execute messages in order to update system state.</li>
<li>A <a href="./#systems__filecoin_vm__state_tree___index"></a> subsystem which manages the creation and maintenance of state trees (the system state) deterministically generated by the vm from a given subchain.</li>
<li>A <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem which tracks <a href="./#systems__filecoin_mining__storage_mining">storage</a> state for a given chain and helps the blockchain system choose subchains to extend and blocks to include in them.</li>
</ul>

<p>At a high-level, the Filecoin blockchain grows through successive rounds of leader election in which a number of miners are elected to generate a block, whose inclusion in the chain will earn them block rewards.</p>

<p>Most of the functions of the Filecoin blockchain system are detailed in the code below. We focus here on particular points of interest.</p>

<h4 id="storage-power">Storage Power</h4>

<p>Filecoin&rsquo;s blockchain runs on storage power. That is, its consensus algorithm by which miners agree on which subchain to mine is predicated on the amount of storage backing that subchain. At a high-level, the <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem maintains a <em>Power Table</em> that tracks the amount of storage <a href="./#systems__filecoin_mining__storage_mining">storage miner actors</a> have contributed to the network through <em>Sector commitments</em> and <em>Proofs of Spacetime</em>.</p>

<h4 id="leader-election-and-expected-consensus">Leader Election and Expected Consensus</h4>

<p>The leader election process is likewise handled by the <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem (SPC). Using the <em>Power Table</em> it maintains, this subsystem runs a Nakamoto-style leader election process called Expected Consensus at every round to elect miners who can extend the block chain by generating new blocks.</p>

<p>Beyond participating in the Storage Market (see the sref storage_market_subsystem), participation in Filecoin&rsquo;s consensus is the other way storage miners can earn Filecoin tokens.</p>

<p><a href="./#algorithms__expected_consensus">Expected Consensus</a> has two main components: a leader election process and a chain selection algorithm dependent on a weight function.</p>

<h4 id="tipsets">Tipsets</h4>

<p>EC can elect multiple leaders in a given round meaning Filecoin chains can contain multiple blocks at each height (one per winning miner). This greatly increases chain throughput by allowing blocks to propagate through the network of nodes more efficiently but also means miners should coordinate how they select messages for inclusion in their blocks in order to avoid duplicates and maximize their earnings from transaction fees (see <a href="./#systems__filecoin_blockchain__message_pool___index">Message Pool</a>).</p>

<p>Accordingly, blocks from a given round are assembled into Tipsets according to certain rules (they must share the same parents and have been mined at the same height). The Filecoin state tree is modified by the execution of all messages in a given Tipset. Different miners may mine on different Tipsets because of network propagation delay.</p>

<p>Due to this fact, adding new blocks to the chain actually validate those blocks&rsquo; parent Tipsets, that is: executing the messages of a new block, a miner cannot know exactly what state tree this will yield. That state tree is only known once all messages in that block&rsquo;s Tipset have been executed. Accordingly, it is in the next round (and based on the number of blocks mined on a given Tipset) that a miner will be able to choose which state tree to extend.</p>

<h4 id="tipsets-1">Tipsets</h4>

<p>All valid blocks generated in a round form a <code>Tipset</code> that participants will attempt to mine off of in the subsequent round (see above). Tipsets are valid so long as:</p>

<ul>
<li>All blocks in a Tipset have the same parent Tipset</li>
<li>All blocks in a Tipset have the same number of tickets in their <code>Tickets</code> array</li>
</ul>

<p>These conditions imply that all blocks in a Tipset were mined at the same height. This rule is key to helping ensure that EC converges over time. While multiple new blocks can be mined in a round, subsequent blocks all mine off of a Tipset bringing these blocks together. The second rule means blocks in a Tipset are mined in a same round.</p>

<p>The blocks in a tipset have no defined order in representation. During state computation, blocks in a tipset are processed in order of block ticket, breaking ties with the block CID bytes.</p>

<p>Due to network propagation delay, it is possible for a miner in round N+1 to omit valid blocks mined at round N from their Tipset. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol as defined by EC&rsquo;s <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> function.</p>

<h4 id="todo-reorder-this">TODO &ndash; reorder this</h4>

<p>The Filecoin blockchain is the main interface linking various actors in the Filecoin system. It ensures that the system&rsquo;s state is verifiably updated over time and dictates how nodes are meant to extend the network through block reception and validation and extend it through block propagation.</p>

<p>Its components include the:</p>

<ul>
<li>{{ <sref chainsync> }} &ndash; which receives and propagates blocks, maintaining sets of candidate chains on which the miner may mine and running syntactic validation on incoming blocks.</li>
<li>{{ <sref chain_manager> }} &ndash; which maintains a given chain&rsquo;s state, providing facilities to other blockchain subsystems which will query state about the latest chain in order to run, and ensuring incoming blocks are semantically validated before inclusion into the chain.</li>
<li>{{ <sref block_producer> }} &ndash; which is called in the event of a successful leader election in order to produce a new block that will extend the current heaviest chain before forwarding it to the syncer for propagation.</li>
</ul>


</div>


  
    








<div id="systems__filecoin_blockchain__struct">

<h3 class="section-header">
  Blocks
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_blockchain__struct__block">

<h4 class="section-header">
  Block
</h4>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__struct__block__block"></div>
The Block is a unit of the Filecoin blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto&#34;</span>

<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">BlockCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">MessageRoot</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">ReceiptRoot</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">ChainWeight</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">ChainEpoch</span> <span class="nx">UVarint</span>

<span class="kd">type</span> <span class="nx">BlockHeader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Chain linking
</span><span class="c1"></span>    <span class="nx">Parents</span>          <span class="nx">Tipset</span>
    <span class="nx">Weight</span>           <span class="nx">ChainWeight</span>
    <span class="nx">Epoch</span>            <span class="nx">ChainEpoch</span>

    <span class="c1">// Miner Info
</span><span class="c1"></span>    <span class="nx">MinerAddress</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// State
</span><span class="c1"></span>    <span class="nx">StateTree</span>        <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
    <span class="nx">Messages</span>         <span class="nx">MessageRoot</span>
    <span class="nx">MessageReceipts</span>  <span class="nx">ReceiptRoot</span>

    <span class="c1">// Consensus things
</span><span class="c1"></span>    <span class="nx">Timestamp</span>        <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">Ticket</span>
    <span class="nx">ElectionProof</span>

    <span class="c1">// Signatures
</span><span class="c1"></span>    <span class="nx">BlockSig</span>         <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
    <span class="nx">BLSAggregateSig</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>

    <span class="c1">//	SerializeSigned()            []byte
</span><span class="c1"></span>    <span class="c1">//	ComputeUnsignedFingerprint() []
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// TODO: remove this. header is signed
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SignedBlock</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">block</span>  <span class="o">&amp;</span><span class="nx">Block</span>
    <span class="nx">sig</span>    <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Header</span>    <span class="nx">BlockHeader</span>
    <span class="nx">Messages</span>  <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">]</span>
    <span class="nx">Receipts</span>  <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Chain</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">HeadEpoch</span><span class="p">()</span>         <span class="nx">ChainEpoch</span>
    <span class="nf">HeadTipset</span><span class="p">()</span>        <span class="nx">Tipset</span>
    <span class="nf">FinalizedEpoch</span><span class="p">()</span>    <span class="nx">ChainEpoch</span>
    <span class="nf">LatestCheckpoint</span><span class="p">()</span>  <span class="nx">ChainEpoch</span>

    <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span>
    <span class="nf">TicketAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Ticket</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">block</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">SmallerBytes</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">util</span><span class="p">.</span><span class="nf">CompareBytesStrict</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">b</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>

	<span class="c1">// dist := chain.HeadEpoch() - epoch
</span><span class="c1"></span>	<span class="c1">// current := chain.HeadTipset()
</span><span class="c1"></span>	<span class="c1">// parents := current.Parents()
</span><span class="c1"></span>	<span class="c1">// for i := 0; i &lt; dist; i++ {
</span><span class="c1"></span>	<span class="c1">// 	current = parents
</span><span class="c1"></span>	<span class="c1">// 	parents = current.Parents
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// return current
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">TicketAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Ticket</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ts</span><span class="p">.</span><span class="nf">MinTicket</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">FinalizedEpoch</span><span class="p">()</span> <span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// ep := chain.HeadEpoch()
</span><span class="c1"></span>	<span class="c1">// return ep - GetFinality()
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">HeadEpoch</span><span class="p">()</span> <span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">HeadTipset</span><span class="p">()</span> <span class="nx">Tipset</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">bl</span> <span class="o">*</span><span class="nx">Block_I</span><span class="p">)</span> <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset_I</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// dist := bl.Epoch - epoch - 1
</span><span class="c1"></span>	<span class="c1">// current := bl.ParentTipset
</span><span class="c1"></span>	<span class="c1">// parents := current.Parents
</span><span class="c1"></span>	<span class="c1">// for i := range dist {
</span><span class="c1"></span>	<span class="c1">// 	current = parents
</span><span class="c1"></span>	<span class="c1">// 	parent = current.Parents
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>	<span class="c1">// return current
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">bl</span> <span class="o">*</span><span class="nx">Block_I</span><span class="p">)</span> <span class="nf">TicketAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Ticket</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">bl</span><span class="p">.</span><span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ts</span><span class="p">.</span><span class="nf">MinTicket</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_blockchain__struct__block__tipset">

<h5 class="section-header">
  Tipset
</h5>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__struct__block__tipset__tipset"></div>
The Tipset is a group of blocks in the same exact round, that all share the exact same parents.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>

<span class="kd">type</span> <span class="nx">Tipset</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BlockCIDs</span>          <span class="p">[</span><span class="nx">BlockCID</span><span class="p">]</span>
    <span class="nx">Blocks</span>             <span class="p">[</span><span class="nx">BlockHeader</span><span class="p">]</span>

    <span class="nf">Has</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">)</span>   <span class="kt">bool</span>           <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Parents</span>            <span class="nx">Tipset</span>         <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">StateTree</span>          <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>   <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Weight</span>             <span class="nx">ChainWeight</span>    <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Epoch</span>              <span class="nx">ChainEpoch</span>     <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>

    <span class="nf">ValidateSyntax</span><span class="p">()</span>   <span class="kt">bool</span>           <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nf">LatestTimestamp</span><span class="p">()</span>  <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span>     <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nf">MinTicket</span><span class="p">()</span>        <span class="nx">Ticket</span>         <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">block</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Tipset_I</span><span class="p">)</span> <span class="nf">MinTicket</span><span class="p">()</span> <span class="nx">Ticket</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ret</span> <span class="nx">Ticket</span>

	<span class="c1">// for _, currBlock := range ts.Blocks() {
</span><span class="c1"></span>	<span class="c1">// 	tix := currBlock.Ticket()
</span><span class="c1"></span>	<span class="c1">// 	if ret == nil {
</span><span class="c1"></span>	<span class="c1">// 		ret = tix
</span><span class="c1"></span>	<span class="c1">// 	} else {
</span><span class="c1"></span>	<span class="c1">// 		ret = SmallerBytes(tix, ret)
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Tipset_I</span><span class="p">)</span> <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ts</span><span class="p">.</span><span class="nx">Blocks_</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>

	<span class="c1">// parents := ts.Parents_
</span><span class="c1"></span>	<span class="c1">// grandparent := parents[0].Parents_
</span><span class="c1"></span>	<span class="c1">// for i := 1; i &lt; len(parents); i++ {
</span><span class="c1"></span>	<span class="c1">// 	if grandparent != parents[i].Parents_ {
</span><span class="c1"></span>	<span class="c1">// 		return false
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// numTickets := len(ts.Blocks_[0].Tickets_)
</span><span class="c1"></span>	<span class="c1">// for i := 1; i &lt; len(ts.Blocks_); i++ {
</span><span class="c1"></span>	<span class="c1">// 	if numTickets != len(ts.Blocks_[i].Tickets_) {
</span><span class="c1"></span>	<span class="c1">// 		return false
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Tipset_I</span><span class="p">)</span> <span class="nf">LatestTimestamp</span><span class="p">()</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">latest</span> <span class="nx">clock</span><span class="p">.</span><span class="nx">Time</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="c1">// for _, blk := range ts.Blocks_ {
</span><span class="c1"></span>	<span class="c1">// 	if blk.Timestamp().After(latest) || latest.IsZero() {
</span><span class="c1"></span>	<span class="c1">// 		latest = blk.Timestamp()
</span><span class="c1"></span>	<span class="c1">// 	}
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">latest</span>
<span class="p">}</span>

<span class="c1">// func (tipset *Tipset_I) StateTree() stateTree.StateTree {
</span><span class="c1">// 	var currTree stateTree.StateTree = nil
</span><span class="c1">// 	for _, block := range tipset.Blocks() {
</span><span class="c1">// 		if currTree == nil {
</span><span class="c1">// 			currTree = block.StateTree()
</span><span class="c1">// 		} else {
</span><span class="c1">// 			Assert(block.StateTree().CID().Equals(currTree.CID()))
</span><span class="c1">// 		}
</span><span class="c1">// 	}
</span><span class="c1">// 	Assert(currTree != nil)
</span><span class="c1">// 	for _, block := range tipset.Blocks() {
</span><span class="c1">// 		currTree = UpdateStateTree(currTree, block)
</span><span class="c1">// 	}
</span><span class="c1">// 	return currTree
</span><span class="c1">// }
</span></code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__chain">

<h4 class="section-header">
  Chain
</h4>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__struct__chain__chain"></div>
A Chain is a sequence of tipsets, linked together. It is a single history of execution in the Filecoin blockchain.</p>

















<p style="color: #D74848"><b><i>Something's not right. The <code>chain.id</code> file was not found.</i></b></p>



















<p style="color: #D74848"><b><i>Something's not right. The <code>chain.go</code> file was not found.</i></b></p>




</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__chain_manager">

<h4 class="section-header">
  Chain Manager
</h4>

<div class="section-content">






































<p>The <em>Chain Manager</em> is a central component in the blockchain system. It tracks and updates competing subchains received by a given node in order to select the appropriate blockchain head: the latest block of the heaviest subchain it is aware of in the system.</p>

<p>In so doing, the <em>chain manager</em> is the central subsystem that handles bookkeeping for numerous other systems in a Filecoin node and exposes convenience methods for use by those systems, enabling systems to sample randomness from the chain for instance, or to see which block has been finalized most recently.</p>

<p>The chain manager interfaces and functions are included here, but we expand on important details below for clarity.</p>

<h5 id="chain-expansion">Chain Expansion</h5>

<h6 id="incoming-blocks-and-semantic-validation">Incoming blocks and semantic validation</h6>

<p>Once a block has been received and syntactically validated by the <a href="./#systems__filecoin_blockchain__chainsync___index"></a>, it must be semantically validated by the chain manager for inclusion on a given chain.</p>

<p>A semantically valid block:</p>

<ul>
<li>must be from a valid miner with power on the chain</li>
<li>must only have valid parents in the tipset, meaning

<ul>
<li>that each parent itself must be a valid block</li>
<li>that they all have the same parents themselves</li>
<li>that they are all at the same height (i.e. include the same number of tickets)</li>
</ul></li>
<li>must have valid tickets:

<ul>
<li>the first ticket in its tickets array was generated from the smallest ticket in the parent tipset</li>
<li>any following ticket in the array was generated from the prior one (meaning all tickets in the ticket array have been generated by the same miner)</li>
</ul></li>
<li>must have a valid timestamp, meaning

<ul>
<li>must be later than the latest parent block timestamp, and must have been mined within the appropriate mining period</li>
</ul></li>
</ul>

<p>must be later than the earliest parent block time plus appreopriate delay, which is BLOCK_DELAY (30s by default) * len(blk.Tickets).
  see <a href="mining.md#block-validation">BLock Validation</a>
- must only have valid state transitions:
  - all messages in the block must be valid
  - the execution of each message, in the order they are in the block, must produce a receipt matching the corresponding one in the receipt set of the block, see <a href="state-machine.md">the state machine spec</a>.
- the resulting state root after all messages are applied, must match the one in the block</p>

<div class="notices info" >Once the block passes validation, it must be added to the local datastore, regardless whether it is understood as the best tip at this point. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching.</div>

<div class="notices info" >To make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.</div>

<p>The following requires having and processing (executing) the messages</p>

<ul>
<li>Messages can be checked by verifying the messages hash correctly to the value.</li>
<li>MessageAggregateSig can be checked by verifying the messages sign correctly</li>
<li>MessageReceipts can only be checked by executing the messages</li>
<li>StateRoot is the result of the execution of the messages, and can only be verified by executing them</li>
</ul>

<h6 id="block-reception-algorithm">Block reception algorithm</h6>

<p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier Tipset rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="expected-consensus.md#chain-selection">chain selection</a> in the Expected Consensus spec.</p>

<p>However, ahead of finality, a given subchain may be abandoned in order of another, heavier one mined in a given round. In order to rapidly adapt to this, the chain manager must maintain and update all subchains being considered up to finality.</p>

<p>That is, for every incoming block, even if the incoming block is not added to the current heaviest tipset, the chain manager should add it to the appropriate subchain it is tracking, or keep track of it independently until either:
- it is able to do so, through the reception of another block in that subchain
- it is able to discard it, as that block was mined before finality</p>

<p>We give an example of how this could work in the block reception algorithm.</p>

<h6 id="chaintipsmanager">ChainTipsManager</h6>

<p>The Chain Tips Manager is a subcomponent of Filecoin consensus that is technically up to the implementer, but since the pseudocode in previous sections reference it, it is documented here for clarity.</p>

<p>The Chain Tips Manager is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current &lsquo;best&rsquo; tipset is.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Returns the ticket that is at round &#39;r&#39; in the chain behind &#39;head&#39;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TicketFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// Returns the tipset that contains round r (Note: multiple rounds&#39; worth of tickets may exist within a single block due to losing tickets being added to the eventually successfully generated block)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TipsetFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// GetBestTipset returns the best known tipset. If the &#39;best&#39; tipset hasn&#39;t changed, then this
</span><span class="c1">// will return the previous best tipset.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetBestTipset</span><span class="p">()</span>

<span class="c1">// Adds the losing ticket to the chaintips manager so that blocks can be mined on top of it
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddLosingTicket</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Ticket</span><span class="p">)</span></code></pre></div>

</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__block_producer">

<h4 class="section-header">
  Block Producer
</h4>

<div class="section-content">






































<div id="systems__filecoin_blockchain__struct__block_producer__block_producer"></div>

<h5 id="mining-blocks">Mining Blocks</h5>

<p>Having registered as a miner, it&rsquo;s time to start making and checking tickets. At this point, the miner should already be running chain validation, which includes keeping track of the latest <a href="expected-consensus.md#tipsets">Tipsets</a> seen on the network.</p>

<p>For additional details around how consensus works in Filecoin, see the <a href="expected-consensus.md">expected consensus spec</a>. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner should mine a block themselves, and some rules pertaining to how &ldquo;Tickets&rdquo; should be validated during block validation.</p>

<h6 id="ticket-generation">Ticket Generation</h6>

<p>For details of ticket generation, see the <a href="expected-consensus.md#ticket-generation">expected consensus spec</a>.</p>

<p>New tickets are generated using the last ticket in the ticket-chain. Generating a new ticket will take some amount of time (as imposed by the VDF in Expected Consensus).</p>

<p>Because of this, on expectation, as it is produced, the miner will hear about other blocks being mined on the network. By the time they have generated their new ticket, they can check whether they themselves are eligible to mine a new block (see <a href="#block-creation">block creation</a>).</p>

<p>At any height <code>H</code>, there are three possible situations:</p>

<ul>
<li>The miner is eligible to mine a block: they produce their block and form a Tipset with it and other blocks received in this round (if there are any), and resume mining at the next height <code>H+1</code>.</li>
<li>The miner is not eligible to mine a block but has received blocks: they form a Tipset with them and resume mining at the next height <code>H+1</code>.</li>
<li>The miner is not eligible to mine a block and has received no blocks: they run leader election again, using:

<ul>
<li>their losing ticket from the last leader election to produce a new ticket (the <code>Tickets</code> array in the block to be published grows with each new ticket generated).</li>
<li>the ticket <code>H + 1 - K</code> blocks back to attempt to generate an <code>ElectionProof</code>.</li>
</ul></li>
</ul>

<p>This process is repeated until either a winning ticket is found (and block published) or a new valid Tipset comes in from the network.</p>

<p>Let&rsquo;s illustrate this with an example.</p>

<p>Miner M is mining at Height H.
Heaviest tipset at H-1 is {B0}</p>

<ul>
<li>New Round:

<ul>
<li>M produces a ticket at H, from B0&rsquo;s ticket (the min ticket at H-1)</li>
<li>M draws the ticket from height H-K to generate an ElectionProof</li>
<li>That ElectionProof is invalid</li>
<li>M has not heard about other blocks on the network.</li>
</ul></li>
<li>New Round:

<ul>
<li>M produces a ticket at H + 1 using the ticket produced at H last round.</li>
<li>M draws a ticket from height H+1-K to generate an ElectionProof</li>
<li>That ElectionProof is valid</li>
<li>M generates a block B1</li>
<li>M has received blocks B2, B3 from the network with the same parents and same height.</li>
<li>M forms a tipset {B1, B2, B3}</li>
</ul></li>
<li>Finding the new min ticket/extending the ticket chain:

<ul>
<li>M compares the final tickets in {B1,B2,B3} (each has two tickets in their <code>Tickets</code> array). B2 has the smallest final ticket. B2 should be used to extend the ticket chain, conceptually.</li>
</ul></li>
<li>New Round:

<ul>
<li>M produces a new ticket at H + 2 using B2&rsquo;s final ticket (the min final ticket in {B1, B2, B3})</li>
<li>M draws a ticket from H+2-K to generate an ElectionProof</li>
<li>That ElectionProof is invalid</li>
<li>M has received B4 from the network, mined atop {B1,B2,B3}</li>
</ul></li>
<li>New Round with M mining atop B4</li>
</ul>

<p>Anytime a miner receives new blocks, it should evaluate which is the heaviest Tipset it knows about and mine atop it.</p>

<h6 id="block-creation">Block Creation</h6>

<p>Scratching a winning ticket, and armed with a valid <code>ElectionProof</code>, a miner can now publish a new block!</p>

<p>To create a block, the eligible miner must compute a few fields:</p>

<ul>
<li><code>Tickets</code> - An array containing a new ticket, and, if applicable, any intermediary tickets generated to prove appropriate delay for any failed election attempts. See <a href="expected-consensus.md#ticket-generation">ticket generation</a>.</li>
<li><code>ElectionProof</code> - A signature over the final ticket from the <code>Tickets</code> array proving. See <a href="expected-consensus.md#checking-election-results">checking election results</a>.</li>
<li><code>ParentWeight</code> - As described in <a href="expected-consensus.md#chain-weighting">Chain Weighting</a>.</li>
<li><code>Parents</code> - the CIDs of the parent blocks.</li>
<li><code>ParentState</code> - Note that it will not end up in the newly generated block, but is necessary to compute to generate other fields. To compute this:

<ul>
<li>Take the <code>ParentState</code> of one of the blocks in the chosen parent set (invariant: this is the same value for all blocks in a given parent set).</li>
<li>For each block in the parent set, ordered by their tickets:</li>
<li>Apply each message in the block to the parent state, in order. If a message was already applied in a previous block, skip it.</li>
<li>Transaction fees are given to the miner of the block that the first occurance of the message is included in. If there are two blocks in the parent set, and they both contain the exact same set of messages, the second one will receive no fees.</li>
<li>It is valid for messages in two different blocks of the parent set to conflict, that is, A conflicting message from the combined set of messages will always error.  Regardless of conflicts all messages are applied to the state.</li>
<li>TODO: define message conflicts in the state-machine doc, and link to it from here</li>
</ul></li>
<li><code>MsgRoot</code> - To compute this:

<ul>
<li>Select a set of messages from the mempool to include in the block.</li>
<li>Separate the messages into BLS signed messages and secpk signed messages</li>
<li>For the BLS messages:</li>
<li>Strip the signatures off of the messages, and insert all the bare <code>Message</code>s for them into a sharray.</li>
<li>Aggregate all of the bls signatures into a single signature and use this to fill out the <code>BLSAggregate</code> field</li>
<li>For the secpk messages:</li>
<li>Insert each of the secpk <code>SignedMessage</code>s into a sharray</li>
<li>Create a <code>TxMeta</code> object and fill each of its fields as follows:</li>
<li><code>blsMessages</code>: the root cid of the bls messages sharray</li>
<li><code>secpkMessages</code>: the root cid of the secp messages sharray</li>
<li>The cid of this <code>TxMeta</code> object should be used to fill the <code>MsgRoot</code> field of the block header.</li>
</ul></li>
<li><code>BLSAggregate</code> - The aggregated signatures of all messages in the block that used BLS signing.</li>
<li><code>StateRoot</code> - Apply each chosen message to the <code>ParentState</code> to get this.

<ul>
<li>Note: first apply bls messages in the order that they appear in the blsMsgs sharray, then apply secpk messages in the order that they appear in the secpkMessages sharray.</li>
</ul></li>
<li><code>ReceiptsRoot</code> - To compute this:

<ul>
<li>Apply the set of messages to the parent state as described above, collecting invocation receipts as this happens.</li>
<li>Insert them into a sharray and take its root.</li>
</ul></li>
<li><code>Timestamp</code> - A Unix Timestamp generated at block creation. We use an unsigned integer to represent a UTC timestamp (in seconds). The Timestamp in the newly created block must satisfy the following conditions:

<ul>
<li>the timestamp on the block is not in the future (with ALLOWABLE_CLOCK_DRIFT grace to account for relative asynchrony)</li>
<li>the timestamp on the block is at least BLOCK_DELAY * len(block.Tickets) higher than the latest of its parents, with BLOCK_DELAY taking on the same value as that needed to generate a valid VDF proof for a new Ticket (currently set to 30 seconds).</li>
<li>We also recommend the use of a networkTime() function to be booted on node launch and run every so frequently to call on a networked time service (e.g. ntp) and ensure relative synchrony with the rest of the network.</li>
</ul></li>
<li><code>BlockSig</code> - A signature with the miner&rsquo;s private key (must also match the ticket signature) over the entire block. This is to ensure that nobody tampers with the block after it propagates to the network, since unlike normal PoW blockchains, a winning ticket is found independently of block generation.</li>
</ul>

<p>An eligible miner can start by filling out <code>Parents</code>, <code>Tickets</code> and <code>ElectionProof</code> with values from the ticket checking process.</p>

<p>Next, they compute the aggregate state of their selected parent blocks, the <code>ParentState</code>. This is done by taking the aggregate parent state of the blocks&rsquo; parent Tipset, sorting the parent blocks by their tickets, and applying each message in each block to that state. Any message whose nonce is already used (duplicate message) in an earlier block should be skipped (application of this message should fail anyway). Note that re-applied messages may result in different receipts than they produced in their original blocks, an open question is how to represent the receipt trie of this tipsets &lsquo;virtual block&rsquo;. For more details on message execution and state transitions, see the <a href="state-machine.md">Filecoin state machine</a> document.</p>

<p>Once the miner has the aggregate <code>ParentState</code>, they must apply the block reward. This is done by adding the correct block reward amount to the miner owner&rsquo;s account balance in the state tree. The reward will be spendable immediately in this block. See <a href="#block-rewards">block reward</a> for details on how the block reward is structured. See <a href="#notes-on-block-reward-application">Notes on Block Reward Application</a> for some of the nuances in applying block rewards.</p>

<p>Now, a set of messages is selected to put into the block. For each message, the miner subtracts <code>msg.GasPrice * msg.GasLimit</code> from the sender&rsquo;s account balance, returning a fatal processing error if the sender does not have enough funds (this message should not be included in the chain).</p>

<p>They then apply the messages state transition, and generate a receipt for it containing the total gas actually used by the execution, the executions exit code, and the return value (see <a href="data-structures.md#message-receipt">receipt</a> for more details). Then, they refund the sender in the amount of <code>(msg.GasLimit - GasUsed) * msg.GasPrice</code>. In the event of a message processing error, the remaining gas is refunded to the user, and all other state changes are reverted. (Note: this is a divergence from the way things are done in Ethereum)</p>

<p>Each message should be applied on the resultant state of the previous message execution, unless that message execution failed, in which case all state changes caused by that message are thrown out. The final state tree after this process will be the block&rsquo;s <code>StateRoot</code>.</p>

<p>The miner merklizes the set of messages selected, and put the root in <code>MsgRoot</code>. They gather the receipts from each execution into a set, merklize them, and put that root in <code>ReceiptsRoot</code>. Finally, they set the <code>StateRoot</code> field with the resultant state.</p>

<div class="notices info" >Note that the <code>ParentState</code> field from the expected consensus document is left out, this is to help minimize the size of the block header. The parent state for any given parent set should be computed by the client and cached locally.</div>

<p>Finally, the miner can generate a Unix Timestamp to add to their block, to show that the block generation was appropriately delayed.</p>

<p>The miner will wait until BLOCK_DELAY has passed since the latest block in the parent set was generated to timestamp and send out their block. We recommend using NTP or another clock synchronization protocol to ensure that the timestamp is correctly generated (lest the block be rejected). While this timestamp does not provide a hard proof that the block was delayed (we rely on the VDF in the ticket-chain to do so), it provides some softer form of block delay by ensuring that honest miners will reject undelayed blocks.</p>

<p>Now the block is complete, all that&rsquo;s left is to sign it. The miner serializes the block now (without the signature field), takes the sha256 hash of it, and signs that hash. They place the resultant signature in the <code>BlockSig</code> field.</p>

<h6 id="block-broadcast">Block Broadcast</h6>

<p>An eligible miner broadcasts the completed block to the network (via <a href="data-propagation.md">block propagation</a>), and assuming everything was done correctly, the network will accept it and other miners will mine on top of it, earning the miner a block reward!</p>

<h5 id="block-rewards">Block Rewards</h5>

<p>Over the entire lifetime of the protocol, 1,400,000,000 FIL (<code>TotalIssuance</code>) will be given out to miners. The rate at which the funds are given out is set to halve every six years, smoothly (not a fixed jump like in Bitcoin). These funds are initially held by the network account actor, and are transferred to miners in blocks that they mine. Over time, the reward will eventually become close zero as the fractional amount given out at each step shrinks the network account&rsquo;s balance to 0.</p>

<p>The equation for the current block reward is of the form:</p>

<pre><code>Reward = (IV * RemainingInNetworkActor) / TotalIssuance
</code></pre>

<p><code>IV</code> is the initial value, and is set to:</p>

<pre><code>IV = 153856861913558700202 attoFIL // 153.85 FIL
</code></pre>

<p>IV was derived from:</p>

<pre><code>// Given one block every 30 seconds, this is how many blocks are in six years
HalvingPeriodBlocks = 6 * 365 * 24 * 60 * 2 = 6,307,200 blocks
Œª = ln(2) / HalvingPeriodBlocks
IV = TotalIssuance * (1-e^(-Œª)) // Converted to attoFIL (10e18)
</code></pre>

<p>Note: Due to jitter in EC, and the gregorian calendar, there may be some error in the issuance schedule over time. This is expected to be small enough that it&rsquo;s not worth correcting for. Additionally, since the payout mechanism is transferring from the network account to the miner, there is no risk of minting <em>too much</em> FIL.</p>

<p>TODO: Ensure that if a miner earns a block reward while undercollateralized, then <code>min(blockReward, requiredCollateral-availableBalance)</code> is garnished (transfered to the miner actor instead of the owner).</p>

<h6 id="notes-on-block-reward-application">Notes on Block Reward Application</h6>

<p>As mentioned above, every round, a miner checks to see if they have been selected as the leader for that particular round (see <a href="expected-consensus.md#secret-leader-election">Secret Leader Election</a> in the Expected Consensus spec for more detail). Thus, it is possible that multiple miners may be selected as winners in a given round, and thus, that there will be multiple blocks with the same parents that are produced at the same block height (forming a Tipset). Each of the winning miners will apply the block reward directly to their actor&rsquo;s state in their state tree.</p>

<p>Other nodes will receive these blocks and form a Tipset out of the eligible blocks (those that have the same parents and are at the same block height). These nodes will then validate the Tipset. The full procedure for how to verify a Tipset can be found above in <a href="#block-validation">Block Validation</a>. To validate Tipset state, the validating node will, for each block in the Tipset, first apply the block reward value directly to the mining node&rsquo;s account and then apply the messages contained in the block.</p>

<p>Thus, each of the miners who produced a block in the Tipset will receive a block reward. There will be no lockup. These rewards can be spent immediately.</p>

<p>Messages in Filecoin also have an associated transaction fee (based on the gas costs of executing the message). In the case where multiple winning miners included the same message in their blocks, only the first miner will be paid this transaction fee. The first miner is the miner with the lowest ticket value (sorted lexicographically). More details on message execution can be found in the <a href="state-machine.md#execution-calling-a-method-on-an-actor">State Machine spec</a>.</p>

<h5 id="open-questions">Open Questions</h5>

<ul>
<li>How should receipts for tipsets &lsquo;virtual blocks&rsquo; be referenced? It is common for applications to provide the merkleproof of a receipt to prove that a transaction was successfully executed.</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__message_pool">

<h3 class="section-header">
  Message Pool
</h3>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__message_pool__message_pool"></div>
The Message Pool is a subsystem in the Filecoin blockchain system. The message pool is acts as the interface between Filecoin nodes and a peer-to-peer network used for off-chain message transmission. It is used by nodes to maintain a set of messages to transmit to the Filecoin VM (for &ldquo;on-chain&rdquo; execution).</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">MessagePoolSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// needs access to:
</span><span class="c1"></span>    <span class="c1">// - BlockchainSubsystem
</span><span class="c1"></span>    <span class="c1">//   - needs access to StateTree
</span><span class="c1"></span>    <span class="c1">//   - needs access to Messages mined into blocks (probably past finality)
</span><span class="c1"></span>    <span class="c1">//     to remove from the MessagePool
</span><span class="c1"></span>    <span class="c1">// - NetworkSubsystem
</span><span class="c1"></span>    <span class="c1">//   - needs access to MessagePubsub
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Important remaining questions:
</span><span class="c1"></span>    <span class="c1">// - how does BlockchainSubsystem.BlockReceiver handle asking for messages?
</span><span class="c1"></span>    <span class="c1">// - how do we note messages are now part of the blockchain
</span><span class="c1"></span>    <span class="c1">//   - how are they cleared from the mempool
</span><span class="c1"></span>    <span class="c1">// - do we need to have some sort of purge?
</span><span class="c1"></span>
    <span class="c1">// AddNewMessage is called to add messages created at this node,
</span><span class="c1"></span>    <span class="c1">// or to be propagated by this node. All messages enter the network
</span><span class="c1"></span>    <span class="c1">// through one of these calls, in at least one filecoin node. They
</span><span class="c1"></span>    <span class="c1">// are then propagated to other filecoin nodes via the MessagePool
</span><span class="c1"></span>    <span class="c1">// subsystem. Other nodes receive and propagate Messages via their
</span><span class="c1"></span>    <span class="c1">// own MessagePools.
</span><span class="c1"></span>    <span class="nf">AddNewMessage</span><span class="p">(</span><span class="nx">m</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">)</span>

    <span class="c1">// Stats returns information about the MessagePool contents.
</span><span class="c1"></span>    <span class="nf">Stats</span><span class="p">()</span> <span class="nx">MessagePoolStats</span>

    <span class="c1">// FindMessage receives a descriptor query q, and returns a set of
</span><span class="c1"></span>    <span class="c1">// messages currently in the mempool that match the Query constraints.
</span><span class="c1"></span>    <span class="c1">// q may have all, any, or no constraints specified.
</span><span class="c1"></span>    <span class="c1">// FindMessage(q MessageQuery) union {
</span><span class="c1"></span>    <span class="c1">//  [base.Message],
</span><span class="c1"></span>    <span class="c1">//  Error
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>
    <span class="c1">// MostProfitableMessages returns messages that are most profitable
</span><span class="c1"></span>    <span class="c1">// to mine for this miner.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Note: This is where algorithms about chosing best messages given
</span><span class="c1"></span>    <span class="c1">//       many leaders should go.
</span><span class="c1"></span>    <span class="nf">GetMostProfitableMessages</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Message</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessagePoolStats</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Size is the amount of messages in the MessagePool
</span><span class="c1"></span>    <span class="nx">Size</span> <span class="nx">UInt</span>
<span class="p">}</span>

<span class="c1">// MessageQuery is a descriptor used to find messages matching one or more
</span><span class="c1">// of the constraints specified.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MessageQuery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="cm">/*
</span><span class="cm">  From   base.Address
</span><span class="cm">  To     base.Address
</span><span class="cm">  Method ActorMethodId
</span><span class="cm">  Params ActorMethodParams
</span><span class="cm">
</span><span class="cm">  ValueMin    TokenAmount
</span><span class="cm">  ValueMax    TokenAmount
</span><span class="cm">  GasPriceMin TokenAmount
</span><span class="cm">  GasPriceMax TokenAmount
</span><span class="cm">  GasLimitMin TokenAmount
</span><span class="cm">  GasLimitMax TokenAmount
</span><span class="cm">  */</span>
<span class="p">}</span>
</code></pre></div>






<p>Clients that use a message pool include:</p>

<ul>
<li>storage market provider and client nodes - for transmission of deals on chain</li>
<li>storage miner nodes - for transmission of PoSts, sector commitments, deals, and other operations tracked on chain</li>
<li>verifier nodes - for transmission of potential faults on chain</li>
<li>relayer nodes - for forwarding and discarding messages appropriately.</li>
</ul>

<p>The message pool subsystem is made of two components:</p>

<ul>
<li>The message syncer <a href="./#systems__filecoin_blockchain__message_pool__message_syncer">Message Syncer</a> &ndash; which receives and propagates messages.</li>
<li>Message storage <a href="./#systems__filecoin_blockchain__message_pool__message_storage">Message Storage</a> &ndash; which caches messages according to a given policy.</li>
</ul>

<p>TODOs:</p>

<ul>
<li>discuss how messages are meant to propagate slowly/async</li>
<li>explain algorithms for choosing profitable txns</li>
</ul>


</div>


  
    








<div id="systems__filecoin_blockchain__message_pool__message_syncer">

<h4 class="section-header">
  Message Syncer
</h4>

<div class="section-content">






































<div id="systems__filecoin_blockchain__message_pool__message_syncer__message_syncer"></div>

<p>TODO:</p>

<ul>
<li>explain message syncer works</li>
<li>include the message syncer code</li>
</ul>

<h5 id="message-propagation">Message Propagation</h5>

<p>Messages are propagated over the libp2p pubsub channel <code>/fil/messages</code>. On this channel, every <a href="data-structures.md#messages">serialised <code>SignedMessage</code></a> is announced.</p>

<p>Upon receiving the message, its validity must be checked: the signature must be valid, and the account in question must have enough funds to cover the actions specified. If the message is not valid it should be dropped and must not be forwarded.</p>

<div class="notices todo" >discuss checking signatures and account balances, some tricky bits that need consideration. Does the fund check cause improper dropping? E.g. I have a message sending funds then use the newly constructed account to send funds, as long as the previous wasn&rsquo;t executed the second will be considered &ldquo;invalid&rdquo; &hellip; though it won&rsquo;t be at the time of execution.</div>


</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__message_pool__message_storage">

<h4 class="section-header">
  Message Storage
</h4>

<div class="section-content">




































<div id="systems__filecoin_blockchain__message_pool__message_storage__message_storage"></div>

<p>TODO:</p>

<ul>
<li>give sample algorithm for miner message selection in block production (to avoid dups)</li>
<li>give sample algorithm for message storage caching/purging policies.</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__chainsync">

<h3 class="section-header">
  Block Syncer
</h3>

<div class="section-content">






































<p>In order to ensure they are always on the correct latest state of the blockchain,
a Filecoin node must continuously monitor and propagate blocks on the network.</p>

<p>When a node receives blocks, it must also <em>validate</em> them.
Validation is split into two stages, syntactic and semantic.
The syntactic stage may be validated without reference to additional data, the semantic stage requires access to the chain which the block extends.</p>

<p>For clarity, we separate these stages into separate components:
syntactic validation is performed by the <a href="./#systems__filecoin_blockchain__chainsync___index"></a>,
and once collected and validated, the blocks are forwarded
to the <a href="./#systems__filecoin_blockchain__struct__chain_manager___index"></a> which performs semantic validation and adds the blocks to the node&rsquo;s current view of the blockchain state.</p>

<p>The block syncer interfaces and functions are included here, but we expand on important details below for clarity.</p>

<p>goFile block_syncer</p>

<h4 id="block-reception-and-syntactic-validation">Block reception and Syntactic Validation</h4>

<ul>
<li>Called by: libp2p <a href="./#systems__filecoin_blockchain__chainsync___index"></a></li>
<li>Calls on: <a href="./#systems__filecoin_blockchain__struct__chain_manager___index"></a></li>
</ul>

<p>On reception of a new block over the appropriate libp2p channel (see gossib_sub), the <em>Block Syncer</em>&rsquo;s <em>OnNewBlock</em> method is invoked. Thereafter, the syncer must perform syntactic validation on the block to discard invalid blocks and forward the others for further validation by the <a href="./#systems__filecoin_blockchain__struct__chain_manager___index"></a>. At a high level, a syntactically valid block:</p>

<ul>
<li>must include a well-formed miner address</li>
<li>must include at least one well-formed ticket</li>
<li>must include an election proof which is a valid signature by the miner address of the final ticket</li>
<li>must include at least one parent CID</li>
<li>must include a positive parent weight</li>
<li>must include a positive height</li>
<li>must include a well-formed state root</li>
<li>must include well-formed messages, and corresponding receipts CIDs</li>
<li>must include a valid timestamp</li>
</ul>

<h5 id="timestamp-syntactic-validation">Timestamp Syntactic validation</h5>

<p>In order to ensure that block producers release blocks as soon as possible, filecoin nodes have a cutoff time within each leader election round after which they cease to accept new blocks for this round.</p>

<p>Specifically, the block syncer validation process will use the <a href="./#systems__filecoin_nodes__clock___index"></a> subsystem to associate a wall clock time to the given round number. Any block coming in after the cutoff time is discarded.</p>

<p>In practice, appropriate parameters will not impact nodes regardless of their network connectivity, but helps clearly demarkate rounds by creating a buffer between a round&rsquo;s end and another&rsquo;s beginning.</p>

<h4 id="block-propagation">Block Propagation</h4>

<ul>
<li>Called by: <a href="./#systems__filecoin_blockchain__struct__block_producer___index">Block Producer</a></li>
<li>Calls on: libp2p <a href="./#systems__filecoin_blockchain__chainsync___index"></a></li>
</ul>

<p>Blocks are propagated over the libp2p pubsub channel <code>/fil/blocks</code>. The following structure is filled out with the appropriate information, serialized (with IPLD), and sent over the wire:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BlockMessage struct <span class="o">{</span>
  header BlockHeader
  secpkMessages <span class="o">[]</span><span class="p">&amp;</span>SignedMessage
  blsMessages <span class="o">[]</span><span class="p">&amp;</span>Message
<span class="o">}</span></code></pre></div>

</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__storage_power_consensus">

<h3 class="section-header">
  Storage Power Consensus
</h3>

<div class="section-content">






































<p><div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_consensus"></div>
The Storage Power Consensus subsystem is the main interface which enables Filecoin nodes to agree on the state of the system. SPC accounts for individual storage miners&rsquo; effective power over consensus in given chains in its <em>Power Table</em>. It also runs <em>Expected Consensus</em> (the underlying consensus algorithm in use by Filecoin), enabling storage miners to run leader election and generate new blocks updating the state of the Filecoin system.</p>

<p>Succinctly, the SPC subsystem offers the following services:
- Access to the <em>Power Table</em> for every subchain, accounting for individual storage miner power and total power on-chain.
- Access to <a href="./#algorithms__expected_consensus">Expected Consensus</a> for individual storage miners, enabling:
    - Access to verifiable randomness <a href="./#algorithms__expected_consenus__tickets">Tickets</a> as needed in the rest of the protocol.
    - Running  <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> to produce new blocks.
    - Running <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> across subchains using EC&rsquo;s weighting function.
    - Identification of <a href="./#algorithms__expected_consensus__finality">the most recently finalized tipset</a>, for use by all protocol participants.</p>

<p>Much of the Storage Power Consensus&rsquo; subsystem functionality is detailed in the code below but we touch upon some of its behaviors in more detail.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">base_mining</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto&#34;</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusSubsystem</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">//(@mutable)
</span><span class="c1"></span>    <span class="nx">actor</span>                <span class="nx">StoragePowerActor</span>
    <span class="nx">associatedStateTree</span>  <span class="o">&amp;</span><span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>  <span class="c1">// TODO: remove this. should not store this here.
</span><span class="c1"></span>
    <span class="nf">GenerateElectionProof</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
    <span class="nf">ChooseTipsetToMine</span><span class="p">(</span><span class="nx">tipsets</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">])</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">]</span>

    <span class="nx">ec</span> <span class="nx">ExpectedConsensus</span>

    <span class="c1">// call by BlockchainSubsystem during block reception
</span><span class="c1"></span>    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">validateElectionProof</span><span class="p">(</span>
        <span class="nx">height</span>         <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
        <span class="nx">electionProof</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>
        <span class="nx">workerAddr</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">validateTicket</span><span class="p">(</span><span class="nx">tix</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">computeTipsetWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>

    <span class="nf">IsWinningElectionProof</span><span class="p">(</span><span class="nx">electionProof</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span><span class="p">,</span> <span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">StoragePowerConsensusError</span><span class="p">()</span> <span class="nx">StoragePowerConsensusError</span>

    <span class="c1">// Randomness methods
</span><span class="c1"></span>
    <span class="c1">// call by StorageMiningSubsystem during block production
</span><span class="c1"></span>    <span class="nf">GetTicketProductionSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>

    <span class="c1">// call by StorageMiningSubsystem during block production
</span><span class="c1"></span>    <span class="nf">GetElectionProofSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>

    <span class="c1">// call by StorageMiningSubsystem in sealing sector
</span><span class="c1"></span>    <span class="nf">GetSealSeed</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">base_mining</span><span class="p">.</span><span class="nx">SealSeed</span>

    <span class="c1">// call by StorageMiningSubsystem after sealing
</span><span class="c1"></span>    <span class="nf">GetPoStChallenge</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">base_mining</span><span class="p">.</span><span class="nx">PoStChallenge</span>

    <span class="nf">GetFinality</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ExpectedConsensus</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ComputeWeight</span><span class="p">(</span><span class="nx">chain</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Chain</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>
    <span class="nf">IsValidConsensusFault</span><span class="p">(</span><span class="nx">faults</span> <span class="nx">ConsensusFaultType</span><span class="p">,</span> <span class="nx">blocks</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">])</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ConsensusFaultType</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">DoubleForkMiningFault</span>  <span class="nx">ConsensusFault</span>
    <span class="nx">ParentGrindingFault</span>    <span class="nx">ConsensusFault</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ConsensusFault</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">StoragePowerConsensusError</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>






<h5 id="distinguishing-between-storage-miners-and-block-miners">Distinguishing between storage miners and block miners</h5>

<p>There are two ways to earn Filecoin tokens in the Filecoin network:
- By participating in the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> as a storage provider and being paid by clients for file storage deals.
- By mining new blocks on the network, helping modify system state and secure the Filecoin consensus mechanism.</p>

<p>We must distinguish between both types of &ldquo;miners&rdquo; (storage and block miners). <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> in Filecoin is predicated on a miner&rsquo;s storage power. Thus, while all block miners will be storage miners, the reverse is not necessarily true.</p>

<p>However, given Filecoin&rsquo;s &ldquo;useful Proof-of-Work&rdquo; is achieved through file storage (PoRep and PoSt), there is little overhead cost for storage miners to participate in leader election. Such a <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">Storage Miner Actor</a> need only register with the <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">Storage Power Actor</a> in order to participate in Expected Consensus and mine blocks.</p>

<h5 id="repeated-leader-election-attempts">Repeated leader election attempts</h5>

<p>In the case that no miner is eligible to produce a block in a given round of EC, the storage power consensus subsystem will be called by the block producer to attempt another leader election by incrementing the nonce appended to the ticket drawn from the past in order to attempt to craft a new valid <code>ElectionProof</code> and trying again.</p>

<div id="systems__filecoin_blockchain__storage_power_consensus__ticket_chain"></div>

<h6 id="the-ticket-chain-and-randomness-on-chain">The Ticket chain and randomness on-chain</h6>

<p>While each Filecoin block header contains a ticket field (see <a href="./#algorithms__expected_consenus__tickets">Tickets</a>), it is useful to provide nodes with a ticket chain abstraction.</p>

<p>Namely, tickets are used throughout the Filecoin system as sources of on-chain randomness. For instance,
- The <a href="./#systems__filecoin_mining__storage_proving__sector_sealer">Sector Sealer</a> uses tickets as SealSeeds to bind sector commitments to a given subchain.
- The <a href="./#systems__filecoin_mining__storage_proving__post_generator">PoSt Generator</a> likewise uses tickets as PoStChallenges to prove sectors remain committed as of a given block.
- They are drawn by the Storage Power subsystem as randomness in <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> to determine their eligibility to mine a block
- They are drawn by the Storage Power subsystem in order to generate new tickets for future use.</p>

<p>Each of these ticket uses may require drawing tickets at different chain heights, according to the security requirements of the particular protocol making use of tickets. Due to the nature of Filecoin&rsquo;s Tipsets and the possibility of using losing tickets (that did not yield leaders in leader election) for randomness at a given height, tracking the canonical ticket of a subchain at a given height can be arduous to reason about in terms of blocks. To that end, it is helpful to create a ticket chain abstraction made up of only those tickets to be used for randomness at a given height.</p>

<p>This ticket chain will track one-to-one with a block at each height in a given subchain, but omits certain details including other blocks mined at that height.</p>

<p>It is composed inductively as follows. For a given chain:</p>

<ul>
<li>At height 0, take the genesis block, return its ticket</li>
<li>At height n+1, take the heaviest tipset in our chain at height n.

<ul>
<li>select the block in that tipset with the smallest final ticket, return its ticket</li>
</ul></li>
</ul>

<p>Because a Tipset can contain multiple blocks, the smallest ticket in the Tipset must be drawn otherwise the block will be invalid.</p>

<pre><code>   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ                      ‚îÇ
   ‚îÇ                      ‚îÇ
   ‚îÇ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
   ‚îÇ‚îÇ TA ‚îÇ              A ‚îÇ
   ‚îî‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

   ‚îå ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
                          ‚îÇ
   ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ       TA &lt; TB &lt; TC
   ‚îÇ‚îÇ TB ‚îÇ              B
    ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îò

   ‚îå ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
                          ‚îÇ
   ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
   ‚îÇ‚îÇ TC ‚îÇ              C
    ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îò
</code></pre>

<p>In the above diagram, a miner will use block A&rsquo;s Ticket to generate a new ticket (or an election proof farther in the future) since it is the smallest in the Tipset.</p>

<h5 id="drawing-randomness-for-sector-commitments">Drawing randomness for sector commitments</h5>

<p>Tickets are used as input to the SEAL above in order to tie Proofs-of-Replication to a given chain, thereby preventing long-range attacks (from another miner in the future trying to reuse SEALs).</p>

<p>The ticket has to be drawn from a finalized block in order to prevent the miner from potential losing storage (in case of a chain reorg) even though their storage is intact.</p>

<p>Verification should ensure that the ticket was drawn no farther back than necessary by the miner. We note that tickets can uniquely be associated to a given round in the protocol (lest a hash collision be found), but that the round number is explicited by the miner in <code>commitSector</code>.</p>

<p>We present precisely how ticket selection and verification should work. In the below, we use the following notation:</p>

<ul>
<li><code>F</code>&ndash; Finality (number of rounds)</li>
<li><code>X</code>&ndash; round in which SEALing starts</li>
<li><code>Z</code>&ndash; round in which the SEAL appears (in a block)</li>
<li><code>Y</code>&ndash; round announced in the SEAL <code>commitSector</code> (should be X, but a miner could use any Y &lt;= X), denoted by the ticket selection

<ul>
<li><code>T</code>&ndash; estimated time for SEAL, dependent on sector size</li>
<li><code>G = T + variance</code>&ndash; necessary flexibility to account for network delay and SEAL-time variance.</li>
</ul></li>
</ul>

<p>We expect Filecoin will be able to produce estimates for sector commitment time based on sector sizes, e.g.:
<code>(estimate, variance) &lt;--- SEALTime(sectors)</code>
G and T will be selected using these.</p>

<h6 id="picking-a-ticket-to-seal">Picking a Ticket to Seal</h6>

<p>When starting to prepare a SEAL in round X, the miner should draw a ticket from X-F with which to compute the SEAL.</p>

<h6 id="verifying-a-seal-s-ticket">Verifying a Seal&rsquo;s ticket</h6>

<p>When verifying a SEAL in round Z, a verifier should ensure that the ticket used to generate the SEAL is found in the range of rounds [Z-T-F-G, Z-T-F+G].</p>

<h6 id="in-detail">In Detail</h6>

<pre><code>                               Prover
           ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
          ‚îÇ

          ‚ñº
         X-F ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄF‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ X ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄT‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ Z
     -G   .  +G                 .                        .
  ‚îÄ‚îÄ‚îÄ(‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ( )‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ( )‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 '                        '        time
 [Z-T-F-G, Z-T-F+G]
          ‚ñ≤

          ‚îî ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
                              Verifier
</code></pre>

<p>Note that the prover here is submitting a message on chain (i.e. the SEAL). Using an older ticket than necessary to generate the SEAL is something the miner may do to gain more confidence about finality (since we are in a probabilistically final system). However it has a cost in terms of securing the chain in the face of long-range attacks (specifically, by mixing in chain randomness here, we ensure that an attacker going back a month in time to try and create their own chain would have to completely regenerate any and all sectors drawing randomness since to use for their fork&rsquo;s power).</p>

<p>We break this down as follows:</p>

<ul>
<li>The miner should draw from <code>X-F</code>.</li>
<li>The verifier wants to find what <code>X-F</code> should have been (to ensure the miner is not drawing from farther back) even though Y (i.e. the round of the ticket actually used) is an unverifiable value.</li>
<li>Thus, the verifier will need to make an inference about what <code>X-F</code> is likely to have been based on:

<ul>
<li>(known) round in which the message is received (Z)</li>
<li>(known) finality value (F)</li>
<li>(approximate) SEAL time (T)</li>
</ul></li>
<li>Because T is an approximate value, and to account for network delay and variance in SEAL time across miners, the verifier allows for G offset from the assumed value of <code>X-F</code>: <code>Z-T-F</code>, hence verifying that the ticket is drawn from the range <code>[Z-T-F-G, Z-T-F+G]</code>.</li>
</ul>


</div>


  
    








<div id="algorithms__expected_consensus">

<h2 class="section-header">
  Expected Consensus
</h2>

<div class="section-content">






































<div id="algorithms__expected_consensus__expected_consensus"></div>

<h4 id="algorithm">Algorithm</h4>

<p>Expected Consensus (EC) is a probabilistic Byzantine fault-tolerant consensus protocol. At a high level, it operates by running a leader election every round in which, on expectation, one participant may be eligible to submit a block. EC guarantees that this winner will be anonymous until they reveal themselves by submitting a proof of their election (we call this proof an <code>Election Proof</code>). All valid blocks submitted in a given round form a <code>Tipset</code>. Every block in a Tipset adds weight to its chain. The &lsquo;best&rsquo; chain is the one with the highest weight, which is to say that the fork choice rule is to choose the heaviest known chain. For more details on how to select the heaviest chain, see <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a>.</p>

<p>At a very high level, with every new block generated, a miner will craft a new ticket from the prior one in the chain. While on expectation at least one block will be generated at every round, in cases where no one finds a block in a given round, a miner may increment a given nonce as part of the input with which they attempt to run leader election in order to ensure liveness in the protocol. These nonces help mark block height. Every block in a given Tipset will contain election proofs with the same nonce (i.e. they are mined at the same height).</p>

<p>The <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem uses access to EC to use the following facilities:
- Access to verifiable randomness for the protocol, derived from <a href="./#algorithms__expected_consenus__tickets">Tickets</a>.
- Running and verifying <a href="./#algorithms__expected_consensus__leader_election">leader election</a> for block generation.
- Access to a weighting function enabling <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> by the chain manager.
- Access to the most recently <a href="./#algorithms__expected_consensus__finality">finalized tipset</a> available to all protocol participants.</p>

<div id="algorithms__expected_consensus__tickets"></div>

<h4 id="tickets">Tickets</h4>

<p>For leader election in EC, participants win in proportion to the power they have within the network.</p>

<p>A ticket is drawn from the past at the beginning of each new round to perform leader election. EC also generates a new ticket in every round for future use. Tickets are chained independently of the main blockchain. A ticket only depends on the ticket before it, and not any other data in the block.
On expectation, in Filecoin, every block header contains one ticket, though it could contain more if that block was generated over multiple rounds.</p>

<p>Tickets are used across the protocol as sources of randomness:
- The <a href="./#systems__filecoin_mining__storage_proving__sector_sealer">Sector Sealer</a> uses tickets to bind sector commitments to a given subchain.
- The <a href="./#systems__filecoin_mining__storage_proving__post_generator">PoSt Generator</a> likewise uses tickets to prove sectors remain committed as of a given block.
- EC uses them to run leader election and generates new ones for use by the protocol, as detailed below.</p>

<p>You can find the Ticket data structure <a href="./#listings__data_structures">here</a>.</p>

<h5 id="comparing-tickets-in-a-tipset">Comparing Tickets in a Tipset</h5>

<p>Whenever comparing tickets is evoked in Filecoin, for instance when discussing selecting the &ldquo;min ticket&rdquo; in a Tipset, the comparison is that of the little endian representation of the ticket&rsquo;s VFOutput bytes.</p>

<h4 id="tickets-in-ec">Tickets in EC</h4>

<p>Within EC, a miner generates a new ticket in their block for every ticket they use running leader election, thereby ensuring the ticket chain is always as long as the block chain.</p>

<p>Tickets are used to achieve the following:
- Ensure leader secrecy &ndash; meaning a block producer will not be known until they release their block to the network.
- Prove leader election &ndash; meaning a block producer can be verified by any participant in the network.</p>

<p>In practice, EC defines two different fields within a block:</p>

<ul>
<li>A <code>Ticket</code> field ‚Äî this stores the new ticket generated during this block generation attempt. It is from this ticket that miners will sample randomness to run leader election in <code>K</code> rounds.</li>

<li><p>An <code>ElectionProof</code> ‚Äî this stores a proof that a given miner has won a leader election using the appropriate ticket <code>K</code> rounds back along with a nonce showing how many rounds generating the EP took. It proves that the leader was elected in this round.</p>

<pre><code>But why the randomness lookback?

The randomness lookback helps turn independent ticket generation from a block one round back
into a global ticket generation game instead. Rather than having a distinct chance of winning or losing
for each potential fork in a given round, a miner will either win on all or lose on all
forks descended from the block in which the ticket is sampled.

This is useful as it reduces opportunities for grinding, across forks or sybil identities.

However this introduces a tradeoff:
- The randomness lookback means that a miner can know K rounds in advance that they will win,
decreasing the cost of running a targeted attack (given they have local predictability).
- It means electionProofs are stored separately from new tickets on a block, taking up
more space on-chain.

How is K selected?
- On the one end, there is no advantage to picking K larger than finality.
- On the other, making K smaller reduces adversarial power to grind.
</code></pre></li>
</ul>

<h5 id="ticket-generation">Ticket generation</h5>

<p>This section discusses how tickets are generated by EC for the <code>Ticket</code> field.</p>

<p>At round <code>N</code>, a new ticket is generated using tickets drawn from the Tipset at round <code>N-1</code> (for more on how tickets are drawn see <a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_chain">Ticket Chain</a>).</p>

<p>The miner runs the prior ticket through a Verifiable Random Function (VRF) to get a new unique output.</p>

<p>The VRF&rsquo;s deterministic output adds entropy to the ticket chain, limiting a miner&rsquo;s ability to alter one block to influence a future ticket (given a miner does not know who will win a given round in advance).</p>

<p>We use the ECVRF algorithm from <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">Goldberg et al. Section 5</a>, with:
  - Sha256 for our hashing function
  - Secp256k1 for our curve
  - Note that the operation type in step 2.1 is necessary to prevent an adversary from guessing an election proof for a miner ahead of time.</p>

<h5 id="ticket-validation">Ticket Validation</h5>

<p>Each Ticket should be generated from the prior one in the ticket-chain.</p>

<div id="algorithms__expected_consensus__leader_election"></div>

<h4 id="secret-leader-election">Secret Leader Election</h4>

<p>Expected Consensus is a consensus protocol that works by electing a miner from a weighted set in proportion to their power. In the case of Filecoin, participants and powers are drawn from the storage <a href="storage-market.md#the-power-table">power table</a>, where power is equivalent to storage provided through time.</p>

<p>Leader Election in Expected Consensus must be Secret, Fair and Verifiable. This is achieved through the use of randomness used to run the election. In the case of Filecoin&rsquo;s EC, the blockchain tracks an independent ticket chain. These tickets are used as randomness inputs for Leader Election. Every block generated references an <code>ElectionProof</code> derived from a past ticket. The ticket chain is extended by the miner who generates a new block for each successful leader election.</p>

<h5 id="running-a-leader-election">Running a leader election</h5>

<p>Now, a miner must also check whether they are eligible to mine a block in this round.</p>

<p>To do so, the miner will use tickets from K rounds back as randomness to uniformly draw a value from 0 to 1. Comparing this value to their power, they determine whether they are eligible to mine. A user&rsquo;s <code>power</code> is defined as the ratio of the amount of storage they proved as of their last PoSt submission to the total storage in the network as of the current block.</p>

<p>We use the ECVRF algorithm (must yield a pseudorandom, deterministic output) from <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">Goldberg et al. Section 5</a>, with:
  - Sha256 for our hashing function
  - Secp256k1 for our curve</p>

<p>If the miner wins the election in this round, it can use newEP, along with a newTicket to generate and publish a new block. Otherwise, it waits to hear of another block generated in this round.</p>

<p>It is important to note that every block contains two artifacts: one, a ticket derived from last block&rsquo;s ticket to extend the ticket-chain, and two, an election proof derived from the ticket <code>K</code> rounds back used to run leader election.</p>

<p>Succinctly, the process of crafting a new ElectionProof in round N is as follows. We use:</p>

<pre><code>The ECVRF algorithm (must yield a pseudorandom, deterministic output) from Goldberg et al. Section 5, with:
    Sha256 for our hashing function
    Secp256k1 for our curve
</code></pre>

<p>Note: We draw the miner power from the prior round. This means that if a miner wins a block on their ProvingPeriodEnd even if they have not yet resubmitted a PoSt, they retain their power (until the next round).</p>

<p>If successful, the miner can craft a block, passing it to the block producer. If unsuccessful, it will wait to hear of another block mined this round to try again. In the case no other block was found in this round the miner can increment its nonce and try leader election again using the same past ticket and new nonce.
While a miner could try to run through multiple nonces in parallel in order to quickly generate a block, this effort will be futile as the rational majority of miners will reject blocks crafted with ElectionProofs whose nonces prove too high (see below).</p>

<h5 id="election-validation">Election Validation</h5>

<p>In order to determine that the mined block was generated by an eligible miner, one must check its <code>ElectionProof</code>.</p>

<div id="algorithms__expected_consensus__chain_selection"></div>

<h4 id="chain-selection">Chain Selection</h4>

<p>Just as there can be 0 miners win in a round, multiple miners can be elected in a given round. This in turn means multiple blocks can be created in a round. In order to avoid wasting valid work done by miners, EC makes use of all valid blocks generated in a round.</p>

<h5 id="chain-weighting">Chain Weighting</h5>

<p>It is possible for forks to emerge naturally in Expected Consensus. EC relies on weighted chains in order to quickly converge on &lsquo;one true chain&rsquo;, with every block adding to the chain&rsquo;s weight. This means the heaviest chain should reflect the most amount of work performed, or in Filecoin&rsquo;s case, the most storage provided.</p>

<p>In short, the weight at each block is equal to its <code>ParentWeight</code> plus that block&rsquo;s delta weight. Details of Filecoin&rsquo;s chain weighting function <a href="https://observablehq.com/d/3812cd65c054082d">are included here</a>.</p>

<p>Delta weight is a term composed of a few elements:
- wForkFactor: which seeks to cut the weight derived from rounds in which produced Tipsets do not correspond to what an honest chain is likely to have yielded (pointing to selfish mining or other non-collaborative miner behavior).
- wPowerFactor: which adds weight to the chain proportional to the total power backing the chain, i.e. accounted for in the chain&rsquo;s power table.
- wBlocksFactor: which adds weight to the chain proportional to the number of blocks mined in a given round. Like wForkFactor, it rewards miner cooperation (which will yield more blocks per round on expectation).</p>

<p>The weight should be calculated using big integer arithmetic with order of operations defined above. We use brackets instead of parentheses below for legibility. We have:</p>

<p><code>w[r+1] = w[r] + (wPowerFactor[r+1] + wBlocksFactor[r+1]) * 2^8</code></p>

<p>For a given tipset <code>ts</code> in round <code>r+1</code>, we define:</p>

<ul>
<li><code>wPowerFactor[r+1]  = wFunction(totalPowerAtTipset(ts))</code></li>
<li>wBlocksFactor[r+1] =  <code>wPowerFactor[r+1] * wRatio * b / e</code>

<ul>
<li>with <code>b = |blocksInTipset(ts)|</code></li>
<li><code>e = expected number of blocks per round in the protocol</code></li>
<li>and <code>wRatio in ]0, 1[</code>
Thus, for stability of weight across implementations, we take:</li>
</ul></li>
<li>wBlocksFactor[r+1] =  <code>(wPowerFactor[r+1] * b * wRatio_num) / (e * wRatio_den)</code></li>
</ul>

<p>We get:
- <code>w[r+1] = w[r] + wFunction(totalPowerAtTipset(ts)) * 2^8 + (wFunction(totalPowerAtTipset(ts)) * len(ts.blocks) * wRatio_num * 2^8) / (e * wRatio_den)</code>
 Using the 2^8 here to prevent precision loss ahead of the division in the wBlocksFactor.</p>

<p>The exact value for these parameters remain to be determined, but for testing purposes, you may use:
 - <code>e = 5</code>
 - <code>wRatio = .5, or wRatio_num = 1, wRatio_den = 2</code>
- <code>wFunction = log2b</code> with
  - <code>log2b(X) = floor(log2(x)) = (binary length of X) - 1</code> and <code>log2b(0) = 0</code>. Note that that special case should never be used (given it would mean an empty power table.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Note that <span class="k">if</span> your implementation does not allow <span class="k">for</span> rounding to the fourth decimal, miners should apply the <span class="o">[</span>tie-breaker below<span class="o">](</span><span class="c1">#selecting-between-tipsets-with-equal-weight). Weight changes will be on the order of single digit numbers on expectation, so this should not have an outsized impact on chain consensus across implementations.</span></code></pre></div>
<p><code>ParentWeight</code> is the aggregate chain weight of a given block&rsquo;s parent set. It is calculated as
the <code>ParentWeight</code> of any of its parent blocks (all blocks in a given Tipset should have
the same <code>ParentWeight</code> value) plus the delta weight of each parent. To make the
computation a bit easier, a block&rsquo;s <code>ParentWeight</code> is stored in the block itself (otherwise
potentially long chain scans would be required to compute a given block&rsquo;s weight).</p>

<h5 id="selecting-between-tipsets-with-equal-weight">Selecting between Tipsets with equal weight</h5>

<p>When selecting between Tipsets of equal weight, a miner chooses the one with the smallest final ticket.</p>

<p>In the case where two Tipsets of equal weight have the same min ticket, the miner will compare the next smallest ticket (and select the Tipset with the next smaller ticket). This continues until one Tipset is selected.</p>

<p>The above case may happen in situations under certain block propagation conditions. Assume three blocks B, C, and D have been mined (by miners 1, 2, and 3 respectively) off of block A, with minTicket(B) &lt; minTicket&copy; &lt; minTicket (D).</p>

<p>Miner 1 outputs their block B and shuts down. Miners 2 and 3 both receive B but not each others&rsquo; blocks. We have miner 2 mining a Tipset made of B and C and miner 3 mining a Tipset made of B and D. If both succesfully mine blocks now, other miners in the network will receive new blocks built off of Tipsets with equal weight and the same smallest ticket (that of block B). They should select the block mined atop [B, C] since minTicket&copy; &lt; minTicket(D).</p>

<p>The probability that two Tipsets with different blocks would have all the same tickets can be considered negligible: this would amount to finding a collision between two 256-bit (or more) collision-resistant hashes.</p>

<div id="algorithms__expected_consensus__finality"></div>

<h4 id="finality-in-ec">Finality in EC</h4>

<p>EC enforces a version of soft finality whereby all miners at round N will reject all blocks that fork off prior to round N-F. For illustrative purposes, we can take F to be 500. While strictly speaking EC is a probabilistically final protocol, choosing such an F simplifies miner implementations and enforces a macroeconomically-enforced finality at no cost to liveness in the chain.</p>

<div id="algorithms__expected_consensus__consensus_faults"></div>

<h4 id="consensus-faults">Consensus Faults</h4>

<p>Due to the existence of potential forks in EC, a miner can try to unduly influence protocol fairness. This means they may choose to disregard the protocol in order to gain an advantage over the power they should normally get from their storage on the network. A miner should be slashed if they are provably deviating from the honest protocol.</p>

<p>This is detectable when a given miner submits two blocks that satisfy any of the following &ldquo;consensus faults&rdquo;:</p>

<ul>
<li>(1) <code>double-fork mining fault</code>: two blocks contains the same electionProof nonce, mined at the same height.</li>

<li><p>(2) <code>parent grinding fault</code>: one block&rsquo;s parent is a Tipset that could have validly included the other block according to Tipset validity rules, however the parent of the first block does not include the other block.</p>

<ul>
<li>While it cannot be proven that a miner omits known blocks from a Tipset in general (i.e. network latency could simply mean the miner did not receive a particular block) in this case it can be proven because a miner must be aware of a block they mined in a previous round.</li>
</ul></li>
</ul>

<p>Any node that detects either of the above events should submit both block headers to the <code>StoragePowerActor</code>&rsquo;s <code>ReportConsensusFault</code> method. The &ldquo;slasher&rdquo; will receive a portion (TODO: define how much) of the offending miner&rsquo;s <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></a> as a reward for notifying the network of the fault.
(TODO: FIP of submitting commitments to block headers to prevent miners censoring slashers in order to gain rewards).</p>

<p>It is important to note that there exists a third type of consensus fault directly reported by the <code>CronActor</code> on <code>StorageDeal</code> failures via the <code>ReportUncommittedPowerFault</code> method:
- (3) <code>uncommitted power fault</code> which occurs when a miner fails to submit their <code>PostProof</code> and is thus participating in leader election with undue power (see <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>).</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">

<h4 class="section-header">
  Storage Power Actor
</h4>

<div class="section-content">

























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">StoragePowerActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// TODO: bytesamount might be inefficient
</span><span class="c1"></span>    <span class="c1">// Miners [addr.Address]
</span><span class="c1"></span>    <span class="nx">Miners</span> <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">}</span>

    <span class="c1">// call by StorageMiningSubsytem on miner creation
</span><span class="c1"></span>    <span class="nf">CreateStorageMiner</span><span class="p">(</span>
        <span class="nx">ownerAddr</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">workerPubKey</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PubKey</span>
        <span class="nx">sectorSize</span>    <span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span>
        <span class="nx">peerId</span>        <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>  <span class="c1">// TODO: will be removed likely (see: https://github.com/filecoin-project/specs/pull/555#pullrequestreview-300991681)
</span><span class="c1"></span>    <span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// TODO add NotifyConsensusFault(addr.Address, [block.Block]) TODO maybe rename to Arbitrate
</span><span class="c1"></span>    <span class="nf">UpdatePower</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">newPower</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span>

    <span class="nf">TotalStorage</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>

    <span class="nf">PowerLookup</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>

    <span class="c1">// call by StorageMinerActor on successful seal
</span><span class="c1"></span>    <span class="c1">// TODO: workerKey of type StorageMiner.WorkerPubKey
</span><span class="c1"></span>    <span class="nf">IncrementPower</span><span class="p">(</span><span class="nx">minerAddress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>

    <span class="nf">SuspendMiner</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>

    <span class="nx">expectedConsensus</span> <span class="nx">ExpectedConsensus</span>
    <span class="nf">ReportConsensusFault</span><span class="p">(</span>
        <span class="nx">slasherAddr</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">faultType</span>    <span class="nx">ConsensusFaultType</span>
        <span class="nx">proof</span>        <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="nf">ReportUncommittedPowerFault</span><span class="p">(</span><span class="nx">cheaterAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">UVarint</span><span class="p">)</span>
    <span class="nx">PowerTable</span>

    <span class="c1">// VerifyElectionProof(addr.Address, ElectionProof)	bool
</span><span class="c1"></span>
    <span class="nf">Surprise</span><span class="p">(</span><span class="nx">ticket</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">)</span> <span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>

    <span class="nf">CheckFaults</span><span class="p">()</span>

    <span class="c1">// // What does graceful removal look like?
</span><span class="c1"></span>
    <span class="c1">// TODO: old methods, should be removed
</span><span class="c1"></span>    <span class="c1">// UpdateStoragePowerSubsystem(Tipset, StateTree)
</span><span class="c1"></span>    <span class="c1">// VerifyElectionProof(addr.Address, ElectionProof)	bool
</span><span class="c1"></span>    <span class="c1">// NotifyStorageFault(addr.Address)
</span><span class="c1"></span>    <span class="c1">// TryPublishBlock(StateTree)					block.Block
</span><span class="c1"></span>    <span class="nf">CommitPledgeCollateral</span><span class="p">(</span><span class="nx">deals</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">])</span>
    <span class="nf">DecommitPledgeCollateral</span><span class="p">(</span><span class="nx">deals</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">])</span>

    <span class="nx">pledgeCollateralBalances</span> <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">UVarint</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PowerTable</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// all power here is always verified
</span><span class="c1"></span>    <span class="nf">RegisterMiner</span><span class="p">(</span>
        <span class="nx">addr</span>        <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">pk</span>          <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PubKey</span>
        <span class="nx">sectorSize</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="p">)</span>
    <span class="nx">miners</span> <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">StorageMiner</span><span class="p">}</span>
    <span class="nf">GetMinerPower</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nf">GetTotalPower</span><span class="p">()</span> <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nf">GetMinerPublicKey</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PubKey</span>
    <span class="nf">IncrementPower</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">UVarint</span><span class="p">)</span>
    <span class="nf">SuspendPower</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">UVarint</span><span class="p">)</span>
    <span class="nf">UnsuspendPower</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">UVarint</span><span class="p">)</span>
    <span class="nf">RemovePower</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">UVarint</span><span class="p">)</span>
    <span class="nf">RemoveAllPower</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">UVarint</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMiner</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">MinerAddress</span>         <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">MinerStoragePower</span>    <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nx">MinerSuspendedPower</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">StoragePower</span>
    <span class="nx">MinerPK</span>              <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PubKey</span>
    <span class="nx">MinerSectorSize</span>      <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSize</span>
<span class="p">}</span>
</code></pre></div>






<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table"></div>

<h6 id="the-power-table">The Power Table</h6>

<p>The portion of blocks a given miner generates through leader election in EC (and so the block rewards they earn) is proportional to their <code>Power Fraction</code> over time. That is, a miner whose storage represents 1% of total storage on the network should mine 1% of blocks on expectation.</p>

<p>SPC provides a power table abstraction which tracks miner power (i.e. miner storage in relation to network storage) over time. The power table is updated for new sector commitments (incrementing miner power), when PoSts fail to be put on-chain (decrementing miner power) or for other storage and consensus faults.</p>

<p>An invariant of the storage power consensus subsystem is that all storage in the power table must be verified. That is, miners can only derive power from storage they have already proven to the network.</p>

<p>In order to achieve this, Filecoin delays updating power for new sector commitments until the first valid PoSt in the next proving period corresponding to that sector.
Conversely, storage faults only lead to power loss once they are detected (up to one proving period after the fault) so miners will mine with no more power than they have used to store data over time.</p>

<p>Put another way, power accounting in the SPC is delayed between storage being proven or faulted, and power being updated in the power table (and so for leader election). This ensures fairness over time.
Finally, we also account for &ldquo;suspended&rdquo; power in order to make accounting simple in the presence of faults (see <a href="./#algorithms__expected_consensus__consensus_faults">Consensus Faults</a>) and subsequent recovery.</p>

<p>The Miner lifecycle in the power table should be roughly as follows:
- MinerRegistration: A new miner with an associated worker public key and address is registered on the power table by the storage mining subsystem, along with their associated sector size (there is only one per worker).
- UpdatePower: These power increments and decrements (in multiples of the associated sector size) are called by various storage actor (and must thus be verified by every full node on the network). Specifically:
    - Power is incremented to account for a new SectorCommitment at the first PoSt past the first ProvingPeriod.
    - All Power is decremented immediately after a missed PoSt.
    - Power is decremented immediately after faults are declared, proportional to the faulty sector size.
    - Power is incremented after a PoSt recovering from a fault.
    - Power is definitively removed from the Power Table past the sector failure timeout (see <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>)</p>

<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></div>

<h6 id="pledge-collateral">Pledge Collateral</h6>

<p>Consensus in Filecoin is secured in part by economic incentives enforced by Pledge Collateral.</p>

<p>Pledge collateral amount is committed based on power pledged to the system (i.e. proportional to number of sectors committed and sector size for a miner). It is a system-wide parameter and is committed to the <code>StoragePowerActor</code>. TODO: define parameter value. Pledge Collateral submission methods take on storage deals to determine the appropriate amount of collateral to be pledged. Pledge collateral can be posted by the <code>StorageMinerActor</code> at any time by a miner up to sector commitments. A sector commitment without the requisite posted pledge collateral will be deemed invalid.</p>

<p>Pledge Collateral will be slashed when <a href="./#algorithms__expected_consensus__consensus_faults">Consensus Faults</a> are reported to the <code>StoragePowerActor</code>&rsquo;s <code>ReportConsensusFault</code> method or when the <code>CronActor</code> calls the <code>StoragePowerActor</code>&rsquo;s <code>ReportUncommittedPowerFault</code> method.</p>

<p>Pledge Collateral is slashed for any fault affecting storage-power consensus, these include:
- faults to expected consensus in particular (see <a href="./#algorithms__expected_consensus__consensus_faults">Consensus Faults</a>) which will be reported by a slasher to the <code>StoragePowerActor</code> in exchange for a reward.
- faults affecting consensus power more generally, specifically uncommitted power faults (i.e. <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>) which will be reported by the <code>CronActor</code> automatically.</p>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_token">

<h2 class="section-header">
  <strong>Token</strong>
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token">
            <strong>Token</strong>


        
            <br /><br /><i class="menuIcon">üìÄ</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__wallets">
            Wallet


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payments">
            Payments


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels">
            Payment Channels


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels__payment_channel_actor">
            Payment Channel Actor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig">
            Multisig Wallet


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig__multisig_actor">
            Multisig Actor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="systems__filecoin_token__wallets">

<h3 class="section-header">
  FIL Wallet
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="systems__filecoin_token__payments">

<h3 class="section-header">
  Payments
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="systems__filecoin_token__payment_channels">

<h3 class="section-header">
  Payment Channels
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_token__payment_channels__payment_channel_actor">

<h4 class="section-header">
  Payment Channel Actor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> Payment Channel Actor <a href="docs/systems/filecoin_token/payment_channels/payment_channel_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Voucher</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">VouchersApprovalResponse</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">PieceInclusionProof</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">PaymentChannelActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">RedeemVoucherWithApproval</span><span class="p">(</span><span class="nx">voucher</span> <span class="nx">Voucher</span><span class="p">)</span>
    <span class="nf">RedeemVoucherWithPIP</span><span class="p">(</span><span class="nx">voucher</span> <span class="nx">Voucher</span><span class="p">,</span> <span class="nx">pip</span> <span class="nx">PieceInclusionProof</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_token__multisig">

<h3 class="section-header">
  Multisig - Wallet requiring multiple signatures
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_token__multisig__multisig_actor">

<h4 class="section-header">
  Multisig Actor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> Multisig Actor <a href="docs/systems/filecoin_token/multisig/multisig_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>

<span class="kd">type</span> <span class="nx">TxSeqNo</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">NumRequired</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">EpochDuration</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">Epoch</span> <span class="nx">UVarint</span>

<span class="kd">type</span> <span class="nx">MultisigActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">signers</span>         <span class="p">[</span><span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>
    <span class="nx">required</span>        <span class="nx">NumRequired</span>
    <span class="nx">nextTxId</span>        <span class="nx">TxSeqNo</span>
    <span class="nx">initialBalance</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">startingBlock</span>   <span class="nx">Epoch</span>
    <span class="nx">unlockDuration</span>  <span class="nx">EpochDuration</span>
    <span class="c1">// transactions    {TxSeqNo: Transaction} // TODO Transaction type does not exist
</span><span class="c1"></span>
    <span class="nf">Construct</span><span class="p">(</span>
        <span class="nx">signers</span>         <span class="p">[</span><span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span>
        <span class="nx">required</span>        <span class="nx">NumRequired</span>
        <span class="nx">unlockDuration</span>  <span class="nx">EpochDuration</span>
    <span class="p">)</span>
    <span class="nf">Propose</span><span class="p">(</span>
        <span class="nx">to</span>      <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">value</span>   <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
        <span class="nx">method</span>  <span class="kt">string</span>
        <span class="nx">params</span>  <span class="nx">Bytes</span>
    <span class="p">)</span> <span class="nx">TxSeqNo</span>
    <span class="nf">Approve</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">TxSeqNo</span><span class="p">)</span>
    <span class="nf">Cancel</span><span class="p">(</span><span class="nx">txid</span> <span class="nx">TxSeqNo</span><span class="p">)</span>
    <span class="nf">ClearCompleted</span><span class="p">()</span>
    <span class="nf">AddSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">increaseReq</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nf">RemoveSigner</span><span class="p">(</span><span class="nx">signer</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">decreaseReq</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nf">SwapSigner</span><span class="p">(</span><span class="nx">old</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">new</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
    <span class="nf">ChangeRequirement</span><span class="p">(</span><span class="nx">req</span> <span class="nx">NumRequired</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining">

<h2 class="section-header">
  Storage Mining System - proving storage for producing blocks
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining">
            <strong>Storage Mining</strong>


        
            <br /><br /><i class="menuIcon">‚õè</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining">
            Storage Miner


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__mining_cycle">
            Storage Mining Cycle


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">
            Storage Miner Actor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__mining_scheduler">
            Mining Scheduler


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector">
            Sector


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector__sectorset">
            Sector Set


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector__sealing">
            Sector Sealing


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index">
            Sector Index


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index__sector_builder">
            Sector Builder


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index__sector_store">
            SectorStore


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving">
            Storage Proving


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving__sealer">
            Sector Sealer


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving__poster">
            Sector Poster


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<p>The Storage Mining System is the part of the Filecoin Protocol that deals with storing Client&rsquo;s
data, producing proof artifacts that demonstrate correct storage behavior, and managing the work
involved.</p>

<p>Storing data and producing proofs is a complex, highly optimizable process, with lots of tunable
choices. Miners should explore the design space to arrive at something that (a) satisfies protocol
and network-wide constraints, (b) satisfies clients&rsquo; requests and expectations (as expressed in
<code>Deals</code>), and (c) gives them the most cost-effective operation. This part of the Filecoin Spec
primarily describes in detail what MUST and SHOULD happen here, and leaves ample room for
various optimizations for implementers, miners, and users to make. In some parts, we describe
algorithms that could be replaced by other, more optimized versions, but in those cases it is
important that the <strong>protocol constraints</strong> are satisfied. The <strong>protocol constraints</strong> are
spelled out in clear detail (an unclear, unmentioned constraint is a &ldquo;spec error&rdquo;).  It is up
to implementers who deviate from the algorithms presented here to ensure their modifications
satisfy those constraints, especially those relating to protocol security.</p>


</div>


  
    








<div id="systems__filecoin_mining__storage_mining">

<h3 class="section-header">
  Storage Miner
</h3>

<div class="section-content">






































<div id="systems__filecoin_mining__storage_mining__storage_mining_subsystem"></div>

<p>TODO:</p>

<ul>
<li>rename &ldquo;Storage Mining Worker&rdquo; ?</li>
</ul>

<p>Filecoin Storage Mining Subsystem</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sectoridx</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>
<span class="kn">import</span> <span class="nx">spc</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/storage_power_consensus&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">blockchain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain&#34;</span>
<span class="kn">import</span> <span class="nx">blockproducer</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block_producer&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">storage_proving</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving&#34;</span>

<span class="kd">type</span> <span class="nx">StorageMiningSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// TODO: constructor
</span><span class="c1"></span>    <span class="c1">// InitStorageMiningSubsystem() struct{}
</span><span class="c1"></span>
    <span class="c1">// Component subsystems
</span><span class="c1"></span>    <span class="c1">// StorageProvider    storage_provider.StorageProvider
</span><span class="c1"></span>    <span class="nx">StoragePowerActor</span>  <span class="nx">spc</span><span class="p">.</span><span class="nx">StoragePowerActor</span>
    <span class="nx">MinerActor</span>         <span class="nx">StorageMinerActor</span>
    <span class="nx">SectorIndex</span>        <span class="nx">sectoridx</span><span class="p">.</span><span class="nx">SectorIndexerSubsystem</span>
    <span class="nx">StorageProving</span>     <span class="nx">storage_proving</span><span class="p">.</span><span class="nx">StorageProvingSubsystem</span>
    <span class="nx">BlockProducer</span>      <span class="nx">blockproducer</span><span class="p">.</span><span class="nx">BlockProducer</span>
    <span class="nx">electionNonce</span>      <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionNonce</span>

    <span class="c1">// Need access to SPC in order to mine a block
</span><span class="c1"></span>    <span class="nx">Consensus</span>          <span class="nx">spc</span><span class="p">.</span><span class="nx">StoragePowerConsensusSubsystem</span>

    <span class="c1">// Need access to the blockchain system in order to query for things in the chain
</span><span class="c1"></span>    <span class="nx">Blockchain</span>         <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainSubsystem</span>

    <span class="c1">// TODO: why are these here? remove?
</span><span class="c1"></span>    <span class="nf">StartMining</span><span class="p">()</span>
    <span class="nf">StopMining</span><span class="p">()</span>

    <span class="c1">// call by StorageMiningSubsystem itself to create miner
</span><span class="c1"></span>    <span class="nf">createMiner</span><span class="p">(</span>
        <span class="nx">ownerPubKey</span>   <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PubKey</span>
        <span class="nx">workerPubKey</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PubKey</span>
        <span class="nx">pledgeAmt</span>     <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">)</span>

    <span class="c1">// get miner key by address
</span><span class="c1"></span>    <span class="nf">GetMinerKeyByAddress</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PubKey</span>

    <span class="c1">// call by StorageMarket.StorageProvider at the start of a deal.
</span><span class="c1"></span>    <span class="c1">// Triggers AddNewDeal on SectorIndexer
</span><span class="c1"></span>    <span class="c1">// StorageDeal contains DealCID
</span><span class="c1"></span>    <span class="nf">HandleStorageDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span>

    <span class="c1">// call by StorageMinerActor when error in sealing
</span><span class="c1"></span>    <span class="nf">CommitSectorError</span><span class="p">()</span>

    <span class="c1">// call by StorageMiningSubsystem itself in BlockProduction
</span><span class="c1"></span>    <span class="nf">DrawElectionProof</span><span class="p">(</span>
        <span class="nx">lookbackTicket</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>
        <span class="nx">nonce</span>           <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionNonce</span>
        <span class="nx">vrfKP</span>           <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFKeyPair</span>
    <span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ElectionProof</span>

    <span class="c1">// call by StorageMiningSubsystem itself in BlockProduction
</span><span class="c1"></span>    <span class="nf">PrepareNewTicket</span><span class="p">(</span><span class="nx">priorTicket</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">,</span> <span class="nx">workerKeyPair</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFKeyPair</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>

    <span class="c1">// call by BlockChain when a new block is produced
</span><span class="c1"></span>    <span class="nf">OnNewBestChain</span><span class="p">()</span>

    <span class="c1">// call by clock during BlockProduction
</span><span class="c1"></span>    <span class="c1">// TODO: define clock better
</span><span class="c1"></span>    <span class="nf">OnNewRound</span><span class="p">()</span>

    <span class="nf">tryLeaderElection</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>






<h4 id="sector-in-storageminer-state-machine-new-one">Sector in StorageMiner State Machine (new one)</h4>













<div class="diagram">

<span class="diagram-title">Sector State (new one)</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_fsm.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_fsm.dot.svg" />




</div>














<div class="diagram">

<span class="diagram-title">Sector State Legend (new one)</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_legend.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_legend.dot.svg" />




</div>


<h4 id="sector-in-storageminer-state-machine-both">Sector in StorageMiner State Machine (both)</h4>













<div class="diagram">

<span class="diagram-title">Sector State Machine (both)</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_fsm.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_fsm.dot.svg" />




</div>



</div>


  
    








<div id="systems__filecoin_mining__storage_mining__mining_cycle">

<h4 class="section-header">
  Storage Mining Cycle
</h4>

<div class="section-content">






































<p>Block miners should constantly be performing Proofs of SpaceTime, and also checking if they have a winning <code>ticket</code> to propose a block at each height/in each round. Rounds are currently set to take around 30 seconds, in order to account for network propagation around the world. The details of both processes are defined here.</p>

<h5 id="the-miner-actor">The Miner Actor</h5>

<p>After successfully calling <code>CreateStorageMiner</code>, a miner actor will be created on-chain, and registered in the storage market. This miner, like all other Filecoin State Machine actors, has a fixed set of methods that can be used to interact with or control it.</p>

<p>For details on the methods on the miner actor, see its entry in the <a href="actors.md#storage-miner-actor">actors spec</a>.</p>

<h6 id="owner-worker-distinction">Owner Worker distinction</h6>

<p>The miner actor has two distinct &lsquo;controller&rsquo; addresses. One is the worker, which is the address which will be responsible for doing all of the work, submitting proofs, committing new sectors, and all other day to day activities. The owner address is the address that created the miner, paid the collateral, and has block rewards paid out to it. The reason for the distinction is to allow different parties to fulfil the different roles. One example would be for the owner to be a multisig wallet, or a cold storage key, and the worker key to be a &lsquo;hot wallet&rsquo; key.</p>

<h6 id="storage-mining-cycle">Storage Mining Cycle</h6>

<p>Storage miners must continually produce Proofs of SpaceTime over their storage to convince the network that they are actually storing the sectors that they have committed to. Each PoSt covers a miner&rsquo;s entire storage.</p>

<h6 id="step-0-registration">Step 0: Registration</h6>

<p>To initially become a miner, a miner first register a new miner actor on-chain. This is done through the storage market actor&rsquo;s <a href="actors.md#createstorageminer"><code>CreateStorageMiner</code></a> method. The call will then create a new miner actor instance and return its address.</p>

<p>The next step is to place one or more storage market asks on the market. This is done through the storage markets <a href="actors.md#addask"><code>AddAsk</code></a> method. A miner may create a single ask for their entire storage, or partition their storage up in some way with multiple asks (at potentially different prices).</p>

<p>After that, they need to make deals with clients and begin filling up sectors with data. For more information on making deals, see the section on <a href="storage-market.md#deal">deal</a>.</p>

<p>When they have a full sector, they should seal it. This is done by invoking <a href="proofs.md#seal"><code>PoRep.Seal</code></a> on the sector.</p>

<h6 id="step-1-commit">Step 1: Commit</h6>

<p>When the miner has completed their first seal, they should post it on-chain using <a href="actors.md#commitsector">CommitSector</a>. If the miner had zero committed sectors prior to this call, this begins their proving period.</p>

<p>The proving period is a fixed amount of time in which the miner must submit a Proof of Space Time to the network.</p>

<p>During this period, the miner may also commit to new sectors, but they will not be included in proofs of space time until the next proving period starts.
For example, if a miner currently PoSts for 10 sectors, and commits to 20 more sectors. The next PoSt they submit (i.e. the one they&rsquo;re currently proving) will be for 10 sectors again, the subsequent one will be for 30.</p>

<p>TODO: sectors need to be globally unique. This can be done either by having the seal proof prove the sector is unique to this miner in some way, or by having a giant global map on-chain is checked against on each submission. As the system moves towards sector aggregation, the latter option will become unworkable, so more thought needs to go into how that proof statement could work.</p>

<h6 id="step-2-proving-storage-post-creation">Step 2: Proving Storage (PoSt creation)</h6>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ProveStorage</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="p">[]</span><span class="nx">commR</span><span class="p">)</span> <span class="nx">PoStProof</span> <span class="p">{</span>
    <span class="nx">challengeBlockHeight</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">ProvingPeriodEnd</span> <span class="o">-</span> <span class="nx">POST_CHALLENGE_TIME</span>

    <span class="c1">// Faults to be used are the currentFaultSet for the miner.
</span><span class="c1"></span>    <span class="nx">faults</span> <span class="o">:=</span> <span class="nx">miner</span><span class="p">.</span><span class="nx">currentFaultSet</span>
    <span class="nx">seed</span> <span class="o">:=</span> <span class="nf">GetRandFromBlock</span><span class="p">(</span><span class="nx">challengeBlockHeight</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">sectors</span><span class="p">,</span> <span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<p>Note: See <a href="proof-of-spacetime.md">&lsquo;Proof of Space Time&rsquo;</a> for more details.</p>

<p>The proving set remains consistent during the proving period. Any sectors added in the meantime will be included in the next proving set, at the beginning of the next proving period.</p>

<h6 id="step-3-post-submission">Step 3: PoSt Submission</h6>

<p>When the miner has completed their PoSt, they must submit it to the network by calling <a href="actors.md#submitpost">SubmitPoSt</a>. There are two different times that this <em>could</em> be done.</p>

<ol>
<li><strong>Standard Submission</strong>: A standard submission is one that makes it on-chain before the end of the proving period. The length of time it takes to compute the PoSts is set such that there is a grace period between then and the actual end of the proving period, so that the effects of network congestion on typical miner actions is minimized.</li>
<li><strong>Penalized Submission</strong>: A penalized submission is one that makes it on-chain after the end of the proving period, but before the generation attack threshold. These submissions count as valid PoSt submissions, but the miner must pay a penalty for their late submission. (See &lsquo;<a href="faults.md">Faults</a>&rsquo; for more information)

<ul>
<li>Note: In this case, the next PoSt should still be started at the beginning of the proving period, even if the current one is not yet complete. Miners must submit one PoSt per proving period.</li>
</ul></li>
</ol>

<p>Along with the PoSt submission, miners may also submit a set of sectors that they wish to remove from their proving set. This is done by selecting the sectors in the &lsquo;done&rsquo; bitfield passed to <code>SubmitPoSt</code>.</p>

<h5 id="stop-mining">Stop Mining</h5>

<p>In order to stop mining, a miner must complete all of its storage contracts, and remove them from their proving set during a PoSt submission. A miner may then call <a href="actors.md#depledge"><code>DePledge()</code></a> to retrieve their collateral. <code>DePledge</code> must be called twice, once to start the cooldown, and once again after the cooldown to reclaim the funds. The cooldown period is to allow clients whose files have been dropped by a miner to slash them before they get their money back and get away with it.</p>

<h5 id="faults">Faults</h5>

<p>Faults are described in the <a href="faults.md">faults document</a>.</p>

<h6 id="on-being-slashed-wip-needs-discussion">On Being Slashed (WIP, needs discussion)</h6>

<p>If a miner is slashed for failing to submit their PoSt on time, they currently lose all their pledge collateral. They do not necessarily lose their storage collateral. Storage collateral is lost when a miner&rsquo;s clients slash them for no longer having the data. Missing a PoSt does not necessarily imply that a miner no longer has the data. There should be an additional timeout here where the miner can submit a PoSt, along with &lsquo;refilling&rsquo; their pledge collateral. If a miner does this, they can continue mining, their mining power will be reinstated, and clients can be assured that their data is still there.</p>

<p>TODO: disambiguate the two collaterals across the entire spec</p>

<p>Review Discussion Note: Taking all of a miners collateral for going over the deadline for PoSt submission is really really painful, and is likely to dissuade people from even mining filecoin in the first place (If my internet going out could cause me to lose a very large amount of money, that leads to some pretty hard decisions around profitability). One potential strategy could be to only penalize miners for the amount of sectors they could have generated in that timeframe.</p>

<h5 id="future-work">Future Work</h5>

<p>There are many ideas for improving upon the storage miner, here are ideas that may be potentially implemented in the future.</p>

<ul>
<li><strong>Sector Resealing</strong>: Miners should be able to &rsquo;re-seal&rsquo; sectors, to allow them to take a set of sectors with mostly expired pieces, and combine the not-yet-expired pieces into a single (or multiple) sectors.</li>
<li><strong>Sector Transfer</strong>: Miners should be able to re-delegate the responsibility of storing data to another miner. This is tricky for many reasons, and will not be implemented in the initial release of Filecoin, but could provide interesting capabilities down the road.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_mining__storage_miner_actor">

<h4 class="section-header">
  Storage Miner Actor
</h4>

<div class="section-content">




































<p>(You can see the <em>old</em> Storage Miner Actor <a href="docs/systems/filecoin_mining/storage_mining/storage_miner_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="kn">import</span> <span class="nx">sealing</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>

<span class="kd">type</span> <span class="nx">Seed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">SectorCommitment</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">SectorExpirationQueueItem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorNumber</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span>
    <span class="nx">Expiration</span>    <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorExpirationQueue</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Add</span><span class="p">(</span><span class="nx">i</span> <span class="nx">SectorExpirationQueueItem</span><span class="p">)</span>
    <span class="nf">Pop</span><span class="p">()</span> <span class="nx">SectorExpirationQueueItem</span>
    <span class="nf">Peek</span><span class="p">()</span> <span class="nx">SectorExpirationQueueItem</span>
    <span class="nf">Remove</span><span class="p">(</span><span class="nx">n</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMinerActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// CollateralVault CollateralVault
</span><span class="c1"></span>
    <span class="c1">// TODO: consider merging SectorState into sector.SealCommitment to keep
</span><span class="c1"></span>    <span class="c1">// only one map, instead of two.
</span><span class="c1"></span>    <span class="nx">Sectors</span>                <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCommitment</span><span class="p">}</span>  <span class="c1">// this should be an AMT
</span><span class="c1"></span>    <span class="nx">SectorStates</span>           <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">:</span> <span class="nx">SectorState</span><span class="p">}</span>
    <span class="nx">ProvingSet</span>             <span class="nx">sector</span><span class="p">.</span><span class="nx">CompactSectorSet</span>
    <span class="nx">LastChallengePoSt</span>      <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>

    <span class="nx">SectorExpirationQueue</span>

    <span class="c1">// contains mostly static info about this miner
</span><span class="c1"></span>    <span class="nx">Info</span>                   <span class="o">&amp;</span><span class="nx">MinerInfo</span>

    <span class="c1">// TODO: add the DePledgeCollateral
</span><span class="c1"></span>    <span class="c1">// TODO: add the Sectors
</span><span class="c1"></span>    <span class="c1">// TODO sectors []SectorInfo CID to AMT
</span><span class="c1"></span>    <span class="c1">// TODO provingSet []SectorInfo CID to AMT
</span><span class="c1"></span>
    <span class="c1">// TODO: should we keep the same structure as before or putting all of that into a struct?
</span><span class="c1"></span>    <span class="c1">// TODO do we need a `slashedAt`?
</span><span class="c1"></span>    <span class="c1">// TODO owedStorageCollateral
</span><span class="c1"></span>    <span class="c1">// TODO ProvingPeriodEnd   Epoch
</span><span class="c1"></span>
    <span class="nf">CommitSector</span><span class="p">(</span><span class="nx">onChainInfo</span> <span class="nx">sealing</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span><span class="p">)</span>  <span class="c1">// TODO: check with Magik on sizes
</span><span class="c1"></span>
    <span class="nf">SubmitPoSt</span><span class="p">(</span><span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span>

    <span class="c1">// TODO: should depledge be in here or in storage market actor?
</span><span class="c1"></span>
    <span class="c1">// TODO: add GetOwner()
</span><span class="c1"></span>    <span class="c1">// TODO: add GetPeerID()
</span><span class="c1"></span>    <span class="c1">// TODO: add GetSectorSize()
</span><span class="c1"></span>    <span class="c1">// TODO: add UpdatePeerID()
</span><span class="c1"></span>    <span class="c1">// TODO: add UpdatePeerID()
</span><span class="c1"></span>    <span class="c1">// TODO: add ChangeWorker()
</span><span class="c1"></span>
    <span class="c1">// TODO: do IsSlashed, IsLate belong here?
</span><span class="c1"></span>
    <span class="nf">DeclareFault</span><span class="p">(</span><span class="nx">faultSet</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">FaultSet</span><span class="p">)</span>

    <span class="nf">computeProvingPeriodEndSectorState</span><span class="p">()</span>  <span class="c1">// TODO
</span><span class="c1"></span>
    <span class="nf">verifyPoStSubmission</span><span class="p">(</span><span class="nx">postSubmission</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MinerInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Account that owns this miner.
</span><span class="c1"></span>    <span class="c1">// - Income and returned collateral are paid to this address.
</span><span class="c1"></span>    <span class="c1">// - This address is also allowed to change the worker address for the miner.
</span><span class="c1"></span>    <span class="nx">Owner</span>       <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// Worker account for this miner.
</span><span class="c1"></span>    <span class="c1">// This will be the key that is used to sign blocks created by this miner, and
</span><span class="c1"></span>    <span class="c1">// sign messages sent on behalf of this miner to commit sectors, submit PoSts, and
</span><span class="c1"></span>    <span class="c1">// other day to day miner activities.
</span><span class="c1"></span>    <span class="nx">Worker</span>      <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>

    <span class="c1">// Libp2p identity that should be used when connecting to this miner.
</span><span class="c1"></span>    <span class="nx">PeerId</span>      <span class="nx">libp2p</span><span class="p">.</span><span class="nx">PeerID</span>

    <span class="c1">// Amount of space in each sector committed to the network by this miner.
</span><span class="c1"></span>    <span class="nx">SectorSize</span>  <span class="nx">util</span><span class="p">.</span><span class="nx">BytesAmount</span>
<span class="p">}</span>

<span class="cm">/*
</span><span class="cm">type CollateralVault struct {
</span><span class="cm">    Pledged(Collateral) TokenAmount
</span><span class="cm">    Pledge(Collateral, TokenAmount)
</span><span class="cm">    DePledge(Collateral, TokenAmount)
</span><span class="cm">
</span><span class="cm">    pledgedStorageCollateral UVarint
</span><span class="cm">    pledgedConsensusCollateral UVarint
</span><span class="cm">}
</span><span class="cm">
</span><span class="cm">type Collateral union {
</span><span class="cm">    | StorageDealCollateral
</span><span class="cm">    | ConsensusCollateral
</span><span class="cm">}
</span><span class="cm">
</span><span class="cm">type TokenAmount UVarint # What are the units? Attofil?
</span><span class="cm">
</span><span class="cm">type MinedSector {
</span><span class="cm">    SectorID           UInt
</span><span class="cm">    CommR              sector.Commitment
</span><span class="cm">    FaultStatus(Epoch) Fault
</span><span class="cm">}
</span><span class="cm">
</span><span class="cm">type Fault union {
</span><span class="cm">    | None
</span><span class="cm">    | GracePeriod
</span><span class="cm">    | Fault
</span><span class="cm">}
</span><span class="cm">*/</span>

<span class="cm">/*
</span><span class="cm">ype StorageMinerActor struct {
</span><span class="cm">  // Amount of power this miner has.
</span><span class="cm">  power UInt
</span><span class="cm">
</span><span class="cm">  provingPeriodEnd Epoch
</span><span class="cm">
</span><span class="cm">
</span><span class="cm">  // Collateral that is waiting to be withdrawn.
</span><span class="cm">  dePledgeCollateral TokenAmount
</span><span class="cm">
</span><span class="cm">  // Time at which the depledged collateral may be withdrawn.
</span><span class="cm">  dePledgeTime Epoch
</span><span class="cm">
</span><span class="cm">  // All sectors this miner has committed.
</span><span class="cm">  sectors &amp;SectorSet
</span><span class="cm">
</span><span class="cm">  // Sectors this miner is currently mining. It is only updated
</span><span class="cm">  // when a PoSt is submitted (not as each new sector commitment is added).
</span><span class="cm">  provingSet &amp;SectorSet
</span><span class="cm">
</span><span class="cm">  // Faulty sectors reported since last SubmitPost, up to the current proving period&#39;s challenge time.
</span><span class="cm">  currentFaultSet FaultSet
</span><span class="cm">
</span><span class="cm">  // Faults submitted after the current proving period&#39;s challenge time, but before the PoSt for that period
</span><span class="cm">  // is submitted. These become the currentFaultSet when a PoSt is submitted.
</span><span class="cm">  nextFaultSet FaultSet
</span><span class="cm">
</span><span class="cm">  // Sectors reported during the last PoSt submission as being &#39;done&#39;. The collateral
</span><span class="cm">  // for them is still being held until the next PoSt submission in case early sector
</span><span class="cm">  // removal penalization is needed.
</span><span class="cm">  nextDoneSet DoneSet
</span><span class="cm">
</span><span class="cm">  // List of sectors that this miner was slashed for.
</span><span class="cm">  slashedSet optional &amp;SectorSet
</span><span class="cm">
</span><span class="cm">  // Deals this miner has been slashed for since the last post submission.
</span><span class="cm">  arbitratedDeals {Cid:Null} // TODO
</span><span class="cm">
</span><span class="cm">  // The height at which this miner was slashed at.
</span><span class="cm">  slashedAt optional Epoch
</span><span class="cm">
</span><span class="cm">  // The amount of storage collateral that is owed to clients, and cannot be used for collateral anymore.
</span><span class="cm">  owedStorageCollateral TokenAmount
</span><span class="cm">
</span><span class="cm">  // Internal methods
</span><span class="cm">  verifySeal(sectorID SectorID, comm SealCommitment, proof SealProof)
</span><span class="cm">  verifyPoSt(proofs base.PoStProof, doneSet Bitfield)
</span><span class="cm">
</span><span class="cm">  // Getters
</span><span class="cm">  GetOwner() address.Address
</span><span class="cm">  GetWorkerAddr() address.Address
</span><span class="cm">  GetPower() BytesAmount
</span><span class="cm">  GetPeerID() PeerID
</span><span class="cm">  GetSectorSize() BytesAmount
</span><span class="cm">  GetCurrentProvingSet() BitField
</span><span class="cm">
</span><span class="cm">  // SubmitPost verifies the PoSt
</span><span class="cm">  SubmitPost(proofs base.PoStProof, doneSet DoneSet) bool // TODO: rename to ProvePower?
</span><span class="cm">  DePledge(amt TokenAmount)
</span><span class="cm">
</span><span class="cm">  AddCollateral()
</span><span class="cm">
</span><span class="cm">  AbitrateDeal (deal Deal)
</span><span class="cm">  SlashStorageFault() // TODO maybe add CheckStorageFault?
</span><span class="cm">  UpdateFaults(faults FaultSet) // TODO rename into ReportFaults
</span><span class="cm">  IsLate() (bool)
</span><span class="cm">  IsSlashed() (bool)
</span><span class="cm">
</span><span class="cm">  UpdatePeerID(pid PeerID)
</span><span class="cm">  ChangeWorker(addr address.Address)
</span><span class="cm">
</span><span class="cm">  PaymentVerifyInclusion(extra PieceInclusionVoucherData, proof InclusionProof) (bool)
</span><span class="cm">  PaymentVerifyInclusion(extra BigInt, proof Bytes) (bool)
</span><span class="cm">}
</span><span class="cm">
</span><span class="cm">*/</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_mining__mining_scheduler">

<h4 class="section-header">
  Mining Scheduler
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">mining</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining&#34;</span>
<span class="c1">// import storage_indexer &#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_indexer&#34;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">ReplicaID</span> <span class="nx">CID</span>

<span class="kd">type</span> <span class="nx">MiningScheduler</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">getStagedSectors</span><span class="p">()</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>
    <span class="nf">getSealedSectors</span><span class="p">()</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorSet</span>
    <span class="nf">getFaultySectors</span><span class="p">()</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>
    <span class="nf">getRepairedSectors</span><span class="p">()</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>
    <span class="c1">// same as completedSectors/doneSectors
</span><span class="c1"></span>    <span class="nf">getExpiredSectors</span><span class="p">()</span>   <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span>

    <span class="nf">ProducePost</span><span class="p">(</span><span class="nx">sectors</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span><span class="p">)</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span>
    <span class="nf">VerifyPost</span><span class="p">(</span><span class="nx">sectors</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span><span class="p">)</span> <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStSubmission</span>

    <span class="nf">ReportFaults</span><span class="p">(</span>
        <span class="nx">actor</span> <span class="o">&amp;</span><span class="nx">StorageMinerActor</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">RemoveSectors</span><span class="p">(</span><span class="nx">remove</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorSet</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">DePledge</span><span class="p">(</span>
        <span class="nx">amount</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// receives from sector storage subsystem
</span><span class="c1"></span>    <span class="nf">SealedSector</span><span class="p">(</span>
        <span class="nx">sealedSector</span> <span class="nx">mining</span><span class="p">.</span><span class="nx">SealedSector</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">AddSector</span><span class="p">(</span>
        <span class="nx">pledge</span>    <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
        <span class="nx">sectorID</span>  <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
        <span class="nx">comm</span>      <span class="o">&amp;</span><span class="nx">sector</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span>
    <span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>

    <span class="c1">// generateReplicaID(CommD Commitment, block Block)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__sector">

<h3 class="section-header">
  Sector
</h3>

<div class="section-content">




































<p>The <code>Sector</code> is a fundamental &ldquo;storage container&rdquo; abstraction used in Filecoin Storage Mining. It is the basic unit of storage,
and serves to make storage conform to a set of expectations.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">Bytes32</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">MinerID</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="kd">type</span> <span class="nx">Commitment</span> <span class="nx">Bytes32</span>  <span class="c1">// TODO
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnsealedSectorCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">SealedSectorCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="c1">// SectorNumber is a numeric identifier for a sector. It is usually
</span><span class="c1">// relative to a Miner.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorNumber</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">FaultSet</span> <span class="nx">CompactSectorSet</span>

<span class="c1">// SectorSize indicates one of a set of possible sizes in the network.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorSize</span> <span class="nx">UInt</span>

<span class="c1">// Ideally, SectorSize would be an enum
</span><span class="c1">// type SectorSize enum {
</span><span class="c1">//   1KiB = UInt 1024
</span><span class="c1">//   1MiB = Uint 1048576
</span><span class="c1">//   1GiB = Uint 1073741824
</span><span class="c1">//   1TiB = Uint 1099511627776
</span><span class="c1">//   1PiB = Uint 1125899906842624
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="c1">// TODO make sure this is globally unique
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorID</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">MinerID</span>
    <span class="nx">Number</span> <span class="nx">SectorNumber</span>
<span class="p">}</span>

<span class="c1">// SectorInDetail describes all the bits of information associated
</span><span class="c1">// with each sector.
</span><span class="c1">// - ID   - a unique identifier assigned once the Sector is registered on chain
</span><span class="c1">// - Size - the size of the sector. there are a set of allowable sizes
</span><span class="c1">//
</span><span class="c1">// NOTE: do not use this struct. It is for illustrative purposes only.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorInDetail</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>    <span class="nx">SectorID</span>
    <span class="nx">Size</span>  <span class="nx">SectorSize</span>

    <span class="nx">Unsealed</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">CID</span>     <span class="nx">UnsealedSectorCID</span>
        <span class="nx">Deals</span>   <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">]</span>
        <span class="nx">Pieces</span>  <span class="p">[</span><span class="nx">piece</span><span class="p">.</span><span class="nx">Piece</span><span class="p">]</span>
        <span class="c1">// Pieces Tree&lt;Piece&gt; // some tree for proofs
</span><span class="c1"></span>        <span class="nx">Bytes</span>
    <span class="p">}</span>

    <span class="nx">Sealed</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">CID</span> <span class="nx">SealedSectorCID</span>
        <span class="nx">Bytes</span>
        <span class="nx">SealCfg</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// SectorInfo is an object that gathers all the information miners know about their
</span><span class="c1">// sectors. This is meant to be used for a local index.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>              <span class="nx">SectorID</span>
    <span class="nx">UnsealedInfo</span>    <span class="nx">UnsealedSectorInfo</span>
    <span class="nx">SealedInfo</span>      <span class="nx">SealedSectorInfo</span>
    <span class="nx">SealVerifyInfo</span>
    <span class="nx">ProofAux</span>
<span class="p">}</span>

<span class="c1">// UnsealedSectorInfo is an object that tracks the relevant data to keep in a sector
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnsealedSectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">UnsealedCID</span>  <span class="nx">UnsealedSectorCID</span>  <span class="c1">// CommD
</span><span class="c1"></span>    <span class="nx">Size</span>         <span class="nx">SectorSize</span>
    <span class="nx">PieceCount</span>   <span class="nx">UVarint</span>  <span class="c1">// number of pieces in this sector (can get it from len(Pieces) too)
</span><span class="c1"></span>    <span class="nx">Pieces</span>       <span class="p">[</span><span class="nx">piece</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">]</span>  <span class="c1">// wont get externalized easy, -- it&#39;s big
</span><span class="c1"></span>    <span class="nx">SealCfg</span>  <span class="c1">// this will be here as well. it&#39;s determined.
</span><span class="c1"></span>    <span class="c1">// Deals       [deal.StorageDeal]
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// SealedSectorInfo keeps around information about a sector that has been sealed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealedSectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealedCID</span>  <span class="nx">SealedSectorCID</span>
    <span class="nx">Size</span>       <span class="nx">SectorSize</span>
    <span class="nx">SealCfg</span>
    <span class="nx">SealArgs</span>   <span class="nx">SealArguments</span>
<span class="p">}</span>
</code></pre></div>






<p>TODO:</p>

<ul>
<li>sector illustration</li>
<li>describe how Sectors are used in practice</li>
<li>describe sizing ranges of sectors</li>
<li>describe &ldquo;storage/shipping container&rdquo; analogy</li>
</ul>


</div>


  
    








<div id="systems__filecoin_mining__sector__sectorset">

<h4 class="section-header">
  Sector Set
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// sector sets
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorSet</span> <span class="p">[</span><span class="nx">SectorID</span><span class="p">]</span>
<span class="kd">type</span> <span class="nx">UnsealedSectorSet</span> <span class="nx">SectorSet</span>
<span class="kd">type</span> <span class="nx">SealedSectorSet</span> <span class="nx">SectorSet</span>

<span class="c1">// compact sector sets
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Bitfield</span> <span class="nx">Bytes</span>  <span class="c1">// TODO: move to the right place -- a lib?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RLEpBitfield</span> <span class="nx">Bitfield</span>  <span class="c1">// TODO: move to the right place -- a lib?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CompactSectorSet</span> <span class="nx">RLEpBitfield</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__sector__sealing">

<h4 class="section-header">
  Sector Sealing
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">Path</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">SealRandomness</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">PoStRandomness</span> <span class="nx">Bytes</span>

<span class="c1">// SealSeed is unique to each Sector
</span><span class="c1">// SealSeed is:
</span><span class="c1">//    SealSeedHash(MinerID, SectorNumber, SealRandomness, UnsealedSectorCID)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealSeed</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">SealCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSize</span>
    <span class="nx">SubsectorCount</span>  <span class="nx">UInt</span>
    <span class="nx">Partitions</span>      <span class="nx">UInt</span>
<span class="p">}</span>

<span class="c1">// SealVerifyInfo is the structure of all thte information a verifier
</span><span class="c1">// needs to verify a Seal.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealVerifyInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>
    <span class="nx">OnChain</span> <span class="nx">OnChainSealVerifyInfo</span>
    <span class="nx">SealCfg</span>
<span class="p">}</span>

<span class="c1">// OnChainSealVerifyInfo is the structure of information that must be sent with
</span><span class="c1">// a message to commit a sector. Most of this information is not needed in the
</span><span class="c1">// state tree but will be verified in sm.CommitSector. See SealCommitment for
</span><span class="c1">// data stored on the state tree for each sector.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">OnChainSealVerifyInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealedCID</span>     <span class="nx">SealedSectorCID</span>  <span class="c1">// CommR
</span><span class="c1"></span>    <span class="nx">Epoch</span>         <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">Proof</span>         <span class="nx">SealProof</span>
    <span class="nx">DealIDs</span>       <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
    <span class="nx">SectorNumber</span>
<span class="p">}</span>

<span class="c1">// SealCommitment is the information kept in the state tree about a sector.
</span><span class="c1">// SealCommitment is a subset of OnChainSealVerifyInfo.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealCommitment</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">UnsealedCID</span>  <span class="nx">UnsealedSectorCID</span>  <span class="c1">// CommD
</span><span class="c1"></span>    <span class="nx">SealedCID</span>    <span class="nx">SealedSectorCID</span>  <span class="c1">// CommR
</span><span class="c1"></span>    <span class="nx">DealIDs</span>      <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
    <span class="nx">Expiration</span>   <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="c1">// ProofAux is meta data required to generate certain proofs
</span><span class="c1">// for a sector, for example PoSt.
</span><span class="c1">// These should be stored and indexed somewhere by CommR.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ProofAux</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CommRLast</span>          <span class="nx">Commitment</span>
    <span class="nx">CommC</span>              <span class="nx">Commitment</span>

    <span class="c1">// TODO: This may be a partially-cached tree.
</span><span class="c1"></span>    <span class="c1">// this may be empty
</span><span class="c1"></span>    <span class="nx">CommRLastTreePath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofAuxTmp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PersistentAux</span>  <span class="nx">ProofAux</span>

    <span class="nx">SectorID</span>
    <span class="nx">CommD</span>          <span class="nx">Commitment</span>
    <span class="nx">CommR</span>          <span class="nx">SealedSectorCID</span>
    <span class="nx">CommDTreePath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>

    <span class="nx">Seed</span>           <span class="nx">SealRandomness</span>
    <span class="nx">Data</span>           <span class="nx">Bytes</span>
    <span class="nx">Replica</span>        <span class="nx">Bytes</span>
    <span class="nx">KeyLayers</span>      <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealArguments</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span>        <span class="nx">SealAlgorithm</span>
    <span class="nx">OutputArtifacts</span>  <span class="nx">SealOutputArtifacts</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealProof</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">//&lt;curve, system&gt; {
</span><span class="c1"></span>    <span class="nx">Config</span>      <span class="nx">SealProofConfig</span>
    <span class="nx">ProofBytes</span>  <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealProofConfig</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">// TODO
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// TODO: move into proofs lib
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FilecoinSNARKProof</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">//&lt;bls12-381, Groth16&gt;
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">SealAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="c1">// ZigZagPoRep
</span><span class="c1"></span>    <span class="nx">StackedDRG</span>
<span class="p">}</span>

<span class="c1">// TODO
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealOutputArtifacts</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__sector_index">

<h3 class="section-header">
  Sector Index
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>

<span class="c1">// TODO import this from StorageMarket
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorIndex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BySectorID</span>     <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByUnsealedCID</span>  <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">BySealedCID</span>    <span class="p">{</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByPieceID</span>      <span class="p">{</span><span class="nx">piece</span><span class="p">.</span><span class="nx">PieceID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByDealID</span>       <span class="p">{</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorIndexerSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Index</span>    <span class="nx">SectorIndex</span>
    <span class="nx">Store</span>    <span class="nx">SectorStore</span>
    <span class="nx">Builder</span>  <span class="nx">SectorBuilder</span>

    <span class="c1">// AddNewDeal is called by StorageMiningSubsystem after the StorageMarket
</span><span class="c1"></span>    <span class="c1">// has made a deal. AddNewDeal returns an error when:
</span><span class="c1"></span>    <span class="c1">// - there is no capacity to store more deals and their pieces
</span><span class="c1"></span>    <span class="nf">AddNewDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">StageDealResponse</span>

    <span class="c1">// bring back if needed.
</span><span class="c1"></span>    <span class="c1">// OnNewTipset(chain Chain, epoch blockchain.Epoch) struct {}
</span><span class="c1"></span>
    <span class="c1">// SectorsExpiredAtEpoch returns the set of sectors that expire
</span><span class="c1"></span>    <span class="c1">// at a particular epoch.
</span><span class="c1"></span>    <span class="nf">SectorsExpiredAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>

    <span class="c1">// removeSectors removes the given sectorIDs from storage.
</span><span class="c1"></span>    <span class="nf">removeSectors</span><span class="p">(</span><span class="nx">sectorIDs</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  

  
    








<div id="systems__filecoin_mining__sector_index__sector_builder">

<h4 class="section-header">
  Sector Builder
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="c1">// import smkt &#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&#34;
</span><span class="c1"></span><span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>

<span class="c1">// SectorBuilder accumulates deals, keeping track of their
</span><span class="c1">// sector configuration requirements and the piece sizes.
</span><span class="c1">// Once there is a sector ready to be sealed, NextSector
</span><span class="c1">// will return a sector.
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">StageDealResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorBuilder</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// DealsToSeal keeps a set of StorageDeal objects.
</span><span class="c1"></span>    <span class="c1">// These include the info for the relevant pieces.
</span><span class="c1"></span>    <span class="c1">// This builder just accumulates deals, keeping track of their
</span><span class="c1"></span>    <span class="c1">// sector configuration requirements, and the piece sizes.
</span><span class="c1"></span>    <span class="nx">DealsToSeal</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">]</span>

    <span class="c1">// StageDeal adds a deal to be packed into a sector.
</span><span class="c1"></span>    <span class="nf">StageDeal</span><span class="p">(</span><span class="nx">d</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">StageDealResponse</span>

    <span class="c1">// NextSector returns an UnsealedSectorInfo, which includes the (ordered) set of
</span><span class="c1"></span>    <span class="c1">// pieces, and the SealCfg. An error may be returned if SectorBuilder is not
</span><span class="c1"></span>    <span class="c1">// ready to produce a Sector.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// TODO: use go channels? or notifications?
</span><span class="c1"></span>    <span class="nf">NextSector</span><span class="p">()</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">i</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__sector_index__sector_store">

<h4 class="section-header">
  SectorStore
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>

<span class="kd">type</span> <span class="nx">SectorStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// FileStore stores all the unsealed and sealed sectors.
</span><span class="c1"></span>    <span class="nx">FileStore</span>   <span class="nx">file</span><span class="p">.</span><span class="nx">FileStore</span>

    <span class="c1">// PieceStore is shared with DataTransfer, and is a way to store or read
</span><span class="c1"></span>    <span class="c1">// pieces temporarily. This may or may not be backed by the FileStore above.
</span><span class="c1"></span>    <span class="nx">PieceStore</span>  <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceStore</span>

    <span class="c1">// GetSectorFile returns the file for a given sector id.
</span><span class="c1"></span>    <span class="c1">// If the SectorID does not have any sector files associated yet, GetSectorFiles
</span><span class="c1"></span>    <span class="c1">// returns an error.
</span><span class="c1"></span>    <span class="nf">GetSectorFiles</span><span class="p">(</span><span class="nx">id</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">SectorFiles</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// CreateSectorFiles allocates two sector files, one for unsealed and one for
</span><span class="c1"></span>    <span class="c1">// sealed sector.
</span><span class="c1"></span>    <span class="nf">CreateSectorFiles</span><span class="p">(</span><span class="nx">id</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">SectorFiles</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// SectorFiles is a datastructure that groups two file objects and a sectorID.
</span><span class="c1">// These files are where unsealed and sealed sectors should go.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorFiles</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">Unsealed</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">File</span>
    <span class="nx">Sealed</span>    <span class="nx">file</span><span class="p">.</span><span class="nx">File</span>
<span class="p">}</span>
</code></pre></div>






<p>TODO</p>

<ul>
<li>talk about how sectors are stored</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__storage_proving">

<h3 class="section-header">
  Storage Proving
</h3>

<div class="section-content">




































<p>Filecoin Poving Subsystem</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>
<span class="kn">import</span> <span class="nx">sealer</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/sealer&#34;</span>

<span class="c1">// type seal.SealOutput struct {}
</span><span class="c1">// type seal.SectorSealer struct {}
</span><span class="c1">// type seal.Seed struct {}
</span><span class="c1">// type sector.SectorID struct {}
</span><span class="c1">// type sector.SealCfg struct {}
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Commitment</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Ticket</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">SectorSealer</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">StorageProvingSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSealer</span>   <span class="nx">sealer</span><span class="p">.</span><span class="nx">SectorSealer</span>
    <span class="nx">PostGenerator</span>  <span class="nx">poster</span><span class="p">.</span><span class="nx">PostGenerator</span>

    <span class="nf">SealSector</span><span class="p">(</span><span class="nx">si</span> <span class="nx">sealer</span><span class="p">.</span><span class="nx">SealInputs</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">sealer</span><span class="p">.</span><span class="nx">SealOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">CreateSealProof</span><span class="p">(</span><span class="nx">si</span> <span class="nx">sealer</span><span class="p">.</span><span class="nx">CreateSealProofInputs</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">sealer</span><span class="p">.</span><span class="nx">CreateSealProofOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">ok</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">)</span>

    <span class="c1">// TODO: remove this?
</span><span class="c1"></span>    <span class="c1">// GetPieceInclusionProof(pieceRef CID) union { PieceInclusionProofs, error }
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_mining__storage_proving__sealer">

<h4 class="section-header">
  Sector Sealer
</h4>

<div class="section-content">




































<p>Sector Sealer</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>

<span class="kd">type</span> <span class="nx">SealInputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>      <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">SealCfg</span>       <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg</span>
    <span class="nx">MinerID</span>       <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">RandomSeed</span>    <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span>
    <span class="nx">UnsealedPath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">SealedPath</span>    <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">DealIDs</span>       <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CreateSealProofInputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>     <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">SealCfg</span>      <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg</span>
    <span class="nx">RandomSeed</span>   <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span>
    <span class="nx">SealedPath</span>   <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">SealOutputs</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealOutputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ProofAuxTmp</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CreateSealProofOutputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealInfo</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span>
    <span class="nx">ProofAux</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAux</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorSealer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">SealSector</span><span class="p">()</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">SealOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">CreateSealProof</span><span class="p">(</span><span class="nx">si</span> <span class="nx">CreateSealProofInputs</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">CreateSealProofOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="nf">MaxUnsealedBytesPerSector</span><span class="p">(</span><span class="nx">SectorSize</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_proving__poster">

<h4 class="section-header">
  Sector Poster
</h4>

<div class="section-content">

























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">UInt64</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">Challenge</span> <span class="nx">UInt64</span>
<span class="kd">type</span> <span class="nx">PoStProof</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span>
<span class="c1">// TODO: move this to somewhere the blockchain can import
</span><span class="c1">// candidates:
</span><span class="c1">// - filproofs - may have to learn about Sectors (and if we move Seal stuff, Deals)
</span><span class="c1">// - &#34;blockchain/builtins&#34; or something like that - a component in the blockchain that handles storage verification
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PoStSubmission</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PostProof</span>   <span class="nx">PoStProof</span>
    <span class="nx">ChainEpoch</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PostGenerator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">Challenge</span><span class="p">,</span> <span class="nx">IDs</span> <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">])</span> <span class="nx">PoStProof</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">poster</span>

<span class="c1">// See &#34;Proof-of-Spacetime Parameters&#34; Section
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">POST_PROVING_PERIOD</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">5760</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">POST_CHALLENGE_DEADLINE</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">480</span><span class="p">)</span>

<span class="c1">// // this must  GetRandFromBlock(self.ProvingPeriodEnd - POST_CHALLENGE_TIME)
</span><span class="c1">//   GetChallenge(minerActor &amp;StorageMinerActor, currBlock) Challenge
</span><span class="c1"></span>
<span class="c1">//   GeneratePoSt(challenge Challenge, sectors [Sector]) PoStProof {
</span><span class="c1">//       sectorsMetadata := sectors.map(func(sector) { SectorStorage.GetMetadata(sector.CommR) });
</span><span class="c1"></span>
<span class="c1">//       // Question: Should we pass metadata into FilProofs so it can interact with SectorStore directly?
</span><span class="c1">//       // Like this:
</span><span class="c1">//       PoStReponse := SectorStorageSubsystem.GeneratePoSt(sectorSize, challenge, faults, sectorsMetatada);
</span><span class="c1"></span>
<span class="c1">//       // Question: Or should we resolve + manifest trees here and pass them in?
</span><span class="c1">//       // Like this:
</span><span class="c1">//       trees := sectorsMetadata.map(func(md) { SectorStorage.GetMerkleTree(md.MerkleTreePath) });
</span><span class="c1">//       // Done this way, we redundantly pass the tree paths in the metadata. At first thought, the other way
</span><span class="c1">//       // seems cleaner.
</span><span class="c1">//       PoStReponse := SectorStorageSubsystem.GeneratePoSt(sectorSize, challenge, faults, sectorsMetadata, trees);
</span><span class="c1">//   }
</span></code></pre></div>






<h5 id="post-generator-object">PoSt Generator object</h5>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_markets">

<h2 class="section-header">
  Markets in Filecoin
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets">
            <strong>Market</strong>


        
            <br /><br /><i class="menuIcon">‚öñÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__order">
            Orders


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__deal">
            Deals


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market">
            Storage Market


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_market_actor">
            Storage Market Actor


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_provider">
            Storage Provider


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_client">
            Storage Client


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__faults">
            Faults


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market">
            Retrieval Market


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_client">
            Retrieval Client


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_provider">
            Retrieval Provider (Miner)


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>


<p>The Filecoin project is a protocol, a platform, and a marketplace. There are two major components to Filecoin markets, storage market and retrieval market. While both markets are expected to happen primarily off the blockchain, storage deals made in storage market will be published on chain and enforced by the protocol. Storage deal negotiation and order matching are expected to happen off chain in the first version of Filecoin. Retrieval deals are also negotiated off chain and executed with micropayments between transacting parties in payment channels.</p>

<p>Even though most of the market actions happen off the blockchain, there are on-chain invariant and structure that create economic structure for network success and allow for positive emergent behavior. Storage Mining in Filecoin can be compared to maintaining a storage cargo container (a <code>Sector</code> reference to <code>Sector</code> here) with storage deals sitting in them. There must be at least one active deal in a <code>Sector</code> for the <code>Sector</code> to count towards a miner&rsquo;s power. Miners should be able to update storage deals in a <code>Sector</code> without changing their power. Once a <code>Sector</code> is filled with active <code>StorageDeals</code>, retrieval miners can then serve data stored in the <code>Sector</code> to users.</p>


</div>


  
    








<div id="systems__filecoin_markets__order">

<h3 class="section-header">
  Market Orders - Asks and Bids
</h3>

<div class="section-content">






































<p>TODO:</p>

<ul>
<li>Write asks</li>
<li>Write bids</li>
<li>Write how market orders propagate (gossipsub)</li>
</ul>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Ask</span> <span class="kd">struct</span> <span class="p">{</span>

<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Bid</span> <span class="kd">struct</span> <span class="p">{</span>

<span class="p">}</span>
</code></pre></div>






<h4 id="verifiability">Verifiability</h4>

<p>TODO:</p>

<ul>
<li>write what parts of market orders are verifiable, and how

<ul>
<li>eg: miner storage ask could carry the amount of storage available (which should be at mot (pledge - sectors sealed))</li>
<li>eg: client storage bid price could be checked against available money in the StorageMarket</li>
</ul></li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__deal">

<h3 class="section-header">
  Market Deals
</h3>

<div class="section-content">






































<p>There are two types of deals in Filecoin markets, storage deals and retrieval deals. Storage deals are recorded on the blockchain and enforced by the protocol. Retrieval deals are off chain and enabled by micropayment channel by transacting parties. All deal negotiation happen off chain and a request-response style storage deal protocol is in place to submit agreed-upon storage deals onto the network with <code>CommitSector</code> to gain storage power on chain. Hence, there is a <code>StorageDealProposal</code> and a <code>RetrievalDealProposal</code> that are half-signed contracts submitted by clients to be counter-signed and posted on-chain by the miners.</p>

<p>Filecoin Storage Market Deal Flow</p>

<h4 id="add-storage-deal-and-power">Add Storage Deal and Power</h4>

<ul>
<li>1. <code>StorageClient</code> and <code>StorageProvider</code> call <code>StorageMarketActor.AddBalance</code> to deposit funds into Storage Market. There are two fund states in the Storage Market, <code>Locked</code> and <code>Available</code>.

<ul>
<li><code>StorageClient</code> and <code>StorageProvider</code> can call <code>WithdrawBalance</code> before any deal is made. (move to state X)</li>
</ul></li>
<li>2. <code>StorageClient</code> and <code>StorageProvider</code> negotiate a deal off chain. <code>StorageClient</code> sends a <code>StorageDealProposal</code> to a <code>StorageProvider</code>.

<ul>
<li><code>StorageProvider</code> verifies the <code>StorageDeal</code> by checking address and signature of <code>StorageClient</code>, checking the proposal has not expired, checking <code>StorageClient</code> did not call withdraw in the last X Epoch, checking both <code>StorageProvider</code> and <code>StorageClient</code> have sufficient available balances in <code>StorageMarketActor</code>.</li>
</ul></li>
<li>3. <code>StorageProvider</code> signs the <code>StorageDealProposal</code>  gets a <code>StorageDeal</code>.

<ul>
<li>a. <code>StorageProvider</code> calls <code>PublishStorageDeals</code> in <code>StorageMarketActor</code> which will generate a <code>DealID</code> for each <code>StorageDeal</code> and store a mapping from <code>DealID</code> to <code>StorageDeal</code>. However, the deals are not active at this point.

<ul>
<li>As a backup, <code>StorageClient</code> MAY call <code>PublishStorageDeals</code> with the <code>StorageDeal</code>, to activate the deal.</li>
<li>It is possible for either <code>StorageProvider</code> or <code>StorageClient</code> to try to enter into two deals simultaneously with funds available only for one. Only the first deal to commit in the chain would clear, the second would fail with error <code>errorcode.InsufficientFunds</code>.</li>
</ul></li>
<li>b. <code>StorageProvider</code> calls <code>HandleStorageDeal</code> in <code>StorageMiningSubsystem</code> which will then add the <code>StorageDeal</code> into a <code>Sector</code>.</li>
</ul></li>
<li>4. Once the miner finishes packing a <code>Sector</code>, it generates a Sealed Sector and calls <code>StorageMinerActor.CommitSector</code> to verify the seal, store sector expiration, and record the mapping from <code>SectorNumber</code> to <code>SealCommitment</code>. It will also place this newly added <code>Sector</code> in the list of <code>CommittedSectors</code> in <code>StorageMinerActor</code>. <code>StorageMiner</code> does not earn any power for this newly added sector until its first PoSt has been submitted.</li>
</ul>

<h4 id="declare-and-recover-faults">Declare and Recover Faults</h4>

<ul>
<li>5. Declared faults are penalized to a smaller degree than spotted faults by <code>CronActor</code>. Miners declare faulty sectors by invoking <code>StorageMinerActor.DeclareFaults</code> and X of the <code>StorageDealCollateral</code> will be slashed and power corresponding to these sectors will be tempororily lost.</li>
<li>6. Miners can then recover faults by invoking <code>StorageMinerActor.RecoverFaults</code> and have sufficient <code>StorageDealCollateral</code> in their available balances. FaultySectors are recommitted and power is only restored at the next PoSt submission.</li>
<li>7. Sectors that are declared faulty for <code>storagemining.MaxFaults</code> consecutive ChainEpochs will result in <code>StoragePowerActor.SlashPledgeCollateral</code>.

<ul>
<li>TODO: set <code>X</code> parameter</li>
</ul></li>
</ul>

<h4 id="submit-post">Submit PoSt</h4>

<p>(TODO: move into Storage Mining)</p>

<p>On every PoSt Submission, the following steps happen.</p>

<ul>
<li>8. <code>StorageMinerActor</code> first verifies the PoSt Submission. All Sectors will be considered in <code>SpottedFaults</code> if PoSt submission has failed (move to State 14).</li>
<li>9. If <code>CommittedSectors</code> are proven in <code>PoStSubmission.SectorSet</code>, Storage Miner gains power for these newly committed sectors.</li>
<li>10. If there are <code>DeclaredFaultySectors</code> , <code>Sector</code> in that set will not be challenged.</li>
<li>11. For all other sectors, payment will be processed by invoking <code>StorageMarketActor.ProcessStorageDealsPayment</code> and miner available balances will be updated.</li>
<li>12. Decide which Sectors have expired by looking at the <code>SectorExpirationQueue</code>. Sectors expire when all deals in that Sector have expired. <code>StorageDealCollateral</code> for both miners and users will only be returned when all deals in the Sector have expired. This is done by calling <code>StorageMarketActor.SettleExpiredDeals</code> and the Sector will be deleted from <code>StorageMinerActor.Sectors</code>.</li>
</ul>

<h4 id="spot-faults">Spot Faults</h4>

<p>(TODO: move into Storage Mining)</p>

<ul>
<li>13. <code>CronActor</code> calls <code>StoragePowerActor.EpochTick</code> at every block. This calls <code>StorageMinerActor.CheckPoSt</code> on all the miners whose <code>ProvingPeriod</code> is up.

<ul>
<li>If no PoSt is submitted by the end of the <code>ProvingPeriod</code>, <code>StorageMinerActor</code> spots the missing PoSt, and sets all sectors to <code>Failing</code>.</li>
<li>TODO: reword in terms of a conditional in the mining cycle</li>
<li>When there are sector faults are spotted, both <code>StorageDealCollateral</code> and <code>PledgeCollateral</code> are slashed, and power is lost.</li>
<li>If the faults persist for <code>storagemining.MaxFaults</code> then sectors are removed/cleared from <code>StorageMinerActor</code>.</li>
</ul></li>
</ul>

<h4 id="deal-code">Deal Code</h4>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">DealID</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">DealCID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>
<span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">StorageDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PieceRef</span>            <span class="nx">DealCID</span>
    <span class="nx">PieceSize</span>           <span class="nx">UInt</span>
    <span class="nx">Client</span>              <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">Provider</span>            <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">ProposalExpiration</span>  <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">DealExpiration</span>      <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">StoragePrice</span>        <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">StorageCollateral</span>   <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">ProposerSignature</span>   <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageDeal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Proposal</span>          <span class="nx">StorageDealProposal</span>
    <span class="nx">CounterSignature</span>  <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalDealProposal</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RetrievalDeal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Proposal</span>          <span class="nx">RetrievalDealProposal</span>
    <span class="nx">CounterSignature</span>  <span class="nx">Signature</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market">

<h3 class="section-header">
  Storage Market in Filecoin
</h3>

<div class="section-content">




































<p><div id="systems__filecoin_markets__storage_market__storage_market_subsystem"></div>
Storage Market subsystem is the data entry point into the network. Storage miners only earn power from data stored in a storage deal and all deals live on the Filecoin network. Specific deal negotiation process happens off chain, clients and miners enter a storage deal after an agreement has been reached and post storage deals on the Filecoin network to earn block rewards and get paid for storing the data in the storage deal. A deal is only valid when it is posted on chain with signatures from both parties and at the time of posting, there are sufficient balances for both parties in <code>StorageMarketActor</code> to honor the deal in terms of deal price and deal collateral.</p>

<p>Both <code>StorageClient</code> and <code>StorageProvider</code> need to first deposit Filecoin token into <code>StorageMarketActor</code> before participating in the storage market. <code>StorageClient</code> can then send a <code>StorageDealProposal</code> to the <code>StorageProvider</code> along with the data. A partially signed <code>StorageDeal</code> is called a <code>StorageDealProposal</code>. <code>StorageProvider</code> can then put this storage deal in their <code>Sector</code>, countersign the <code>StorageDealProposal</code> and result in a <code>StorageDeal</code>. A <code>StorageDeal</code> is only in effect when it is submitted to and accepted by the <code>StorageMarketActor</code> on chain before the <code>ProposalExpiryEpoch</code>. <code>StorageDeal</code> does not include a <code>StartEpoch</code> as it will come into effect at the block when the deal gets accepted into the network. Hence, <code>StorageProvider</code> should publish the deal as soon as possible.</p>

<p><code>StorageDeal</code> payments are processed at every successful PoSt submission and <code>StorageMarketActor</code> will move locked funds from <code>StorageClient</code> to <code>StorageProvider</code>. <code>SlashStorageDealCollateral</code> is also triggered on PoSt submission when a Sector containing a particular <code>StorageDeal</code> is faulty or miners fail to submit PoSt related to a <code>StorageDeal</code>. Note that <code>StorageProvider</code> does not need to be the same entity as the <code>StorageMinerActor</code> as long as the deal is stored in at least one <code>Sector</code> throughout the life time of the storage deal.</p>

<p>TODO: process <code>StorageDeal</code> payments are larger interval beyond every PoSt submission</p>


</div>


  
    








<div id="systems__filecoin_markets__storage_market__storage_market_actor">

<h4 class="section-header">
  Storage Market Actor
</h4>

<div class="section-content">






































<p><code>StorageMarketActor</code> is responsible for processing and managing on-chain deals. This is also the entry point of all storage deals and data into the system. It maintains a mapping of <code>StorageDealID</code> to <code>StorageDeal</code> and keeps track of locked balances of <code>StorageClient</code> and <code>StorageProvider</code>. When a deal is posted on chain through the <code>StorageMarketActor</code>, it will first check if both transacting parties have sufficient balances locked up and include the deal on chain. On every successful submission of <code>PoStProof</code>, <code>StorageMarketActor</code> will credit the <code>StorageProvider</code> a fraction of the storage fee based on how many blocks have passed since the last <code>PoStProof</code>. In the event that there are sectors included in the <code>FaultSet</code>, <code>StorageMarketActor</code> will fetch deal information from the chain and <code>SlashStorageFault</code> for faulting on those deals. Similarly, when a <code>PoStProof</code> is missed by the end of a <code>ProvingPeriod</code>, <code>SlashStorageFault</code> will also be called by the <code>CronActor</code> to penalize <code>StorageProvider</code> for dropping a <code>StorageDeal</code>.</p>

<p>(You can see the <em>old</em> Storage Market Actor <a href="docs/systems/filecoin_markets/storage_market/storage_market_actor_old">here</a> )</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>

<span class="kd">type</span> <span class="nx">StorageParticipantBalance</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Locked</span>     <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">Available</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageMarketActor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// need access to:
</span><span class="c1"></span>    <span class="c1">// - DataTransferSubsystem
</span><span class="c1"></span>    <span class="c1">//   - transfer data
</span><span class="c1"></span>    <span class="c1">// - NetworkSubsystem
</span><span class="c1"></span>    <span class="c1">//   - needs access to MessagePubsub
</span><span class="c1"></span>
    <span class="nx">Balances</span>  <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">StorageParticipantBalance</span><span class="p">}</span>
    <span class="nx">Deals</span>     <span class="p">{</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">:</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">}</span>

    <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">balance</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">balance</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">CheckLockedBalance</span><span class="p">(</span><span class="nx">participantAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>

    <span class="c1">// call by CommitSector in StorageMiningSubsystem
</span><span class="c1"></span>    <span class="c1">// a StorageDeal is only published on chain when it passes verifyStorageDeal
</span><span class="c1"></span>    <span class="c1">// a DealID will be assigned and stored in the mapping of DealID to StorageDeal
</span><span class="c1"></span>    <span class="c1">// PublishStorageDeal should be called before SecotrCommits
</span><span class="c1"></span>    <span class="c1">// an unregistered StorageDeal will not be processed
</span><span class="c1"></span>    <span class="nf">PublishStorageDeals</span><span class="p">(</span><span class="nx">deals</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">])</span> <span class="p">[</span><span class="nx">PublishStorageDealResponse</span><span class="p">]</span>

    <span class="c1">// check if StorageDeal is signed before expiry
</span><span class="c1"></span>    <span class="c1">// check if StorageDeal has the right signatures
</span><span class="c1"></span>    <span class="c1">// check if minimum StoragePrice and StorageCollateral are met
</span><span class="c1"></span>    <span class="c1">// check if provider and client have sufficient balances
</span><span class="c1"></span>    <span class="nf">verifyStorageDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// generate storage deal id
</span><span class="c1"></span>    <span class="nf">generateStorageDealID</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span>

    <span class="c1">// TODO: StorageDeals should be renewable
</span><span class="c1"></span>    <span class="c1">// UpdateStorageDeal(newStorageDeals [deal.StorageDeal])
</span><span class="c1"></span>
    <span class="c1">// call by CronActor when no PoSt is submitted within a ProvingPeriod
</span><span class="c1"></span>    <span class="c1">// trigger subsequent calls on different SectorSet
</span><span class="c1"></span>    <span class="c1">// pull SectorSet from the run time
</span><span class="c1"></span>    <span class="nf">HandleCronAction</span><span class="p">()</span>

    <span class="c1">// call by CronActor / onPoStSubmission on ExpiredSet
</span><span class="c1"></span>    <span class="c1">// remove StorageDeal from StorageMarketActor
</span><span class="c1"></span>    <span class="c1">// if no more active deals contain in the sector
</span><span class="c1"></span>    <span class="c1">// return StorageCollateral to miners
</span><span class="c1"></span>    <span class="nf">SettleExpiredDeals</span><span class="p">(</span><span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span>

    <span class="c1">// call by CronActor / onPoStSubmission on ActiveSet to process deal payment
</span><span class="c1"></span>    <span class="c1">// go through StorageDealIDs, if IDs are active in MarketActor
</span><span class="c1"></span>    <span class="c1">// payment will be processed
</span><span class="c1"></span>    <span class="nf">ProcessStorageDealsPayment</span><span class="p">(</span><span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span>

    <span class="c1">// call by CronActor / on DeclareFault on FaultSet to slash deal collateral
</span><span class="c1"></span>    <span class="c1">// Deals should be slashed for a single proving period
</span><span class="c1"></span>    <span class="nf">SlashStorageDealCollateral</span><span class="p">(</span><span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span>

    <span class="nf">GetLastExpirationFromDealIDs</span><span class="p">(</span><span class="nx">dealIDs</span> <span class="p">[</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealID</span><span class="p">])</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>
</code></pre></div>






<div id="systems__filecoin_markets__storage_market__storage_market_actor__storage_deal_collateral"></div>

<h6 id="storage-deal-collateral">Storage Deal Collateral</h6>

<p>Storage Deals have an associated collateral amount. This <code>StorageDealCollateral</code> is held in the <code>StorageMarketActor</code>.
Its value is agreed upon by the storage provider and client off-chain, but must be greater than a protocol-defined minimum in any deal. Storage providers will choose to offer greater collateral to signal high-quality storage to clients.</p>

<p>On <code>SectorFailureTimeout</code> (see <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>), the <code>StorageDealCollateral</code> will be burned. In the future, the Filecoin protocol may be amended to send up to half of the collateral to storage clients as damages in such cases.</p>

<p>Upon graceful deal expiration, storage providers must wait for finality number of epochs (as defined in <a href="./#algorithms__expected_consensus__finality">EC Finality</a>) before being able to withdraw their <code>StorageDealCollateral</code> from the <code>StorageMarketActor</code>.</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_provider">

<h4 class="section-header">
  Storage Provider
</h4>

<div class="section-content">




































<p>Both <code>StorageProvider</code> and <code>StorageClient</code> are <code>StorageMarketParticipant</code>. Any party can be a storage provider or client or both at the same time. Storage deal negotiation is expected to happen completely off chain and the request-response style storage deal protocol is to submit agreed-upon storage deal onto the network and gain storage power on chain. <code>StorageClient</code> will initiate the storage deal protocol by submitting a <code>StorageDealProposal</code> to the <code>StorageProvider</code> who will then add the deal data to a <code>Sector</code> and commit the sector onto the blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>
<span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>

<span class="kd">type</span> <span class="nx">StorageDealStagedNotification</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Deal</span>      <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span>
    <span class="nx">SectorID</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageProvider</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">DealStatus</span> <span class="p">{</span><span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">:</span> <span class="nx">StorageDealStatus</span><span class="p">}</span>

    <span class="c1">// calls between StorageClient and StorageProvider happen over libp2p
</span><span class="c1"></span>    <span class="c1">// Client calls this to submit new StorageDealProposal
</span><span class="c1"></span>    <span class="nf">HandleNewStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span>

    <span class="c1">// Call by StorageProvider to sign a StorageDealProposal
</span><span class="c1"></span>    <span class="nf">signStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span>

    <span class="c1">// Call by StorageProvider to reject a StorageDealProposal
</span><span class="c1"></span>    <span class="nf">rejectStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span>

    <span class="c1">// Check client balance and signature
</span><span class="c1"></span>    <span class="nf">verifyStorageClient</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">signature</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="c1">// TODO: Call by StorageMiningSubsystem
</span><span class="c1"></span>    <span class="nf">NotifyStorageDealStaged</span><span class="p">(</span><span class="nx">storageDealNotification</span> <span class="nx">StorageDealStagedNotification</span><span class="p">)</span>

    <span class="c1">// Call by StorageClient
</span><span class="c1"></span>    <span class="nf">HandleStorageDealQuery</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">)</span> <span class="nx">StorageDealStatus</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

	<span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="p">)</span>

<span class="c1">// import deal_status &#34;github.com/filecoin-project/specs/systems/filecoin_markets/storage_market&#34;
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">HandleNewStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">verifyStorageClient</span><span class="p">(</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">Client</span><span class="p">(),</span> <span class="nx">proposal</span><span class="p">.</span><span class="nf">ProposerSignature</span><span class="p">(),</span> <span class="nx">proposal</span><span class="p">.</span><span class="nf">StoragePrice</span><span class="p">())</span> <span class="p">{</span>
		<span class="c1">// status := &amp;deal.StorageDealStatus_StorageDealProposed_I{}
</span><span class="c1"></span>		<span class="c1">// s := deal.StorageDealStatus_Make_StorageDealProposed(status)
</span><span class="c1"></span>		<span class="nx">provider</span><span class="p">.</span><span class="nf">DealStatus</span><span class="p">()[</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">PieceRef</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">StorageDealProposed</span>
		<span class="c1">// TODO notify StorageClient that a deal has been received
</span><span class="c1"></span>		<span class="c1">// TODO notify StorageMiningSubsystem to add deals to sector
</span><span class="c1"></span>		<span class="nx">provider</span><span class="p">.</span><span class="nf">signStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span><span class="p">)</span>
		<span class="c1">// DO THIS TODAY Call StorageMarketActor.publishStorageDeal()
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">signStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDeal</span> <span class="p">{</span>
	<span class="c1">// TODO add signature to the proposal
</span><span class="c1"></span>	<span class="c1">// TODO notify StorageClient that a deal has been signed
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">rejectStorageDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">provider</span><span class="p">.</span><span class="nf">DealStatus</span><span class="p">()[</span><span class="nx">proposal</span><span class="p">.</span><span class="nf">PieceRef</span><span class="p">()]</span> <span class="p">=</span> <span class="nx">StorageDealRejected</span>
	<span class="c1">// TODO send notification to client
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">verifyStorageClient</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">signature</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span> <span class="nx">price</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// TODO make call to StorageMarketActor
</span><span class="c1"></span>	<span class="c1">// balance, found := StorageMarketActor.Balances()[address]
</span><span class="c1"></span>
	<span class="c1">// if !found {
</span><span class="c1"></span>	<span class="c1">// 	return false
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// if balance &lt; price {
</span><span class="c1"></span>	<span class="c1">// 	return false
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="c1">// TODO Check on Signature
</span><span class="c1"></span>	<span class="c1">// return true
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// TODO: func (provider *StorageProvider_I) NotifyStorageDealStaged(storageDealNotification StorageDealStagedNotification) {
</span><span class="c1">// 	panic(&#34;TODO&#34;)
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">provider</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">HandleStorageDealQuery</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">)</span> <span class="nx">StorageDealStatus</span> <span class="p">{</span>
	<span class="nx">dealStatus</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">provider</span><span class="p">.</span><span class="nf">DealStatus</span><span class="p">()[</span><span class="nx">dealCID</span><span class="p">]</span>

	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">dealStatus</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">StorageDealNotFound</span>
<span class="p">}</span>

<span class="c1">// TODO this should be moved into storage market
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sp</span> <span class="o">*</span><span class="nx">StorageProvider_I</span><span class="p">)</span> <span class="nf">NotifyStorageDealStaged</span><span class="p">(</span><span class="nx">storageDealNotification</span> <span class="nx">StorageDealStagedNotification</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>






<!-- # Storage Provider State Machine -->


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_client">

<h4 class="section-header">
  Storage Client
</h4>

<div class="section-content">




































<p>Both <code>StorageProvider</code> and <code>StorageClient</code> are <code>StorageMarketParticipant</code>. Any party can be a storage provider or client or both at the same time. Storage deal negotiation is expected to happen completely off chain and the request-response style storage deal protocol is to submit agreed-upon storage deal onto the network and gain storage power on chain. <code>StorageClient</code> will initiate the storage deal protocol by submitting a <code>StorageDealProposal</code> to the <code>StorageProvider</code> who will then add the deal data to a <code>Sector</code> and commit the sector onto the blockchain.</p>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">deal</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_markets/deal&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">StorageClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// calls between StorageClient and StorageProvider happen over libp2p
</span><span class="c1"></span>    <span class="c1">// make call to StorageProvider in StorageDealProposal
</span><span class="c1"></span>    <span class="nf">ProposeStorageDeal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span>

    <span class="c1">// make call to StorageProvider
</span><span class="c1"></span>    <span class="nf">QueryStorageDeal</span><span class="p">(</span><span class="nx">dealCID</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">DealCID</span><span class="p">,</span> <span class="nx">provider</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>






















<p style="color: #D74848"><b><i>Something's not right. The <code>storage_client.go</code> file was not found.</i></b></p>



<!-- # Storage Client State Machine -->


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__faults">

<h4 class="section-header">
  Faults
</h4>

<div class="section-content">






































<p><div id="systems__filecoin_markets__storage_market__faults__storage_faults"></div>
There are two main categories of faults in the Filecoin network.</p>

<ul>
<li>ConsensusFaults</li>
<li>StorageDealFaults</li>
</ul>

<p>ConsensusFaults are faults that impact network consensus and StorageDealFaults are faults where data in a <code>StorageDeal</code> is not maintained by the providers pursuant to deal terms.</p>

<p><a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></a> is slashed for ConsensusFaults and <a href="./#systems__filecoin_markets__storage_market__storage_deal_collateral">Storage Deal Collateral</a> for StorageDealFaults.</p>

<p>Any misbehavior may result in more than one fault thus lead to slashing on both collaterals. For example, missing a <code>PoStProof</code> will incur a penalty on both <code>PledgeCollateral</code> and <code>StorageDealCollateral</code> given it impacts both a given <code>StorageDeal</code> and power derived from the sector commitments in <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a>.</p>

<h6 id="storage-faults">Storage Faults</h6>

<p>TODO: complete this.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market">

<h3 class="section-header">
  Retrieval Market in Filecoin
</h3>

<div class="section-content">






































<h4 id="components">Components</h4>

<p>Version 0 of the <code>retrieval market</code> protocol is what we (tentatively) will launch the filecoin network with. It is version zero because it will only be good enough to fit the bill as a way to pay another node for a file.</p>

<p>The main components are as follows:</p>

<ul>
<li>A payment channel actor (See <a href="payment-channels.md">payment channels</a> for details)</li>
<li>&lsquo;retrieval-v0&rsquo; <code>libp2p</code> services</li>
<li>A chain-based content routing interface</li>
<li>A set of commands to interact with the above</li>
</ul>

<h4 id="retrieval-v0-libp2p-services">Retrieval V0 <code>libp2p</code> Services</h4>

<p>The v0 <code>retrieval market</code> will initially be implemented as two <code>libp2p</code> services. It will be request response based, where the client who is requesting a file sends a <code>retrieval deal proposal</code> to the miner. The miner chooses whether or not to accept it, sends their response which (if they accept the proposal) includes a <code>signed retrieval deal</code>, followed by the actual requested content, streamed as a series of bitswap block messages, using a pre-order traversal of the dag. Each block should use the <a href="https://github.com/ipfs/go-bitswap/blob/c980d7ed36f278e93828acf920f3a911e8263265/message/message.go#L228">bitswap block message format</a>. This way, the client should be able to verify the data incrementally as it receives it. Once the client has received all the data, it should then send a payment channel SpendVoucher of the proposed amount to the miner. This protocol may be easily extended to include payments from the client to the miner every N blocks, but for now we omit that feature.</p>


</div>


  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_client">

<h4 class="section-header">
  Retrieval Client
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">RetrievalClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">CreatePaymentChannel</span><span class="p">(</span><span class="nx">provider</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">payment</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">PaymentChannel</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_provider">

<h4 class="section-header">
  Retrieval Provider (Miner)
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor/address&#34;</span>

<span class="kd">type</span> <span class="nx">PaymentChannel</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">CID</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// File Retrieval Query
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FileRetrievalAvailable</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">MinPrice</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">Miner</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">FileRetrievalUnavailable</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalQueryResponse</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">FileRetrievalAvailable</span>
    <span class="nx">FileRetrievalUnavailable</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalQuery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">File</span> <span class="nx">CID</span>
<span class="p">}</span>

<span class="c1">// File Retrieval Deal Proposal and Deal
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RetrievalDealProposalError</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposalRejected</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposalAccepted</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CounterParty</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">Payment</span>       <span class="nx">PaymentChannel</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposalResponse</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">RetrievalDealProposalAccepted</span>
    <span class="nx">RetrievalDealProposalRejected</span>
    <span class="nx">RetrievalDealProposalError</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">RetrievalDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">File</span>      <span class="nx">CID</span>
    <span class="nx">Payment</span>   <span class="nx">PaymentChannel</span>
    <span class="nx">MinPrice</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalProvider</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">NewRetrievalQuery</span><span class="p">(</span><span class="nx">query</span> <span class="nx">RetrievalQuery</span><span class="p">)</span> <span class="nx">RetrievalQueryResponse</span>

    <span class="c1">// NewRetrievalDealProposal is called to propose a retrieval
</span><span class="c1"></span>    <span class="nf">NewRetrievalDealProposal</span><span class="p">(</span><span class="nx">proposal</span> <span class="nx">RetrievalDealProposal</span><span class="p">)</span> <span class="nx">RetrievalDealProposalResponse</span>

    <span class="c1">// AcceptRetrievalDeal is called to accept a retrieval deal
</span><span class="c1"></span>    <span class="nf">AcceptRetrievalDealProposal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">RetrievalDealProposal</span><span class="p">)</span> <span class="nx">RetrievalDealProposalResponse</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  


</div>

  


</div>

  

  
    








<div id="libraries">

<h1 class="section-header">
  Libraries used in Filecoin
</h1>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries">
            Libraries


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__filcrypto">
            filcrypto


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__filcrypto__filproofs">
            filproofs


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__fcs">
            FCS


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld">
            IPLD


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__cid">
            CID


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__datamodel">
            Data Model


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__selectors">
            Selectors


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__graphstore">
            GraphStore


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p">
            libp2p


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__gossipsub">
            gossipsub


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__kad_dht">
            kad-dht


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__fil_libp2p_nodes">
            fil-libp2p Nodes


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs">
            IPFS


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__bitswap">
            BitSwap


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__graphsync">
            GraphSync


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__unixfs">
            UnixFS


        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__multiformats">
            Multiformats


        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="libraries__filcrypto">

<h2 class="section-header">
  filcrypto - Filecoin Cryptographic Primitives
</h2>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">VRFPublicKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">VRFSecretKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">SigPublicKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">SigSecretKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">PubKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">PrivKey</span> <span class="nx">Bytes</span>  <span class="c1">// TODO merge it into SigSecretKey
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">VRFKeyPair</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PublicKey</span>              <span class="nx">VRFPublicKey</span>
    <span class="nx">SecretKey</span>              <span class="nx">VRFSecretKey</span>

    <span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span> <span class="nx">Bytes</span><span class="p">)</span>  <span class="nx">VRFResult</span>     <span class="err">@</span><span class="p">(</span><span class="nx">static</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">VRFResult</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Output</span>  <span class="nx">Bytes</span>  <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>
    <span class="nx">Proof</span>   <span class="nx">Bytes</span>  <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>

    <span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SigKeyPair</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PublicKey</span>  <span class="nx">SigPublicKey</span>
    <span class="nx">SecretKey</span>  <span class="nx">SigSecretKey</span>

    <span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">_type</span> <span class="nx">SigType</span><span class="p">)</span> <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Signature</span>  <span class="nx">Bytes</span>    <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>
    <span class="nx">sigType</span>    <span class="nx">SigType</span>  <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>

    <span class="nf">Verify</span><span class="p">(</span><span class="nx">pk</span> <span class="nx">SigPublicKey</span><span class="p">,</span> <span class="nx">input</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SigType</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">RSASigType</span>
    <span class="nx">BLSSigType</span>
    <span class="nx">EdDSASigType</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">BLS</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Secp256k1</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>






<p>TODO: describe BLS VRF in implementable detail</p>


</div>


  
    








<div id="libraries__filcrypto__filproofs">

<h3 class="section-header">
  filproofs - Filecoin Storage Proofs
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>

<span class="kd">type</span> <span class="nx">SectorInfo</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">SectorID</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">FilecoinProofsSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sealVerifyInfo</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>

<span class="kd">type</span> <span class="nx">StackedDRGLayers</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">StackedDRGNodeSize</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">StackedDRGChallenges</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">DRGDepth</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGFraction</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGDegree</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">DRGSeed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGNodeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphNodeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelKeys</span> <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelRounds</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelHashFunction</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">Blake2S</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">ChungExpanderAlpha</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ChungExpanderBeta</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphDegree</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphSeed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGNodeSize</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">SealAlgorithmArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">AlgorithmWideSetupArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// trusted setup output parameters go here
</span><span class="c1"></span>        <span class="c1">// updates to public parameters go here
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nx">SealSetupArtifacts</span>

    <span class="c1">// ProveArtifacts or
</span><span class="c1"></span>    <span class="nx">ChallengeArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// inputs into prove() go here
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nx">VerifyArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// inputs into verify() go here
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// per-sector setup artifacts go here   
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealSetupArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CommD</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommR</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
    <span class="nx">CommC</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommRLast</span>          <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommDTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommCTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommRLastTreePath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">KeyLayers</span>          <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
    <span class="nx">Replica</span>            <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoRep</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">ZigZagPoRep</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoSpace</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">PoRep</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ZigZagPoRep</span> <span class="nx">StackedDRG</span>

<span class="kd">type</span> <span class="nx">SDRPoSpace</span> <span class="nx">StackedDRG</span>

<span class="kd">type</span> <span class="nx">EllipticCurve</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">FieldModulus</span> <span class="o">&amp;</span><span class="nx">BigInt</span>
<span class="p">}</span>

<span class="c1">//type StackedDRG_Algorithm struct {}
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">StackedDRG</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Layers</span>            <span class="nx">StackedDRGLayers</span>
    <span class="nx">NodeSize</span>          <span class="nx">StackedDRGNodeSize</span>
    <span class="nx">Challenges</span>        <span class="nx">StackedDRGChallenges</span>
    <span class="nx">Algorithm</span>         <span class="kd">struct</span> <span class="p">{}</span>
    <span class="nx">DRGCfg</span>
    <span class="nx">ExpanderGraphCfg</span>
    <span class="c1">// invariant: DRGCfg.Nodes == ExpanderGraphCfg.Nodes
</span><span class="c1"></span>    <span class="nx">Curve</span>             <span class="nx">EllipticCurve</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DRGCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Depth</span>     <span class="nx">DRGDepth</span>  <span class="c1">// D
</span><span class="c1"></span>        <span class="nx">Fraction</span>  <span class="nx">DRGFraction</span>  <span class="c1">// E
</span><span class="c1"></span>
        <span class="nx">ParentsAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
            <span class="nx">DRSample</span>
        <span class="p">}</span>

        <span class="nx">RNGAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
            <span class="nx">ChaCha20</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">Degree</span> <span class="nx">DRGDegree</span>
    <span class="nx">Seed</span> <span class="nx">DRGSeed</span>
    <span class="nx">Nodes</span> <span class="nx">DRGNodeCount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DRG</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>         <span class="nx">DRGCfg</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">UInt</span><span class="p">)</span>  <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ExpanderGraphCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span> <span class="nx">union</span> <span class="p">{</span>
        <span class="nx">ChungExpanderAlgorithm</span>
    <span class="p">}</span>

    <span class="nx">Degree</span>  <span class="nx">ExpanderGraphDegree</span>
    <span class="nx">Seed</span>    <span class="nx">ExpanderGraphSeed</span>
    <span class="nx">Nodes</span>   <span class="nx">ExpanderGraphNodeCount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ExpanderGraph</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>         <span class="nx">ExpanderGraphCfg</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">UInt</span><span class="p">)</span>  <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ChungExpanderAlgorithm</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Alpha</span>  <span class="nx">ChungExpanderAlpha</span>
    <span class="nx">Beta</span>   <span class="nx">ChungExpanderBeta</span>
    <span class="nx">PermutationAlgorithm</span> <span class="nx">union</span> <span class="p">{</span>
        <span class="nx">Feistel</span>
    <span class="p">}</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Feistel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Keys</span>          <span class="nx">ChungExpanderPermutationFeistelKeys</span>
    <span class="nx">Rounds</span>        <span class="nx">ChungExpanderPermutationFeistelRounds</span>
    <span class="nx">HashFunction</span>  <span class="nx">ChungExpanderPermutationFeistelHashFunction</span>
    <span class="nf">Permute</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">n</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span>
<span class="p">}</span>
</code></pre></div>

























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">filproofs</span>

<span class="kn">import</span> <span class="s">&#34;math&#34;</span>
<span class="kn">import</span> <span class="s">&#34;math/rand&#34;</span>
<span class="kn">import</span> <span class="nx">big</span> <span class="s">&#34;math/big&#34;</span>
<span class="kn">import</span> <span class="s">&#34;encoding/binary&#34;</span>

<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>

<span class="kd">type</span> <span class="nx">Blake2sHash</span> <span class="nx">Bytes32</span>
<span class="kd">type</span> <span class="nx">PedersenHash</span> <span class="nx">Bytes32</span>
<span class="kd">type</span> <span class="nx">Bytes32</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="kd">type</span> <span class="nx">UInt</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span>

<span class="kd">func</span> <span class="nf">SDRParams</span><span class="p">(</span><span class="nx">sealCfg</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealCfg</span><span class="p">)</span> <span class="o">*</span><span class="nx">StackedDRG_I</span> <span class="p">{</span>
	<span class="c1">// TODO: Bridge constants with orient model.
</span><span class="c1"></span>	<span class="kd">const</span> <span class="nx">LAYERS</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="kd">const</span> <span class="nx">NODE_SIZE</span> <span class="p">=</span> <span class="mi">32</span>
	<span class="kd">const</span> <span class="nx">OFFLINE_CHALLENGES</span> <span class="p">=</span> <span class="mi">6666</span>
	<span class="kd">const</span> <span class="nx">FEISTEL_ROUNDS</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="kd">var</span> <span class="nx">FEISTEL_KEYS</span> <span class="p">=</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="nx">UInt</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">FIELD_MODULUS</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="c1">// https://github.com/zkcrypto/pairing/blob/master/src/bls12_381/fr.rs#L4
</span><span class="c1"></span>	<span class="nx">FIELD_MODULUS</span><span class="p">.</span><span class="nf">SetString</span><span class="p">(</span><span class="s">&#34;52435875175126190479447740508185965837690552500527637822603658699938581184513&#34;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">sealCfg</span><span class="p">.</span><span class="nf">SectorSize</span><span class="p">()</span> <span class="o">/</span> <span class="nx">NODE_SIZE</span><span class="p">)</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">StackedDRG_I</span><span class="p">{</span>
		<span class="nx">Layers_</span><span class="p">:</span>     <span class="nf">StackedDRGLayers</span><span class="p">(</span><span class="nx">LAYERS</span><span class="p">),</span>
		<span class="nx">Challenges_</span><span class="p">:</span> <span class="nf">StackedDRGChallenges</span><span class="p">(</span><span class="nx">OFFLINE_CHALLENGES</span><span class="p">),</span>
		<span class="nx">NodeSize_</span><span class="p">:</span>   <span class="nf">StackedDRGNodeSize</span><span class="p">(</span><span class="nx">NODE_SIZE</span><span class="p">),</span>
		<span class="nx">Algorithm_</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">StackedDRG_Algorithm_I</span><span class="p">{},</span>
		<span class="nx">DRGCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">DRGCfg_I</span><span class="p">{</span>
			<span class="nx">Algorithm_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">DRGCfg_Algorithm_I</span><span class="p">{</span>
				<span class="nx">ParentsAlgorithm_</span><span class="p">:</span> <span class="nf">DRGCfg_Algorithm_ParentsAlgorithm_Make_DRSample</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">DRGCfg_Algorithm_ParentsAlgorithm_DRSample_I</span><span class="p">{}),</span>
				<span class="nx">RNGAlgorithm_</span><span class="p">:</span>     <span class="nf">DRGCfg_Algorithm_RNGAlgorithm_Make_ChaCha20</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">DRGCfg_Algorithm_RNGAlgorithm_ChaCha20_I</span><span class="p">{}),</span>
			<span class="p">},</span>
			<span class="nx">Degree_</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
			<span class="nx">Nodes_</span><span class="p">:</span>  <span class="nf">DRGNodeCount</span><span class="p">(</span><span class="nx">nodes</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="nx">ExpanderGraphCfg_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">ExpanderGraphCfg_I</span><span class="p">{</span>
			<span class="nx">Algorithm_</span><span class="p">:</span> <span class="nf">ExpanderGraphCfg_Algorithm_Make_ChungExpanderAlgorithm</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">{</span>
					<span class="nx">PermutationAlgorithm_</span><span class="p">:</span> <span class="nf">ChungExpanderAlgorithm_PermutationAlgorithm_Make_Feistel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Feistel_I</span><span class="p">{</span>
						<span class="nx">Keys_</span><span class="p">:</span>   <span class="nx">FEISTEL_KEYS</span><span class="p">[:],</span>
						<span class="nx">Rounds_</span><span class="p">:</span> <span class="nx">FEISTEL_ROUNDS</span><span class="p">,</span>
						<span class="nx">HashFunction_</span><span class="p">:</span> <span class="nf">ChungExpanderPermutationFeistelHashFunction_Make_Blake2S</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="nx">ChungExpanderPermutationFeistelHashFunction_Blake2S_I</span><span class="p">{}),</span>
					<span class="p">}),</span>
				<span class="p">}),</span>
			<span class="nx">Degree_</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
			<span class="nx">Nodes_</span><span class="p">:</span>  <span class="nf">ExpanderGraphNodeCount</span><span class="p">(</span><span class="nx">nodes</span><span class="p">),</span>
		<span class="p">},</span>
		<span class="nx">Curve_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">EllipticCurve_I</span><span class="p">{</span>
			<span class="nx">FieldModulus_</span><span class="p">:</span> <span class="o">*</span><span class="nx">FIELD_MODULUS</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">config</span> <span class="o">:=</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Config</span><span class="p">()</span>
	<span class="nx">degree</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nf">Degree</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">config</span><span class="p">.</span><span class="nf">Algorithm</span><span class="p">().</span><span class="nf">ParentsAlgorithm</span><span class="p">().</span><span class="nf">As_DRSample</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">degree</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// TODO: Verify this. Both the port from impl and the algorithm.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">drs</span> <span class="o">*</span><span class="nx">DRGCfg_Algorithm_ParentsAlgorithm_DRSample_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">degree</span><span class="p">,</span> <span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">node</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">node</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">degree</span> <span class="o">-</span> <span class="mi">1</span>

	<span class="kd">var</span> <span class="nx">k</span> <span class="nx">UInt</span>
	<span class="k">for</span> <span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">logi</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Log2</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">m</span><span class="p">))))</span>
		<span class="c1">// FIXME: Make RNG parameterizable and specify it.
</span><span class="c1"></span>		<span class="nx">j</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">logi</span><span class="p">)</span>
		<span class="nx">jj</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">node</span><span class="o">*</span><span class="nx">m</span><span class="o">+</span><span class="nx">k</span><span class="p">),</span> <span class="nb">float64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
		<span class="nx">backDist</span> <span class="o">:=</span> <span class="nf">randInRange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">jj</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
		<span class="nx">out</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">node</span><span class="o">*</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">backDist</span><span class="p">)</span> <span class="o">/</span> <span class="nx">m</span>

		<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">parents</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">randInRange</span><span class="p">(</span><span class="nx">lowInclusive</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">highExclusive</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">highExclusive</span><span class="o">-</span><span class="nx">lowInclusive</span><span class="p">)</span> <span class="o">+</span> <span class="nx">lowInclusive</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">exp</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Degree</span><span class="p">()</span>

	<span class="c1">// TODO: How do we handle choice of algorithm generically?
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Algorithm</span><span class="p">().</span><span class="nf">As_ChungExpanderAlgorithm</span><span class="p">().</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Nodes</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chung</span> <span class="o">*</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="nx">UInt</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="nx">UInt</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">parent</span> <span class="o">:=</span> <span class="nx">chung</span><span class="p">.</span><span class="nf">ithParent</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">)</span>
		<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">parents</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chung</span> <span class="o">*</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">)</span> <span class="nf">ithParent</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">degree</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="c1">// ithParent generates one of d parents of node.
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">degree</span><span class="p">)</span>

	<span class="c1">// This is done by operating on permutations of a set with d elements per node.
</span><span class="c1"></span>	<span class="nx">setSize</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">nodes</span><span class="p">)</span> <span class="o">*</span> <span class="nx">d</span>

	<span class="c1">// There are d ways of mapping each node into the set, and we choose the ith.
</span><span class="c1"></span>	<span class="c1">// Note that we can project the element back to the original node: element / d == node.
</span><span class="c1"></span>	<span class="nx">element</span> <span class="o">:=</span> <span class="nx">node</span><span class="o">*</span><span class="nx">d</span> <span class="o">+</span> <span class="nx">i</span>

	<span class="c1">// Permutations of the d elements corresponding to each node yield d new elements,
</span><span class="c1"></span>	<span class="nx">permuted</span> <span class="o">:=</span> <span class="nx">chung</span><span class="p">.</span><span class="nf">PermutationAlgorithm</span><span class="p">().</span><span class="nf">As_Feistel</span><span class="p">().</span><span class="nf">Permute</span><span class="p">(</span><span class="nx">setSize</span><span class="p">,</span> <span class="nx">element</span><span class="p">)</span>

	<span class="c1">// each of which can be projected back to a node.
</span><span class="c1"></span>	<span class="nx">projected</span> <span class="o">:=</span> <span class="nx">permuted</span> <span class="o">/</span> <span class="nx">d</span>

	<span class="c1">// We have selected the ith such parent of node.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">projected</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Feistel_I</span><span class="p">)</span> <span class="nf">Permute</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">StackedDRG_I</span><span class="p">)</span> <span class="nf">Seal</span><span class="p">(</span><span class="nx">sid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">)</span> <span class="nx">SealSetupArtifacts</span> <span class="p">{</span>
	<span class="nx">commD</span><span class="p">,</span> <span class="nx">commDTreePath</span> <span class="o">:=</span> <span class="nf">ComputeDataCommitment</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">replicaID</span> <span class="o">:=</span> <span class="nf">ComputeReplicaID</span><span class="p">(</span><span class="nx">sid</span><span class="p">,</span> <span class="nx">commD</span><span class="p">,</span> <span class="nx">seed</span><span class="p">)</span>

	<span class="nx">drg</span> <span class="o">:=</span> <span class="nx">DRG_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">DRGCfg</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="nx">expander</span> <span class="o">:=</span> <span class="nx">ExpanderGraph_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">ExpanderGraphCfg</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">())</span>
	<span class="nx">nodes</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">/</span> <span class="nx">nodeSize</span>
	<span class="nx">curveModulus</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">Curve</span><span class="p">().</span><span class="nf">FieldModulus</span><span class="p">()</span>
	<span class="nx">layers</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Layers</span><span class="p">())</span>

	<span class="nx">keyLayers</span> <span class="o">:=</span> <span class="nf">generateSDRKeyLayers</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">drg</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expander</span><span class="p">,</span> <span class="nx">replicaID</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">layers</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">curveModulus</span><span class="p">)</span>
	<span class="nx">key</span> <span class="o">:=</span> <span class="nx">keyLayers</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="nx">replica</span> <span class="o">:=</span> <span class="nf">encodeData</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">curveModulus</span><span class="p">)</span>

	<span class="nx">commRLast</span><span class="p">,</span> <span class="nx">commRLastTreePath</span> <span class="o">:=</span> <span class="nf">RepHash_PedersenHash</span><span class="p">(</span><span class="nx">replica</span><span class="p">)</span>
	<span class="nx">commC</span><span class="p">,</span> <span class="nx">commCTreePath</span> <span class="o">:=</span> <span class="nf">computeCommC</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>
	<span class="nx">commR</span> <span class="o">:=</span> <span class="nf">RepCompress_PedersenHash</span><span class="p">(</span><span class="nx">commC</span><span class="p">,</span> <span class="nx">commRLast</span><span class="p">)</span>

	<span class="nx">result</span> <span class="o">:=</span> <span class="nx">SealSetupArtifacts_I</span><span class="p">{</span>
		<span class="nx">CommD_</span><span class="p">:</span>             <span class="nx">sector</span><span class="p">.</span><span class="nf">Commitment</span><span class="p">(</span><span class="nx">commC</span><span class="p">),</span>
		<span class="nx">CommR_</span><span class="p">:</span>             <span class="nf">SealedSectorCID</span><span class="p">(</span><span class="nx">commR</span><span class="p">),</span>
		<span class="nx">CommC_</span><span class="p">:</span>             <span class="nx">sector</span><span class="p">.</span><span class="nf">Commitment</span><span class="p">(</span><span class="nx">commC</span><span class="p">),</span>
		<span class="nx">CommRLast_</span><span class="p">:</span>         <span class="nx">sector</span><span class="p">.</span><span class="nf">Commitment</span><span class="p">(</span><span class="nx">commRLast</span><span class="p">),</span>
		<span class="nx">CommDTreePath_</span><span class="p">:</span>     <span class="nx">commDTreePath</span><span class="p">,</span>
		<span class="nx">CommCTreePath_</span><span class="p">:</span>     <span class="nx">commCTreePath</span><span class="p">,</span>
		<span class="nx">CommRLastTreePath_</span><span class="p">:</span> <span class="nx">commRLastTreePath</span><span class="p">,</span>
		<span class="nx">KeyLayers_</span><span class="p">:</span>         <span class="nx">keyLayers</span><span class="p">,</span>
		<span class="nx">Replica_</span><span class="p">:</span>           <span class="nx">replica</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">result</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeReplicaID</span><span class="p">(</span><span class="nx">sid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">commD</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">)</span> <span class="nx">Bytes32</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">sid</span><span class="p">.</span><span class="nf">MinerID</span><span class="p">(),</span> <span class="p">(</span><span class="nx">sid</span><span class="p">.</span><span class="nf">Number</span><span class="p">())</span>

	<span class="c1">// FIXME: Implement
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">Bytes32</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateSDRKeyLayers</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">replicaID</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">layers</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">modulus</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">keyLayers</span> <span class="p">[][]</span><span class="kt">byte</span>
	<span class="kd">var</span> <span class="nx">prevLayer</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">layers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">currentLayer</span> <span class="o">:=</span> <span class="nf">labelLayer</span><span class="p">(</span><span class="nx">drg</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">replicaID</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">prevLayer</span><span class="p">)</span>
		<span class="nx">keyLayers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">,</span> <span class="nx">currentLayer</span><span class="p">)</span>
		<span class="nx">prevLayer</span> <span class="p">=</span> <span class="nx">currentLayer</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">keyLayers</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">labelLayer</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">replicaID</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">prevLayer</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">nodes</span> <span class="o">*</span> <span class="nx">nodeSize</span>
	<span class="nx">labels</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nodes</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="kt">byte</span>

		<span class="c1">// The first node of every layer has no DRG Parents.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">start</span> <span class="o">:=</span> <span class="nx">parent</span> <span class="o">*</span> <span class="nx">nodeSize</span>
				<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">start</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// The first layer has no expander parents.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">prevLayer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">start</span> <span class="o">:=</span> <span class="nx">parent</span> <span class="o">*</span> <span class="nx">nodeSize</span>
				<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">start</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">label</span> <span class="o">:=</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">replicaID</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">parents</span><span class="p">)</span>
		<span class="nx">labels</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">labels</span><span class="p">,</span> <span class="nx">label</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">labels</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">encodeData</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Key and data must be same length.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">encoded</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">encoded</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nf">encodeNode</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">modulus</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">encoded</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">replicaID</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">node</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">dependencies</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">nodeBytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">PutUint64</span><span class="p">(</span><span class="nx">nodeBytes</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span>

	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">replicaID</span><span class="p">,</span> <span class="nx">nodeBytes</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">dependencies</span><span class="o">...</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">deriveLabel</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deriveLabel</span><span class="p">(</span><span class="nx">elements</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">WideRepCompress_Blake2sHash</span><span class="p">(</span><span class="nx">elements</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computeCommC</span><span class="p">(</span><span class="nx">keyLayers</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">leaves</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

	<span class="c1">// For each node in the graph,
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">start</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leaves</span><span class="p">);</span> <span class="nx">start</span> <span class="o">+=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">nodeSize</span>

		<span class="kd">var</span> <span class="nx">column</span> <span class="p">[]</span><span class="kt">byte</span>
		<span class="c1">// Concatenate that node&#39;s label at each layer, in order, into a column.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">label</span> <span class="o">:=</span> <span class="nx">keyLayers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">]</span>
			<span class="nx">column</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">column</span><span class="p">,</span> <span class="nx">label</span><span class="o">...</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// And hash that column to create the leaf of a new tree.
</span><span class="c1"></span>		<span class="nx">hashed</span> <span class="o">:=</span> <span class="nf">hashColumn</span><span class="p">(</span><span class="nx">column</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">leaves</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">],</span> <span class="nx">hashed</span><span class="p">[:])</span>
	<span class="p">}</span>

	<span class="c1">// Return the root of and path to the column tree.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">RepHash_PedersenHash</span><span class="p">(</span><span class="nx">leaves</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">hashColumn</span><span class="p">(</span><span class="nx">column</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">WideRepCompress_PedersenHash</span><span class="p">(</span><span class="nx">column</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">StackedDRG_I</span><span class="p">)</span> <span class="nf">CreateSealProof</span><span class="p">(</span><span class="nx">randomSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span> <span class="p">{</span>
	<span class="nx">replicaID</span> <span class="o">:=</span> <span class="nf">ComputeReplicaID</span><span class="p">(</span><span class="nx">aux</span><span class="p">.</span><span class="nf">SectorID</span><span class="p">(),</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">CommD</span><span class="p">(),</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">Seed</span><span class="p">())</span>

	<span class="nx">drg</span> <span class="o">:=</span> <span class="nx">DRG_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">DRGCfg</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="nx">expander</span> <span class="o">:=</span> <span class="nx">ExpanderGraph_I</span><span class="p">{</span>
		<span class="nx">Config_</span><span class="p">:</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">ExpanderGraphCfg</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">NodeSize</span><span class="p">())</span>
	<span class="nx">challenges</span> <span class="o">:=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">GenerateOfflineChallenges</span><span class="p">(</span><span class="nx">randomSeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">sdr</span><span class="p">.</span><span class="nf">Challenges</span><span class="p">()))</span>

	<span class="kd">var</span> <span class="nx">challengeProofs</span> <span class="p">[]</span><span class="nx">OfflineSDRChallengeProof</span>

	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">challenges</span> <span class="p">{</span>
		<span class="nx">challengeProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">challengeProofs</span><span class="p">,</span> <span class="nf">CreateChallengeProof</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">drg</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">expander</span><span class="p">,</span> <span class="nx">replicaID</span><span class="p">,</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">aux</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">CreateOfflineCircuitProof</span><span class="p">(</span><span class="nx">challengeProofs</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CreateChallengeProof</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">replicaID</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="p">(</span><span class="nx">proof</span> <span class="nx">OfflineSDRChallengeProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">columnElements</span> <span class="p">[]</span><span class="nx">UInt</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">columnProofs</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnElements</span> <span class="p">{</span>
		<span class="nx">columnProof</span> <span class="o">:=</span> <span class="nf">CreateColumnProof</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>
		<span class="nx">columnProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnProofs</span><span class="p">,</span> <span class="nx">columnProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">dataProof</span> <span class="o">:=</span> <span class="nf">createInclusionProof</span><span class="p">(</span><span class="nx">aux</span><span class="p">.</span><span class="nf">Data</span><span class="p">()[</span><span class="nx">challenge</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">:(</span><span class="nx">challenge</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">Data</span><span class="p">())</span>
	<span class="nx">replicaProof</span> <span class="o">:=</span> <span class="nf">createInclusionProof</span><span class="p">(</span><span class="nx">aux</span><span class="p">.</span><span class="nf">Replica</span><span class="p">()[</span><span class="nx">challenge</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">:(</span><span class="nx">challenge</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">Data</span><span class="p">())</span>

	<span class="nx">proof</span> <span class="p">=</span> <span class="nx">OfflineSDRChallengeProof</span><span class="p">{</span>
		<span class="nx">DataProof</span><span class="p">:</span>    <span class="nx">dataProof</span><span class="p">,</span>
		<span class="nx">ColumnProofs</span><span class="p">:</span> <span class="nx">columnProofs</span><span class="p">,</span>
		<span class="nx">ReplicaProof</span><span class="p">:</span> <span class="nx">replicaProof</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">proof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CreateColumnProof</span><span class="p">(</span><span class="nx">c</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="p">(</span><span class="nx">columnProof</span> <span class="nx">SDRColumnProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">commC</span> <span class="o">:=</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">PersistentAux</span><span class="p">().</span><span class="nf">CommC</span><span class="p">()</span>
	<span class="nx">layers</span> <span class="o">:=</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">KeyLayers</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">column</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">layers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">column</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">column</span><span class="p">,</span> <span class="nx">layers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">c</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">:(</span><span class="nx">c</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">leaf</span> <span class="o">:=</span> <span class="nf">hashColumn</span><span class="p">(</span><span class="nx">column</span><span class="p">)</span>
	<span class="nx">columnProof</span> <span class="p">=</span> <span class="nx">SDRColumnProof</span><span class="p">{</span>
		<span class="nx">ColumnElements</span><span class="p">:</span> <span class="nx">column</span><span class="p">,</span>
		<span class="nx">InclusionProof</span><span class="p">:</span> <span class="nf">createInclusionProof</span><span class="p">(</span><span class="nx">leaf</span><span class="p">,</span> <span class="nx">commC</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">columnProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createInclusionProof</span><span class="p">(</span><span class="nx">leaf</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">root</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">InclusionProof</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OfflineSDRChallengeProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">CommRLast</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
	<span class="nx">CommC</span>     <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>

	<span class="c1">// TODO: these proofs need to depend on hash function.
</span><span class="c1"></span>	<span class="nx">DataProof</span>    <span class="nx">InclusionProof</span> <span class="c1">// Blake2s
</span><span class="c1"></span>	<span class="nx">ColumnProofs</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="nx">ReplicaProof</span> <span class="nx">InclusionProof</span> <span class="c1">// Pedersen
</span><span class="c1"></span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InclusionProof</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">SDRColumnProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ColumnElements</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">InclusionProof</span> <span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">StackedDRG_I</span><span class="p">)</span> <span class="nf">CreateOfflineCircuitProof</span><span class="p">(</span><span class="nx">challengeProofs</span> <span class="p">[]</span><span class="nx">OfflineSDRChallengeProof</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">StackedDRG_I</span><span class="p">)</span> <span class="nf">GenerateOfflineChallenges</span><span class="p">(</span><span class="nx">randomSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">,</span> <span class="nx">challenges</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">encodeNode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="c1">// TODO: Make this a method of StackedDRG.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">addEncode</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">modulus</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addEncode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>

	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">k</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

	<span class="nx">sum</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">modulus</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">littleEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Verification
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">StackedDRG_I</span><span class="p">)</span> <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">onChain</span> <span class="o">:=</span> <span class="nx">sv</span><span class="p">.</span><span class="nf">OnChain</span><span class="p">()</span>

	<span class="nx">sealProof</span> <span class="o">:=</span> <span class="nx">onChain</span><span class="p">.</span><span class="nf">Proof</span><span class="p">()</span>

	<span class="kd">var</span> <span class="nx">commD</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
	<span class="nx">commR</span> <span class="o">:=</span> <span class="nf">Commitment_SealedSectorCID</span><span class="p">(</span><span class="nx">sector</span><span class="p">.</span><span class="nf">SealedSectorCID</span><span class="p">(</span><span class="nx">onChain</span><span class="p">.</span><span class="nf">SealedCID</span><span class="p">()))</span>

	<span class="nx">sdr</span><span class="p">.</span><span class="nf">VerifyOfflineCircuitProof</span><span class="p">(</span><span class="nx">commD</span><span class="p">,</span> <span class="nx">commR</span><span class="p">,</span> <span class="nx">sealProof</span><span class="p">)</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sdr</span> <span class="o">*</span><span class="nx">StackedDRG_I</span><span class="p">)</span> <span class="nf">VerifyOfflineCircuitProof</span><span class="p">(</span><span class="nx">commD</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span><span class="p">,</span> <span class="nx">commR</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span><span class="p">,</span> <span class="nx">sv</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealProof</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">/// Generic Hashing and Merkle Tree generation
</span><span class="c1"></span>
<span class="c1">/// Binary hash compression.
</span><span class="c1">// RepCompress&lt;T&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepCompress_T</span><span class="p">(</span><span class="nx">left</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// RepCompress&lt;PedersenHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepCompress_PedersenHash</span><span class="p">(</span><span class="nx">left</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PedersenHash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// RepCompress&lt;Blake2sHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepCompress_Blake2sHash</span><span class="p">(</span><span class="nx">left</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">right</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Blake2sHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Blake2sHash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="c1">/// Digest
</span><span class="c1">// WideRepCompress&lt;T&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WideRepCompress_T</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// RepCompress&lt;PedersenHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WideRepCompress_PedersenHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PedersenHash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// RepCompress&lt;Blake2sHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">WideRepCompress_Blake2sHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Blake2sHash</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Blake2sHash</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">DigestSize_T</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unspecialized&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DigestSize_PedersenHash</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">32</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DigestSize_Blake2sHash</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="mi">32</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">/// Binary Merkle-tree generation
</span><span class="c1"></span>
<span class="c1">// RepHash&lt;T&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepHash_T</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Plan: define this in terms of RepCompress_T, then copy-paste changes into T-specific specializations, for now.
</span><span class="c1"></span>
	<span class="c1">// Nodes are always the digest size so data cannot be compressed to digest for storage.
</span><span class="c1"></span>	<span class="nx">nodeSize</span> <span class="o">:=</span> <span class="nf">DigestSize_T</span><span class="p">()</span>

	<span class="c1">// TODO: Fail if len(dat) is not a power of 2 and a multiple of the node size.
</span><span class="c1"></span>
	<span class="nx">rows</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">{</span><span class="nx">data</span><span class="p">}</span>

	<span class="k">for</span> <span class="nx">row</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{};</span> <span class="nb">len</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">nodeSize</span><span class="p">;</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">nodeSize</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">]</span>
			<span class="nx">right</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span> <span class="p">:</span> <span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">]</span>
			<span class="nx">hashed</span> <span class="o">:=</span> <span class="nf">RepCompress_T</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>

			<span class="nx">row</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nf">asBytes</span><span class="p">(</span><span class="nx">hashed</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">rows</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rows</span><span class="p">,</span> <span class="nx">row</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Last row is the root
</span><span class="c1"></span>	<span class="nx">root</span> <span class="o">:=</span> <span class="nx">rows</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">rows</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;math failed us&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">filePath</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span> <span class="c1">// TODO: dump tree to file.
</span><span class="c1"></span>	<span class="c1">// NOTE: merkle tree file layout is illustrative, not prescriptive.
</span><span class="c1"></span>
	<span class="c1">// TODO: Check above more carefully. It&#39;s just an untested sketch for the moment.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">fromBytes_T</span><span class="p">(</span><span class="nx">root</span><span class="p">),</span> <span class="nx">filePath</span>
<span class="p">}</span>

<span class="c1">// RepHash&lt;PedersenHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepHash_PedersenHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PedersenHash</span><span class="p">{},</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span> <span class="c1">// FIXME
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">//  RepHash&lt;Blake2sHash&gt;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepHash_Blake2sHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">Blake2sHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span> <span class="nx">file</span><span class="p">.</span><span class="nf">Path</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span> <span class="c1">// FIXME
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nx">h</span> <span class="nx">Blake2sHash</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SealedSectorCID</span><span class="p">(</span><span class="nx">h</span> <span class="nx">PedersenHash</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Commitment_UnsealedSectorCID</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Commitment_SealedSectorCID</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;not implemented -- re-arrange bits&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeDataCommitment</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: make hash parameterizable
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">RepHash_Blake2sHash</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Compute CommP or CommD.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">ComputeUnsealedSectorCID</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// TODO: check that len(data) &gt; minimum piece size and is a power of 2.
</span><span class="c1"></span>	<span class="nx">hash</span><span class="p">,</span> <span class="nx">treePath</span> <span class="o">:=</span> <span class="nf">RepHash_Blake2sHash</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nx">hash</span><span class="p">),</span> <span class="nx">treePath</span>
<span class="p">}</span>

<span class="c1">// Utilities
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">reverse</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">j</span><span class="p">;</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="p">=</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">j</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
		<span class="nx">bytes</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">bytes</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">bytes</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">bytes</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="nf">reverse</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">SetBytes</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// size is number of bytes to return
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">littleEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">z</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">bytes</span> <span class="o">:=</span> <span class="nx">z</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">:</span><span class="nx">size</span><span class="p">]</span>
	<span class="nf">reverse</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">bytes</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">asBytes</span><span class="p">(</span><span class="nx">t</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unimplemented for T&#34;</span><span class="p">)</span>

	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">fromBytes_T</span><span class="p">(</span><span class="nx">_</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unimplemented for T&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">util</span><span class="p">.</span><span class="nx">T</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="libraries__fcs">

<h2 class="section-header">
  FCS
</h2>

<div class="section-content">




















































<p style="color: #D74848"><b><i>Something's not right. The <code>fcs.id</code> file was not found.</i></b></p>




</div>



</div>

  

  
    








<div id="libraries__ipld">

<h2 class="section-header">
  IPLD - InterPlanetary Linked Data
</h2>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Store</span> <span class="nx">GraphStore</span>

<span class="c1">// imported as ipld.Object
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Object</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">CID</span><span class="p">()</span> <span class="nx">CID</span>

    <span class="c1">// Populate(v interface{}) error
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="libraries__ipld__cid">

<h3 class="section-header">
  CIDs - Content IDentifiers
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BytesKey</span> <span class="kt">string</span>  <span class="c1">// so that we can use it in go maps
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">CID</span> <span class="nx">BytesKey</span>  <span class="c1">// TODO: remove util.
</span></code></pre></div>







</div>



</div>

  

  
    








<div id="libraries__ipld__datamodel">

<h3 class="section-header">
  Data Model
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipld__selectors">

<h3 class="section-header">
  Selectors
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipld__graphstore">

<h3 class="section-header">
  GraphStore - IPLD Data Storage
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// imported as ipld.Store
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GraphStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">cid</span> <span class="nx">CID</span><span class="p">)</span>   <span class="nx">union</span> <span class="p">{</span><span class="nx">o</span> <span class="nx">Object</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">o</span> <span class="nx">Object</span><span class="p">)</span>  <span class="nx">union</span> <span class="p">{</span><span class="nx">cid</span> <span class="nx">CID</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="libraries__libp2p">

<h2 class="section-header">
  libp2p
</h2>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">mf</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/multiformats&#34;</span>

<span class="c1">// PeerID is the CID of the public key of this peer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PeerID</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">CID</span>

<span class="c1">// PeerInfo is a simple datastructure that relates PeerIDs to corresponding partial Multiaddrs.
</span><span class="c1">// This is a convenience struct used in interfaces where we must specify both, or may specify
</span><span class="c1">// either.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PeerInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PeerID</span>
    <span class="nx">Addrs</span> <span class="p">[</span><span class="nx">mf</span><span class="p">.</span><span class="nx">Multiaddr</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// PeerID returns the PeerID associated with this libp2p Node
</span><span class="c1"></span>    <span class="nf">PeerID</span><span class="p">()</span> <span class="nx">PeerID</span>

    <span class="c1">// MountProtocol adds given Protocol under specified protocol id.
</span><span class="c1"></span>    <span class="nf">MountProtocol</span><span class="p">(</span><span class="nx">path</span> <span class="nx">ProtocolPath</span><span class="p">,</span> <span class="nx">protocol</span> <span class="nx">Protocol</span><span class="p">)</span>

    <span class="c1">// ConnectPeerID establishes a connection to peer matching given PeerInfo.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// PeerInfo.Addrs may be empty. If so:
</span><span class="c1"></span>    <span class="c1">// - Libp2pNode will try to use any Multiaddrs it knows (internal PeerStore)
</span><span class="c1"></span>    <span class="c1">// - Libp2pNode may use any `PeerRouting` protocol mounted onto the libp2p node.
</span><span class="c1"></span>    <span class="c1">//     TODO: how to define this.
</span><span class="c1"></span>    <span class="c1">//     NOTE: probably implies using kad-dht or gossipsub for this.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Idempotent. If a connection already exists, this method returns silently.
</span><span class="c1"></span>    <span class="nf">Connect</span><span class="p">(</span><span class="nx">peerInfo</span> <span class="nx">PeerInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProtocolPath</span> <span class="kt">string</span>

<span class="kd">type</span> <span class="nx">Protocol</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">StreamProtocol</span>
    <span class="nx">DatagramProtocol</span>
<span class="p">}</span>

<span class="c1">// Stream is an interface to deal with networked processes, which communicate
</span><span class="c1">// via streams of bytes.
</span><span class="c1">//
</span><span class="c1">// See golang.org/pkg/io -- as this is modelled after io.Reader and io.Writer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Stream</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Read reads bytes from the underlying stream and copies them to buf.
</span><span class="c1"></span>    <span class="c1">// Read returns the number of bytes read (n), and potentially an error
</span><span class="c1"></span>    <span class="c1">// encountered while reading. Read reads at most len(buf) byte.
</span><span class="c1"></span>    <span class="c1">// Read may read 0 bytes.
</span><span class="c1"></span>    <span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Write writes bytes to the underlying stream, copying them from buf.
</span><span class="c1"></span>    <span class="c1">// Write returns the number of bytes written (n), and potentially an error
</span><span class="c1"></span>    <span class="c1">// encountered while writing. Write writes at most len(buf) byte.
</span><span class="c1"></span>    <span class="c1">// Write may read 0 bytes.
</span><span class="c1"></span>    <span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Close terminates client&#39;s use of the stream.
</span><span class="c1"></span>    <span class="c1">// Calling Read or Write after Close is an error.
</span><span class="c1"></span>    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StreamProtocol</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// AcceptStream accepts an incoming stream connection.
</span><span class="c1"></span>    <span class="nf">AcceptStream</span><span class="p">()</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">stream</span>    <span class="nx">Stream</span>
        <span class="nx">peerInfo</span>  <span class="nx">PeerInfo</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="c1">// OpenStream opens a stream to a particular PeerID.
</span><span class="c1"></span>    <span class="nf">OpenStream</span><span class="p">(</span><span class="nx">peerInfo</span> <span class="nx">PeerInfo</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">stream</span>  <span class="nx">Stream</span>
        <span class="nx">err</span>     <span class="kt">error</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Datagram
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Datagram</span> <span class="nx">Bytes</span>

<span class="c1">// Datagrams are &#34;messages&#34; in the network packet sense of the word.
</span><span class="c1">//
</span><span class="c1">// &#34;message-oriented network protocols&#34; should use this interface,
</span><span class="c1">// not the StreamProtocol interface.
</span><span class="c1">//
</span><span class="c1">// We call it &#34;Datagram&#34; here because unfortunately the word &#34;Message&#34;
</span><span class="c1">// is very overloaded in Filecoin.
</span><span class="c1">// Suggestion for libp2p: use datagram too.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DatagramProtocol</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// AcceptDatagram accepts an incoming message.
</span><span class="c1"></span>    <span class="nf">AcceptDatagram</span><span class="p">()</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">datagram</span>  <span class="nx">Datagram</span>
        <span class="nx">peerInfo</span>  <span class="nx">PeerInfo</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="c1">// OpenStream opens a stream to a particular PeerID
</span><span class="c1"></span>    <span class="nf">SendDatagram</span><span class="p">(</span><span class="nx">datagram</span> <span class="nx">Datagram</span><span class="p">,</span> <span class="nx">peerInfo</span> <span class="nx">PeerInfo</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// type StorageDealLibp2pProtocol struct {
</span><span class="c1">//   StreamProtocol StreamProtocol
</span><span class="c1">//   // ---
</span><span class="c1">//   AcceptStream() struct {}
</span><span class="c1">//   OpenStream() struct {}
</span><span class="c1">// }
</span></code></pre></div>







</div>


  
    








<div id="libraries__libp2p__gossipsub">

<h3 class="section-header">
  Gossipsub for broadcasts
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__libp2p__kad_dht">

<h3 class="section-header">
  Kademlia DHT for Peer Routing
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__libp2p__fil_libp2p_nodes">

<h3 class="section-header">
  Filecoin libp2p Nodes
</h3>

<div class="section-content">






































</div>



</div>

  


</div>

  

  
    








<div id="libraries__ipfs">

<h2 class="section-header">
  IPFS - InterPlanetary File System
</h2>

<div class="section-content">






































</div>


  
    








<div id="libraries__ipfs__bitswap">

<h3 class="section-header">
  BitSwap
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipfs__graphsync">

<h3 class="section-header">
  GraphSync
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipfs__unixfs">

<h3 class="section-header">
  UnixFS
</h3>

<div class="section-content">






































</div>



</div>

  


</div>

  

  
    








<div id="libraries__multiformats">

<h2 class="section-header">
  Multiformats - self describing protocol values
</h2>

<div class="section-content">






































<h3 id="multihash-self-describing-hash-values">Multihash - self describing hash values</h3>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Multihash</span> <span class="nx">Bytes</span>
</code></pre></div>






<h3 id="multiaddr-self-describing-network-addresses">Multiaddr - self describing network addresses</h3>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Multiaddr</span> <span class="nx">Bytes</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="algorithms">

<h1 class="section-header">
  Algorithms
</h1>

<div class="section-content">






































</div>


  
    








<div id="algorithms__expected_consensus">

<h2 class="section-header">
  Expected Consensus
</h2>

<div class="section-content">






































<div id="algorithms__expected_consensus__expected_consensus"></div>

<h4 id="algorithm">Algorithm</h4>

<p>Expected Consensus (EC) is a probabilistic Byzantine fault-tolerant consensus protocol. At a high level, it operates by running a leader election every round in which, on expectation, one participant may be eligible to submit a block. EC guarantees that this winner will be anonymous until they reveal themselves by submitting a proof of their election (we call this proof an <code>Election Proof</code>). All valid blocks submitted in a given round form a <code>Tipset</code>. Every block in a Tipset adds weight to its chain. The &lsquo;best&rsquo; chain is the one with the highest weight, which is to say that the fork choice rule is to choose the heaviest known chain. For more details on how to select the heaviest chain, see <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a>.</p>

<p>At a very high level, with every new block generated, a miner will craft a new ticket from the prior one in the chain. While on expectation at least one block will be generated at every round, in cases where no one finds a block in a given round, a miner may increment a given nonce as part of the input with which they attempt to run leader election in order to ensure liveness in the protocol. These nonces help mark block height. Every block in a given Tipset will contain election proofs with the same nonce (i.e. they are mined at the same height).</p>

<p>The <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem uses access to EC to use the following facilities:
- Access to verifiable randomness for the protocol, derived from <a href="./#algorithms__expected_consenus__tickets">Tickets</a>.
- Running and verifying <a href="./#algorithms__expected_consensus__leader_election">leader election</a> for block generation.
- Access to a weighting function enabling <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> by the chain manager.
- Access to the most recently <a href="./#algorithms__expected_consensus__finality">finalized tipset</a> available to all protocol participants.</p>

<div id="algorithms__expected_consensus__tickets"></div>

<h4 id="tickets">Tickets</h4>

<p>For leader election in EC, participants win in proportion to the power they have within the network.</p>

<p>A ticket is drawn from the past at the beginning of each new round to perform leader election. EC also generates a new ticket in every round for future use. Tickets are chained independently of the main blockchain. A ticket only depends on the ticket before it, and not any other data in the block.
On expectation, in Filecoin, every block header contains one ticket, though it could contain more if that block was generated over multiple rounds.</p>

<p>Tickets are used across the protocol as sources of randomness:
- The <a href="./#systems__filecoin_mining__storage_proving__sector_sealer">Sector Sealer</a> uses tickets to bind sector commitments to a given subchain.
- The <a href="./#systems__filecoin_mining__storage_proving__post_generator">PoSt Generator</a> likewise uses tickets to prove sectors remain committed as of a given block.
- EC uses them to run leader election and generates new ones for use by the protocol, as detailed below.</p>

<p>You can find the Ticket data structure <a href="./#listings__data_structures">here</a>.</p>

<h5 id="comparing-tickets-in-a-tipset">Comparing Tickets in a Tipset</h5>

<p>Whenever comparing tickets is evoked in Filecoin, for instance when discussing selecting the &ldquo;min ticket&rdquo; in a Tipset, the comparison is that of the little endian representation of the ticket&rsquo;s VFOutput bytes.</p>

<h4 id="tickets-in-ec">Tickets in EC</h4>

<p>Within EC, a miner generates a new ticket in their block for every ticket they use running leader election, thereby ensuring the ticket chain is always as long as the block chain.</p>

<p>Tickets are used to achieve the following:
- Ensure leader secrecy &ndash; meaning a block producer will not be known until they release their block to the network.
- Prove leader election &ndash; meaning a block producer can be verified by any participant in the network.</p>

<p>In practice, EC defines two different fields within a block:</p>

<ul>
<li>A <code>Ticket</code> field ‚Äî this stores the new ticket generated during this block generation attempt. It is from this ticket that miners will sample randomness to run leader election in <code>K</code> rounds.</li>

<li><p>An <code>ElectionProof</code> ‚Äî this stores a proof that a given miner has won a leader election using the appropriate ticket <code>K</code> rounds back along with a nonce showing how many rounds generating the EP took. It proves that the leader was elected in this round.</p>

<pre><code>But why the randomness lookback?

The randomness lookback helps turn independent ticket generation from a block one round back
into a global ticket generation game instead. Rather than having a distinct chance of winning or losing
for each potential fork in a given round, a miner will either win on all or lose on all
forks descended from the block in which the ticket is sampled.

This is useful as it reduces opportunities for grinding, across forks or sybil identities.

However this introduces a tradeoff:
- The randomness lookback means that a miner can know K rounds in advance that they will win,
decreasing the cost of running a targeted attack (given they have local predictability).
- It means electionProofs are stored separately from new tickets on a block, taking up
more space on-chain.

How is K selected?
- On the one end, there is no advantage to picking K larger than finality.
- On the other, making K smaller reduces adversarial power to grind.
</code></pre></li>
</ul>

<h5 id="ticket-generation">Ticket generation</h5>

<p>This section discusses how tickets are generated by EC for the <code>Ticket</code> field.</p>

<p>At round <code>N</code>, a new ticket is generated using tickets drawn from the Tipset at round <code>N-1</code> (for more on how tickets are drawn see <a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_chain">Ticket Chain</a>).</p>

<p>The miner runs the prior ticket through a Verifiable Random Function (VRF) to get a new unique output.</p>

<p>The VRF&rsquo;s deterministic output adds entropy to the ticket chain, limiting a miner&rsquo;s ability to alter one block to influence a future ticket (given a miner does not know who will win a given round in advance).</p>

<p>We use the ECVRF algorithm from <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">Goldberg et al. Section 5</a>, with:
  - Sha256 for our hashing function
  - Secp256k1 for our curve
  - Note that the operation type in step 2.1 is necessary to prevent an adversary from guessing an election proof for a miner ahead of time.</p>

<h5 id="ticket-validation">Ticket Validation</h5>

<p>Each Ticket should be generated from the prior one in the ticket-chain.</p>

<div id="algorithms__expected_consensus__leader_election"></div>

<h4 id="secret-leader-election">Secret Leader Election</h4>

<p>Expected Consensus is a consensus protocol that works by electing a miner from a weighted set in proportion to their power. In the case of Filecoin, participants and powers are drawn from the storage <a href="storage-market.md#the-power-table">power table</a>, where power is equivalent to storage provided through time.</p>

<p>Leader Election in Expected Consensus must be Secret, Fair and Verifiable. This is achieved through the use of randomness used to run the election. In the case of Filecoin&rsquo;s EC, the blockchain tracks an independent ticket chain. These tickets are used as randomness inputs for Leader Election. Every block generated references an <code>ElectionProof</code> derived from a past ticket. The ticket chain is extended by the miner who generates a new block for each successful leader election.</p>

<h5 id="running-a-leader-election">Running a leader election</h5>

<p>Now, a miner must also check whether they are eligible to mine a block in this round.</p>

<p>To do so, the miner will use tickets from K rounds back as randomness to uniformly draw a value from 0 to 1. Comparing this value to their power, they determine whether they are eligible to mine. A user&rsquo;s <code>power</code> is defined as the ratio of the amount of storage they proved as of their last PoSt submission to the total storage in the network as of the current block.</p>

<p>We use the ECVRF algorithm (must yield a pseudorandom, deterministic output) from <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">Goldberg et al. Section 5</a>, with:
  - Sha256 for our hashing function
  - Secp256k1 for our curve</p>

<p>If the miner wins the election in this round, it can use newEP, along with a newTicket to generate and publish a new block. Otherwise, it waits to hear of another block generated in this round.</p>

<p>It is important to note that every block contains two artifacts: one, a ticket derived from last block&rsquo;s ticket to extend the ticket-chain, and two, an election proof derived from the ticket <code>K</code> rounds back used to run leader election.</p>

<p>Succinctly, the process of crafting a new ElectionProof in round N is as follows. We use:</p>

<pre><code>The ECVRF algorithm (must yield a pseudorandom, deterministic output) from Goldberg et al. Section 5, with:
    Sha256 for our hashing function
    Secp256k1 for our curve
</code></pre>

<p>Note: We draw the miner power from the prior round. This means that if a miner wins a block on their ProvingPeriodEnd even if they have not yet resubmitted a PoSt, they retain their power (until the next round).</p>

<p>If successful, the miner can craft a block, passing it to the block producer. If unsuccessful, it will wait to hear of another block mined this round to try again. In the case no other block was found in this round the miner can increment its nonce and try leader election again using the same past ticket and new nonce.
While a miner could try to run through multiple nonces in parallel in order to quickly generate a block, this effort will be futile as the rational majority of miners will reject blocks crafted with ElectionProofs whose nonces prove too high (see below).</p>

<h5 id="election-validation">Election Validation</h5>

<p>In order to determine that the mined block was generated by an eligible miner, one must check its <code>ElectionProof</code>.</p>

<div id="algorithms__expected_consensus__chain_selection"></div>

<h4 id="chain-selection">Chain Selection</h4>

<p>Just as there can be 0 miners win in a round, multiple miners can be elected in a given round. This in turn means multiple blocks can be created in a round. In order to avoid wasting valid work done by miners, EC makes use of all valid blocks generated in a round.</p>

<h5 id="chain-weighting">Chain Weighting</h5>

<p>It is possible for forks to emerge naturally in Expected Consensus. EC relies on weighted chains in order to quickly converge on &lsquo;one true chain&rsquo;, with every block adding to the chain&rsquo;s weight. This means the heaviest chain should reflect the most amount of work performed, or in Filecoin&rsquo;s case, the most storage provided.</p>

<p>In short, the weight at each block is equal to its <code>ParentWeight</code> plus that block&rsquo;s delta weight. Details of Filecoin&rsquo;s chain weighting function <a href="https://observablehq.com/d/3812cd65c054082d">are included here</a>.</p>

<p>Delta weight is a term composed of a few elements:
- wForkFactor: which seeks to cut the weight derived from rounds in which produced Tipsets do not correspond to what an honest chain is likely to have yielded (pointing to selfish mining or other non-collaborative miner behavior).
- wPowerFactor: which adds weight to the chain proportional to the total power backing the chain, i.e. accounted for in the chain&rsquo;s power table.
- wBlocksFactor: which adds weight to the chain proportional to the number of blocks mined in a given round. Like wForkFactor, it rewards miner cooperation (which will yield more blocks per round on expectation).</p>

<p>The weight should be calculated using big integer arithmetic with order of operations defined above. We use brackets instead of parentheses below for legibility. We have:</p>

<p><code>w[r+1] = w[r] + (wPowerFactor[r+1] + wBlocksFactor[r+1]) * 2^8</code></p>

<p>For a given tipset <code>ts</code> in round <code>r+1</code>, we define:</p>

<ul>
<li><code>wPowerFactor[r+1]  = wFunction(totalPowerAtTipset(ts))</code></li>
<li>wBlocksFactor[r+1] =  <code>wPowerFactor[r+1] * wRatio * b / e</code>

<ul>
<li>with <code>b = |blocksInTipset(ts)|</code></li>
<li><code>e = expected number of blocks per round in the protocol</code></li>
<li>and <code>wRatio in ]0, 1[</code>
Thus, for stability of weight across implementations, we take:</li>
</ul></li>
<li>wBlocksFactor[r+1] =  <code>(wPowerFactor[r+1] * b * wRatio_num) / (e * wRatio_den)</code></li>
</ul>

<p>We get:
- <code>w[r+1] = w[r] + wFunction(totalPowerAtTipset(ts)) * 2^8 + (wFunction(totalPowerAtTipset(ts)) * len(ts.blocks) * wRatio_num * 2^8) / (e * wRatio_den)</code>
 Using the 2^8 here to prevent precision loss ahead of the division in the wBlocksFactor.</p>

<p>The exact value for these parameters remain to be determined, but for testing purposes, you may use:
 - <code>e = 5</code>
 - <code>wRatio = .5, or wRatio_num = 1, wRatio_den = 2</code>
- <code>wFunction = log2b</code> with
  - <code>log2b(X) = floor(log2(x)) = (binary length of X) - 1</code> and <code>log2b(0) = 0</code>. Note that that special case should never be used (given it would mean an empty power table.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Note that <span class="k">if</span> your implementation does not allow <span class="k">for</span> rounding to the fourth decimal, miners should apply the <span class="o">[</span>tie-breaker below<span class="o">](</span><span class="c1">#selecting-between-tipsets-with-equal-weight). Weight changes will be on the order of single digit numbers on expectation, so this should not have an outsized impact on chain consensus across implementations.</span></code></pre></div>
<p><code>ParentWeight</code> is the aggregate chain weight of a given block&rsquo;s parent set. It is calculated as
the <code>ParentWeight</code> of any of its parent blocks (all blocks in a given Tipset should have
the same <code>ParentWeight</code> value) plus the delta weight of each parent. To make the
computation a bit easier, a block&rsquo;s <code>ParentWeight</code> is stored in the block itself (otherwise
potentially long chain scans would be required to compute a given block&rsquo;s weight).</p>

<h5 id="selecting-between-tipsets-with-equal-weight">Selecting between Tipsets with equal weight</h5>

<p>When selecting between Tipsets of equal weight, a miner chooses the one with the smallest final ticket.</p>

<p>In the case where two Tipsets of equal weight have the same min ticket, the miner will compare the next smallest ticket (and select the Tipset with the next smaller ticket). This continues until one Tipset is selected.</p>

<p>The above case may happen in situations under certain block propagation conditions. Assume three blocks B, C, and D have been mined (by miners 1, 2, and 3 respectively) off of block A, with minTicket(B) &lt; minTicket&copy; &lt; minTicket (D).</p>

<p>Miner 1 outputs their block B and shuts down. Miners 2 and 3 both receive B but not each others&rsquo; blocks. We have miner 2 mining a Tipset made of B and C and miner 3 mining a Tipset made of B and D. If both succesfully mine blocks now, other miners in the network will receive new blocks built off of Tipsets with equal weight and the same smallest ticket (that of block B). They should select the block mined atop [B, C] since minTicket&copy; &lt; minTicket(D).</p>

<p>The probability that two Tipsets with different blocks would have all the same tickets can be considered negligible: this would amount to finding a collision between two 256-bit (or more) collision-resistant hashes.</p>

<div id="algorithms__expected_consensus__finality"></div>

<h4 id="finality-in-ec">Finality in EC</h4>

<p>EC enforces a version of soft finality whereby all miners at round N will reject all blocks that fork off prior to round N-F. For illustrative purposes, we can take F to be 500. While strictly speaking EC is a probabilistically final protocol, choosing such an F simplifies miner implementations and enforces a macroeconomically-enforced finality at no cost to liveness in the chain.</p>

<div id="algorithms__expected_consensus__consensus_faults"></div>

<h4 id="consensus-faults">Consensus Faults</h4>

<p>Due to the existence of potential forks in EC, a miner can try to unduly influence protocol fairness. This means they may choose to disregard the protocol in order to gain an advantage over the power they should normally get from their storage on the network. A miner should be slashed if they are provably deviating from the honest protocol.</p>

<p>This is detectable when a given miner submits two blocks that satisfy any of the following &ldquo;consensus faults&rdquo;:</p>

<ul>
<li>(1) <code>double-fork mining fault</code>: two blocks contains the same electionProof nonce, mined at the same height.</li>

<li><p>(2) <code>parent grinding fault</code>: one block&rsquo;s parent is a Tipset that could have validly included the other block according to Tipset validity rules, however the parent of the first block does not include the other block.</p>

<ul>
<li>While it cannot be proven that a miner omits known blocks from a Tipset in general (i.e. network latency could simply mean the miner did not receive a particular block) in this case it can be proven because a miner must be aware of a block they mined in a previous round.</li>
</ul></li>
</ul>

<p>Any node that detects either of the above events should submit both block headers to the <code>StoragePowerActor</code>&rsquo;s <code>ReportConsensusFault</code> method. The &ldquo;slasher&rdquo; will receive a portion (TODO: define how much) of the offending miner&rsquo;s <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></a> as a reward for notifying the network of the fault.
(TODO: FIP of submitting commitments to block headers to prevent miners censoring slashers in order to gain rewards).</p>

<p>It is important to note that there exists a third type of consensus fault directly reported by the <code>CronActor</code> on <code>StorageDeal</code> failures via the <code>ReportUncommittedPowerFault</code> method:
- (3) <code>uncommitted power fault</code> which occurs when a miner fails to submit their <code>PostProof</code> and is thus participating in leader election with undue power (see <a href="./#systems__filecoin_markets__storage_market__faults">Faults</a>).</p>


</div>



</div>

  

  
    








<div id="algorithms__porep">

<h2 class="section-header">
  Proof-of-Replication
</h2>

<div class="section-content">




































<p>See <a href="https://filecoin.io/filecoin.pdf">Filecoin Paper</a></p>


</div>


  
    








<div id="algorithms__porep__stacked_drg">

<h3 class="section-header">
  Stacked DRG PoRep
</h3>

<div class="section-content">






































<p>This section describes <em>Stacked DRG PoRep</em> (SDR), the specific Proof-of-Replication (PoRep) used in Filecoin. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.</p>

<p>SDR has been presented by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.</p>

<h4 id="introduction">Introduction</h4>

<h5 id="background-on-proof-of-replication">Background on Proof-of-Replication</h5>

<p><em>Proof-of-Replication</em> enables a prover <em>P</em> to convince a verifier <em>V</em> that <em>P</em> is storing a replica <em>R</em>, a physically independent copy of some data <em>D</em>, unique to <em>P</em>. The scheme is defined by a tuple of polynomial time algorithms (<em>Setup</em>, Replication, <em>Prove</em>, <em>Verify</em>). The assumption is that generation of a replica after <em>Replicate</em>  must be difficult (if not impossible) to generate.</p>

<ul>
<li><em>Setup</em>: On setup, the public parameters of the proving systems are set.</li>
<li><em>Replicate</em>: On replication, either a party or both (depending on the scheme, in our case the prover only!) generate a unique permutation of the original data <em>D</em>, which we call replica <em>R</em>.</li>
<li><em>Prove</em>: On receiving a challenge, the prover must generate a proof that it is in possession of the replica and that it was derived from data <em>D</em>. The prover must only be able to respond to the challenge successfully if it is in possession of the replica, since would be difficult (if not impossible) to generate a replica that can be used to generate the proof at this stage</li>
<li><em>Verify</em>: On receiving the proof, the verifier checks the validity of the proof and accepts or rejects the proof.</li>
</ul>

<div class="mermaid" align="center">
sequenceDiagram
    Note right of Prover: CommD
    Prover-->>Prover: R, CommR ‚Üê Replicate(D)
    Prover->>Verifier: CommR
    Verifier-->>Verifier: Generate random challenge
    Verifier->>Prover: challenge
    Prover-->>Prover: proof ‚Üê Prove(D, R, challenge)
    Prover->>Verifier: proof
</div>

<h5 id="time-bounded-proof-of-replication">Time-bounded Proof-of-Replication</h5>

<p><strong>Timing assumption</strong>. <em>Time-bounded Proof-of-Replication</em> are constructions of PoRep with timing assumptions. The assumption is that generation of the replica (hence the <em>Replication</em>) takes some time <em>t</em> that is substantially larger than the time it takes to produce a proof (hence <em>time(Prove)</em>) and the round-trip time (<em>RTT</em>) for sending a challenge and receiving a proof.</p>

<p><strong>Distinguishing Malicious provers</strong>. A malicious prover that does not have <em>R</em>, must obtain it (or generate it), before the <em>Prove</em> step. A verifier can distinguish an honest prover from a malicious prover, since the malicious one will take too long to answer the challenge. A verifier will reject if receiving the proof from the prover takes longer than a timeout (bounded between proving time and replication time).</p>

<h5 id="background-on-stacked-drg-porep">Background on Stacked DRG PoRep</h5>

<p><em>Stacked DRG PoRep</em> (SDR) is a specific Proof-of-Replication construction that we use in Filecoin. SDR has been designed by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.  At a high level, SDR ensures that the <em>Replicate</em> step is a slow non-parallelizable sequential process by using a special type of graph called Depth Robust Graphs (DRG).</p>

<p><strong>Encoding using DRGs</strong>. A key is generated by sequentially labeling nodes in the graph such that each label depends on the labels of its parents. The depth robustness property of these graphs ensure that the sequential labeling steps are not parallelizable. The final labels are used as a key to encode the original data.</p>

<p>TODO: This probably needs a more thorough rewrite.</p>

<p>** Stacked DRGs**. SDR builds on the above by stacking DRG graphs into <code>LAYERS</code> layers. Each layer is connected to the previous by a Bipartite Expander Graph. The combination of DRGs and expander graphs guarantee the security property of PoRep. As before, the key produced by the final layer is used to encode the original data, yielding the replica.</p>

<p><strong>Generating SDR proofs</strong>. Given the following public parameters:</p>

<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details).</li>
<li><code>CommD</code> is the Merkle tree root hash of the input data to the first layer.</li>
<li><code>CommC</code> is the Merkle tree root hash of the SDR column commitments.</li>
<li><code>CommRLast</code> is the Merkle tree root hash of the replica.</li>
<li><code>CommR</code> is the on-chain commitment to the replica, dervied as the hash of the concatenation of <code>CommC</code> and <code>CommRLast</code>.</li>
</ul>

<p>An SDR proof proves that some data whose committment is <code>CommD</code> has been used to run a <code>Replicate</code> algorithm and generated some data. <code>CommR</code> is the on-chain commitment to both the replicated data and to intermediate stages required to prove <code>Replicate</code> was performed correctly.</p>

<p>An SDR proof consists of a set of challenged DRG nodes for each layer, a set of parent nodes for each challenged node and a Merkle tree inclusion proof for each node provided. The verifier can then verify the correct labeling of each node and that the nodes given were consistent with the prover&rsquo;s commitments.</p>

<p><strong>Making proofs succinct with SNARKs</strong>: The proof size in SDR is too large for blockchain usage (~100MB TODO: check this), mostly due to the large amount of Merkle tree inclusion proofs required to achieve security. We use SNARKs to generate a proof of knowledge of a correct SDR proof. In other words, we implement the SDR proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>

<p>The SNARK circuit proves that given Merkle roots <code>CommD</code>, and <code>CommR</code>, the prover correctly derived the labels at each layer and correctly performed the final encoding.</p>

<h5 id="porep-in-filecoin">PoRep in Filecoin</h5>

<p>Proof-of-Replication proves that a Storage Miner is dedicating unique storage for each <strong><em>sector</em></strong>. Filecoin Storage Miners collect new clients&rsquo; data in a sector, run a slow encoding process (called <code>Seal</code>) and generate a proof (<code>SealProof</code>) that the encoding was generated correctly.</p>

<p>In Filecoin, PoRep provides two guarantees: (1) <em>space-hardness</em>: Storage Miners cannot lie about the amount of space they are dedicating to Filecoin in order to gain more power in the consensus; (2) <em>replication</em>: Storage Miners are dedicating unique storage for each copy of their clients data.</p>

<p>Glossary:</p>

<ul>
<li><strong><em>sector:</em></strong> a fixed-size block of data of <code>SECTOR_SIZE</code> bytes which generally contains clients&rsquo; data.</li>
<li><strong><em>unsealed sector:</em></strong> a concrete representation (on disk or in memory) of a sector&rsquo;s that follows the &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</li>
<li><strong><em>sealed sector:</em></strong>  a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an <strong><em>unsealed sector</em></strong>. A sector contains one or more <strong><em>pieces</em></strong>.</li>
<li><strong><em>piece:</em></strong> a block of data of at most <code>SECTOR_SIZE</code> bytes which is generally a client&rsquo;s file or part of.</li>
</ul>

<h4 id="stacked-drg-construction">Stacked DRG Construction</h4>

<h5 id="public-parameters">Public Parameters</h5>

<p>The following public parameters are used in the Stacked DRG Replication and Proof Generation algorithms:</p>

<p>TODO: the Appendix should explain why we picked those values
TODO: Just interpolate a table of the Orient parameters and reconcile naming.</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>SECTOR_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the DRG in bytes</td>
<td align="right"><code>68,719,476,736</code></td>
</tr>

<tr>
<td><code>LAYERS</code></td>
<td><code>uint</code></td>
<td>Number of Depth Robust Graph stacked layers.</td>
<td align="right"><code>10</code></td>
</tr>

<tr>
<td><code>BASE_DEGREE</code></td>
<td><code>uint</code></td>
<td>In-Degree of each Depth Robust Graph.</td>
<td align="right"><code>6</code></td>
</tr>

<tr>
<td><code>EXPANSION_DEGREE</code></td>
<td><code>uint</code></td>
<td>Degree of each Bipartite Expander Graph to extend dependencies between layers.</td>
<td align="right"><code>8</code></td>
</tr>

<tr>
<td><code>GRAPH_SEED</code></td>
<td><code>uint</code></td>
<td>Seed used for random number generation in <code>baseParents</code>.</td>
<td align="right"><code>TODO</code></td>
</tr>

<tr>
<td><code>NODE_SIZE</code></td>
<td><code>uint</code></td>
<td>Size of each node in bytes.</td>
<td align="right"><code>32B</code></td>
</tr>
</tbody>
</table>

<p>The following constants are computed from the public parameters:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">computation</th>
<th>value</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>PARENTS_COUNT</code></td>
<td><code>uint</code></td>
<td>Total number of parent nodes</td>
<td align="right"><code>EXPANSION_DEGREE + BASE_DEGREE</code></td>
<td><code>13</code></td>
</tr>

<tr>
<td><code>GRAPH_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the graph</td>
<td align="right"><code>SECTOR_SIZE / NODE_SIZE</code></td>
<td><code>2,147,483,648</code></td>
</tr>

<tr>
<td><code>TREE_DEPTH</code></td>
<td><code>uint</code></td>
<td>Height of the Merkle Tree of a sector</td>
<td align="right"><code>LOG_2(GRAPH_SIZE)</code></td>
<td><code>31</code></td>
</tr>
</tbody>
</table>

<p>The following additional public parameters are required:</p>

<ul>
<li><code>TAPER</code> : <code>Float</code>: Fraction of each layer&rsquo;s challenges by which to reduce next-lowest layer&rsquo;s challenge count.</li>
<li><code>TAPER_LAYERS</code>: <code>uint</code>: Number of layers
<code>Data</code> is a byte array initialized to the content of <strong><em>unsealed sector</em></strong> and will be mutated in-place by the replication process.</li>
</ul>

<h5 id="hash-functions">Hash Functions</h5>

<p>We have describe three hash functions:</p>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>size of input</th>
<th>size of output</th>
<th>construction</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>KDFHash</code></td>
<td>Hash function used as a KDF to derive the key used to label a single node.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>Blake2s-256</code></td>
</tr>

<tr>
<td><code>ColumnHash</code></td>
<td>Hash function used to hash the labeled leaves of each layer (see SDR Column Commitments).</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>

<tr>
<td><code>RepCompress</code></td>
<td>Collision Resistant Hash function used for the Merkle tree.</td>
<td>2 x <code>32B</code> + integer height</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>

<tr>
<td><code>RepHash</code></td>
<td>Balanced binary Merkle tree based used to generate commitments to sealed sectors, unsealed sectors, piece commitments, and intermediate parts of the Proof-of-Replication.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td>Uses <code>RepCompress</code></td>
</tr>

<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

<h6 id="rephash">RepHash</h6>

<p><code>RepHash</code> is a vector commitment used to generate commitments to sealed sectors, unsealed sectors, piece commitments and intermediate stepds of the Proof-of-Replication. Filecoin uses a balanced binary Merkle tree for <code>RepHash</code>. The leaves of the Merkle tree are pairs of adjacent nodes.</p>

<p><code>RepHash</code> inputs MUST respect a valid Storage Format. [TODO: What does this mean?]</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">node</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uint8</span>

<span class="c1">// Create and return a balanced binary Merkle tree and its root commitment.
</span><span class="c1">// len(leaves) must be a power of 2.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">RepHash</span><span class="p">(</span><span class="nx">leaves</span> <span class="p">[]</span><span class="nx">node</span><span class="p">)</span> <span class="p">([][]</span><span class="nx">node</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rows</span> <span class="p">=</span> <span class="p">[][]</span><span class="nx">node</span>

	<span class="nx">currentRow</span> <span class="o">:=</span> <span class="nx">leaves</span>
	<span class="k">for</span> <span class="nx">height</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">currentRow</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">height</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nx">rows</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">currentRow</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">nextRow</span> <span class="p">[]</span><span class="nx">node</span>

		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">{</span>
			<span class="nx">left</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
			<span class="nx">right</span> <span class="o">:=</span> <span class="nx">row</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

			<span class="c1">// NOTE: Depending on choice of RepCompress, heightPart may be trimmed to fewer than 8 bits.
</span><span class="c1"></span>			<span class="nx">heightPart</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint8</span><span class="p">{</span><span class="nx">height</span><span class="p">}</span>

			<span class="nx">input1</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">heightPart</span><span class="p">,</span> <span class="nx">left</span><span class="o">...</span><span class="p">)</span>
			<span class="nx">input</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">input1</span><span class="p">,</span> <span class="nx">right</span><span class="o">...</span><span class="p">)</span>
			<span class="nx">hashed</span> <span class="p">=</span> <span class="nf">RepCompress</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">height</span><span class="p">)</span>
			<span class="nx">nextRow</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">nextRow</span><span class="p">,</span> <span class="nx">hashed</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">currentRow</span> <span class="p">=</span> <span class="nx">nextRow</span>
	<span class="p">}</span>
    <span class="c1">// The tree returned here is just a vector of rows for later use. Its representation is not part of the spec.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">currentRow</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span></code></pre></div>
<h5 id="stacked-drg-graph">Stacked DRG Graph</h5>

<p>The slow sequential encoding required is enforced by the depth robusness property of the SDR graph.</p>

<p><strong>Encoding with SDR</strong>: The data from a sector (of size <code>SECTOR_SIZE</code>) is divided in <code>NODE_SIZE</code> nodes (for a total of <code>GRAPH_SIZE</code> nodes) and arranged in a directed acyclic graph. The structure of the graph is used to label the nodes sequentially to generate a key with which to encode the original data: in order to label a node, its parents must be labeled (see the &ldquo;Layer Labeling&rdquo; section below). We repeat this process for <code>LAYERS</code> layers, where the input to a next layer is the output of the previous one.</p>

<p><strong>Generating the SDR graph</strong>: The SDR graph is divided in <code>LAYERS</code> layers. Each layer is a directed acyclic graph and it combines a Depth Robust Graph (DRG) and a Bipartite Expander graph. [TODO: this isn&rsquo;t quite right.]</p>

<p>We provide an algorithm (<code>SDR</code>) which computes the parents of a node. In high level, the parents of a node are computed by combining two algorithms: some parents (<code>BASE_DEGREE</code> of them) are computed via the <code>BucketSample</code> algorithm extended with a direct ordering of nodes, others (<code>EXPANSION_DEGREE</code> of them) are computed via the <code>Chung</code> algorithm.</p>

<h6 id="sdrgraph-sdr-graph-algorithm"><code>SDRGraph</code>: SDR Graph algorithm</h6>

<p>Overview: Compute the DRG and Bipartite Expander parents using respectively <code>BucketSample</code> and <code>ChungExpander</code>.</p>

<h6 id="inputs">Inputs</h6>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>node</code></td>
<td>The node for which the parents are being computed</td>
<td><code>uint</code></td>
</tr>

<tr>
<td><code>layer</code></td>
<td>The layer of the SDR graph</td>
<td><code>uint</code></td>
</tr>
</tbody>
</table>

<h6 id="outputs">Outputs</h6>

<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>

<tbody>
<tr>
<td><code>parents</code></td>
<td>The ordered parents of node <code>node</code> on layer <code>layer</code></td>
<td><code>[PARENTS_COUNT]uint</code></td>
</tr>
</tbody>
</table>

<h6 id="algorithm">Algorithm</h6>

<ul>
<li><p>If <code>layer = 1</code>:</p>

<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Set <code>parents</code> to be <code>drgParents</code>.</li>
</ul></li>

<li><p>If <code>layer &gt; 1</code>:</p>

<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Compute <code>expanderParents = ChungExpander(node)</code></li>
<li>Set <code>parents</code> to be the concatenation of <code>drgParents</code> and <code>expanderParents</code></li>
</ul></li>
</ul>

<h6 id="pseudocode">Pseudocode</h6>

<p>We provide below a more succinct representation of the algorithm:</p>

<pre><code>func SDRParents(node uint, layer uint) {

  if layer == 1 {
  	// On first layer
  	let drgParents = BucketSample(node)
  	return drgParents
  } else {
    // On subsequent layers
    let drgParents = BucketSample(node)
  	let expanderParents = ChungExpander(node)
  	return concat(drgParents, expanderParents)
  }
}
</code></pre>

<h6 id="tests">Tests</h6>

<p>FIXME: Change this.</p>

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST not be greater than <code>GRAPH_SIZE-1</code> and lower than <code>0</code></li>
<li>If <code>layer</code> is even:

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST be greater than <code>node</code></li>
<li>EXCEPT: if <code>node</code> is <code>0</code>, then all parents MUST be <code>0</code></li>
</ul></li>
<li>if <code>layer</code> is odd:

<ul>
<li>Each <code>parent</code> in <code>parents</code> MUST be less than <code>node</code></li>
<li>EXCEPT: if <code>node</code> is <code>GRAPH_SIZE-1</code>, then all parents MUST be <code>GRAPH_SIZE-1</code></li>
</ul></li>
</ul>

<h6 id="time-space-tradeoff">Time-space tradeoff</h6>

<p>Computing the parents using both <code>BucketSample</code> and <code>ChungExpander</code> for every layer can be an expensive operation, however, this can be avoided by caching the parents.</p>

<h6 id="bucketsample-depth-robust-graphs-algorithm"><code>BucketSample</code>: Depth Robust Graphs algorithm</h6>

<p>This section describes how to compute the &ldquo;base parents&rdquo; of the SDR graph, which is the equivalent of computing the parents of a Depth Robust Graph.</p>

<p>The properties of DRG graphs guarantee that a sector has been encoded with a slow, non-parallelizable process. We use the <code>BucketSample</code> algorithm that is based on DRSample (<a href="https://acmccs.github.io/papers/p1001-alwenA.pdf">ABH17</a>) and described in <a href="https://web.stanford.edu/~bfisch/porep_short.pdf">FBGB18</a> and generates a directed acyclic graph of in-degree <code>BASE_DEGREE</code>.</p>

<p><code>BucketSample</code> DRG graphs are random graphs that can be deterministically generated from a seed; different seed lead with high probability to different graphs. In SDR, we use the same seed <code>GRAPH_SEED</code> for each layer of the SDR graph such that they are all based on the same underlying DRG graph.</p>

<p>The parents of any node can be locally computed without computing the entire graph. We call the parents of a node calculated in this way <em>base parents</em>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">BucketSampleInner</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[</span><span class="nx">BASE_DEGREE</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="nx">node</span> <span class="p">{</span>
        <span class="c1">// Special case for the first node, it self references.
</span><span class="c1"></span>        <span class="c1">// Special case for the second node, it references only the first one.
</span><span class="c1"></span>        <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">BASE_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span>
            <span class="p">}</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nx">rng</span> <span class="o">:=</span> <span class="nx">ChaChaRng</span><span class="p">.</span><span class="nf">from_seed</span><span class="p">(</span><span class="nx">GRAPH_SEED</span><span class="p">)</span>

            <span class="k">for</span> <span class="nx">k</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">BASE_DEGREE</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
                <span class="c1">// iterate over m meta nodes of the ith real node
</span><span class="c1"></span>                <span class="c1">// simulate the edges that we would add from previous graph nodes
</span><span class="c1"></span>                <span class="c1">// if any edge is added from a meta node of jth real node then add edge (j,i)
</span><span class="c1"></span>                <span class="nx">logi</span> <span class="o">:=</span> <span class="nf">floor</span><span class="p">(</span><span class="nf">log2</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span><span class="p">))</span>
                <span class="nx">j</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nf">gen</span><span class="p">()</span> <span class="o">%</span> <span class="nx">logi</span>
                <span class="nx">jj</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span> <span class="o">+</span> <span class="nx">k</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="nx">backDist</span> <span class="o">:=</span> <span class="nx">rng</span><span class="p">.</span><span class="nf">gen_range</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="nx">jj</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nx">jj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nx">out</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">BASE_DEGREE</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">backDist</span><span class="p">)</span> <span class="o">/</span> <span class="nx">BASE_DEGREE</span>

                <span class="c1">// remove self references and replace with reference to previous node
</span><span class="c1"></span>                <span class="k">if</span> <span class="nx">out</span> <span class="o">==</span> <span class="nx">node</span> <span class="p">{</span>
                    <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">node</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">parents</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">out</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="nf">sort</span><span class="p">(</span><span class="nx">parents</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p><code>BucketSample</code> extends <code>BucketSampleInner</code> to include the node&rsquo;s &lsquo;immediate predecessor&rsquo;. Each node except the first in a
DRG generated by <code>BucketSample</code> has the node whose index is one less than its own as a parent. This ensures that
visiting nodes whose indexes are sequential will result in a graph traversal in topological order.</p>

<h6 id="chungexpander-bipartite-expander-graphs"><code>ChungExpander</code>: Bipartite Expander Graphs</h6>

<p>TODO: explain why we link nodes in the current layer</p>

<p>Each node in layers other than the first has <code>EXPANSION_DEGREE</code> parents generated via the <code>ChungExpander</code>
algorithm. Note that the indexes returned refer to labels from the <em>previous</em> layer. TODO: Make this all clearer with explicit notation.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChungExpander</span><span class="p">(</span><span class="nx">node</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">parents</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint</span><span class="p">,</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">)</span>

	<span class="nx">feistelKeys</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span> <span class="c1">// TODO
</span><span class="c1"></span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">p</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">a</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span> <span class="o">+</span> <span class="nx">i</span>
    <span class="nx">transformed</span> <span class="o">:=</span> <span class="nf">feistelPermute</span><span class="p">(</span><span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">feistelKeys</span><span class="p">)</span>
    <span class="nx">other</span> <span class="o">:=</span> <span class="nx">transformed</span> <span class="o">/</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="k">if</span> <span class="nx">other</span> <span class="p">&lt;</span> <span class="nx">node</span> <span class="p">{</span>
      <span class="nx">parents</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nx">other</span>
      <span class="nx">p</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h6 id="time-space-tradeoff-1">Time-Space tradeoff</h6>

<p>Computing these parents can be expensive (especially due to the hashing required by the Feistel algorithm). A miner can trade this computation by storing the expansion parents.</p>

<h6 id="feistel-construction">Feistel construction</h6>

<p>We use three rounds of <code>Feistel</code> to generate a permutation to compute the parents of the Bipartite Expander graph.</p>

<p>TODO: Add <code>FEISTEL_ROUNDS</code> and <code>FEISTEL_BYTES</code> (or find its definitions)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">permute</span><span class="p">(</span><span class="nx">numElements</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">u</span> <span class="o">:=</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>

    <span class="nx">while</span> <span class="nx">u</span> <span class="o">&gt;=</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">u</span> <span class="p">=</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">u</span><span class="p">,</span> <span class="nx">keys</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// Since we are representing `numElements` using an even number of bits,
</span><span class="c1"></span>    <span class="c1">// that can encode many values above it, so keep repeating the operation
</span><span class="c1"></span>    <span class="c1">// until we land in the permitted range.
</span><span class="c1"></span>
    <span class="k">return</span> <span class="nx">u</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">feistelEncode</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">keys</span> <span class="p">[</span><span class="nx">FEISTEL_ROUNDS</span><span class="p">]</span><span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span> <span class="o">:=</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">keys</span> <span class="p">{</span>
        <span class="nx">left</span><span class="p">,</span> <span class="nx">right</span> <span class="p">=</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">left</span> <span class="p">^</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">right</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">return</span>  <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="p">|</span> <span class="nx">right</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">commonSetup</span><span class="p">(</span><span class="nx">index</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">numElements</span> <span class="o">:=</span> <span class="nx">GRAPH_SIZE</span> <span class="o">*</span> <span class="nx">EXPANSION_DEGREE</span>
    <span class="nx">nextPow4</span> <span class="o">:=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nx">halfBits</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nx">while</span> <span class="nx">nextPow4</span> <span class="p">&lt;</span> <span class="nx">numElements</span> <span class="p">{</span>
        <span class="nx">nextPow4</span> <span class="o">*=</span> <span class="mi">4</span>
        <span class="nx">halfBits</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="nx">rightMask</span> <span class="p">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">leftMask</span> <span class="p">=</span> <span class="nx">rightMask</span> <span class="o">&lt;&lt;</span> <span class="nx">halfBits</span>

    <span class="nx">right</span> <span class="o">:=</span> <span class="nx">index</span> <span class="o">&amp;</span> <span class="nx">rightMask</span>
    <span class="nx">left</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&amp;</span> <span class="nx">leftMask</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="nx">halfBits</span>

    <span class="k">return</span>  <span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">,</span> <span class="nx">rightMask</span><span class="p">,</span> <span class="nx">halfBits</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Round function of the Feistel network: `F(Ri, Ki)`. Joins the `right`
</span><span class="c1">// piece and the `key`, hashes it and returns the lower `uint32` part of
</span><span class="c1">// the hash filtered trough the `rightMask`.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">feistel</span><span class="p">(</span><span class="nx">right</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">rightMask</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="p">[</span><span class="nx">FEISTEL_BYTES</span><span class="p">]</span><span class="kt">uint</span>

    <span class="kd">var</span> <span class="nx">r</span> <span class="kt">uint</span>
    <span class="k">if</span> <span class="nx">FEISTEL_BYTES</span> <span class="o">&lt;=</span> <span class="mi">8</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

        <span class="nx">hash</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

        <span class="nx">r</span> <span class="p">=</span>   <span class="nx">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span>

        <span class="nx">data</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">56</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span>  <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">48</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span>
        <span class="nx">data</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

        <span class="nx">hash</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

        <span class="nx">r</span> <span class="p">=</span>   <span class="nx">hash</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span>
            <span class="p">|</span> <span class="nx">hash</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">r</span> <span class="o">&amp;</span> <span class="nx">rightMask</span>
<span class="p">}</span></code></pre></div>
<h4 id="replication">Replication</h4>

<blockquote>
<p>The Replication phase turns an <em>unsealed sector</em> into a <em>sealed sector</em> by first <em>generating a key</em>, then using the key to <em>encode the orignal data</em>.</p>
</blockquote>

<p>Before running the <code>Replicate</code> algorithm, the prover must ensure that the sector is correctly formatted with a valid &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Filecoin Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</p>

<p>TODO: inputs are missing</p>

<p>The Replication Algorithm  proceeds as follows:</p>

<ul>
<li>Calculate <code>ReplicaID</code> using <code>Hash</code> (Blake2s):</li>
</ul>

<p><code>ReplicaID</code> is a 32-byte array constructed by hashing the concatenation of the following values
- <code>ProverId</code> is a 32-byte array uniquely identifying a prover.
- <code>SectorNumber</code> is an unsigned 64-bit integer in little-endian encoding represented as an 8-byte array.
- <code>RandomSeed</code> is a 32-byte array of randomness extracted from the chain.
- <code>CommD</code> is the Merkle root obtained by performing <code>RepHash</code> on the original data represented in <code>paddedfr32v1</code>.</p>

<pre><code>ReplicaID := Hash(ProverID || SectorNumber || RandomSeed || CommD)
</code></pre>

<ul>
<li><p>Perform <code>RepHash</code> on <code>Data</code> to yield <code>CommD</code> and <code>TreeD</code>:</p>

<pre><code>CommD, TreeD = RepHash(data)
</code></pre></li>
</ul>

<p>For each of <code>LAYERS</code> layers, <code>l</code>, perform one <strong><em>Layer Replication</em></strong>, yielding a replica, tree, and commitment (<code>CommR_&lt;l&gt;</code>) per layer:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">let</span> <span class="nx">layer_replicas</span> <span class="p">=</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">][</span><span class="nx">nodes</span><span class="p">]</span><span class="kt">uint8</span>
<span class="nx">let</span> <span class="nx">layer_trees</span> <span class="p">=</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">]</span><span class="nx">MerkleTree</span>
<span class="nx">let</span> <span class="nx">CommRs</span> <span class="p">=</span> <span class="p">[]</span><span class="nx">commitment</span>

<span class="nx">let</span> <span class="nx">layer</span> <span class="p">=</span> <span class="nx">data</span>
<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="mf">0.</span><span class="p">.</span><span class="nx">layers</span> <span class="p">{</span>
	<span class="nx">let</span> <span class="nx">layer_replica</span> <span class="p">=</span> <span class="nf">ReplicateLayer</span><span class="p">(</span><span class="nx">layer</span><span class="p">)</span>
	<span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">=</span> <span class="nx">layer_replica</span>
	<span class="nx">CommRs</span><span class="p">[</span><span class="nx">l</span><span class="p">],</span> <span class="nx">layers_trees</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">=</span> <span class="nf">RepTree</span><span class="p">(</span><span class="nx">layer_replica</span><span class="p">)</span>
	<span class="nx">layer</span> <span class="p">=</span> <span class="nx">layer_replica</span>
<span class="p">}</span></code></pre></div>
<p>The replicated data is the output of the final <strong><em>Layer Replication</em></strong>,<code>layer_replicas[layers-1]</code>.
Set <code>CommRLast</code> to be  <code>CommR_&lt;Layers&gt;</code>.
Set <code>CommRStar</code> to be <code>CommRHash(ReplicaID || CommR_0 || CommR_&lt;i&gt; || ... || CommRLast)</code>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">Replica</span> <span class="o">:=</span> <span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
<span class="nx">CommRLast</span> <span class="p">:</span><span class="o">-</span> <span class="nx">CommRs</span><span class="p">[</span><span class="nx">layers</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nx">CommRStar</span> <span class="o">:=</span> <span class="nf">CommRHash</span><span class="p">(</span><span class="nx">replicaID</span><span class="p">,</span> <span class="o">...</span><span class="nx">CommRs</span><span class="p">)</span></code></pre></div>
<h5 id="layer-labeling">Layer Labeling</h5>

<p>TODO: Define <code>Graph</code>. We need to decide if this is an object we&rsquo;ll explicitly define or if its properties (e.g., <code>GRAPH_SIZE</code>) are just part of the replication parameters and all the functions just refer to the <em>same</em> graphs being manipulated across the entire replication process. (At the moment I&rsquo;ve avoided defining a <code>Graph</code> structure as in other specs I didn&rsquo;t see any object methods, just standalone functions.)</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">FIXME</span><span class="p">,</span> <span class="nx">move</span> <span class="nx">these</span> <span class="nx">to</span> <span class="p">.</span><span class="k">go</span> <span class="nx">files</span><span class="p">.</span>

<span class="kd">func</span> <span class="nf">generateKey</span> <span class="p">(</span><span class="nx">replicaId</span> <span class="nx">Domain</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="nx">Domain</span><span class="p">)</span> <span class="p">[</span><span class="nx">LAYERS</span><span class="p">][</span><span class="nx">NODES</span><span class="p">]</span><span class="nx">Domain</span>
<span class="kd">func</span> <span class="nf">encodeData</span> <span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="nx">Domain</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="nx">Domain</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Domain</span>
<span class="kd">func</span> <span class="nf">replicate</span> <span class="p">(</span><span class="nx">replicaId</span> <span class="nx">Domain</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="nx">Domain</span><span class="p">)</span> <span class="p">([]</span><span class="nx">Domain</span><span class="p">,</span> <span class="p">[]</span><span class="nx">Tree</span><span class="p">)</span>

<span class="nx">fun</span> <span class="nf">seal</span> <span class="p">(</span><span class="nx">replicaId</span> <span class="nx">Domain</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="nx">Domain</span><span class="p">)</span> <span class="p">([]</span><span class="nx">Domain</span><span class="p">,</span>  <span class="err">????</span><span class="p">)</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">label</span><span class="p">(</span><span class="nx">replicaId</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">parents</span> <span class="p">[</span><span class="nx">PARENT_COUNT</span><span class="p">]</span><span class="kt">uint</span>
    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">GRAPH_SIZE</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">node</span> <span class="kt">uint</span> <span class="o">:=</span> <span class="nx">n</span>

        <span class="nx">parents</span> <span class="p">=</span> <span class="nf">parents</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span>

        <span class="nx">key</span> <span class="o">:=</span> <span class="nf">KDFHash</span><span class="p">(</span><span class="nx">replicaId</span><span class="p">,</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">parents</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span>

        <span class="nx">start</span> <span class="o">:=</span> <span class="nx">node</span> <span class="o">*</span> <span class="nx">NODE_SIZE</span>
        <span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">NODE_SIZE</span><span class="p">;</span>

        <span class="nx">data</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">]</span> <span class="p">=</span> <span class="nx">key</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="proof-generation">Proof Generation</h4>

<p>Overview:</p>

<ul>
<li>Challenge Derivation</li>
<li>Proof Generation</li>
<li>Circuit Proof Generation</li>
</ul>

<p>TODO: write a single algorithm which includes the spec below</p>

<h5 id="challenge-derivation">Challenge Derivation</h5>

<p>TODO: define <code>Domain</code> (for practical purposes a <code>uint</code>) and <code>LayerChallenges</code> (or find existing definition).</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// TODO: we should replace the word commitment with the word seed, this will be more interactive porep friendly
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeriveChallenges</span><span class="p">(</span><span class="nx">challenges</span> <span class="nx">LayerChallenges</span><span class="p">,</span> <span class="nx">layer</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">leaves</span> <span class="kt">uint</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">RandomSeed</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">[]</span><span class="kt">uint</span> <span class="p">{</span>

    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">challenges</span><span class="p">.</span><span class="nf">ChallengesForLayer</span><span class="p">(</span><span class="nx">layer</span><span class="p">)</span>
    <span class="kd">var</span> <span class="nx">derivedChallenges</span> <span class="p">[</span><span class="nx">n</span><span class="p">]</span><span class="kt">uint</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">bytes</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">ranodomness</span><span class="p">)</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">layer</span><span class="p">);</span>
        <span class="nx">bytes</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nf">toLittleEndian</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span> <span class="nx">k</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span>

        <span class="c1">// For now, we cannot try to prove the first or last node, so make
</span><span class="c1"></span>        <span class="c1">// sure the challenge can never be 0 or leaves - 1.
</span><span class="c1"></span>        <span class="nx">big_mod_challenge</span> <span class="o">:=</span> <span class="nf">blake2s</span><span class="p">(</span><span class="nx">bytes</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="nx">leaves</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
        <span class="nx">derivedChallenges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">big_mod_challenge</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="challenge-generation">Challenge Generation</h5>

<p>TODO: we may need to remove this section.</p>

<p>Calculate <code>LAYER_CHALLENGES : [LAYERS]uint</code>: Number of challenges per layer. (This will be passed to the SDR circuit proof.)</p>

<p>Derive challenges for each layer (call <code>DeriveChallenges()</code>).</p>

<h5 id="witness-generation">Witness Generation</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">let</span> <span class="nx">layer_proofs</span> <span class="p">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="mf">0.</span><span class="p">.</span><span class="nx">LAYERS</span> <span class="p">{</span>
  <span class="nx">let</span> <span class="nx">replica</span> <span class="p">=</span> <span class="nx">layer_replicas</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  <span class="nx">let</span> <span class="nx">replica_tree</span> <span class="p">=</span> <span class="nx">layer_trees</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>

  <span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="nf">derive_challenges</span><span class="p">(</span><span class="nx">LAYER_CHALLENGES</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
    <span class="nx">data_inclusion_proof</span> <span class="p">=</span> <span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataTree</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="p">&gt;)</span>
    <span class="nx">replica_inclusion_proof</span> <span class="p">=</span> <span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">replica</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">replica_tree</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">&gt;)</span> <span class="o">||</span> <span class="nx">FAIL</span><span class="c1">// Prove the replica. TODO explain replica[].
</span><span class="c1"></span>
    <span class="c1">// *** let kdf_preimage = [replica_id] ***
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">parent_replica_inclusion_proofs</span> <span class="p">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="nf">parents</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// *** kdf_preimage.push(p)***
</span><span class="c1"></span>      <span class="nx">parent_replica_inclusion_proofs</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nf">inclusion_proof</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">CommR_</span><span class="p">&lt;</span><span class="nx">l</span><span class="o">+</span><span class="mi">1</span><span class="p">&gt;))</span>
    <span class="p">}</span>
    <span class="c1">// *** let key = kdf(kdf_preimage); ***
</span><span class="c1"></span>
    <span class="c1">// *** encode(key, data[c]) == replica[c]
</span><span class="c1"></span>    <span class="c1">// *** We don&#39;t actually need to encode in the proof. ***
</span><span class="c1"></span>    <span class="c1">// TODO: move this ***stuff*** to verification.
</span><span class="c1"></span>
    <span class="nx">layer_proof</span><span class="p">.</span><span class="nf">push</span><span class="p">((</span><span class="nx">data_inclusion_proof</span><span class="p">,</span> <span class="nx">replication_inclusion_proof</span><span class="p">,</span> <span class="nx">parent_replica_inclusion_proofs</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">return</span> <span class="nx">layer_proofs</span><span class="p">,</span> <span class="nx">CommRstar</span><span class="p">,</span> <span class="nx">CommRLast</span></code></pre></div>
<p>TODO: reconcile outputs of non-circuit proof with inputs to circuit proof.</p>

<h5 id="layer-challenge-counts">Layer Challenge Counts</h5>

<p>TODO: define <code>Challenge</code> (or find existing definition)</p>

<p>TODO: we should just list current parameters and show this as a calculation for correctness, this should not mandatory to implement.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ChallengesForLayer</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">Challenge</span><span class="p">,</span> <span class="nx">layer</span> <span class="kt">uint</span><span class="p">)</span> <span class="kt">uint</span> <span class="p">{</span>

    <span class="k">switch</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Type</span> <span class="p">{</span>
      <span class="c1">// TODO: remove ambiguity, there should not be a &#34;fixed&#34; case
</span><span class="c1"></span>        <span class="k">case</span> <span class="nx">Fixed</span><span class="p">:</span>
            <span class="k">return</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Count</span>
        <span class="k">case</span> <span class="nx">Tapered</span><span class="p">:</span>
      <span class="c1">// FIXME
</span><span class="c1"></span>            <span class="nf">assert</span><span class="p">(</span><span class="nx">layer</span> <span class="p">&lt;</span> <span class="nx">LAYERS</span><span class="p">)</span>
            <span class="nx">l</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">LAYERS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="nx">layer</span>
            <span class="nx">r</span> <span class="o">:=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="nx">TAPER</span><span class="p">;</span>
            <span class="nx">t</span> <span class="o">:=</span> <span class="nf">min</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">TAPER_LAYERS</span><span class="p">)</span>

            <span class="nx">totalTaper</span> <span class="o">:=</span> <span class="nf">pow</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span>

            <span class="nx">calculated</span> <span class="o">:=</span> <span class="nf">ceil</span><span class="p">(</span><span class="nx">totalTaper</span> <span class="o">*</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>

            <span class="c1">// Although implied by the call to `ceil()` above, be explicit
</span><span class="c1"></span>            <span class="c1">// that a layer cannot contain 0 challenges.
</span><span class="c1"></span>            <span class="nf">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">calculated</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

</div>



</div>

  

  
    








<div id="algorithms__porep__porep_commitments">

<h3 class="section-header">
  PoRep Commitments
</h3>

<div class="section-content">






































</div>


  
    








<div id="algorithms__porep__porep_commitments__sdr_commitments">

<h4 class="section-header">
  Stacked DRG Commitments
</h4>

<div class="section-content">






































</div>


  
    








<div id="algorithms__porep__porep_commitments__sdr_commitments__sdr_commitments">

<h5 class="section-header">
  Stacked DRG Commitments
</h5>

<div class="section-content">






































<p>This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in <a href="https://www.overleaf.com/read/kcdhnxwptxbc">Tight PoS - ZigZag</a>.</p>

<h6 id="graph">Graph</h6>

<p>In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only
to illustrate the nature of the SDR commitment scheme. They accurately represent how parent-child relationships
function between layers, and are accurate for expander parents. However, this is not representative of the DRG parent
selection algorithm.</p>

<p>The following graphs illustrate the positions of challenges, DRG parents, and expander parents between layers. Only a
single DRG parent and a single expander parent are shown. The immediate predecessor parent is shown for graph topology,
but it is not tracked in the tables below.</p>

<p>In order to have a compact and concrete example, we use a graph containing only <code>8</code> nodes replicated in <code>4</code> layers.</p>

<h6 id="legend">Legend</h6>

<figure>
    <img src="./ox-hugo/legend.png"/> 
</figure>


<h6 id="data-layer--comm-d--tree">Data Layer: \(Comm_D\) Tree</h6>

<figure>
    <img src="./ox-hugo/data-layer.png"/> 
</figure>


<h6 id="replica-column-layers--comm-c--tree">Replica Column Layers: \(Comm_C\) Tree</h6>

<figure>
    <img src="./ox-hugo/layer-1.png"/> 
</figure>


<figure>
    <img src="./ox-hugo/layer-2.png"/> 
</figure>


<figure>
    <img src="./ox-hugo/layer-3.png"/> 
</figure>


<figure>
    <img src="./ox-hugo/layer-4.png"/> 
</figure>


<h6 id="final-layer--comm-r-last--tree">Final Layer: \(Comm_{R_{LAST}}\) Tree</h6>

<figure>
    <img src="./ox-hugo/replica-layer.png"/> 
</figure>


<h6 id="commitment-algorithm">Commitment Algorithm</h6>

<h6 id="goal">Goal</h6>

<p>We will generate two commitments \(Comm_R, Comm_D\) to be placed on chain.</p>

<p>\(Comm_D\) is the merkle root of the original data.</p>

<p>\(Comm_R = H(Comm_C || Comm_{R_{LAST}})\).</p>

<p>Their construction is described below.</p>

<h6 id="definitions-and-notation">Definitions and Notation</h6>

<p>We will perform \(L\) layers of SDR key generation over \(N\) labeled nodes.</p>

<p>In the running example, \(L\) is <code>4</code> and \(N\) is <code>8</code>.</p>

<p>Merkle roots (commitments) are generated with the vector-commitment function \(VC(‚Ä¶)\).</p>

<p>Hashes are produced with a hash function \(H(‚Ä¶)\), which is not necessarily that used by \(VC(‚Ä¶)\).</p>

<p>\(Comm = VC(l_1||‚Ä¶||l_N)\), where the \(l_i\) are the data (labels or hashes) to be committed.</p>

<p>Generated trees are retained until the proving phase, when merkle proofs of a given label&rsquo;s inclusion in \(Comm\) will be
created. We will designate such proofs \(l_i \rightarrow Comm\).</p>

<p>We use the notation \(e{_i}^{(l)}\), correlated in the table below with the \((l, i)\) notation used in the graphs above,
where \(l\) indexes layers, and \(i\) indexes labels or columns.</p>

<table>
<thead>
<tr>
<th>Graph</th>
<th>\((1, 1)\)</th>
<th>\((1, 2)\)</th>
<th>\((1, 3)\)</th>
<th>\((1, 4)\)</th>
<th>\((1, 5)\)</th>
<th>\((1, 6)\)</th>
<th>\((1, 7)\)</th>
<th>\((1, 8)\)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Notation</td>
<td>\(e_1^{(1)}\)</td>
<td>\(e_2^{(1)}\)</td>
<td>\(e_3^{(1)}\)</td>
<td>\(e_4^{(1)}\)</td>
<td>\(e_5^{(1)}\)</td>
<td>\(e_6^{(1)}\)</td>
<td>\(e_7^{(1)}\)</td>
<td>\(e_8^{(1)}\)</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>Graph</th>
<th>\((2, 1)\)</th>
<th>\((2, 2)\)</th>
<th>\((2, 3)\)</th>
<th>\((2, 4)\)</th>
<th>\((2, 5)\)</th>
<th>\((2, 6)\)</th>
<th>\((2, 7)\)</th>
<th>\((2, 8)\)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Notation</td>
<td>\(e_1^{(2)}\)</td>
<td>\(e_2^{(2)}\)</td>
<td>\(e_3^{(2)}\)</td>
<td>\(e_4^{(2)}\)</td>
<td>\(e_5^{(2)}\)</td>
<td>\(e_6^{(2)}\)</td>
<td>\(e_7^{(2)}\)</td>
<td>\(e_8^{(2)}\)</td>
</tr>
</tbody>
</table>

<p>‚Ä¶</p>

<table>
<thead>
<tr>
<th>Graph</th>
<th>\((4, 1)\)</th>
<th>\((4, 2)\)</th>
<th>\((4, 3)\)</th>
<th>\((4, 4)\)</th>
<th>\((4, 5)\)</th>
<th>\((4, 6)\)</th>
<th>\((4, 7)\)</th>
<th>\((4, 8)\)</th>
</tr>
</thead>

<tbody>
<tr>
<td>Notation</td>
<td>\(e_1^{(4)}\)</td>
<td>\(e_2^{(4)}\)</td>
<td>\(e_3^{(4)}\)</td>
<td>\(e_4^{(4)}\)</td>
<td>\(e_5^{(4)}\)</td>
<td>\(e_6^{(4)}\)</td>
<td>\(e_7^{(4)}\)</td>
<td>\(e_8^{(4)}\)</td>
</tr>
</tbody>
</table>

<h6 id="initial-data-layer">Initial Data Layer</h6>

<table>
<thead>
<tr>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th>Challenge</th>
<th><code>~~~~</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>\((0, 1)\)</td>
<td>\((0, 2)\)</td>
<td>\((0, 3)\)</td>
<td>\((0, 4)\)</td>
<td>\((0, 5)\)</td>
<td>\((0, 6)\)</td>
<td>\((0, 7)\)</td>
<td>\((0, 8)\)</td>
</tr>
</tbody>
</table>

<ul>
<li><p>Vector Commitment</p>

<p>Generate Merkle root for data leaves.</p>

<p>\(Comm_D = VC(D_1 || D_2 || ‚Ä¶ || D_N)\), where \(D_i = e_i^{(0)}\).</p>

<p>This example: \(Comm_D = VC(e_1^{(0)}, e_2^{(0)}, e_3^{(0)}, e_4^{(0)}, e_5^{(0)}, e_6^{(0)}, e_7^{(0)}, e_8^{(0)})\).</p></li>

<li><p>Opening</p>

<p>To open \(D_i\), provide a merkle proof \(D_i \rightarrow Comm_D\).</p></li>
</ul>

<h6 id="sdr-replica-columns">SDR Replica Columns</h6>

<ul>
<li><p>Columns</p>

<table>
<thead>
<tr>
<th><code>~~~~</code></th>
<th>DRG Parents</th>
<th><code>~~~~</code></th>
<th>Expander Parents</th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th>Challenges</th>
<th><code>~~~~</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>\((1, 1)\)</td>
<td>\((1, 2)\)</td>
<td>\((1, 3)\)</td>
<td>\((1, 4)^{*}\)</td>
<td>\((1, 5)\)</td>
<td>\((1, 6)\)</td>
<td>\((1, 7)\)</td>
<td>\((1, 8)\)</td>
</tr>

<tr>
<td>\((2, 1)\)</td>
<td>\((2, 2)\)</td>
<td>\((2, 3)\)</td>
<td>\((2, 4)\)</td>
<td>\((2, 5)\)</td>
<td>\((2, 6)\)</td>
<td>\((2, 7)\)</td>
<td>\((2, 8)\)</td>
</tr>

<tr>
<td>\((3, 1)\)</td>
<td>\((3, 2)\)</td>
<td>\((3, 3)\)</td>
<td>\((3, 4)\)</td>
<td>\((3, 5)\)</td>
<td>\((3, 6)\)</td>
<td>\((3, 7)\)</td>
<td>\((3, 8)\)</td>
</tr>

<tr>
<td>\((4, 1)\)</td>
<td>\((4, 2)\)</td>
<td>\((4, 3)\)</td>
<td>\((4, 4)\)</td>
<td>\((4, 5)\)</td>
<td>\((4, 6)\)</td>
<td>\((4, 7)\)</td>
<td>\((4, 8)\)</td>
</tr>
</tbody>
</table>

<p>\(^{*}\) Indicates labels which must be hashed for column commitments but need not be opened for label checks.</p>

<p>Concatenate and hash rows of column \(i\) to construct \(O_i\).</p>

<p>Column hash \(C_i = H(e_i^{(1)} || e_i^{(2)} || ‚Ä¶ || e_i^{(L)})\).</p></li>

<li><p>Vector Commitment</p>

<p>Generate Merkle tree for column leaves, \(C_i\):</p>

<p>\(Comm_C = VC(C_1 || C_2 || ‚Ä¶ || C_N)\).</p></li>

<li><p>Opening</p>

<ul>
<li><p>To open labels for column \(i\):</p>

<ul>
<li>Reveal all labels and prove they hash to \(C_i\) as above. (\(L\) hash proofs).</li>
<li>Provide a merkle proof \(C_i \rightarrow Comm_C\).</li>
</ul></li>

<li><p>Then once, reusable for all columns,</p>

<ul>
<li>Reveal \(Comm_{R_{LAST}}\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_R\).</li>
</ul></li>
</ul></li>
</ul>

<h6 id="final-replica-layer">Final Replica Layer</h6>

<table>
<thead>
<tr>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th><code>~~~~</code></th>
<th>Challenge</th>
<th><code>~~~~</code></th>
</tr>
</thead>

<tbody>
<tr>
<td>\((5, 1)\)</td>
<td>\((5, 2)\)</td>
<td>\((5, 3)\)</td>
<td>\((5, 4)\)</td>
<td>\((5, 5)\)</td>
<td>\((5, 6)\)</td>
<td>\((5, 7)\)</td>
<td>\((5, 8)\)</td>
</tr>
</tbody>
</table>

<ul>
<li><p>Vector Commitment</p>

<p>Generate Merkle tree for replica leaves.</p>

<p>\(R_{LAST_i} = e_i^{(L+1)}\).</p>

<p>\(Comm_{R_{LAST}} = VC(R_{LAST_1} || R_{LAST_2} || ‚Ä¶ || R_{LAST_N})\).</p></li>

<li><p>Opening</p>

<ul>
<li><p>To open \(R_{LAST_i}\),</p>

<ul>
<li>Provide a merkle proof \(R_{LAST_i} \rightarrow Comm_{R_{LAST}}\).</li>
</ul></li>

<li><p>Then once (shared with Replica Columns ‚Äî see above):</p>

<ul>
<li>Reveal \(Comm_C\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_pR\).</li>
</ul></li>
</ul></li>
</ul>

<h6 id="replica-commitment">Replica Commitment</h6>

<ul>
<li><p>Commitment</p>

<ul>
<li><p>Produce \(Comm_R\) from its constituents.</p></li>

<li><p>\(Comm_R = H(Comm_C || Comm_{R_{LAST}})\).</p></li>
</ul></li>

<li><p>Opening (performed once per PoRep)</p>

<ul>
<li>Reveal \(Comm_C\) and \(Comm_{R_{LAST}}\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_R\).</li>
</ul></li>
</ul>

<h6 id="challenge-selection">Challenge Selection</h6>

<p>For each challenge \(\chi\), we challenge each node \(e_{\chi}^{(l)}\) for \(l = 1, 2, .. L\).</p>

<h6 id="opening-commitments-for-offline-proof">Opening Commitments for Offline Proof</h6>

<p>For use in all challenge proofs, reveal \(Comm_C\) and \(Comm_{R_{LAST}}\) and prove that \(H(Comm_C || Comm_{R_{LAST}}) =
Comm_R\).</p>

<p>To prove encoding for a challenged label \(\chi\):</p>

<ul>
<li>Initial data layer openings

<ul>
<li>Open label for challenged data node \(e_\chi^{(0)} ‚Äî using Comm_D\).</li>
</ul></li>
<li>SDR replica column openings

<ul>
<li>Open all labels in \(C_\chi\) containing challenged label&rsquo;s &lsquo;replica node&rsquo;, (\(C_\chi\)) ‚Äî using \(Comm_C\).</li>
<li>Open all labels in the columns containing challenged label&rsquo;s DRG parents ‚Äî using \(Comm_C\).</li>
<li>Open all labels in the columns containing challenged label&rsquo;s expander parents ‚Äî using \(Comm_C\).</li>
</ul></li>

<li><p>Final replica layer openings</p>

<ul>
<li>Open all challenged labels (\(e_{\chi}^{(L+1)}\)) using \(Comm_{R_{LAST}}\).</li>
</ul></li>

<li><p>Prove labeling for all challenged labels $e{_&chi;}<sup>(l))</sup> for \(l = 1, 2, .. L\).</p></li>

<li><p>Prove encoding for all challenged nodes \(e{_\chi}^{(L+1))}\).</p></li>
</ul>

<h6 id="opening-commitments-for-online-proof">Opening Commitments for Online Proof</h6>

<p>To prove encoding for a challenged label \(C\) in the replica:</p>

<ul>
<li>Reveal \(Comm_C\) (which must have been stored along with the replica).</li>
<li>Open \(Comm_{R_{LAST}}\) from provided \(Comm_R\) by proving that \(H(Comm_C || Comm_{R_{LAST}}) = Comm_R\).</li>
<li>Provide a merkle proof \(e_C^{(L)} \rightarrow Comm_{R_{LAST}}\).</li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="algorithms__porep__stacked_drg_circuit">

<h3 class="section-header">
  
</h3>

<div class="section-content">






































<h5 id="stacked-drg-offline-porep-circuit-spec">Stacked DRG: Offline PoRep Circuit Spec</h5>

<h6 id="stacked-drg-overview">Stacked DRG Overview</h6>

<p>Stacked DRG PoRep is based on layering DRG graphs <code>LAYERS</code> times. The data represented in each DRG layer is a labeling based on previously labeled nodes. The final labeled layer is the SDR key, and the &lsquo;final layer&rsquo; of replication the replica, an encoding of the original data using the generated key.</p>

<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details).</li>
<li><code>CommD</code> is the Merkle tree root hash of the input data to the first layer.</li>
<li><code>CommC</code> is the Merkle tree root hash of the SDR column commitments.</li>
<li><code>CommRLast</code> is the Merkle tree root hash of the replica.</li>
<li><code>CommR</code> is the on-chain commitment to the replica, dervied as the hash of the concatenation of <code>CommC</code> and <code>CommRLast</code>.</li>
</ul>

<p>The (offline) proof size in SDR is too large for blockchain usage (~3MB). We use SNARKs to generate a proof of knowledge of a correct SDR proof. In other words, we implement the SDR proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>

<p>This circuit proves that given a Merkle root <code>CommD</code>, <code>CommRLast</code>, and <code>commRStar</code>, that the prover knew the correct replicated data at each layer.</p>

<h6 id="spec-notation">Spec notation</h6>

<ul>
<li><strong>Fr</strong>: Field element of BLS12-381</li>
<li><strong>UInt</strong>: Unsigned integer</li>
<li><strong>{0..x}</strong>: From <code>0</code> (included) to <code>x</code> (not included) (e.g. <code>[0,x)</code> )</li>
<li><strong>Check</strong>:

<ul>
<li>If there is an equality, create a constraint</li>
<li>otherwise, execute the function</li>
</ul></li>
<li><strong>Inclusion path</strong>: Binary representation of the Merkle tree path that must be proven packed into a single <code>Fr</code> element.</li>
</ul>

<h4 id="offline-porep-circuit">Offline PoRep circuit</h4>

<h5 id="public-parameters">Public Parameters</h5>

<p><em>Parameters that are embeded in the circuits or used to generate the circuit</em></p>

<ul>
<li><code>LAYERS : UInt</code>: Number of DRG layers.</li>
<li><code>LAYER_CHALLENGES : [LAYERS]UInt</code>: Number of challenges per layer.</li>
<li><code>EXPANSION_DEGREE: UInt</code>: Degree of each bipartite expander graph to extend dependencies between layers.</li>
<li><code>BASE_DEGREE: UInt</code>: Degree of each Depth Robust Graph.</li>
<li><code>TREE_DEPTH: UInt</code>: Depth of the Merkle tree. Note, this is (log_2(Size of original data in bytes/32 bytes per leaf)).</li>
<li><code>PARENT_COUNT : UInt</code>: Defined as <code>EXPANSION_DEGREE+BASE_DEGREE</code>.</li>
</ul>

<h5 id="public-inputs">Public Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof and that the verifier uses to verify it</em></p>

<ul>
<li><code>ReplicaId : Fr</code>: A unique identifier for the replica.</li>
<li><code>CommD : Fr</code>: the Merkle tree root hash of the original data (input to the first layer).</li>
<li><code>CommR : Fr</code>: The Merkle tree root hash of the final replica (output of the last layer).</li>
<li><code>InclusionPath : [LAYERS][]Fr</code>: Inclusion path for the challenged data and replica leaf.</li>
<li><code>ParentInclusionPath : [LAYERS][][PARENT_COUNT]Fr</code>:  Inclusion path for the parents of the corresponding <code>InclusionPath[l][c]</code>.</li>
</ul>

<p>Design notes:</p>

<ul>
<li><code>CommRLast</code> is a private input used during during Proof-of-Spacetime.
To enable this, the prover must store <code>CommC</code> and use it to prove that <code>CommRLast</code> is included in <code>CommR</code> [TODO: define &lsquo;included&rsquo; language.]</li>
<li><code>InclusionPath</code> and <code>ParentInclusionPath</code>: Each layer <code>l</code> has <code>LAYER_CHALLENGES[l]</code> inclusion paths.</li>
</ul>

<h5 id="private-inputs">Private Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof, these are not needed by the verifier to verify the proof</em></p>

<ul>
<li><code>CommR : [LAYERS-1]Fr</code>: Commitment of the the encoded data at each layer.</li>
</ul>

<p>Note: Size is <code>LAYERS-1</code> since the commitment to the last layer is <code>CommRLast</code></p>

<ul>
<li><p><code>DataProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer unencoded challenged leaf.</p></li>

<li><p><code>ReplicaProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer encoded challenged leaves.</p></li>

<li><p><code>ParentProof : [LAYERS][][PARENT_COUNT][TREE_DEPTH]Fr</code>: Pedersen hashes of the Merkle inclusion proofs of the parent leaves for each challenged leaf at layer <code>l</code>.</p></li>

<li><p><code>DataValue : [LAYERS][]Fr</code>: Value of the unencoded challenged leaves at layer <code>l</code>.</p></li>

<li><p><code>ReplicaValue : [LAYERS][]Fr</code>: Value of the encoded leaves for each challenged leaf at layer <code>l</code>.</p></li>

<li><p><code>ParentValue : [LAYERS][][PARENT_COUNT]Fr</code>: Value of the parent leaves for each challenged leaf at layer <code>l</code>.</p></li>
</ul>

<h5 id="circuit">Circuit</h5>

<p>In high level, we do 4 checks:</p>

<ol>
<li><strong>ReplicaId Check</strong>: Check the binary representation of the ReplicaId</li>
<li><strong>Inclusion Proofs Checks</strong>: Check the inclusion proofs</li>
<li><strong>Encoding Checks</strong>: Check that the data has been correctly encoding into a replica</li>
<li><strong>CommRStar Check</strong>: Check that CommRStar has been generated correctly</li>
</ol>

<p>Detailed</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 1: ReplicaId Check - Check ReplicaId is equal to its bit representation
</span><span class="c1"></span><span class="nx">let</span> <span class="nx">ReplicaIdBits</span> <span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">ReplicaId</span><span class="p">)</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">replica_id_bits</span><span class="p">)</span> <span class="o">==</span> <span class="nx">ReplicaId</span><span class="p">)</span>

<span class="nx">let</span> <span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">ReplicaRoot</span> <span class="nx">Fr</span>

<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span> <span class="p">{</span>

  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommD</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommRLast</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS_CHALLENGES</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// 2: Inclusion Proofs Checks
</span><span class="c1"></span>    <span class="c1">// 2.1: Check inclusion proofs for data leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.2: Check inclusion proofs for replica leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.3: Check inclusion proofs for parent leaves are correct
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">ParentInclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">],</span> <span class="nx">ParentProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]))</span>
    <span class="p">}</span>

    <span class="c1">// 3: Encoding checks - Check that replica leaves have been correctly encoded
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">ParentBits</span> <span class="p">[</span><span class="nx">PARENT_COUNT</span><span class="p">][</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span>
    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="c1">// 3.1: Check that each ParentValue is equal to its bit representation
</span><span class="c1"></span>      <span class="nx">let</span> <span class="nx">parent</span> <span class="p">=</span> <span class="nx">ParentValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]</span>
      <span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">])</span> <span class="o">==</span> <span class="nx">parent</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 3.2: KDF check - Check that each key has generated correctly
</span><span class="c1"></span>    <span class="c1">// PreImage = ReplicaIdBits || ParentBits[1] .. ParentBits[PARENT_NODES]
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">PreImage</span> <span class="p">=</span> <span class="nx">ReplicaIdBits</span>
    <span class="k">for</span> <span class="nx">parentbits</span> <span class="nx">in</span> <span class="nx">ParentBits</span> <span class="p">{</span>
      <span class="nx">PreImage</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">parentbits</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">let</span> <span class="nx">key</span> <span class="nx">Fr</span> <span class="p">=</span> <span class="nf">Blake2s</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span>
    <span class="nf">assert</span><span class="p">(</span><span class="nf">Blake2s</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span><span class="p">)</span>

    <span class="c1">// 3.3: Check that the data has been encoded to a replica with the right key
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">==</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">+</span> <span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// 4: CommRStar check - Check that the CommRStar constructed correctly
</span><span class="c1"></span>  <span class="nx">let</span> <span class="nx">hash</span> <span class="p">=</span> <span class="nx">ReplicaId</span>
  <span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommRLast</span><span class="p">)</span>

  <span class="nf">assert</span><span class="p">(</span><span class="nx">CommRStar</span> <span class="o">==</span> <span class="nf">PedersenHash</span><span class="p">(</span><span class="nx">hash</span><span class="p">))</span>
  <span class="c1">// TODO check if we need to do packing/unpacking
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
<h5 id="verification-of-offline-porep-proof">Verification of offline porep proof</h5>

<ul>
<li>SNARK proof check: <strong>Check</strong> that given the SNARK proof and the public inputs, the SNARK verification outputs true</li>
<li>Parent checks: For each <code>leaf = InclusionPath[l][c]</code>:

<ul>
<li><strong>Check</strong> that all <code>ParentsInclusionPaths_[l][c][0..PARENT_COUNT}</code> are the correct parent leaves of <code>leaf</code> in the DRG graph, if a leaf has less than <code>PARENT_COUNT</code>, repeat the leaf with the highest label in the graph.</li>
<li><strong>Check</strong> that the parent leaves are in ascending numerical order.</li>
</ul></li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="algorithms__post">

<h2 class="section-header">
  Proof-of-Spacetime
</h2>

<div class="section-content">




































<p>See <a href="https://filecoin.io/filecoin.pdf">Filecoin Paper</a></p>


</div>


  
    








<div id="algorithms__post__rational_post">

<h3 class="section-header">
  Rational-PoSt
</h3>

<div class="section-content">






































<p>This document describes Rational-PoSt, the Proof-of-Spacetime used in Filecoin.</p>

<h4 id="high-level-api">High Level API</h4>

<h5 id="fault-detection">Fault Detection</h5>

<p>Fault detection happens over the course of the life time of a sector. When the sector is for some reason unavailable, the miner is responsible to submit the known <code>faults</code>, before the PoSt challenge begins. (Using the <code>AddFaults</code> message to the chain).
Only faults which have been reported at challenge time, will be accounted for. If any other faults have occured the miner can not submit a valid PoSt for this proving period.</p>

<p>The PoSt generation then takes the latest available <code>faults</code> of the miner to generate a PoSt matching the committed sectors and faults.</p>

<p>When a PoSt is successfully submitted all faults are reset and assumed to be recovered. A miner must either (1) resolve a faulty sector and accept challenges against it in the next proof submission, (2) report a sector faulty again if it persists but is eventually recoverable, (3) report a sector faulty <em>and done</em> if the fault cannot be recovered.</p>

<p>If the miner knows that the sectors are permanently lost, they can submit them as part of the <code>doneSet</code>, to ensure they are removed from the proving set.</p>

<div class="notices note" ><strong>Note</strong>: It is important that all faults are known (i.e submitted to the chain) prior to challenge generation, because otherwise it would be possible to know the challenge set, before the actual challenge time. This would allow a miner to report only faults on challenged sectors, with a gurantee that other faulty sectors would not be detected.</div>

<div class="notices todo" ><strong>TODO</strong>: The penalization for faults is not clear yet.</div>

<h5 id="fault-penalization">Fault Penalization</h5>

<p>Each reported fault carries a penality with it.</p>

<div class="notices todo" ><strong>TODO</strong>: Define the exact penality structure for this.</div>

<h5 id="generation">Generation</h5>

<p><code>GeneratePoSt</code> generates a <strong><em>Proof of Spacetime</em></strong> over all  <strong><em>sealed sectors</em></strong> of a single miner‚Äî identified by their <code>commR</code> commitments. This is accomplished by performing a series of merkle inclusion proofs (<strong><em>Proofs of Retrievability</em></strong>). Each proof is of a challenged node in a challenged sector. The challenges are generated pseudo-randomly, based on the provided <code>seed</code>. At each time step, a number of <strong><em>Proofs of Retrievability</em></strong> are performed.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Generate a new PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GeneratePoSt</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="nx">SectorSet</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">)</span> <span class="nx">PoStProof</span> <span class="p">{</span>
    <span class="c1">// Generate the Merkle Inclusion Proofs + Faults
</span><span class="c1"></span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nf">SortAsc</span><span class="p">(</span><span class="nf">GetSectorIds</span><span class="p">(</span><span class="nx">sectors</span><span class="p">)))</span>
    <span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="p">[]</span>
    <span class="nx">inclusionProofs</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">challenges</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">challenge</span> <span class="o">:=</span> <span class="nx">challenges</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

        <span class="c1">// Leaf index of the selected sector
</span><span class="c1"></span>        <span class="nx">inclusionProof</span><span class="p">,</span> <span class="nx">isFault</span> <span class="o">:=</span> <span class="nf">GenerateMerkleInclusionProof</span><span class="p">(</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">.</span><span class="nx">Leaf</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">isFault</span> <span class="p">{</span>
            <span class="c1">// faulty sector, need to post a fault to the chain and try to recover from it
</span><span class="c1"></span>            <span class="k">return</span> <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Detected late fault&#34;</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="nx">inclusionProofs</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">inclusionProof</span>
        <span class="nx">challengedSectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectors</span><span class="p">[</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">// Generate the snark
</span><span class="c1"></span>    <span class="nx">snarkProof</span> <span class="o">:=</span> <span class="nf">GeneratePoStSnark</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">challenges</span><span class="p">,</span> <span class="nx">challengedSectors</span><span class="p">,</span> <span class="nx">inclusionProofs</span><span class="p">)</span>

    <span class="k">return</span> <span class="nx">snarkProof</span>
<span class="p">}</span></code></pre></div>
<h5 id="verification">Verification</h5>

<p><code>VerifyPoSt</code> is the functional counterpart to <code>GeneratePoSt</code>. It takes all of <code>GeneratePoSt</code>&rsquo;s output, along with those of <code>GeneratePost</code>&rsquo;s inputs required to identify the claimed proof. All inputs are required because verification requires sufficient context to determine not only that a proof is valid but also that the proof indeed corresponds to what it purports to prove.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Verify a PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">VerifyPoSt</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">BytesAmount</span><span class="p">,</span> <span class="nx">sectors</span> <span class="nx">SectorSet</span><span class="p">,</span> <span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">proof</span> <span class="nx">PoStProof</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">faults</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nf">SortAsc</span><span class="p">(</span><span class="nf">GetSectorIds</span><span class="p">(</span><span class="nx">sectors</span><span class="p">)))</span>
    <span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="c1">// Match up commitments with challenges
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">challenges</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">challengedSectors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectors</span><span class="p">[</span><span class="nx">challenges</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">Sector</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="c1">// Verify snark
</span><span class="c1"></span>    <span class="k">return</span> <span class="nf">VerifyPoStSnark</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">challenges</span><span class="p">,</span> <span class="nx">challengedSectors</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h5 id="types">Types</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// The random challenge seed, provided by the chain.
</span><span class="c1"></span><span class="nx">Seed</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">byte</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Challenge</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Sector</span> <span class="nx">SectorID</span>
    <span class="nx">Leaf</span> <span class="nx">Uint</span>
<span class="p">}</span></code></pre></div>
<h5 id="challenge-derivation">Challenge Derivation</h5>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Derive the full set of challenges for PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DerivePoStChallenges</span><span class="p">(</span><span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">faults</span> <span class="nx">FaultSet</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sortedSectors</span> <span class="p">[]</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">[</span><span class="nx">POST_CHALLENGES_COUNT</span><span class="p">]</span><span class="nx">Challenge</span> <span class="p">{</span>
    <span class="nx">challenges</span> <span class="o">:=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">n</span> <span class="p">&lt;</span> <span class="nx">POST_CHALLENGES_COUNT</span><span class="p">;</span> <span class="nx">n</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">attemptedSectors</span> <span class="o">:=</span> <span class="p">{</span><span class="nx">SectorID</span><span class="p">:</span><span class="kt">bool</span><span class="p">}</span>
        <span class="nx">while</span> <span class="nx">challenges</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">challenge</span> <span class="o">:=</span> <span class="nf">DerivePoStChallenge</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">attempt</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">sortedSectors</span><span class="p">)</span>

            <span class="c1">// check if we landed in a faulty sector
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">!</span><span class="nx">faults</span><span class="p">.</span><span class="nf">Contains</span><span class="p">(</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Valid challenge
</span><span class="c1"></span>                <span class="nx">challenges</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">challenge</span>
            <span class="p">}</span>

            <span class="c1">// invalid challenge, regenerate
</span><span class="c1"></span>            <span class="nx">attemptedSectors</span><span class="p">[</span><span class="nx">challenge</span><span class="p">.</span><span class="nx">Sector</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">attemptedSectors</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">sortedSectors</span><span class="p">)</span> <span class="p">{</span>
                <span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;All sectors are faulty&#34;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">challenges</span>
<span class="p">}</span>

<span class="c1">// Derive a single challenge for PoSt.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DerivePoStChallenge</span><span class="p">(</span><span class="nx">seed</span> <span class="nx">Seed</span><span class="p">,</span> <span class="nx">n</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">attempt</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">Uint</span><span class="p">,</span> <span class="nx">sortedSectors</span> <span class="p">[]</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">Challenge</span> <span class="p">{</span>
    <span class="nx">nBytes</span> <span class="o">:=</span> <span class="nf">WriteUintToLittleEndian</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="nf">concat</span><span class="p">(</span><span class="nx">seed</span><span class="p">,</span> <span class="nx">nBytes</span><span class="p">,</span> <span class="nf">WriteUintToLittleEndian</span><span class="p">(</span><span class="nx">attempt</span><span class="p">))</span>
    <span class="nx">challengeBytes</span> <span class="o">:=</span> <span class="nf">blake2b</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>

    <span class="nx">sectorChallenge</span> <span class="o">:=</span> <span class="nf">ReadUintLittleEndian</span><span class="p">(</span><span class="nx">challengeBytes</span><span class="p">[</span><span class="mf">0..8</span><span class="p">])</span>
    <span class="nx">leafChallenge</span> <span class="o">:=</span> <span class="nf">ReadUintLittleEndian</span><span class="p">(</span><span class="nx">challengeBytes</span><span class="p">[</span><span class="mf">8..16</span><span class="p">])</span>

    <span class="nx">sectorIdx</span> <span class="o">:=</span> <span class="nx">sectorChallenge</span> <span class="o">%</span> <span class="nx">sectorCount</span>

    <span class="k">return</span> <span class="nx">Challenge</span> <span class="p">{</span>
        <span class="nx">Sector</span><span class="p">:</span> <span class="nx">sortedSectors</span><span class="p">[</span><span class="nx">sectorIdx</span><span class="p">],</span>
        <span class="nx">Leaf</span><span class="p">:</span> <span class="nx">leafChallenge</span> <span class="o">%</span> <span class="p">(</span><span class="nx">sectorSize</span> <span class="o">/</span> <span class="nx">NODE_SIZE</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h4 id="post-circuit">PoSt Circuit</h4>

<h5 id="public-parameters">Public Parameters</h5>

<p><em>Parameters that are embeded in the circuits or used to generate the circuit</em></p>

<ul>
<li><code>POST_CHALLENGES_COUNT: UInt</code>: Number of challenges.</li>
<li><code>POST_TREE_DEPTH: UInt</code>: Depth of the Merkle tree. Note, this is <code>(log_2(Size of original data in bytes/32 bytes per leaf))</code>.</li>
<li><code>SECTOR_SIZE: UInt</code>: The size of a single sector in bytes.</li>
</ul>

<h5 id="public-inputs">Public Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof and that the verifier uses to verify it</em></p>

<ul>
<li><code>CommRs: [POST_CHALLENGES_COUNT]Fr</code>: The Merkle tree root hashes of all replicas, ordered to match the inclusion paths and challenge order.</li>
<li><code>InclusionPaths: [POST_CHALLENGES_COUNT]Fr</code>: Inclusion paths for the replica leafs, ordered to match the <code>CommRs</code> and challenge order. (Binary packed bools)</li>
</ul>

<h5 id="private-inputs">Private Inputs</h5>

<p><em>Inputs that the prover uses to generate a SNARK proof, these are not needed by the verifier to verify the proof</em></p>

<ul>
<li><code>InclusionProofs: [POST_CHALLENGES_COUNT][TREE_DEPTH]Fr</code>: Merkle tree inclusion proofs, ordered to match the challenge order.</li>
<li><code>InclusionValues: [POST_CHALLENGES_COUNT]Fr</code>: Value of the encoded leaves for each challenge, ordered to match challenge order.</li>
</ul>

<h5 id="circuit">Circuit</h5>

<h6 id="high-level">High Level</h6>

<p>In high level, we do 1 check:</p>

<ol>
<li><strong>Inclusion Proofs Checks</strong>: Check the inclusion proofs</li>
</ol>

<h6 id="details">Details</h6>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">POST_CHALLENGES_COUNT</span> <span class="p">{</span>
  <span class="c1">// Inclusion Proofs Checks
</span><span class="c1"></span>  <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">CommRs</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionProof</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span> <span class="nx">InclusionValue</span><span class="p">[</span><span class="nx">c</span><span class="p">]))</span>
<span class="p">}</span></code></pre></div>
<h5 id="verification-of-post-proof">Verification of PoSt proof</h5>

<ul>
<li>SNARK proof check: <strong>Check</strong> that given the SNARK proof and the public inputs, the SNARK verification outputs true</li>
</ul>


</div>



</div>

  

  
    








<div id="algorithms__post__proof_of_spacetime_parameters">

<h3 class="section-header">
  PoSt Parameters
</h3>

<div class="section-content">




































<p>This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.</p>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>POST-CHALLENGE-BLOCKS</td>
<td>BLOCKS</td>
<td>480</td>
<td>The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.</td>
</tr>

<tr>
<td>POST-CHALLENGE-HOURS</td>
<td>HOURS</td>
<td>2</td>
<td>PoSt challenge time (see POST_CHALLENGE_BLOCKS).</td>
</tr>

<tr>
<td>POST-PROVING-PERIOD</td>
<td>BLOCKS</td>
<td>5760</td>
<td>The time interval in which a PoSt has to be submitted</td>
</tr>
</tbody>
</table>

<div class="notices todo" ><strong>TODO</strong>: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</div>


</div>



</div>

  


</div>

  

  
    








<div id="algorithms__payment_channels">

<h2 class="section-header">
  Payment Channels
</h2>

<div class="section-content">






































<h3 id="payment-channels">Payment Channels</h3>

<p>In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.</p>

<p>The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&rdquo;. Once that money is locked up, user A can send user B signed transactions that user B can cash out at any time.</p>

<p>For example:</p>

<ul>
<li>User A locks up 10 FIL to B</li>
<li>User B does something for A</li>
<li>User A sends <code>SignedVoucher{Channel, 1 FIL}</code> to B</li>
<li>User B does something for user A</li>
<li>User A sends <code>SignedVoucher{Channel, 2 FIL}</code> to B</li>
</ul>

<p>At this point, B has two signed messages from A, but the contract is set up such that it can only be cashed out once. So if B decided to cash out, they would obviously select the message with the higher value. Also, once B cashes out, they must not accept any more payments from A on that same channel.</p>

<h4 id="multi-lane-payment-channel">Multi-Lane Payment Channel</h4>

<p>The filecoin storage market may require a way to do incremental payments between two parties, over time, for multiple different transactions. The primary motivating usecase for this is to provide payment for file storage over time, for each file stored. An additional requirement is the ability to have less than one message on chain per transaction &lsquo;lane&rsquo;, meaning that payments for multiple files should be aggregateable (Note: its okay if this aggregation is an interactive process).</p>

<p>Let&rsquo;s say that <code>A</code> wants to make such an arrangement with <code>B</code>. <code>A</code> should create the payment channel with enough funds to cover all potential transactions. Then <code>A</code> decides to start the first transaction, so they send a signed voucher for the payment channel on &lsquo;lane 1&rsquo;, for 2 FIL. They can then send more updates on lane 1 as needed. Then, at some point <code>A</code> decides to start another independent transaction to <code>B</code>, so they send a voucher on &lsquo;lane 2&rsquo;. The voucher for lane 2 can be cashed out independently of lane 1. However, <code>B</code> can ask <code>A</code> to &lsquo;reconcile&rsquo; the two payment channels for them into a single update. This update could contain a value, and a list of lanes to close. Cashing out that reconciled update would invalidate the other lanes, meaning <code>B</code> couldnt also cash in those. The single update would be much smaller, and therefore cheaper to close out.</p>

<p>Lane state can be easily tracked on-chain with a compact bitfield.</p>

<h4 id="payment-channel-reconciliation">Payment Channel Reconciliation</h4>

<p>In a situation where peers A and B  have several different payment channels between them, the scenario may frequently come up where A has multiple payment channel updates from B to apply. Submitting each of these individually would cost a noticeable amount in fees, and put excess unnecessary load on the chain. To remedy this, A can contact B and ask them for a single payment channel update for the combined value of all the updates they have (minus some fee to incent B to actually want to do this). This aggregated update would contain a list of the IDs of the other payment channels that it is superceding so that A cannot also cash out on the originals.</p>

<h3 id="payment-reconciliation">Payment Reconciliation</h3>

<p>The filecoin storage market will (likely) have many independent payments between the same parties. These payments will be secured through payment channels, set up initially on chain, but utilized almost entirely off-chain. The point at which they need to touch the chain is when miners wish to cash out their earnings. A naive solution to this problem would have miners perform one on-chain action per file stored for a particular client. This would not scale well. Instead, we need a system where the miner and client can have some additional off-chain communication and end up with the miner submitting only a single message to the chain.</p>

<p>To accomplish this, we introduce the Payment Reconciliation Protocol.</p>

<p>This is a libp2p service run by all participants wanting to participate in payment reconciliation. When Alice has a set of payments from Bob that she is ready to cash out, Alice can send a <code>ReconcileRequest</code> to Bob, containing the following information:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileRequest struct <span class="o">{</span>
	vouchers <span class="o">[</span>Vouchers<span class="o">]</span>
	reqVal TokenAmount
<span class="o">}</span></code></pre></div>
<p>The Vouchers should all be valid vouchers from Bob to Alice, on the same payment channel, and they should all be ready to be cashed in. <code>ReqVal</code> is a token amount less than or equal to the sum of all the values in the given vouchers. Generally, this value will be between the total sum of the vouchers, and that total sum minus the fees it would cost to submit them all to the chain.</p>

<p>Bob receives this request, and checks that all the fields are correct, and then ensures that the difference between ReqVal and the vouchers sum is sufficient (this is a parameter that the client can set).  Then, he sends back a response which either contains the requested voucher, or an error status and message.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileResponse struct <span class="o">{</span>
	combined Voucher
	status  Status
	message optional String
<span class="o">}</span>

<span class="c1">## TODO: what are the possible status cases?</span>
<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="p">|</span> Success
    <span class="p">|</span> Failure
<span class="o">}</span></code></pre></div>
<p>Open Questions:</p>

<ul>
<li>In a number of usecases, this protocol will require the miner look up and connect to a client to propose reconciliation. How does a miner look up and connect to a client over libp2p given only their filecoin address?</li>
<li>Without repair miners, this protocol will likely not be used that much. Should that be made clear? Should there be other considerations added to compensate?</li>
</ul>


</div>



</div>

  

  
    








<div id="algorithms__block_sync">

<h2 class="section-header">
  BlockSync
</h2>

<div class="section-content">






































<ul>
<li><strong>Name</strong>: Block Sync</li>
<li><strong>Protocol ID</strong>: <code>/fil/sync/blk/0.0.1</code></li>
</ul>

<p>The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol.</p>

<p>The request requests a chain of a given length by the hash of its highest block. The <code>Options</code> allow the requester to specify whether or not blocks and messages to be included.</p>

<p>The response contains the requested chain in reverse iteration order. Each item in the <code>Chain</code> array contains the blocks for that tipset if the <code>Blocks</code> option bit in the request was set, and if the <code>Messages</code> bit was set, the messages across all blocks in that tipset. The <code>MsgIncludes</code> array contains one array of integers for each block in the <code>Blocks</code> array. Each of the arrays in <code>MsgIncludes</code> contains a list of indexes of messages from the <code>Messages</code> array that are in each <code>Block</code> in the blocks array.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BlockSyncRequest struct <span class="o">{</span>
    <span class="c1">## The TipSet being synced from</span>
	start <span class="o">[</span><span class="p">&amp;</span>Block<span class="o">]</span>
    <span class="c1">## How many tipsets to sync</span>
	requestLength UInt
    <span class="c1">## Query options</span>
    options Options
<span class="o">}</span></code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Options enum <span class="o">{</span>
    <span class="c1"># Include only blocks</span>
    <span class="p">|</span> Blocks <span class="m">0</span>
    <span class="c1"># Include only messages</span>
    <span class="p">|</span> Messages <span class="m">1</span>
    <span class="c1"># Include messages and blocks</span>
    <span class="p">|</span> BlocksAndMessages <span class="m">2</span>
<span class="o">}</span>

<span class="nb">type</span> BlockSyncResponse struct <span class="o">{</span>
	chain <span class="o">[</span>TipSetBundle<span class="o">]</span>
	status Status
<span class="o">}</span>

<span class="nb">type</span> TipSetBundle struct <span class="o">{</span>
  blocks <span class="o">[</span>Blocks<span class="o">]</span>
  secpMsgs <span class="o">[</span>SignedMessage<span class="o">]</span>
  secpMsgIncludes <span class="o">[[</span>UInt<span class="o">]]</span>

  blsMsgs <span class="o">[</span>Message<span class="o">]</span>
  blsMsgIncludes <span class="o">[[</span>Uint<span class="o">]]</span>
<span class="o">}</span>

<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="c1">## All is well.</span>
    <span class="p">|</span> Success <span class="m">0</span>
    <span class="c1">## Sent back fewer blocks than requested.</span>
    <span class="p">|</span> PartialResponse <span class="m">101</span>
    <span class="c1">## Request.Start not found.</span>
    <span class="p">|</span> BlockNotFound <span class="m">201</span>
    <span class="c1">## Requester is making too many requests.</span>
    <span class="p">|</span> GoAway <span class="m">202</span>
    <span class="c1">## Internal error occured.</span>
    <span class="p">|</span> InternalError <span class="m">203</span>
    <span class="c1">## Request was bad</span>
    <span class="p">|</span> BadRequest <span class="m">204</span>
<span class="o">}</span></code></pre></div>
<h4 id="example">Example</h4>

<p>The TipSetBundle</p>

<pre><code>Blocks: [b0, b1]
secpMsgs: [mA, mB, mC, mD]
secpMsgIncludes: [[0, 1, 3], [1, 2, 0]]
</code></pre>

<p>corresponds to:</p>

<pre><code>Block 'b0': [mA, mB, mD]
Block 'b1': [mB, mC, mA]
</code></pre>


</div>



</div>

  

  
    








<div id="algorithms__gossip_sub">

<h2 class="section-header">
  GossipSub
</h2>

<div class="section-content">






































<div id="algorithms__gossip_sub__gossip_sub"></div>

<p>Messages and block headers along side the message references are propagated using the <a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">gossipsub libp2p pubsub router</a>. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be <a href="./validation.md#syntactical-validation">syntactically validated</a> before being propagated further.</p>

<p>Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it. This allows any node to fetch missing pieces (e.g. <code>Message</code>) from any node it is connected to. However, the node should fan out these requests to multiple nodes and not bombard any single node with too many requests at a time. A node may implement throttling and DDoS protection to prevent such a bombardment.</p>

<h3 id="bitswap">Bitswap</h3>

<p>Run bitswap to fetch and serve data (such as blockdata and messages) to and from other filecoin nodes. This is used to fill in missing bits during block propagation, and also to fetch data during sync.</p>

<p>There is not yet an official spec for bitswap, but <a href="https://github.com/ipfs/go-bitswap/blob/master/message/pb/message.proto">the protobufs</a> should help in the interim.</p>


</div>



</div>

  

  
    








<div id="algorithms__crypto">

<h2 class="section-header">
  Cryptographic Primitives
</h2>

<div class="section-content">




































<ul>
<li>Merkle tree/DAG</li>
<li>Vector commitment scheme</li>
<li>zkSNARK</li>
<li>Verifiable random function (VRF)</li>
<li>Verifiable delay function (VDF)</li>

<li><p>Reliable broadcast channel (libp2p)</p></li>

<li><div class="notices todo">
<strong>TODO</strong>:  Add more detail and include references to relevant papers. 
</div></li>
</ul>


</div>


  
    








<div id="algorithms__crypto__signatures">

<h3 class="section-header">
  Signatures
</h3>

<div class="section-content">






































<p>Signatures are cryptographic functions that attest to the origin of a particular message. In the context of Filecoin, signatures are used to send and receive messages among with the assurance that each message was generated by specific individuals. In other words, it is infeasible for another individual i to generate a signed message that appears to have been generated by j.</p>

<p>We use signatures in filecoin to verify <em>something</em> was done by <em>someone</em>. For example, we use signatures in order to validate deal messages which represent an action like a storage deals. We also use signatures to determine who generated a particular message, determine public keys&ndash;which can be recovered from signed data and a signature, and find filecoin addresses which generated from a public key.</p>

<ul>
<li>Messages (From users to the blockchain)</li>
<li>Tickets (Signature of proof - <a href="mining.md">Mining</a>)</li>
<li>Block signature (Signature over all data in the block - done by block leader)</li>
</ul>

<h4 id="interface">Interface</h4>

<p>Filecoin requires a system that fulfils the following interface to function correctly.</p>

<p>Note: <code>Message</code> is used here as the object being signed, but this interface should also work for other things that need to be signed.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">interface</span> <span class="p">{</span>

	<span class="c1">// Sign generates a proof that miner `M` generate message `m`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Out:
</span><span class="c1"></span>	<span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>	<span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>	<span class="c1">// In:
</span><span class="c1"></span>	<span class="c1">//    m - a series of bytes representing a message to be signed
</span><span class="c1"></span>	<span class="c1">//    sk - a private key which cryptographically links `M` to `sig`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">Sign</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Message</span><span class="p">,</span> <span class="nx">sk</span> <span class="nx">PrivateKey</span><span class="p">)</span> <span class="p">(</span><span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Verify validates the statement: only `M` could have generated `sig`
</span><span class="c1"></span>	<span class="c1">// given the validator has a message `m`, a signature `sig`, and a
</span><span class="c1"></span>	<span class="c1">// public key `pk`.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Out:
</span><span class="c1"></span>	<span class="c1">//    valid - a boolean value indicating the signature is valid
</span><span class="c1"></span>	<span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>	<span class="c1">// In:
</span><span class="c1"></span>	<span class="c1">//    m - a series of bytes representing the signed message
</span><span class="c1"></span>	<span class="c1">//    pk - the public key belonging to the signer `M`
</span><span class="c1"></span>	<span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">Verify</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Messgage</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="p">(</span><span class="nx">valid</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>

	<span class="c1">// Recover, as its name implies, recovers a public key associated with a
</span><span class="c1"></span>	<span class="c1">// particular signature. In the case of ECDSA signatures, this function can
</span><span class="c1"></span>	<span class="c1">// be fulfilled via the &#39;ECRecover&#39; method. If a different signature scheme
</span><span class="c1"></span>	<span class="c1">// is used, then some other mechanism of &#39;recovering&#39; a message authors
</span><span class="c1"></span>	<span class="c1">// public key must be provided.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Out:
</span><span class="c1"></span>	<span class="c1">//    pk - the public key associated with `M` who signed `m`
</span><span class="c1"></span>	<span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>	<span class="c1">//    **
</span><span class="c1"></span>	<span class="c1">// In:
</span><span class="c1"></span>	<span class="c1">//    m - a series of bytes representing the signed message
</span><span class="c1"></span>	<span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="nf">Recover</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Message</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="p">(</span><span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h4 id="secp256k1-signatures">Secp256k1 Signatures</h4>

<p>Currently, Filecoin uses secp256k1 signatures to fulfill the above interface. All signatures on messages, blocks, and tickets currently use the same scheme and format.</p>

<h5 id="signing-messages">Signing Messages</h5>

<p>To generate a signature for the <a href="data-structures.md#message"><code>Message</code></a> type, first serialize it, then hash the serialized bytes with blake2b-256. Then, take the 32 byte digest output the hash and compute the secp256k1 signature over it.</p>

<h5 id="wire-format">Wire Format</h5>

<p>We use standard secp256k1 signature serialization, as described below. For more details on how the Filecoin <code>Signature</code> type is serialized, see the relevant section in <a href="data-structures.md#signature">the data structures spec</a></p>

<p><strong>Signature</strong></p>

<pre><code>SignatureBytes = [0x30][len][0x02][r][indicator][s][indicator][recovery]
</code></pre>

<p><code>s</code> = Scalar of size 32 bytes</p>

<p><code>r</code> = Compressed elliptic curve point (x-coordinate) of size 32 bytes</p>

<p><code>recovery</code> = Information needed to recover a public key from <code>sig</code>.</p>

<ul>
<li>LSB(0) = parity of y-coordinate of r</li>
<li>LSB(1) = overflow indicator</li>
</ul>

<p><code>indicator</code> = a 2 byte formatting indicator</p>

<h4 id="external-references">External References</h4>

<ul>
<li>Elliptic Curve Cryptography Paper

<ul>
<li><a href="http://www.secg.org/sec1-v2.pdf">http://www.secg.org/sec1-v2.pdf</a></li>
</ul></li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="listings">

<h1 class="section-header">
  Listings
</h1>

<div class="section-content">






































</div>


  
    








<div id="listings__actors">

<h2 class="section-header">
  Filecoin VM Actors
</h2>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="listings__data_structures">

<h2 class="section-header">
  Data Structures
</h2>

<div class="section-content">






































<h3 id="address">Address</h3>

<p>An address is an identifier that refers to an actor in the Filecoin state. All <a href="actors.md">actors</a> (miner actors, the storage market actor, account actors) have an address. An address encodes information about:</p>

<ul>
<li>Network this address belongs to</li>
<li>Type of data the address contains</li>
<li>The data itself</li>
<li>Checksum (depending on the type of address)</li>
</ul>

<p>For more detail, see the full <a href="./#appendix__address">address spec</a>.</p>

<h3 id="block">Block</h3>

<p>A block header contains information relevant to a particular point in time over which the network may achieve consensus. The block header contains:</p>

<ul>
<li>The address of the miner that mined the block</li>
<li>A ticket associated to this block&rsquo;s creation to be used as randomness elsewhere in the protocol (see
<a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> for more details)</li>
<li>An electionProof showing this miner was eligible to mine, as well as a Nonce relating the number of rounds over which the block was mined (on expectation 1)</li>
<li>The set of parent blocks and aggregate <a href="./#algorithms__expected_consensus__chain_selection">chain weight</a> of the parents</li>
<li>This block&rsquo;s height</li>
<li>Merkle root of the state tree (after applying the messages &ndash; state transitions &ndash; included in this block)</li>
<li>Merkle root of the messages (state transitions) in this block</li>
<li>Merkle root of the message receipts in this block</li>
<li>Timestamp</li>
</ul>

<div class="notices note" ><strong>Note:</strong> A block is functionally the same as a block header in the Filecoin protocol. While a block header contains Merkle links to the full system state, messages, and message receipts, a block can be thought of as the full set of this information (not just the Merkle roots, but rather the full data of the state tree, message tree, receipts tree, etc.). Because a full block is quite large, our chain consists of block headers rather than full blocks. We often use the terms <code>block</code> and <code>block header</code> interchangeably.</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Miner is the address of the miner actor that mined this block.
</span><span class="c1"></span>    <span class="nx">miner</span> <span class="nx">Address</span>

    <span class="c1">// Tickets is a chain (possibly singleton) of tickets ending with a winning ticket
</span><span class="c1"></span>    <span class="c1">// submitted with this block.
</span><span class="c1"></span>    <span class="nx">tickets</span> <span class="p">[</span><span class="nx">Ticket</span><span class="p">]</span>

    <span class="c1">// ElectionProof is generated from a past ticket and proves this miner is a leader
</span><span class="c1"></span>    <span class="c1">// in this block&#39;s round.
</span><span class="c1"></span>    <span class="nx">electionProof</span> <span class="nx">ElectionProof</span>

    <span class="c1">// Parents is an array of distinct CIDs of parents on which this block was based.
</span><span class="c1"></span>    <span class="c1">// Typically one, but can be several in the case where there were multiple winning
</span><span class="c1"></span>    <span class="c1">// ticket-holders for a given round. The order of parent CIDs is not defined.
</span><span class="c1"></span>    <span class="nx">parents</span> <span class="p">[</span><span class="o">&amp;</span><span class="nx">Block</span><span class="p">]</span>

    <span class="c1">// ParentWeight is the aggregate chain weight of the parent set.
</span><span class="c1"></span>    <span class="nx">parentWeight</span> <span class="nx">UInt</span>

    <span class="c1">// Height is the chain height of this block.
</span><span class="c1"></span>    <span class="nx">height</span> <span class="nx">UInt</span>

    <span class="c1">// StateRoot is a CID pointer to the VM state tree after application of the state
</span><span class="c1"></span>    <span class="c1">// transitions corresponding to this block&#39;s messages.
</span><span class="c1"></span>    <span class="nx">stateRoot</span> <span class="o">&amp;</span><span class="nx">StateTree</span>

    <span class="c1">// Messages is the set of messages included in this block. This field is the CID
</span><span class="c1"></span>    <span class="c1">// of the TxMeta object that contains the bls and secpk signed message trees.
</span><span class="c1"></span>    <span class="nx">messages</span> <span class="o">&amp;</span><span class="nx">TxMeta</span>

    <span class="c1">// BLSAggregate is an aggregated BLS signature for all the messages in this block
</span><span class="c1"></span>    <span class="c1">// that were signed using BLS signatures.
</span><span class="c1"></span>    <span class="nx">blsAggregate</span> <span class="nx">Signature</span>

    <span class="c1">// MessageReceipts is a set of receipts matching to the sending of the `Messages`.
</span><span class="c1"></span>    <span class="c1">// This field is the CID of the root of a sharray of MessageReceipts.
</span><span class="c1"></span>    <span class="nx">messageReceipts</span> <span class="o">&amp;</span><span class="p">[</span><span class="nx">MessageReceipt</span><span class="p">]</span>

    <span class="c1">// The block Timestamp is used to enforce a form of block delay by honest miners.
</span><span class="c1"></span>    <span class="c1">// Unix time UTC timestamp (in seconds) stored as an unsigned integer.
</span><span class="c1"></span>    <span class="nx">timestamp</span> <span class="nx">Timestamp</span>

    <span class="c1">// BlockSig is a signature over the hash of the entire block with the miners
</span><span class="c1"></span>    <span class="c1">// worker key to ensure that it is not tampered with after creation
</span><span class="c1"></span>    <span class="nx">blockSig</span> <span class="nx">Signature</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TxMeta</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">blsMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">Message</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
    <span class="nx">secpkMessages</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">SignedMessage</span><span class="p">]&lt;</span><span class="nx">Sharray</span><span class="p">&gt;</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<h3 id="tipset">Tipset</h3>

<p>For more on Tipsets, see <a href="./#algorithms__expected_consensus">the Expected Consensus spec</a>. Implementations may choose not to create a Tipset data structure, instead representing its operations in terms of the underlying blocks.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TipSet</span> <span class="p">[</span><span class="o">&amp;</span><span class="nx">Block</span><span class="p">]</span>
</code></pre></div>
  
</div>


<h3 id="vrf-personalization">VRF Personalization</h3>

<p>We define VRF personalizations as follow, to enable domain separation across operations that make use of the same VRF (e.g. <code>Ticket</code> and
<code>ElectionProof</code>).</p>

<table>
<thead>
<tr>
<th>Type</th>
<th>Prefix</th>
</tr>
</thead>

<tbody>
<tr>
<td>Ticket</td>
<td><code>0x01</code></td>
</tr>

<tr>
<td>ElectionProof</td>
<td><code>0x02</code></td>
</tr>
</tbody>
</table>

<h3 id="ticket">Ticket</h3>

<p>A ticket contains a shared random value referenced by a particular <code>Block</code> in the Filecoin blockchain.
Every miner must produce a new <code>Ticket</code> for each ticket used in a leader election attempt.</p>

<p>To produce the ticket values,
we use an <a href="https://tools.ietf.org/html/draft-irtf-cfrg-vrf-04#page-10">EC-VRF per Goldberg et al.</a>
with Secp256k1 and SHA-256 to obtain a deterministic, pseudorandom output.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Ticket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The VRFProof (pi_string in the RFC) is generated by running our VRF on a past ticket
</span><span class="c1"></span>    <span class="c1">// in the ticket chain signed with the miner&#39;s keypair. This field is 97 bytes long
</span><span class="c1"></span>    <span class="c1">// (may be compressible to 80).
</span><span class="c1"></span>    <span class="nx">VRFProof</span> <span class="nx">Bytes</span>

    <span class="c1">// The VDFResult is derived from the VRFResult of the ticket. It is the value that
</span><span class="c1"></span>    <span class="c1">// will be used to generate future tickets or ElectionProofs.
</span><span class="c1"></span>    <span class="nx">VDFResult</span> <span class="nx">Bytes</span>

    <span class="c1">// The VDF proves a delay between tickets generated.
</span><span class="c1"></span>    <span class="nx">VDFProof</span> <span class="nx">Bytes</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>


<h4 id="ticket-comparison">Ticket Comparison</h4>

<p>The ticket is represented concretely by the <code>Ticket</code> data structure.
Whenever the Filecoin protocol refers to ticket values
(notably in crafting <a href="./#algorithms__post___index">PoSTs</a> or running leader election),
what is meant is that the bytes of the <code>VRFResult</code> field in the <code>Ticket</code> struct are used.
Specifically, tickets are compared lexicographically,
interpreting the bytes of the <code>VRFResult.Output</code> as an unsigned integer value (little-endian).</p>

<h3 id="electionproof">ElectionProof</h3>

<p>An election proof is generated from a past ticket (chosen based on public network parameters)
by a miner during the leader election process.
Its output value determines whether the miner is elected as one of the leaders,
and hence is eligible to produce a block for the current epoch.
The inclusion of the <code>ElectionProof</code> in the block allows other network participants
to verify that the block was mined by a valid leader. With every leader election attempt for a given ticket,
(in cases where no blocks are found in a round) a miner increments that ElectionProof&rsquo;s associated <code>Nonce</code>, marking
increased block height.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ElectionProof</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The VRFProof is generated by running our VRF on a past ticket in the ticket chain
</span><span class="c1"></span>    <span class="c1">// signed with the miner&#39;s keypair. This field is 97 bytes long (may be compressible
</span><span class="c1"></span>    <span class="c1">// to 80).
</span><span class="c1"></span>    <span class="nx">VRFProof</span> <span class="nx">Bytes</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<h3 id="message">Message</h3>

<p><code>Message</code> data structures in Filecoin describe operations that can be performed on the Filecoin VM state
(e.g., FIL transactions between accounts).
To facilitate the process of producing secure protocol implementations,
we explicitly distinguish between
<a href="./#algorithms__crypto__signatures">signed and unsigned</a> <code>Message</code> structures.</p>

<p><div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Message</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">UnsignedMessage</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">SignedMessage</span> <span class="mi">1</span>
<span class="p">}</span> <span class="c1">// representation keyed
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UnsignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">to</span> <span class="nx">Address</span>
    <span class="nx">from</span> <span class="nx">Address</span>

    <span class="c1">// When receiving a message from a user account the nonce in the message must match
</span><span class="c1"></span>    <span class="c1">// the expected nonce in the &#34;from&#34; actor. This prevents replay attacks.
</span><span class="c1"></span>    <span class="nx">nonce</span> <span class="nx">UInt</span>
    <span class="nx">value</span> <span class="nx">UInt</span>

    <span class="nx">gasPrice</span> <span class="nx">UInt</span>
    <span class="nx">gasLimit</span> <span class="nx">UInt</span>

    <span class="nx">method</span> <span class="nx">Uint</span>
    <span class="nx">params</span> <span class="nx">Bytes</span>  <span class="c1">// Serialized parameters to the method.
</span><span class="c1"></span><span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">message</span>   <span class="nx">UnsignedMessage</span>
    <span class="nx">signature</span> <span class="nx">Signature</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">MessageReceipt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">exitCode</span> <span class="nx">UInt</span>
    <span class="nx">returnValue</span> <span class="nx">Bytes</span>
    <span class="nx">gasUsed</span> <span class="nx">UInt</span>
<span class="p">}</span> <span class="c1">// representation tuple
</span></code></pre></div>
  
</div>
</p>

<h3 id="state-tree">State Tree</h3>

<p>The state tree keeps track of the entire state of the <a href="./#systems__filecoin_vm">VM - Virtual Machine</a> at any given point.
It is a map from <code>Address</code> structures to <code>Actor</code> structures, where each <code>Actor</code>
may also contain some additional <code>ActorState</code> that is specific to a given actor
type.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">StateTree</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Address</span><span class="p">]</span><span class="nx">Actor</span>
</code></pre></div>
  
</div>


<h3 id="actor">Actor</h3>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Actor</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// CID of the code object for this actor
</span><span class="c1"></span>    <span class="nx">code</span> <span class="nx">CID</span>

    <span class="c1">// Reference to the root of this actor&#39;s state
</span><span class="c1"></span>    <span class="nx">head</span> <span class="o">&amp;</span><span class="nx">ActorState</span>

    <span class="c1">// Counter of the number of messages this actor has sent
</span><span class="c1"></span>    <span class="nx">nonce</span> <span class="nx">UInt</span>

    <span class="c1">// Current Filecoin balance of this actor
</span><span class="c1"></span>    <span class="nx">balance</span> <span class="nx">UInt</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<h3 id="signature">Signature</h3>

<p><a href="./#algorithms__crypto__signatures">Cryptographic signatures</a> in Filecoin are represented
as byte arrays, and come with a tag that signifies what key type was used to create
the signature.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Signature</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">Secp256k1Signature</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">Bls12_381Signature</span> <span class="mi">1</span>
<span class="p">}</span> <span class="c1">// representation byteprefix
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Secp256k1Signature</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">Bls12_381Signature</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<h3 id="faultset">FaultSet</h3>

<p><code>FaultSet</code> data structures are used to denote which sectors failed at which block heights.</p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FaultSet</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">index</span>    <span class="nx">UInt</span>
    <span class="nx">bitField</span> <span class="nx">BitField</span>
<span class="p">}</span>
</code></pre></div>
  
</div>


<p>In order to make the serialization more compact,
the <code>index</code> field denotes a block height offset from the start of the corresponding
miner&rsquo;s proving period.</p>

<h3 id="basic-types">Basic Types</h3>

<h4 id="cid">CID</h4>

<p>For most objects referenced by Filecoin, a Content Identifier (CID for short) is used.
This is effectively a hash value, prefixed with its hash function (multihash)
as well as extra labels to inform applications about how to deserialize the given data.
For a more detailed specification, we refer the reader to the
<a href="https://github.com/ipld/cid">IPLD repository</a>.</p>

<h4 id="timestamp">Timestamp</h4>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Timestamp</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>


<h4 id="publickey">PublicKey</h4>

<p>The public key type is simply an array of bytes.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PublicKey</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="bytesamount">BytesAmount</h4>

<p>BytesAmount is just a re-typed Integer.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">BytesAmount</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>
</p>

<h4 id="peerid">PeerId</h4>

<p>The serialized bytes of a libp2p peer ID.
<div class="notices todo">
  <strong>TODO</strong>:  Spec incomplete; take a look at <a href="https://github.com/libp2p/specs/pull/100">this PR</a>.
</div></p>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PeerId</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<h4 id="bitfield">Bitfield</h4>

<p>Bitfields are a set encoded using a custom run length encoding: RLE+.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Bitfield</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="sectorset">SectorSet</h4>

<p>A sector set stores a mapping of sector IDs to the respective <code>commR</code>s.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SectorSet</span> <span class="kd">map</span><span class="p">[</span><span class="nx">SectorID</span><span class="p">]</span><span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<div class="notices todo">
  <strong>TODO</strong>: 
Improve on this; see https://github.com/filecoin-project/specs/issues/116.

</div>

<h4 id="sealproof">SealProof</h4>

<p>SealProof is an opaque, dynamically-sized array of bytes.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SealProof</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="postproof">PoSTProof</h4>

<p>PoSTProof is an opaque, dynamically-sized array of bytes.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">PoSTProof</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>
</p>

<h4 id="tokenamount">TokenAmount</h4>

<p>A type to represent an amount of Filecoin tokens.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">TokenAmount</span> <span class="nx">UInt</span>
</code></pre></div>
  
</div>
</p>

<h4 id="sectorid">SectorID</h4>

<p>Uniquely identifies a miner&rsquo;s sector.
<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">SectorID</span> <span class="kt">uint64</span>
</code></pre></div>
  
</div>
</p>

<h3 id="rle-bitset-encoding">RLE+ Bitset Encoding</h3>

<p>RLE+ is a lossless compression format based on <a href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE</a>.
Its primary goal is to reduce the size in the case of many individual bits, where RLE breaks down quickly,
while keeping the same level of compression for large sets of contiugous bits.</p>

<p>In tests it has shown to be more compact than RLE itself, as well as <a href="https://arxiv.org/pdf/1004.0403.pdf">Concise</a> and <a href="https://roaringbitmap.org/">Roaring</a>.</p>

<h4 id="format">Format</h4>

<p>The format consists of a header, followed by a series of blocks, of which there are three different types.</p>

<p>The format can be expressed as the following <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> grammar.</p>

<pre><code>    &lt;encoding&gt; ::= &lt;header&gt; &lt;blocks&gt;
      &lt;header&gt; ::= &lt;version&gt; &lt;bit&gt;
     &lt;version&gt; ::= &quot;00&quot;
      &lt;blocks&gt; ::= &lt;block&gt; &lt;blocks&gt; | &quot;&quot;
       &lt;block&gt; ::= &lt;block_single&gt; | &lt;block_short&gt; | &lt;block_long&gt;
&lt;block_single&gt; ::= &quot;1&quot;
 &lt;block_short&gt; ::= &quot;01&quot; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt;
  &lt;block_long&gt; ::= &quot;00&quot; &lt;unsigned_varint&gt;
         &lt;bit&gt; ::= &quot;0&quot; | &quot;1&quot;
</code></pre>

<p>An <code>&lt;unsigned_varint&gt;</code> is defined as specified <a href="https://github.com/multiformats/unsigned-varint">here</a>.</p>

<h5 id="header">Header</h5>

<p>The header indicates the very first bit of the bit vector to encode. This means the first bit is always
the same for the encoded and non-encoded form.</p>

<h5 id="blocks">Blocks</h5>

<p>The blocks represent how many bits, of the current bit type there are. As <code>0</code> and <code>1</code> alternate in a bit vector
the inital bit, which is stored in the header, is enough to determine if a length is currently referencing
a set of <code>0</code>s, or <code>1</code>s.</p>

<h6 id="block-single">Block Single</h6>

<p>If the running length of the current bit is only <code>1</code>, it is encoded as a single set bit.</p>

<h6 id="block-short">Block Short</h6>

<p>If the running length is less than <code>16</code>, it can be encoded into up to four bits, which a short block
represents. The length is encoded into a 4 bits, and prefixed with <code>01</code>, to indicate a short block.</p>

<h6 id="block-long">Block Long</h6>

<p>If the running length is <code>16</code> or larger, it is encoded into a varint, and then prefixed with <code>00</code> to indicate
a long block.</p>

<blockquote>
<p><strong>Note:</strong> The encoding is unique, so no matter which algorithm for encoding is used, it should produce
the same encoding, given the same input.</p>
</blockquote>

<h6 id="bit-numbering">Bit Numbering</h6>

<p>For Filecoin, byte arrays representing RLE+ bitstreams are encoded using <a href="https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering">LSB 0</a> bit numbering.</p>

<h3 id="other-considerations">Other Considerations</h3>

<ul>
<li>The maximum size of an Object should be 1MB (2^20 bytes). Objects larger than this are invalid.</li>
<li>Hashes should use a blake2b-256 multihash.</li>
</ul>


</div>



</div>

  

  
    








<div id="listings__system_map">

<h2 class="section-header">
  Components
</h2>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="listings__libp2p_protocols">

<h2 class="section-header">
  libp2p Protocols
</h2>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  


</div>

  

  
    








<div id="glossary">

<h1 class="section-header">
  Glossary
</h1>

<div class="section-content">






































<h2 id="updates-to-definitions">Updates to definitions</h2>

<p>To make any updates to these definitions please submit a pull request with the changes, or open an issue and one of the maintainers will do it for you.</p>

<h2 id="notes">Notes</h2>

<ul>
<li>Want to split all repair stuff to separate doc</li>
<li>Let&rsquo;s refer to Filecoin system rather than network. In a sense, the network is an instantiation of the system (this protocol). We can however refer to the Filecoin VM separately which means the system by which we apply changes to the state of the system at a point in time.</li>
<li>Asterisks indicate that the definition requires updating by any affected party.</li>
</ul>

<h2 id="definitions">Definitions</h2>

<h3 id="actor">Actor</h3>

<p>An actor is an on-chain object with its own state and set of methods. An actors state is persisted on-chain in the state tree, keyed by its address. All actors (miner actors, the storage market actor, account actors) have an address. Actors methods are invoked by crafting messages and getting miners to include them in blocks.</p>

<p>Actors are very similar to smart contracts in Ethereum.</p>

<h3 id="address">Address</h3>

<p>An address is an identifier that refers to an actor in the Filecoin state.</p>

<h3 id="ask">Ask</h3>

<h3 id="bid">Bid</h3>

<h3 id="block">Block</h3>

<p>A block in the Filecoin blockchain is a chunk of data appended to the shared history of the network including transactions, messages, etc. and representing the state of the storage network at a given point in time.</p>

<p>See [Data Structures]()</p>

<h3 id="bootstrapping">Bootstrapping</h3>

<h3 id="chain-weight">Chain weight</h3>

<h3 id="challenge-sampling">Challenge sampling</h3>

<h3 id="cid">Cid</h3>

<p>CID is short for Content Identifier, a self describing content address used throughout the ipfs ecosystem. For more detailed information, see <a href="https://github.com/ipld/cid">the github documentation for it</a>.</p>

<h3 id="client">Client</h3>

<p>A client is any user with an account who wishes to store data with a miner. A client&rsquo;s account is used to pay for the storage, and helps to prove the clients ability to pay.</p>

<h3 id="collateral">Collateral</h3>

<p>Collateral is Filecoin tokens pledged by an actor as a commitment to a promise. If the promise is respected, the collateral is returned. If the promise is broken, the collateral is not returned in full. For instance:</p>

<ul>
<li>In becoming a Filecoin storage miner: the miner will put up collateral alongside their SEAL to</li>
<li>In a Filecoin deal: both the miner and client put up collateral to ensure their respect of deal terms.</li>
</ul>

<h3 id="commitment">Commitment</h3>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h3 id="confirmation">Confirmation</h3>

<h3 id="consensus">Consensus</h3>

<h3 id="deal">Deal</h3>

<p>*** *A deal in a Filecoin market is made when a bid and ask are matched, corresponding to an agreement on a service and price between a miner and client.</p>

<h3 id="election-proof">Election Proof</h3>

<p>An <code>ElectionProof</code> is derived from a past <code>ticket</code> and is included in every block header. The <code>ElectionProof</code> proves that the miner was eligible to mine a block at that <code>height</code>.</p>

<h3 id="erasure-coding">Erasure coding</h3>

<p>Erasure coding is a strategy through which messages can be lengthened so as to be made recoverable in spite of errors.</p>

<p>See <a href="https://en.wikipedia.org/wiki/Erasure_code">Wikipedia</a></p>

<h3 id="fault">Fault</h3>

<p>A fault occurs when a proof is not posted in the Filecoin system within the proving period, denoting another malfunction such as loss of network connectivity, storage malfunction, malicious miner, etc.</p>

<h3 id="fair">Fair</h3>

<h3 id="file">File</h3>

<p>Files are what clients bring to the filecoin system to store. A file is split up into <code>pieces</code>, which are what is actually stored by the network.</p>

<h3 id="finality">Finality</h3>

<h3 id="piece-inclusion-proof">Piece Inclusion Proof</h3>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h3 id="gas-fees-prices">Gas, Fees, Prices</h3>

<h3 id="generation-attack-threshold">Generation Attack Threshold</h3>

<p>Security parameter. Number of rounds within which a new Proof-of-Storage must be submitted in order for a miner to retain power in the network (and avoid getting slashed). This number must be be smaller than the minimum time it takes for an adversarial miner to generate a replica of the data (thereby not storing it undetectably for some period of time).</p>

<p>The Generation Attack Threshold is equal to the Polling Time + some Grace Period after which miners get slashed.</p>

<h3 id="ghost">GHOST</h3>

<p><a href="https://eprint.iacr.org/2013/881.pdf">GHOST</a> is an acronym for <code>Greedy Heaviest Observable SubTree</code>, a class of blockchain structures in which multiple blocks can validly be included in the chain at any given height or round. GHOSTy protocols produce blockDAGs rather than blockchains and use a weighting function for fork selection, rather than simply picking the longest chain.</p>

<h3 id="height">Height</h3>

<p><code>Height</code> and <code>round</code> are synonymous and used interchangeably in this spec.</p>

<p><code>Height</code> refers to the number of tickets generated between this <code>TipSet</code> and the genesis block (height 0), counting only the tickets of the block in a TipSet whose final ticket &ndash; the one generated alongside the <code>ElectionProof</code> &ndash; is the smallest.</p>

<p>If a <code>TipSet</code> contains multiple blocks, each block in the TipSet will have the same <code>height</code>. Put another way, there is a new <code>round</code> of leader election attempts at each <code>height</code>. Typically, such an attempt will find a single leader. If a single leader is found, that leader can generate a single block. If multiple leaders are found, they can each generate multiple blocks in the given round. If no leader is found, no block is generated (but a ticket is).</p>

<h3 id="leader">Leader</h3>

<p>A leader, in the context of Filecoin consensus, is a node that is chosen to propose the next block in the blockchain.</p>

<h3 id="leader-election">Leader election</h3>

<p>Leader election is the process by which the Filecoin network agrees who gets to create the next block.</p>

<h3 id="message">Message</h3>

<p>A message is a call to an actor in the Filecoin VM.</p>

<h3 id="miner">Miner</h3>

<p>A miner is an actor in the Filecoin system performing a service in the network for a reward.</p>

<p>There are multiple types of miners in Filecoin:</p>

<ul>
<li>Storage miners - storage miners</li>
<li>Retrieval miners:</li>
<li>Repair miners (to be split out):</li>
</ul>

<h3 id="node">Node</h3>

<p>*** *A node is a communication endpoint that implements the Filecoin protocol. (also mention IPLD Node?)</p>

<h3 id="on-chain-off-chain">On-chain/off-chain</h3>

<h3 id="online-offline">Online/offline</h3>

<h3 id="payment-channel">Payment Channel</h3>

<p>A payment channel is set up between actors in the Filecoin system to enable off-chain payments with on-chain guarantees, making settlement more efficient.</p>

<h3 id="piece">Piece</h3>

<p>A piece is a portion of a file that gets fitted into a sector.</p>

<h3 id="pledge">Pledge</h3>

<p>****The initial commitment of a storage miner to provide a number of sectors to the system.</p>

<h3 id="polling-time">Polling Time</h3>

<p>Security Parameter. Polling time is the time between two online PoReps in a PoSt proof.</p>

<h3 id="power">Power</h3>

<p>See <code>Power Fraction</code>.</p>

<h3 id="power-fraction">Power Fraction</h3>

<p>A miner&rsquo;s <code>Power Fraction</code> or <code>Power</code> is the ratio of their committed storage as of their last PoSt submission over Filecoin&rsquo;s total committed storage as of the current block. It is used in leader election.</p>

<h3 id="power-table">Power table</h3>

<p>The power table is an abstraction provided by the Filecoin storage market that lists the <code>power</code> of every miner in the system.</p>

<h3 id="protocol">Protocol</h3>

<h3 id="proving-period">Proving Period</h3>

<p>The period of time during which storage miners must compute Proofs of Spacetime. At the end of the period they must submit their PoSt. Put another way, it is the duration of a PoSt.</p>

<h3 id="proving-set">Proving Set</h3>

<p>The elements used as input by a proof of Spacetime to enable a proof to be generated.</p>

<p>**** elements necessary to generate a SEAL, or elements necessary to generate a proof</p>

<h3 id="proof-of-replication">Proof of Replication</h3>

<p>Proof that a unique encoding of data exists in physical storage.</p>

<p>Used in the Filecoin system to generate SEALed sectors through which storage miners prove they hold client data.</p>

<h3 id="proof-of-spacetime">Proof of Spacetime</h3>

<p>Proof that a given encoding of data existed in physical storage continuously over a period of time.</p>

<p>Used in the Filecoin system by a storage miner to prove that client data was kept over the contract duration.</p>

<h3 id="random-ness">Random(ness)</h3>

<p>****Source of unpredictability used in the Filecoin system to ensure fairness and prevent malicious actors from gaining an advantage over the system.</p>

<p>TODO add a note to distinguish predictability from randomness</p>

<h3 id="election-randomness-lookback">Election Randomness Lookback</h3>

<p>Security parameter. A number of rounds to sample back from when choosing randomness for use in leader election. A higher number turns a more localized lottery into a more global one since a miner wins or loses on all descendants of a given randomness, but enables miners to look-ahead and know whether they will be elected in the future.</p>

<p>Also referred to as <code>K</code> in consensus settings.</p>

<h3 id="repair">Repair</h3>

<p>Repair refers to the processes and protocols by which the Filecoin network ensures that data that is partially lost (by, for example, a miner disappearing) can be re-constructed and re-added to the network.</p>

<h3 id="round">Round</h3>

<p>See <code>Height</code> for definition. They are synonymous.</p>

<h3 id="seal-unseal">SEAL/UNSEAL</h3>

<p>See <a href="proofs.md">Filecoin Proofs</a></p>

<h3 id="sector">Sector</h3>

<p>A sector is a contiguous array of bytes that a miner puts together, seals, and performs Proofs of Spacetime on.</p>

<h3 id="slashing">Slashing</h3>

<h3 id="smart-contracts">Smart contracts</h3>

<h3 id="storage">Storage</h3>

<p>Storage widely refers to a place in which to store data in a given system.</p>

<p>In the context of:</p>

<ul>
<li>The Filecoin miner: sotrage refers to disk sectors made available to the network.</li>
<li>The Filecoin chain: storage refers to the way in which system state is tracked through time on-chain through blocks.</li>
<li>Actor: the struct that defines an actor.</li>
</ul>

<h3 id="state">State</h3>

<p>****Refers to The shared history of the Filecoin system contains actors and their storage, deals, etc. State is deterministically generated from the initial state and the set of messages generated by the system.</p>

<h3 id="ticket">Ticket</h3>

<p>A <code>ticket</code> is used as a source of randomness in EC leader election. Every block depends on an <code>ElectionProof</code> derived from a <code>ticket</code>. At least one new <code>ticket</code> is produced with every new block. Ticket creation is described <a href="./expected-consensus.md#Ticket-generation">here</a>.</p>

<h3 id="ticket-chain">Ticket Chain</h3>

<p>Each chain in Filecoin can be associated to a given <code>ticket chain</code>. The <code>ticket chain</code> is assembled by taking the tickets (usually one) contained by the block with the smallest final ticket in each of the chain&rsquo;s <code>TipSet</code>s.</p>

<p>Ticket comparison is done by interpreting the tickets&rsquo; Bytes as unsigned integers (little endian representation).</p>

<h3 id="tipset">TipSet</h3>

<p>A <code>TipSet</code> is a set of blocks that have the same parent set and same number of <code>tickets</code>, which implies they will have been mined at the same <code>height</code>. A <code>TipSet</code> can contain multiple blocks if more than one miner successfully mines a block at the same <code>height</code> as another miner.</p>

<h3 id="verifiable">Verifiable</h3>

<p>Something that is verifiable can be checked for correctness by a third party.</p>

<h3 id="vdf">VDF</h3>

<p>A verifiable function that guarantees a time delay given some hardware assumptions and a small set of requirements. These requirements are efficient proof verification, random output, and strong sequentiality. Verifiable delay functions are formally defined by [[BBBF]](<a href="https://eprint.iacr.org/2018/601">https://eprint.iacr.org/2018/601</a>).</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;‚Äî- VDF(public parameters, seed)</code></pre></div>
<h3 id="vm">VM</h3>

<p>Virtual Machine. The Filecoin VM refers to the system by which changes are applied to the Filecoin system&rsquo;s state. The VM takes messages as input, and outputs state.</p>

<h3 id="voucher">Voucher</h3>

<p>Held by an actor as part of a payment channel to complete settlement when the counterparty defaults.</p>

<h3 id="vrf">VRF</h3>

<p>A verifiable random function that receives {Secret Key (SK), seed} and outputs {proof of correctness, output value}. VRFs must yield a proof of correctness and a unique &amp; efficiently verifiable output.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;-- VRF(SK, seed)</code></pre></div>
<h3 id="weight">Weight</h3>

<p>Every mined block has a computed <code>weight</code>. Together, the <code>weights</code> of all the blocks in a branch of the chain determines the cumulative <code>weight</code> of that branch. Filecoin&rsquo;s Expected Consensus is a GHOSTy or heaviest-chain protocol, where chain selection is done on the basis of an explicit weighting function. Filecoin‚Äôs <code>weight</code> function currently seeks to incentivize collaboration amongst miners as well as the addition of storage to the network. The specific weighting function is defined in <a href="expected-consensus.md#chain-weighting">Chain Weighting</a>.</p>

<h3 id="zksnark">zkSNARK</h3>

<p>Zero Knowledge Succinct ARguments of Knowledge. A way of producing a small &lsquo;proof&rsquo; that convinces a &lsquo;verifier&rsquo; that some computation was done correctly.</p>


</div>



</div>

  

  
    








<div id="appendix">

<h1 class="section-header">
  Appendix
</h1>

<div class="section-content">






































</div>


  
    








<div id="appendix__sharray">

<h2 class="section-header">
  Sharded IPLD Array
</h2>

<div class="section-content">






































<p>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.</p>

<h3 id="ipld-representation">IPLD Representation</h3>

<p>Each sharray node is represented by an IPLD node of the following schema:</p>

<pre><code>type Node struct {
  height Int
  items [Item]
} representation tuple
</code></pre>

<p><code>Item</code> may be either a direct value, if <code>height == 0</code>, or the Cid of a child node if <code>height &gt; 0</code>.</p>

<p>(For details on IPLD Schemas, see the <a href="https://github.com/ipld/specs/blob/dcbfb25468092be796bab90e90e3f2535fdeddc7/schema/representations.md">IPLD Schema Spec (draft)</a>)</p>

<p>We use DAG-CBOR for serialization, and blake2b-256 for hashing.</p>

<h3 id="construction">Construction</h3>

<p>The tree must not be sparse.
Given an array of size <code>N</code> and a fixed width of <code>W</code>.
- The left <code>floor(N/W)</code> leaves contain the first <code>N</code> items.
- If <code>N % W != 0</code> the final leaf contains the final remainder.
- The tree is perfectly balanced.
- The height is the distance from the leaves, not the root.
- Leaves (nodes with a height of 0) contain array values.
- Inner nodes (nodes with height greater than zero) contain the cids of their child nodes.</p>

<h3 id="operations">Operations</h3>

<h4 id="create-items"><code>create(items)</code></h4>

<blockquote>
<p>Create a sharray from a given set of items</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">create</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="nx">Item</span><span class="p">)</span> <span class="nx">Cid</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">layer</span> <span class="nx">cidQueue</span>

	<span class="nx">itemQ</span> <span class="o">:=</span> <span class="nf">queue</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">!</span><span class="nx">itemQ</span><span class="p">.</span><span class="nf">Empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// get the next &#39;Width&#39; items from the input items
</span><span class="c1"></span>		<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">itemQ</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

		<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
			<span class="nx">height</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="c1">// persist the node to the datastore
</span><span class="c1"></span>		<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

		<span class="nx">layer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">nextLayer</span> <span class="nx">cidQueue</span>
	<span class="k">for</span> <span class="nx">height</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">height</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

			<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
				<span class="nx">height</span><span class="p">:</span> <span class="nx">height</span><span class="p">,</span>
				<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
			<span class="p">}</span>

			<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

			<span class="nx">nextLayer</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">layer</span> <span class="p">=</span> <span class="nx">nextLayer</span>
		<span class="nx">nextLayer</span><span class="p">.</span><span class="nf">ClearItems</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nextLayer</span><span class="p">.</span><span class="nf">First</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
<h4 id="get-i"><code>get(i)</code></h4>

<blockquote>
<p>Get the element at index <code>i</code></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">node</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">childWidth</span> <span class="o">:=</span> <span class="nf">Pow</span><span class="p">(</span><span class="nx">Width</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>

	<span class="nx">child</span> <span class="o">:=</span> <span class="nf">loadNode</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="nx">childWidth</span><span class="p">])</span>
	<span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="nx">childWidth</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>

</div>



</div>

  

  
    








<div id="appendix__address">

<h2 class="section-header">
  Address
</h2>

<div class="section-content">






































<p>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</p>

<h3 id="design-criteria">Design criteria</h3>

<ol>
<li><strong>Identifiable</strong>: The address must be easily identifiable as a Filecoin address.</li>
<li><strong>Reliable</strong>: Addresses must provide a mechanism for error detection when they might be transmitted outside the network.</li>
<li><strong>Upgradable</strong>: Addresses must be versioned to permit the introduction of new address formats.</li>
<li><strong>Compact</strong>: Given the above constraints, addresses must be as short as possible.</li>
</ol>

<h3 id="specification">Specification</h3>

<p>There are 2 ways a filecoin address can be represented. An address appearing on chain will always be formatted as raw bytes. An address may also be encoded to a string, this encoding includes a checksum and network prefix. An address encoded as a string will never appear on chain, this format is used for sharing among humans.</p>

<h4 id="bytes">Bytes</h4>

<p>When represented as bytes a filecoin address contains the following:</p>

<ul>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>

<li><p>The <strong>payload</strong> used to uniquely identify the actor according to the protocol.</p>

<pre><code>|----------|---------|
| protocol | payload |
|----------|---------|
|  1 byte  | n bytes |
</code></pre></li>
</ul>

<h4 id="string">String</h4>

<p>When encoded to a string a filecoin address contains the following:</p>

<ul>
<li>A <strong>network prefix</strong> character that identifies the network the address belongs to.</li>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>
<li>A <strong>payload</strong> used to uniquely identify the actor according to the protocol.</li>

<li><p>A <strong>checksum</strong> used to validate the address.</p>

<pre><code>|------------|----------|---------|----------|
|  network   | protocol | payload | checksum |
|------------|----------|---------|----------|
| 'f' or 't' |  1 byte  | n bytes | 4 bytes  |
</code></pre></li>
</ul>

<div>
  
    <div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Address</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="p">|</span> <span class="nx">AddressId</span> <span class="mi">0</span>
    <span class="p">|</span> <span class="nx">AddressSecp256k1</span> <span class="mi">1</span>
    <span class="p">|</span> <span class="nx">AddressActor</span> <span class="mi">2</span>
    <span class="p">|</span> <span class="nx">AddressBLS12_381</span> <span class="mi">3</span>
<span class="p">}</span> <span class="c1">// representation byteprefix
</span><span class="c1"></span>
<span class="c1">// ID
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressId</span> <span class="nx">UInt</span>

<span class="c1">// Blake2b-160 Hash
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressSecp256k1</span> <span class="nx">Bytes</span>

<span class="c1">// Blake2b-160 Hash
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressActor</span> <span class="nx">Bytes</span>

<span class="c1">// 48 byte PublicKey
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AddressBLS12_381</span> <span class="nx">Bytes</span>
</code></pre></div>
  
</div>


<h4 id="network-prefix">Network Prefix</h4>

<p>The <strong>network prefix</strong> is prepended to an address when encoding to a string. The network prefix indicates which network an address belongs in. The network prefix may either be <code>f</code> for filecoin mainnet or <code>t</code> for filecoin testnet. It is worth noting that a network prefix will never appear on chain and is only used when encoding an address to a human readable format.</p>

<h4 id="protocol-indicator">Protocol Indicator</h4>

<p>The <strong>protocol indicator</strong> byte describes how a method should interpret the information in the payload field of an address. Any deviation for the algorithms and data types specified by the protocol must be assigned a new protocol number. In this way, protocols also act as versions.</p>

<ul>
<li><code>0</code> : ID</li>
<li><code>1</code> : SECP256K1 Public Key</li>
<li><code>2</code> : Actor</li>
<li><code>3</code> : BLS Public Key</li>
</ul>

<p>An example description in golang:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Protocol byte
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kt">byte</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">ID</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">SECP256K1</span>
	<span class="nx">Actor</span>
	<span class="nx">BLS</span>
<span class="p">)</span></code></pre></div>
<h5 id="protocol-0-ids">Protocol 0: IDs</h5>

<p><strong>Protocol 0</strong> addresses are simple IDs.  All actors have a numeric ID even if they don&rsquo;t have public keys. The payload of an ID address is base10 encoded. IDs are not hashed and do not have a checksum.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------|
| protocol |    payload    |
|----------|---------------|
|    0     | leb128-varint |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------|
|  network   | protocol |    payload    |
|------------|----------|---------------|
| 'f' or 't' |    '0'   | leb128-varint |
                  base10[...............]
</code></pre>

<h5 id="protocol-1-libsecpk1-elliptic-curve-public-keys">Protocol 1: libsecpk1 Elliptic Curve Public Keys</h5>

<p><strong>Protocol 1</strong> addresses represent secp256k1 public encryption keys. The payload field contains the <a href="https://blake2.net/">Blake2b 160</a> hash of the public key.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    1     | blake2b-160(PubKey) |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '1'   | blake2b-160(PubKey) |  4 bytes |
                  base32[................................]
</code></pre>

<h5 id="protocol-2-actor">Protocol 2: Actor</h5>

<p><strong>Protocol 2</strong> addresses representing an Actor. The payload field contains the <a href="https://blake2.net/">Blake2b 160</a> hash of meaningful data produced as a result of creating the actor.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    2     | blake2b-160(Random) |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|-----------------------|----------|
|  network   | protocol |         payload       | checksum |
|------------|----------|-----------------------|----------|
| 'f' or 't' |    '2'   |  blake2b-160(Random)  |  4 bytes |
                  base32[..................................]
</code></pre>

<h5 id="protocol-3-bls">Protocol 3: BLS</h5>

<p><strong>Protocol 3</strong> addresses represent BLS public encryption keys. The payload field contains the BLS public key.</p>

<p><strong>Bytes</strong></p>

<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    3     | 48 byte BLS PubKey  |
</code></pre>

<p><strong>String</strong></p>

<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '3'   |  48 byte BLS PubKey |  4 bytes |
                  base32[................................]
</code></pre>

<h4 id="payload">Payload</h4>

<p>The payload represents the data specified by the protocol. All payloads except the payload of the ID protocol are <a href="https://tools.ietf.org/html/rfc4648#section-6">base32</a> encoded using the lowercase alphabet when seralized to their human readable format.</p>

<h4 id="checksum">Checksum</h4>

<p>Filecoin checksums are calculated over the address protocol and payload using blake2b-4. Checksums are base32 encoded and only added to an address when encoding to a string. Addresses following the ID Protocol do not have a checksum.</p>

<h4 id="expected-methods">Expected Methods</h4>

<p>All implementations in Filecoin must have methods for creating, encoding, and decoding addresses in addition to checksum creation and validation. The follwing is a golang version of the Address Interface:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span>

<span class="kd">type</span> <span class="nx">Address</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="nx">Network</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Adress</span><span class="p">)</span> <span class="kt">string</span>
	<span class="nf">Decode</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span>
	<span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span></code></pre></div>
<h5 id="new">New()</h5>

<p>New returns an Address for the specified protocol encapsulating corresponding payload. New fails for unknown protocols.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="p">&lt;</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="p">&gt;</span> <span class="nx">BLS</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownType</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="encode">Encode()</h5>

<p>Software encoding a Filecoin address must:</p>

<ul>
<li>produce an address encoded to a known network</li>
<li>produce an address encoded to a known protocol</li>
<li>produce an address with a valid checksum (if applicable)</li>
</ul>

<p>Encodes an Address as a string, prepending the network prefix, calculating the checksum, and encoding the payload and checksum to <a href="https://tools.ietf.org/html/rfc4648">base32</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Invalid Network&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SECP256K1</span><span class="p">,</span> <span class="nx">Actor</span><span class="p">,</span> <span class="nx">BLS</span><span class="p">:</span>
		<span class="nx">cksm</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="o">+</span><span class="nx">cksm</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">ID</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base10</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">leb128</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid address protocol&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="decode">Decode()</h5>

<p>Software decoding a Filecoin address must:
* verify the network is a known network.
* verify the protocol is a number of a known protocol.
* verify the checksum is valid</p>

<p>Decode an Address from a string by removing the network prefix, validating the address is of a know protocol, decoding the payload and checksum, and validating the checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">3</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidLength</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownNetwork</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">protocol</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">raw</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">ID</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
			<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
			<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">leb128</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">base10</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">raw</span> <span class="p">=</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span>
	<span class="nx">payload</span> <span class="p">=</span> <span class="nx">raw</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">Actor</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidBytes</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">cksm</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">:]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">cksm</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidChecksum</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
<h5 id="checksum-1">Checksum()</h5>

<p>Checksum produces a byte array by taking the blake2b-4 hash of an address protocol and payload.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nf">blake2b4</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
<h5 id="validatechecksum">ValidateChecksum()</h5>

<p>ValidateChecksum returns true if the Checksum of data matches the expected checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">expected</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">digest</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">digest</span> <span class="o">==</span> <span class="nx">expected</span>
<span class="p">}</span></code></pre></div>
<h3 id="test-vectors">Test Vectors</h3>

<p>These are a set of test vectors that can be used to test an implementation of
this address spec. Test vectors are presented as newline-delimited address/hex
fields. The &lsquo;address&rsquo; field, when parsed, should produce raw bytes that match
the corresponding item in the &lsquo;hex&rsquo; field. For example:</p>

<pre><code>address1
hex1

address2
hex2
</code></pre>

<h4 id="id-type-addresses">ID Type Addresses</h4>

<pre><code>f00
0000

f0150
009601

f01024
008008

f01729
00c10d

f018446744073709551615
00ffffffffffffffffff01
</code></pre>

<h4 id="secp256k1-type-addresses">Secp256k1 Type Addresses</h4>

<pre><code>f17uoq6tp427uzv7fztkbsnn64iwotfrristwpryy
01fd1d0f4dfcd7e99afcb99a8326b7dc459d32c628

f1xcbgdhkgkwht3hrrnui3jdopeejsoatkzmoltqy
01b882619d46558f3d9e316d11b48dcf211327026a

f1xtwapqc6nh4si2hcwpr3656iotzmlwumogqbuaa
01bcec07c05e69f92468e2b3e3bf77c874f2c5da8c

f1wbxhu3ypkuo6eyp6hjx6davuelxaxrvwb2kuwva
01b06e7a6f0f551de261fe3a6fe182b422ee0bc6b6

f12fiakbhe2gwd5cnmrenekasyn6v5tnaxaqizq6a
01d1500504e4d1ac3e89ac891a4502586fabd9b417
</code></pre>

<h4 id="actor-type-addresses">Actor Type Addresses</h4>

<pre><code>f24vg6ut43yw2h2jqydgbg2xq7x6f4kub3bg6as6i
02e54dea4f9bc5b47d261819826d5e1fbf8bc5503b

f25nml2cfbljvn4goqtclhifepvfnicv6g7mfmmvq
02eb58bd08a15a6ade19d0989674148fa95a8157c6

f2nuqrg7vuysaue2pistjjnt3fadsdzvyuatqtfei
026d21137eb4c4814269e894d296cf6500e43cd714

f24dd4ox4c2vpf5vk5wkadgyyn6qtuvgcpxxon64a
02e0c7c75f82d55e5ed55db28033630df4274a984f

f2gfvuyh7v2sx3patm5k23wdzmhyhtmqctasbr23y
02316b4c1ff5d4afb7826ceab5bb0f2c3e0f364053
</code></pre>

<h4 id="bls-type-addresses">BLS Type Addresses</h4>

<p>To aid in readability, these addresses are line-wrapped. Address and hex pairs
are separated by <code>---</code>.</p>

<pre><code>f3vvmn62lofvhjd2ugzca6sof2j2ubwok6cj4xxbfzz
4yuxfkgobpihhd2thlanmsh3w2ptld2gqkn2jvlss4a
---
03ad58df696e2d4e91ea86c881e938ba4ea81b395e12
797b84b9cf314b9546705e839c7a99d606b247ddb4f9
ac7a3414dd

f3wmuu6crofhqmm3v4enos73okk2l366ck6yc4owxwb
dtkmpk42ohkqxfitcpa57pjdcftql4tojda2poeruwa
---
03b3294f0a2e29e0c66ebc235d2fedca5697bf784af
605c75af608e6a63d5cd38ea85ca8989e0efde9188b
382f9372460d

f3s2q2hzhkpiknjgmf4zq3ejab2rh62qbndueslmsdz
ervrhapxr7dftie4kpnpdiv2n6tvkr743ndhrsw6d3a
---
0396a1a3e4ea7a14d49985e661b22401d44fed402d1
d0925b243c923589c0fbc7e32cd04e29ed78d15d37d
3aaa3fe6da33

f3q22fijmmlckhl56rn5nkyamkph3mcfu5ed6dheq53
c244hfmnq2i7efdma3cj5voxenwiummf2ajlsbxc65a
---
0386b454258c589475f7d16f5aac018a79f6c1169d2
0fc33921dd8b5ce1cac6c348f90a3603624f6aeb91b
64518c2e8095

f3u5zgwa4ael3vuocgc5mfgygo4yuqocrntuuhcklf4
xzg5tcaqwbyfabxetwtj4tsam3pbhnwghyhijr5mixa
---
03a7726b038022f75a384617585360cee629070a2d9
d28712965e5f26ecc40858382803724ed34f2720336
f09db631f074
</code></pre>


</div>



</div>

  

  
    








<div id="appendix__orient">

<h2 class="section-header">
  Filecoin Parameters
</h2>

<div class="section-content">






































<h4 id="all-parameters">All Parameters</h4>

<table>
<thead>
<tr>
<th>Parameter</th>
<th>Type</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>

<tbody>
<tr>
<td>ACTOR-METHOD</td>
<td>BYTES</td>
<td>8</td>
<td>The size required to represent an actor method.</td>
</tr>

<tr>
<td>ACTORS-MESSAGES-FRACTION</td>
<td></td>
<td>0.30000004</td>
<td></td>
</tr>

<tr>
<td>ACTORS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>32.661842</td>
<td></td>
</tr>

<tr>
<td>ADDRESS-SIZE</td>
<td>BYTES</td>
<td>35</td>
<td>The size of an address.</td>
</tr>

<tr>
<td>ALL-POST-MESSAGES-PER-YEAR</td>
<td></td>
<td>122557560.0</td>
<td></td>
</tr>

<tr>
<td>ALL-SEAL-MESSAGES-PER-YEAR</td>
<td></td>
<td>335544320</td>
<td></td>
</tr>

<tr>
<td>ALL-SEAL-SIZE-PER-YEAR</td>
<td></td>
<td>335544320</td>
<td></td>
</tr>

<tr>
<td>AVG-POSTS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>11.650845</td>
<td></td>
</tr>

<tr>
<td>AVG-PROOFS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>43.549118</td>
<td></td>
</tr>

<tr>
<td>AVG-SEALS-MESSAGES-PER-BLOCK</td>
<td></td>
<td>31.898273</td>
<td></td>
</tr>

<tr>
<td>AVG-TICKETS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>BLOCK-FRAMING-SIZE</td>
<td>BYTES</td>
<td>14709.481</td>
<td>The total amount of block framing.</td>
</tr>

<tr>
<td>BLOCK-HEADER-FIXED-SIZE</td>
<td></td>
<td>420</td>
<td></td>
</tr>

<tr>
<td>BLOCK-HEADER-SIZE</td>
<td></td>
<td>1427</td>
<td></td>
</tr>

<tr>
<td>BLOCK-HEADER-VARIABLE-SIZE</td>
<td></td>
<td>1007</td>
<td></td>
</tr>

<tr>
<td>BLOCK-HEIGHT-SIZE</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>BLOCK-SIG-SIZE</td>
<td></td>
<td>96</td>
<td></td>
</tr>

<tr>
<td>BLOCK-SIZE</td>
<td></td>
<td>37265.1</td>
<td></td>
</tr>

<tr>
<td>BLOCK-SIZE-KIB</td>
<td></td>
<td>36.3917</td>
<td></td>
</tr>

<tr>
<td>BLOCK-TIME</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>BLOCKS-IN-A-YEAR</td>
<td></td>
<td>10519200.0</td>
<td></td>
</tr>

<tr>
<td>BLOCKS-IN-TEN-YEARS</td>
<td></td>
<td>105192000.0</td>
<td></td>
</tr>

<tr>
<td>BLS-AGG-SIZE</td>
<td></td>
<td>96</td>
<td></td>
</tr>

<tr>
<td>CHAIN-SIZE-YEAR</td>
<td></td>
<td>391999060000.0</td>
<td></td>
</tr>

<tr>
<td>CHAIN-SIZE-YEAR-GIB</td>
<td></td>
<td>365.07758</td>
<td></td>
</tr>

<tr>
<td>CID-SIZE</td>
<td>BYTES</td>
<td>35</td>
<td>The size of a CID.</td>
</tr>

<tr>
<td>COMM-C-CONSTRAINTS</td>
<td></td>
<td>218221140.0</td>
<td></td>
</tr>

<tr>
<td>COMM-C-OPENINGS</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>COMM-C-TIME</td>
<td></td>
<td>12924.399</td>
<td></td>
</tr>

<tr>
<td>COMM-D-CONSTRAINTS</td>
<td></td>
<td>11011791.0</td>
<td></td>
</tr>

<tr>
<td>COMM-D-OPENINGS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>COMM-D-TIME</td>
<td></td>
<td>652.18604</td>
<td></td>
</tr>

<tr>
<td>COMM-P-SIZE</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>COMM-R-CONSTRAINTS</td>
<td></td>
<td>66070744.0</td>
<td></td>
</tr>

<tr>
<td>COMM-R-OPENINGS</td>
<td></td>
<td>6</td>
<td></td>
</tr>

<tr>
<td>COMM-R-TIME</td>
<td></td>
<td>3913.1165</td>
<td></td>
</tr>

<tr>
<td>COMMIT-SIZE</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>COMMIT-TIME</td>
<td></td>
<td>14042.3955</td>
<td></td>
</tr>

<tr>
<td>CORES</td>
<td></td>
<td>16</td>
<td></td>
</tr>

<tr>
<td>DEGREE</td>
<td></td>
<td>14</td>
<td></td>
</tr>

<tr>
<td>DEGREE-BASE</td>
<td></td>
<td>6</td>
<td></td>
</tr>

<tr>
<td>DEGREE-EXPANDER</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>DELTA</td>
<td></td>
<td>0.02425</td>
<td></td>
</tr>

<tr>
<td>DRG-D</td>
<td></td>
<td><sup>1</sup>&frasl;<sub>4</sub></td>
<td></td>
</tr>

<tr>
<td>DRG-E</td>
<td></td>
<td>0.8</td>
<td></td>
</tr>

<tr>
<td>EIX</td>
<td></td>
<td>1152921504606846976</td>
<td></td>
</tr>

<tr>
<td>ELECTION-PROOF-SIZE</td>
<td></td>
<td>64</td>
<td></td>
</tr>

<tr>
<td>ENCODING-AMAX</td>
<td></td>
<td>2</td>
<td></td>
</tr>

<tr>
<td>ENCODING-TIME</td>
<td></td>
<td>6605.1006</td>
<td></td>
</tr>

<tr>
<td>ENCODING-TIME-MINS</td>
<td></td>
<td>110.08501</td>
<td></td>
</tr>

<tr>
<td>EPSILON</td>
<td></td>
<td>0.0505</td>
<td></td>
</tr>

<tr>
<td>EXIT-CODE</td>
<td>BYTES</td>
<td>4</td>
<td>The size of an exit code.</td>
</tr>

<tr>
<td>EXPECTED-WINNING-MINERS</td>
<td></td>
<td>5</td>
<td></td>
</tr>

<tr>
<td>FROM-ADDRESS</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>GAS-LIMIT</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>GAS-PRICE</td>
<td>BYTES</td>
<td>8</td>
<td>The size required to represent the gas limit.</td>
</tr>

<tr>
<td>GAS-USED</td>
<td>BYTES</td>
<td>8</td>
<td>The size required to represent the amount of gas used by a message.</td>
</tr>

<tr>
<td>GIB</td>
<td></td>
<td>1073741824</td>
<td></td>
</tr>

<tr>
<td>INCLUSION-CIRCUIT-TIME</td>
<td></td>
<td>2.3098202</td>
<td></td>
</tr>

<tr>
<td>INCLUSION-CONSTRAINTS</td>
<td></td>
<td>39000.0</td>
<td></td>
</tr>

<tr>
<td>KDF-CONTENT</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>KDF-HASH-SIZE</td>
<td></td>
<td>32</td>
<td></td>
</tr>

<tr>
<td>KDF-HASH-TIME</td>
<td></td>
<td>4.5608e-08</td>
<td></td>
</tr>

<tr>
<td>KIB</td>
<td>BYTES</td>
<td>1024</td>
<td>The number of bytes in one KiB.</td>
</tr>

<tr>
<td>LAMBDA</td>
<td></td>
<td>10</td>
<td></td>
</tr>

<tr>
<td>LAYERS</td>
<td></td>
<td>9.634086</td>
<td></td>
</tr>

<tr>
<td>LAYERS-A</td>
<td></td>
<td>6.8276772</td>
<td></td>
</tr>

<tr>
<td>LAYERS-B</td>
<td></td>
<td>9.634086</td>
<td></td>
</tr>

<tr>
<td>LEAF-CIRCUIT-TIME</td>
<td></td>
<td>0.7417668</td>
<td></td>
</tr>

<tr>
<td>LEAF-CONSTRAINTS</td>
<td></td>
<td>12524.312</td>
<td></td>
</tr>

<tr>
<td>LEAF-HASH-CIRCUIT-TIME</td>
<td></td>
<td>0.076994</td>
<td></td>
</tr>

<tr>
<td>LEAF-HASH-CONSTRAINTS</td>
<td></td>
<td>1300</td>
<td></td>
</tr>

<tr>
<td>LEAF-HASH-TIME</td>
<td></td>
<td>4.5608e-08</td>
<td></td>
</tr>

<tr>
<td>LEAF-TIME</td>
<td></td>
<td>4.3939139e-07</td>
<td></td>
</tr>

<tr>
<td>MALICIOUS-ENCODING</td>
<td></td>
<td>3302.5503</td>
<td></td>
</tr>

<tr>
<td>MAX-TICKETS</td>
<td></td>
<td>19.07985</td>
<td></td>
</tr>

<tr>
<td>MERKLE-HASH-CONSTRAINTS</td>
<td></td>
<td>1300</td>
<td></td>
</tr>

<tr>
<td>MERKLE-HASH-TIME</td>
<td></td>
<td>1.3078e-05</td>
<td></td>
</tr>

<tr>
<td>MERKLE-HASH-TIME-CIRCUIT</td>
<td></td>
<td>0.076994</td>
<td></td>
</tr>

<tr>
<td>MESSAGE-NONCE</td>
<td>BYTES</td>
<td>4</td>
<td>The size of a message&rsquo;s nonce.</td>
</tr>

<tr>
<td>MESSAGE-RECEIPT</td>
<td>BYTES</td>
<td>16</td>
<td>The size of one message receipt.</td>
</tr>

<tr>
<td>MESSAGE-RECEIPTS-CID</td>
<td>BYTES</td>
<td>35</td>
<td>The size of one message receipt&rsquo;s CID.</td>
</tr>

<tr>
<td>MESSAGE-SIZE</td>
<td>BYTES</td>
<td>106</td>
<td>The size of a single message.</td>
</tr>

<tr>
<td>MESSAGES</td>
<td></td>
<td>108.872795</td>
<td></td>
</tr>

<tr>
<td>MESSAGES-ROOT-CID</td>
<td>BYTES</td>
<td>35</td>
<td>Size of the CID of the root merkle tree of the messages.</td>
</tr>

<tr>
<td>MESSAGES-SIZE</td>
<td>BYTES</td>
<td>11540.517</td>
<td>The total size of the messages in a block.</td>
</tr>

<tr>
<td>MIB</td>
<td>BYTES</td>
<td>1048576</td>
<td>The number of bytes in one EiX.</td>
</tr>

<tr>
<td>MIN-TICKETS</td>
<td></td>
<td>0</td>
<td></td>
</tr>

<tr>
<td>MINER-ADDRESS-SIZE</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>MINERS</td>
<td></td>
<td>1000</td>
<td></td>
</tr>

<tr>
<td>NODE-SIZE</td>
<td></td>
<td>32</td>
<td></td>
</tr>

<tr>
<td>NODES</td>
<td></td>
<td>1073741824</td>
<td></td>
</tr>

<tr>
<td>OFFLINE-CHALLENGES</td>
<td></td>
<td>282.3536</td>
<td></td>
</tr>

<tr>
<td>ONE-BLOCK-IN-TEN-YEARS</td>
<td></td>
<td>9.506427e-09</td>
<td></td>
</tr>

<tr>
<td>ONLINE-CHALLENGES</td>
<td></td>
<td>136.53467</td>
<td></td>
</tr>

<tr>
<td>OPENING-PER-CHALLENGE</td>
<td></td>
<td>15</td>
<td></td>
</tr>

<tr>
<td>OPENINGS</td>
<td></td>
<td>4235.304</td>
<td></td>
</tr>

<tr>
<td>P-SIZE</td>
<td></td>
<td>35.0</td>
<td></td>
</tr>

<tr>
<td>PARALLEL-SEAL-TIME</td>
<td></td>
<td>8575.856</td>
<td></td>
</tr>

<tr>
<td>PARENT-WEIGHT-SIZE</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>PARENTS</td>
<td></td>
<td>5</td>
<td></td>
</tr>

<tr>
<td>PARENTS-CIDS</td>
<td></td>
<td>175</td>
<td></td>
</tr>

<tr>
<td>PIB</td>
<td></td>
<td>1125899906842624</td>
<td></td>
</tr>

<tr>
<td>POLLING-TIME</td>
<td></td>
<td>825.6376</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-CONSTRAINTS</td>
<td></td>
<td>295303680.0</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-PARTITIONS</td>
<td></td>
<td>2.9530368</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-PROOF-SIZE</td>
<td></td>
<td>566.98303</td>
<td></td>
</tr>

<tr>
<td>POREP-SNARK-TIME</td>
<td></td>
<td>17489.703</td>
<td></td>
</tr>

<tr>
<td>POST-CHALLENGE-BLOCKS</td>
<td>BLOCKS</td>
<td>480</td>
<td>The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.</td>
</tr>

<tr>
<td>POST-CHALLENGE-HOURS</td>
<td>HOURS</td>
<td>2</td>
<td>PoSt challenge time (see POST_CHALLENGE_BLOCKS).</td>
</tr>

<tr>
<td>POST-CHALLENGE-TIME</td>
<td>SECONDS</td>
<td>7200</td>
<td>PoSt challenge time (see POST_CHALLENGE_BLOCKS).</td>
</tr>

<tr>
<td>POST-CHALLENGES</td>
<td></td>
<td>136.53467</td>
<td></td>
</tr>

<tr>
<td>POST-PROOF-SIZE</td>
<td></td>
<td>192</td>
<td></td>
</tr>

<tr>
<td>POST-PROVING-PERIOD</td>
<td>BLOCKS</td>
<td>5760</td>
<td>The time interval in which a PoSt has to be submitted</td>
</tr>

<tr>
<td>POST-SIZE-PER-BLOCK</td>
<td></td>
<td>2236.9622</td>
<td></td>
</tr>

<tr>
<td>POST-SNARK-CIRCUIT</td>
<td></td>
<td>5324852.0</td>
<td></td>
</tr>

<tr>
<td>POST-SNARK-PROOF-PARTITIONS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>POST-SNARK-PROOF-SIZE</td>
<td></td>
<td>192</td>
<td></td>
</tr>

<tr>
<td>POSTS-PER-SECTOR-PER-YEAR</td>
<td></td>
<td>365.25</td>
<td></td>
</tr>

<tr>
<td>PROOF-MESSAGES-FRACTION</td>
<td></td>
<td>0.4</td>
<td></td>
</tr>

<tr>
<td>PROOFGEN-TIME</td>
<td></td>
<td>17489.703</td>
<td></td>
</tr>

<tr>
<td>PROOFS-SIZE-PER-BLOCK</td>
<td></td>
<td>22555.621</td>
<td></td>
</tr>

<tr>
<td>PROOFS-SIZE-PER-BLOCK-KIB</td>
<td></td>
<td>22.026974</td>
<td></td>
</tr>

<tr>
<td>PROVING-PERIOD-HOURS</td>
<td></td>
<td>24</td>
<td></td>
</tr>

<tr>
<td>PROVING-PERIOD-SECONDS</td>
<td></td>
<td>86400</td>
<td></td>
</tr>

<tr>
<td>RECEIPTS</td>
<td></td>
<td>108.872795</td>
<td></td>
</tr>

<tr>
<td>RECEIPTS-SIZE</td>
<td></td>
<td>1741.9647</td>
<td>The total size of all message receipts, in bytes.</td>
</tr>

<tr>
<td>REPLICA-COMMIT-TIME</td>
<td></td>
<td>42598.98</td>
<td></td>
</tr>

<tr>
<td>RESEAL</td>
<td></td>
<td>0</td>
<td></td>
</tr>

<tr>
<td>RETURN</td>
<td>BYTES</td>
<td>4</td>
<td>The size of a message&rsquo;s return value.</td>
</tr>

<tr>
<td>RSA-ELEMENT</td>
<td>BYTES</td>
<td>256</td>
<td>The size of an RSA element.</td>
</tr>

<tr>
<td>SEAL-COMMITMENTS-SIZE</td>
<td></td>
<td>70</td>
<td></td>
</tr>

<tr>
<td>SEAL-PROOF-SIZE</td>
<td></td>
<td>636.98303</td>
<td></td>
</tr>

<tr>
<td>SEAL-SIZE-PER-BLOCK</td>
<td></td>
<td>20318.658</td>
<td></td>
</tr>

<tr>
<td>SEAL-TIME</td>
<td></td>
<td>66693.78</td>
<td></td>
</tr>

<tr>
<td>SEALS-PER-SECTOR-PER-YEAR</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>SECTOR-SIZE</td>
<td></td>
<td>34359738368</td>
<td></td>
</tr>

<tr>
<td>SECTOR-SIZE-GIB</td>
<td></td>
<td>32</td>
<td></td>
</tr>

<tr>
<td>SECTORS-COUNT</td>
<td></td>
<td>335544320</td>
<td></td>
</tr>

<tr>
<td>SNARK-MAX-CONSTRAINTS</td>
<td></td>
<td>100000000</td>
<td></td>
</tr>

<tr>
<td>SNARK-SINGLE-PROOF-SIZE</td>
<td></td>
<td>192</td>
<td></td>
</tr>

<tr>
<td>SPACEGAP</td>
<td></td>
<td>0.1</td>
<td></td>
</tr>

<tr>
<td>STATE-ROOT-CID</td>
<td></td>
<td>35</td>
<td></td>
</tr>

<tr>
<td>STORAGE-NETWORK-CAPACITY</td>
<td></td>
<td>1.152921504606847e+19</td>
<td></td>
</tr>

<tr>
<td>TIB</td>
<td></td>
<td>1099511627776</td>
<td></td>
</tr>

<tr>
<td>TICKET-SIZE</td>
<td></td>
<td>832</td>
<td></td>
</tr>

<tr>
<td>TICKETS</td>
<td></td>
<td>1</td>
<td></td>
</tr>

<tr>
<td>TICKETS-SIZE</td>
<td></td>
<td>832</td>
<td></td>
</tr>

<tr>
<td>TIMESTAMP-SIZE</td>
<td></td>
<td>8</td>
<td></td>
</tr>

<tr>
<td>TO-ADDRESS</td>
<td>BYTES</td>
<td>35</td>
<td>The size of a message&rsquo;s &lsquo;from address&rsquo;.</td>
</tr>

<tr>
<td>TREE-DEPTH</td>
<td></td>
<td>30.0</td>
<td></td>
</tr>

<tr>
<td>TX-MESSAGES-FRACTION</td>
<td></td>
<td>0.3</td>
<td></td>
</tr>

<tr>
<td>TX-MESSAGES-PER-BLOCK</td>
<td></td>
<td>32.66184</td>
<td></td>
</tr>

<tr>
<td>U64</td>
<td></td>
<td>8</td>
<td>The size of a U64, in bytes.</td>
</tr>

<tr>
<td>VALUE</td>
<td>BYTES</td>
<td>8</td>
<td>The size of a &lsquo;value&rsquo; element.</td>
</tr>

<tr>
<td>VARINT</td>
<td>BYTES</td>
<td>4</td>
<td>The size of a VarInt.</td>
</tr>

<tr>
<td>VDF-OUTPUT-SIZE</td>
<td></td>
<td>0</td>
<td></td>
</tr>

<tr>
<td>VDF-PROOF-SIZE</td>
<td></td>
<td>768</td>
<td></td>
</tr>

<tr>
<td>YEAR-IN-SECONDS</td>
<td>SECONDS</td>
<td>31557600.0</td>
<td>The number of seconds in one year.</td>
</tr>
</tbody>
</table>

<h4 id="effect-of-space-gap-and-sector-size-on-block-size-dot">Effect of Space Gap and Sector Size on Block Size.</h4>

<table>
<thead>
<tr>
<th>LAMBDA</th>
<th>SPACEGAP</th>
<th>BLOCK-SIZE-KIB</th>
<th>SECTOR-SIZE-GIB</th>
</tr>
</thead>

<tbody>
<tr>
<td>10</td>
<td>0.2</td>
<td>2.0183308</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>2.1250708</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>2.2424922</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>2.2729497</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>2.5627122</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>2.6715527</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>2.7350836</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>2.847705</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>3.0063488</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>3.2539802</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>3.589003</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>3.8169022</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>3.9404943</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>4.2021575</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>4.3927507</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>4.730614</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>4.7323604</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>4.7720346</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>5.3342724</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>5.501524</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>5.57777</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>5.829611</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>5.94944</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>6.9545097</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>7.102623</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>7.638206</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>7.960858</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>8.008982</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>8.787309</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>8.827972</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>9.263679</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>9.3208065</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>10.384581</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>10.399412</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>10.503603</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>12.190317</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>12.920809</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>13.331349</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>13.4014015</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>13.676332</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>15.2998495</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>15.598608</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>16.252815</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>17.561655</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>17.942131</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>20.070072</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>22.549423</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>22.671417</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>23.978535</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>24.036263</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>24.376612</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>25.470312</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>27.385735</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>28.776114</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>29.061607</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>30.596579</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>32.48009</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>34.33397</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>36.181545</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>36.3917</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>42.983322</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>46.211964</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>46.80707</td>
<td>1024</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>48.038197</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>48.872463</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>54.612484</td>
<td>32</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>55.240646</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>58.89311</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>62.670723</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>69.31734</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>72.59843</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>82.51584</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>87.89453</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>87.977234</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>94.63942</td>
<td>1024</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>107.03619</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>107.64613</td>
<td>256</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>114.18173</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.2</td>
<td>131.21773</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>140.30208</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>160.02498</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>175.19678</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.1</td>
<td>176.24756</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>177.6102</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>209.20566</td>
<td>128</td>
</tr>

<tr>
<td>10</td>
<td>0.06</td>
<td>238.65137</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>259.8711</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>340.8757</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>357.2812</td>
<td>256</td>
</tr>

<tr>
<td>10</td>
<td>0.03</td>
<td>406.86823</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.2</td>
<td>434.17523</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>529.018</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>695.79944</td>
<td>128</td>
</tr>

<tr>
<td>80</td>
<td>0.1</td>
<td>794.4138</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.06</td>
<td>1293.6443</td>
<td>32</td>
</tr>

<tr>
<td>80</td>
<td>0.03</td>
<td>2639.3792</td>
<td>32</td>
</tr>
</tbody>
</table>

<h4 id="parameter-definitions">Parameter Definitions</h4>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Assumptions:
  CID [CRH]:
    declare(cid_size, bytes)
    describe(cid_size, &#34;The size of a CID.&#34;, bytes)
    cid_size = 32 + 1 + 1 + 1

  SLE [VRF]:
    declare(vrf_proof_size) // TODO
    describe(vrf_proof_size, &#34;The size of a VRF proof.&#34;, bytes)

Primitives:
  declare(varint, bytes)
  describe(varint, &#34;The size of a VarInt.&#34;, bytes)
  varint = 4

  u64 = 8
  describe(u64, &#34;The size of a U64, in bytes.&#34;)

  Dimensions:
    Size:
      kib = 1024
      describe (kib, &#34;The number of bytes in one KiB.&#34;, bytes)

      mib = 1024 * kib
      describe (mib, &#34;The number of bytes in one MiB.&#34;, bytes)

      gib = 1024 * mib
      describe (mib, &#34;The number of bytes in one GiB.&#34;, bytes)

      tib = 1024 * gib
      describe (mib, &#34;The number of bytes in one TiB.&#34;, bytes)

      pib = 1024 * tib
      describe (mib, &#34;The number of bytes in one PiB.&#34;, bytes)

      eix = 1024 * pib
      describe (mib, &#34;The number of bytes in one EiX.&#34;, bytes)
    Time:
      year_in_seconds = 365.25 * 24 * 60 * 60
      describe(year_in_seconds, &#34;The number of seconds in one year.&#34;, seconds)

VDFRSA:
  declare(rsa_element, bytes)
  describe(rsa_element, &#34;The size of an RSA element.&#34;, bytes)
  rsa_element = (2048/8)

Blockchain:
  declare(block_time, seconds)
  Address:
    address_size = cid_size
    describe(address_size, &#34;The size of an address.&#34;, bytes)

  Block:
    block_framing_size = block_header_size + messages_size + receipts_size
    describe(block_framing_size, &#34;The total amount of block framing.&#34;, bytes)

    Messages:
      // declare(messages, integer) // TODO
      messages_size = messages * message_size
      describe(messages_size, &#34;The total size of the messages in a block.&#34;, bytes)

      messages_root_cid = cid_size
      describe(messages_root_cid, &#34;Size of the CID of the root merkle tree of the messages.&#34;, bytes)

      Message:
        message_size = to_address + from_address + message_nonce + value + gas_price + gas_limit + actor_method
        describe(message_size, &#34;The size of a single message.&#34;, bytes)

        to_address = address_size
        describe(to_address, &#34;The size of a message&#39;s &#39;to address&#39;.&#34;, bytes)

        from_address = address_size
        describe(to_address, &#34;The size of a message&#39;s &#39;from address&#39;.&#34;, bytes)

        Nonce:
          declare(message_nonce, bytes) // TODO
          describe(message_nonce, &#34;The size of a message&#39;s nonce.&#34;, bytes)
          message_nonce = varint

        Value:
          declare(value, bytes)
          describe(value, &#34;The size of a &#39;value&#39; element.&#34;, bytes)
          value = u64

        Gas:
          declare(gas_price, bytes)
          describe(gas_price, &#34;The size required to represent the gas price.&#34;, bytes)
          gas_price = u64

          declare(gas_limit, bytes)
          describe(gas_price, &#34;The size required to represent the gas limit.&#34;, bytes)
          gas_limit = u64

        ActorMethod:
          declare(actor_method, bytes) // TODO: actor_method what is it? how big is it?
          actor_method = u64
          describe(actor_method, &#34;The size required to represent an actor method.&#34;, bytes)

    Receipts:
      receipts = messages // TODO check
      // declare(receipts, integer) // TODO
      receipts_size = receipts * message_receipt
      describe(receipts_size, &#34;The total size of all message receipts, in bytes.&#34;)
      message_receipts_cid = cid_size
      describe(message_receipts_cid, &#34;The size of one message receipt&#39;s CID.&#34;, bytes)

      Receipt:
        message_receipt = exit_code + return + gas_used
        describe(message_receipt, &#34;The size of one message receipt.&#34;, bytes)

        // declare(exit_code, bytes) // TODO
        exit_code = varint
        describe(exit_code, &#34;The size of an exit code.&#34;, bytes)
        // declare(return, bytes) // TODO
        return = varint
        describe(return, &#34;The size of a message&#39;s return value.&#34;, bytes)

        // declare(gas_used, bytes) // TODO
        gas_used = u64
        describe(gas_used, &#34;The size required to represent the amount of gas used by a message.&#34;, bytes)

    BlockHeader (EC):
      declare(block_header_size, bytes)
      assume(block_header_size &gt; 0)
      assume(block_header_size &lt; 1024*1024*10) // assume max is 10MB

      block_header_size = block_header_fixed_size + block_header_variable_size
      block_header_fixed_size = miner_address_size + election_proof_size + parent_weight_size + block_height_size + state_root_cid + messages_root_cid + bls_agg_size + message_receipts_cid + timestamp_size + block_sig_size
      block_header_variable_size = tickets_size + parents_cids

      StateTree:
        state_root_cid = cid_size

      Weight:
        declare(parent_weight_size, bytes) // TODO
        parent_weight_size = u64

      Height:
        declare(block_height_size, bytes) // TODO
        block_height_size = u64

      MinerAddress [CID]:
        miner_address_size = address_size

      ElectionProof (VRFBls) [SLE, BLSSig]:
        declare(election_proof_size, bytes) // TODO
        election_proof_size = 64

      // ElectionProof (VRFSecpk) [SLE, Secpk]:
      //   declare(election_proof_size, bytes) // TODO
      //   election_proof_size = 80

      Parents [CID]:
        // declare(parents, integer) // TODO
        parents = expected_winning_miners
        parents_cids = parents * cid_size

      BLSSignatures (BLSSigAgg) [BLSSigAgg]:
        declare(bls_agg_size, bytes) // TODO
        bls_agg_size = 96

      Timestamp:
        // declare(timestamp_size, integer) // TODO
        timestamp_size = u64

      // BlockSig (BlockSigSecpk):
        // declare(block_sig_size, integer) // TODO
        // block_sig_size = 80

      BlockSig (BlockSigBls):
        declare(block_sig_size, integer) // TODO
        block_sig_size = 96

      Tickets:
        // declare(tickets, integer)
        declare(tickets_size, bytes)
        tickets_size = ticket_size * tickets
        ticket_size = election_proof_size + vdf_proof_size + vdf_output_size

SNARK [SNARKAssumptions]:
  declare(snark_single_proof_size, bytes)
  snark_single_proof_size = 192
  snark_max_constraints = 100000000

// VDF (VDFStorageBased):
//   vdf_proof_size = (vdf_snark_circuit / snark_max_constraints) * snark_single_proof_size
//   vdf_output_size = hash_size

VDF (VDFRSA):
  vdf_proof_size = 3 * rsa_element
  vdf_output_size = 0

Proofs:
  ProofOfReplication:
    Graph:
      // declare(node_size, integer)
      // declare(sector_size, integer)
      // declare(nodes, integer)
      nodes = sector_size / node_size
      degree = degree_base + degree_expander
      sector_size_gib = sector_size / gib

      DRG (DRSample) [DRGAssumption]:
        // declare(degree_base, integer)
        drg_e = 0.80
        drg_d = 1/4

      ExpanderParents (Chung) [ChungAssumption]:
        // declare(degree_expander, integer)

      Layers:
        // declare(layers, integer)
        assume(layers &gt; 0)

    Soundness:
      // declare(lambda, integer)
      assume(soundness &gt; 0)
      assume(soundness &lt; 0.5)
      soundness = 1/(2^lambda)

    SpaceGap:
      assume(spacegap &gt; 0)
      assume(spacegap &lt; 0.5)

    Challenges:
      OfflineChallenges:
        // declare(offline_challenges, integer)
        // declare(offline_challenges_all, integer)
        assume(offline_challenges &gt; 0)

      OnlineChallenges:
        // declare(online_challenges, integer)
        assume(online_challenges &gt; 0)

    Seal:
      Encoding [KDFTiming]:
        assume(kdf_content &gt; 0)
        assume(encoding_time &gt; 0)
        assume(polling_time &gt; 0)
        kdf_content = degree + 1
        encoding_time = layers * nodes * (kdf_content - 1) * kdf_hash_time * (node_size / kdf_hash_size)
        encoding_time_mins = encoding_time / 60
        malicious_encoding = encoding_time / encoding_amax
        polling_time = malicious_encoding * drg_d

    Commitment (ColumnCommitments) [CRH]:
      commit_size = cid_size
      assume(replica_commit_time &gt; 0)
      replica_commit_time = commit_time * 3 + leaf_time * nodes
      seal_commitments_size = commit_size * 2 // 1 commD, 1 CommR

    ProofGeneration (ColumnCommitments):
      assume(opening_time &gt; 0)
      openings = offline_challenges * opening_per_challenge

      Leaf:
        leaf_constraints =  layers * leaf_hash_constraints
        leaf_circuit_time = layers * leaf_hash_circuit_time
        leaf_time = layers * leaf_hash_time

      Inclusion (MerkleVC) [CRH]:
        // declare(tree_depth, integer)
        tree_depth = (log2(nodes))
        inclusion_circuit_time = tree_depth * merkle_hash_time_circuit
        inclusion_constraints = tree_depth * merkle_hash_constraints
        commit_time = nodes * merkle_hash_time

      SNARK [SNARKAssumptions]:
        comm_d_openings = 1
        comm_d_time = offline_challenges * (comm_d_openings * inclusion_circuit_time)
        comm_d_constraints = offline_challenges * (comm_d_openings * inclusion_constraints)

        comm_r_openings = degree_base
        comm_r_time = offline_challenges * (comm_r_openings * inclusion_circuit_time)
        comm_r_constraints = offline_challenges * (comm_r_openings * inclusion_constraints)

        comm_c_openings = opening_per_challenge
        comm_c_time = offline_challenges * (comm_c_openings * (inclusion_circuit_time + leaf_circuit_time))
        comm_c_constraints = offline_challenges * (comm_c_openings * (inclusion_constraints + leaf_constraints))

        porep_snark_time = comm_d_time + comm_r_time + comm_c_time
        porep_snark_constraints = comm_d_constraints + comm_r_constraints + comm_c_constraints

        porep_snark_partitions = porep_snark_constraints / snark_max_constraints
        porep_snark_proof_size = porep_snark_partitions * snark_single_proof_size

        proofgen_time = porep_snark_time

    Size:
      seal_proof_size = porep_snark_proof_size + seal_commitments_size

    Time:
      seal_time = replica_commit_time + proofgen_time + encoding_time
      parallel_seal_time = (porep_snark_time + commit_time)/cores + encoding_time
      declare(unseal_time) // TODO

    Cost:
      seal_cost = seal_time * (cpu_cost_per_second + memory_cost_per_second)
      declare(unseal_cost) // TODO

  ProofOfReplication (SDR):
    Graph:
      Layers:
        layers = layers_b // TODO max(layers_a, layers_b) + 1
        layers_a = (0.68 - epsilon + delta) / (0.12 - delta)
        layers_b = (log2(1 / (3 * (epsilon - 2 * delta)))) + 0.12 / (0.12 - delta) + 1

    SpaceGap:
      assume(epsilon &lt;= 0.24)
      // delta &lt; epsilon/2
      // delta = epsilon/2 + 0.001
      // spacegap = epsilon + 2 * delta
      spacegap = 2 * epsilon - 0.001
      delta = epsilon/2 - 0.001

    Challenges:
      OfflineChallenges:
        offline_challenges = (- lambda) / (log2(1 - delta))

      OnlineChallenges:
        online_challenges = (- lambda) / (log2(2 - epsilon - 2 * delta) - 1)

    ProofGeneration (ColumnCommitments):
      opening_per_challenge = degree_base + degree_expander + 1

  ProofOfSpacetime:
    Randomness [RandomBeacon]:
      declare(post_randomness_lookback)

    Parameters:
      declare(proving_period_hours)
      declare(max_proving_sectors)

      declare(post_challenge_blocks)
      describe(post_challenge_blocks, &#34;The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.&#34;, blocks)

      describe(post_challenge_time, &#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;, seconds)
      post_challenge_time = post_challenge_blocks * block_time
      post_challenge_time = post_challenge_hours * 60 * 60
      describe(post_challenge_hours &#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;, hours)

  ProofOfSpacetime (RationalPoSt):
    Parameters:
      post_challenges = online_challenges
      post_proving_period = proving_period_seconds / block_time
      describe(post_proving_period, &#34;The time interval in which a PoSt has to be submitted&#34;, blocks)

    Cost:
      declare(post_proving_cost)

    SNARK:
      post_snark_circuit = online_challenges * inclusion_constraints

    Size:
      post_proof_size = post_snark_proof_size
      post_snark_proof_partitions = 1 // TODO post_snark_circuit / snark_max_constraints
      post_snark_proof_size = post_snark_proof_partitions * snark_single_proof_size


Consensus [ProofOfReplication, ProofOfSpacetime]:
  // declare(expected_winning_miners, integer)
  // declare(finality_height, integer)
  Tickets:
    tickets = avg_tickets
    avg_tickets = 1
    min_tickets = 0
    max_tickets = log(one_block_in_ten_years)/log(0.36) + 1 // 0.36^(max_tickets-1) = one_block_in_ten_years
    blocks_in_a_year = (year_in_seconds / block_time) * expected_winning_miners
    blocks_in_ten_years = blocks_in_a_year * 10
    one_block_in_ten_years = 1/blocks_in_ten_years

StorageMarket:
  declare(min_storing_time)
  Deals (OnChainDeals):
    comm_p_size = cid_size
    declare(p_size, 1)
    p_size = (log2(sector_size))
    sector_manifest_size = pieces * comm_p_size + p_size
    max_sector_manifest_hashes = sector_size / min_piece_size


Mining:
  proving_period_seconds = proving_period_hours * 60 * 60

  seals_per_sector_per_year = reseal+1
  posts_per_sector_per_year = year_in_seconds / proving_period_seconds

ScalingRequirements:
  storage_network_capacity = 10 * eix

ChainBandwidth:
  sectors_count = storage_network_capacity / sector_size
  all_seal_size_per_year = all_seal_messages_per_year
  all_seal_messages_per_year = sectors_count * seals_per_sector_per_year
  all_post_messages_per_year = sectors_count * posts_per_sector_per_year / miners

  Chain Size:

  Block Size:
    chain_size_year = block_size * blocks_in_a_year
    chain_size_year_gib = chain_size_year / gib
    block_size_kib = block_size / kib

  Block Content:
    block_size = block_framing_size + proofs_size_per_block
    messages = avg_proofs_messages_per_block + tx_messages_per_block + actors_messages_per_block // TODO messages dont include deals

    Proofs:
      avg_proofs_messages_per_block = avg_seals_messages_per_block + avg_posts_messages_per_block
      avg_seals_messages_per_block = all_seal_messages_per_year / blocks_in_a_year
      avg_posts_messages_per_block = all_post_messages_per_year / blocks_in_a_year

      seal_size_per_block = avg_seals_messages_per_block * seal_proof_size
      post_size_per_block = avg_posts_messages_per_block * post_proof_size
      proofs_size_per_block = seal_size_per_block + post_size_per_block
      proofs_size_per_block_kib = proofs_size_per_block / kib

    Composition:
      avg_proofs_messages_per_block = proof_messages_fraction * messages
      tx_messages_per_block = tx_messages_fraction * messages
      actors_messages_per_block = actors_messages_fraction * messages</code></pre></div>
<h4 id="parsed-parameter-definitions">Parsed Parameter Definitions</h4>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Assumptions&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;cid&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;cidSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a CID.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">},</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;cidSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ 32 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;cidSize.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ cid-size.tmp1% 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;cidSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ cid-size.tmp2% 1)&#34;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;sle&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;vrfProofSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a VRF proof.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Primitives&#34;</span><span class="p">,</span>
      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;u64&#34;</span><span class="p">,</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a U64, in bytes.&#34;</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;varint&#34;</span><span class="p">,</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a VarInt.&#34;</span><span class="p">,</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">},</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;varint&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 4)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;u64&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 8)&#34;</span>
      <span class="p">},</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Dimensions&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Size&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one EiX.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one PiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one TiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one GiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;mib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one MiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;kib&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of bytes in one KiB.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;kib&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1024)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;mib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 kib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;gib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 mib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;tib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 gib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;pib&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 tib)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;eix&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 1024 pib)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Time&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;yearInSeconds&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The number of seconds in one year.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;seconds&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;yearInSeconds.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 365.25 24)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;yearInSeconds.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* year-in-seconds.tmp1% 60)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;yearInSeconds&#34;</span><span class="p">:</span> <span class="s2">&#34;(* year-in-seconds.tmp2% 60)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;vdfrsa&#34;</span><span class="p">,</span>
      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;rsaElement&#34;</span><span class="p">,</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of an RSA element.&#34;</span><span class="p">,</span>
            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">},</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;rsaElement&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 2048 8)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Blockchain&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Address&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;addressSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of an address.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">},</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;addressSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Block&#34;</span><span class="p">,</span>
          <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
            <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;blockFramingSize&#34;</span><span class="p">,</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The total amount of block framing.&#34;</span><span class="p">,</span>
                <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">},</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;blockFramingSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-size messages-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blockFramingSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-framing-size.tmp1% receipts-size)&#34;</span>
          <span class="p">},</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Messages&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messagesRootCid&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;Size of the CID of the root merkle tree of the messages.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messagesSize&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The total size of the messages in a block.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;messagesSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* messages message-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;messagesRootCid&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Message&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                    <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;toAddress&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s &#39;from address&#39;.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;toAddress&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s &#39;to address&#39;.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageSize&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a single message.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">}</span>
                    <span class="p">]</span>
                  <span class="p">},</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;messageSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ to-address from-address)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp1% message-nonce)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp2% value)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp3% gas-price)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp4% gas-limit)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-size.tmp5% actor-method)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;toAddress&#34;</span><span class="p">:</span> <span class="s2">&#34;(== address-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;fromAddress&#34;</span><span class="p">:</span> <span class="s2">&#34;(== address-size)&#34;</span>
                  <span class="p">},</span>
                  <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Nonce&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageNonce&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s nonce.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;messageNonce&#34;</span><span class="p">:</span> <span class="s2">&#34;(== varint)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">},</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Value&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;value&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a &#39;value&#39; element.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;value&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">},</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Gas&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gasPrice&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent the gas limit.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">},</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gasPrice&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent the gas price.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;gasPrice&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;gasLimit&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">},</span>
                    <span class="p">{</span>
                      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ActorMethod&#34;</span><span class="p">,</span>
                      <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                        <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                          <span class="p">{</span>
                            <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;actorMethod&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent an actor method.&#34;</span><span class="p">,</span>
                            <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                          <span class="p">}</span>
                        <span class="p">]</span>
                      <span class="p">},</span>
                      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="nt">&#34;actorMethod&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                      <span class="p">}</span>
                    <span class="p">}</span>
                  <span class="p">]</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Receipts&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageReceiptsCid&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of one message receipt&#39;s CID.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;receiptsSize&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The total size of all message receipts, in bytes.&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;receipts&#34;</span><span class="p">:</span> <span class="s2">&#34;(== messages)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;receiptsSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* receipts message-receipt)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;messageReceiptsCid&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Receipt&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                    <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;gasUsed&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size required to represent the amount of gas used by a message.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;return&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of a message&#39;s return value.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;exitCode&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of an exit code.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">},</span>
                      <span class="p">{</span>
                        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;messageReceipt&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The size of one message receipt.&#34;</span><span class="p">,</span>
                        <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;bytes&#34;</span>
                      <span class="p">}</span>
                    <span class="p">]</span>
                  <span class="p">},</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;messageReceipt.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ exit-code return)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;messageReceipt&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ message-receipt.tmp1% gas-used)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;exitCode&#34;</span><span class="p">:</span> <span class="s2">&#34;(== varint)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;return&#34;</span><span class="p">:</span> <span class="s2">&#34;(== varint)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;gasUsed&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;BlockHeader&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;blockHeaderSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size block-header-variable-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ miner-address-size election-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp1% parent-weight-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp2% block-height-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp3% state-root-cid)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp4% messages-root-cid)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp5% bls-agg-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp7%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp6% message-receipts-cid)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize.tmp8%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp7% timestamp-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderFixedSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-header-fixed-size.tmp8% block-sig-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;blockHeaderVariableSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ tickets-size parents-cids)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;StateTree&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;stateRootCid&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Weight&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;parentWeightSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Height&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;blockHeightSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;MinerAddress&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;minerAddressSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== address-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ElectionProof&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;electionProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Parents&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;parents&#34;</span><span class="p">:</span> <span class="s2">&#34;(== expected-winning-miners)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;parentsCids&#34;</span><span class="p">:</span> <span class="s2">&#34;(* parents cid-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;blsSignatures&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;blsAggSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 96)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Timestamp&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;timestampSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== u64)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;BlockSig&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;blockSigSizeInteger%&#34;</span><span class="p">:</span> <span class="s2">&#34;(integer block-sig-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;blockSigSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 96)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Tickets&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;ticketsSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* ticket-size tickets)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;ticketSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ election-proof-size vdf-proof-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;ticketSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ ticket-size.tmp1% vdf-output-size)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;snark&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;snarkSingleProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 192)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;snarkMaxConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 100000000)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;vdf&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;vdfProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 3 rsa-element)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;vdfOutputSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 0)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Proofs&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfReplication&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Graph&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;nodes&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ sector-size node-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;degree&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ degree-base degree-expander)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sectorSizeGib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ sector-size gib)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;drg&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;drgE&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 0.8)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;drgD&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 4)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ExpanderParents&#34;</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Layers&#34;</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Soundness&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;soundness&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 soundness.tmp1%)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;SpaceGap&#34;</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Challenges&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OfflineChallenges&#34;</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OnlineChallenges&#34;</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Seal&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Encoding&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;kdfContent&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ degree 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- kdf-content 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ node-size kdf-hash-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers nodes)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* encoding-time.tmp4% encoding-time.tmp1%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* encoding-time.tmp5% kdf-hash-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* encoding-time.tmp6% encoding-time.tmp2%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;encodingTimeMins&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ encoding-time 60)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;maliciousEncoding&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ encoding-time encoding-amax)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;pollingTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* malicious-encoding drg-d)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Commitment&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;commitSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;replicaCommitTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* commit-time 3)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;replicaCommitTime.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* leaf-time nodes)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;replicaCommitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ replica-commit-time.tmp1% replica-commit-time.tmp2%)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealCommitmentsSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* commit-size 2)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofGeneration&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;openings&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges opening-per-challenge)&#34;</span>
              <span class="p">},</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Leaf&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;leafConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers leaf-hash-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;leafCircuitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers leaf-hash-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;leafTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* layers leaf-hash-time)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Inclusion&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;treeDepth&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 nodes)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;inclusionCircuitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* tree-depth merkle-hash-time-circuit)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;inclusionConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* tree-depth merkle-hash-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commitTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* nodes merkle-hash-time)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;snark&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;commDOpenings&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-d-openings inclusion-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-d-time.tmp1%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDConstraints.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-d-openings inclusion-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commDConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-d-constraints.tmp2%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commROpenings&#34;</span><span class="p">:</span> <span class="s2">&#34;(== degree-base)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRTime.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-r-openings inclusion-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-r-time.tmp3%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRConstraints.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-r-openings inclusion-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commRConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-r-constraints.tmp4%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCOpenings&#34;</span><span class="p">:</span> <span class="s2">&#34;(== opening-per-challenge)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCTime.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ inclusion-circuit-time leaf-circuit-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCTime.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-c-openings comm-c-time.tmp6%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-c-time.tmp5%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCConstraints.tmp8%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ inclusion-constraints leaf-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCConstraints.tmp7%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* comm-c-openings comm-c-constraints.tmp8%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;commCConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(* offline-challenges comm-c-constraints.tmp7%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkTime.tmp9%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ comm-d-time comm-r-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-time.tmp9% comm-c-time)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkConstraints.tmp10%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ comm-d-constraints comm-r-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkConstraints&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-constraints.tmp10% comm-c-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkPartitions&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ porep-snark-constraints snark-max-constraints)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;porepSnarkProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* porep-snark-partitions snark-single-proof-size)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;proofgenTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(== porep-snark-time)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Size&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;sealProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-proof-size seal-commitments-size)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Time&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;sealTime.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ replica-commit-time proofgen-time)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ seal-time.tmp3% encoding-time)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;parallelSealTime.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ porep-snark-time commit-time)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;parallelSealTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ parallel-seal-time.tmp2% cores)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;parallelSealTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ parallel-seal-time.tmp1% encoding-time)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Cost&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;sealCost.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ cpu-cost-per-second memory-cost-per-second)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealCost&#34;</span><span class="p">:</span> <span class="s2">&#34;(* seal-time seal-cost.tmp1%)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfReplication&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Graph&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Layers&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;layers&#34;</span><span class="p">:</span> <span class="s2">&#34;(== layers-b)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0.68 epsilon)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ layers-a.tmp2% delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0.12 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersA&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ layers-a.tmp1% layers-a.tmp3%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp8%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 2 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp7%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- epsilon layers-b.tmp8%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 3 layers-b.tmp7%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 layers-b.tmp6%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 layers-b.tmp5%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp10%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0.12 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp9%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 0.12 layers-b.tmp10%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB.tmp15%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ layers-b.tmp4% layers-b.tmp9%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;layersB&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ layers-b.tmp15% 1)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;SpaceGap&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;spacegap.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 2 epsilon)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;spacegap&#34;</span><span class="p">:</span> <span class="s2">&#34;(- spacegap.tmp1% 0.001)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;delta.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ epsilon 2)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;delta&#34;</span><span class="p">:</span> <span class="s2">&#34;(- delta.tmp2% 0.001)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Challenges&#34;</span><span class="p">,</span>
              <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OfflineChallenges&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;offlineChallenges.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0 lambda)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;offlineChallenges.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 1 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;offlineChallenges.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 offline-challenges.tmp3%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;offlineChallenges&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ offline-challenges.tmp1% offline-challenges.tmp2%)&#34;</span>
                  <span class="p">}</span>
                <span class="p">},</span>
                <span class="p">{</span>
                  <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;OnlineChallenges&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="nt">&#34;onlineChallenges.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 0 lambda)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp5%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 2 delta)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp4%.tmp6%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- 2 epsilon)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- online-challenges.tmp4%.tmp6% online-challenges.tmp5%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 online-challenges.tmp4%)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(- online-challenges.tmp3% 1)&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;onlineChallenges&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ online-challenges.tmp1% online-challenges.tmp2%)&#34;</span>
                  <span class="p">}</span>
                <span class="p">}</span>
              <span class="p">]</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofGeneration&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;openingPerChallenge.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ degree-base degree-expander)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;openingPerChallenge&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ opening-per-challenge.tmp1% 1)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfSpacetime&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Randomness&#34;</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Parameters&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postChallengeHours&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;hours&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postChallengeTime&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;PoSt challenge time (see POST_CHALLENGE_BLOCKS).&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;seconds&#34;</span>
                  <span class="p">},</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postChallengeBlocks&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;blocks&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postChallengeTime&#34;</span><span class="p">:</span> <span class="s2">&#34;(* post-challenge-time.tmp1% 60)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postChallengeTime.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* post-challenge-hours 60)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ProofOfSpacetime&#34;</span><span class="p">,</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Parameters&#34;</span><span class="p">,</span>
              <span class="nt">&#34;schema&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
                <span class="nt">&#34;parameters&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="p">{</span>
                    <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;postProvingPeriod&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;description&#34;</span><span class="p">:</span> <span class="s2">&#34;The time interval in which a PoSt has to be submitted&#34;</span><span class="p">,</span>
                    <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;blocks&#34;</span>
                  <span class="p">}</span>
                <span class="p">]</span>
              <span class="p">},</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postChallenges&#34;</span><span class="p">:</span> <span class="s2">&#34;(== online-challenges)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postProvingPeriod&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ proving-period-seconds block-time)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Cost&#34;</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;snark&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postSnarkCircuit&#34;</span><span class="p">:</span> <span class="s2">&#34;(* online-challenges inclusion-constraints)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Size&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;postProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== post-snark-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postSnarkProofPartitions&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postSnarkProofSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(* post-snark-proof-partitions snark-single-proof-size)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Consensus&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Tickets&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;tickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(== avg-tickets)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;avgTickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;minTickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(== 0)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets.tmp2%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log one-block-in-ten-years)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets.tmp3%&#34;</span><span class="p">:</span> <span class="s2">&#34;(log 0.36)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ max-tickets.tmp2% max-tickets.tmp3%)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxTickets&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ max-tickets.tmp1% 1)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blocksInAYear.tmp4%&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ year-in-seconds block-time)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blocksInAYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(* blocks-in-a-year.tmp4% expected-winning-miners)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blocksInTenYears&#34;</span><span class="p">:</span> <span class="s2">&#34;(* blocks-in-a-year 10)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;oneBlockInTenYears&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ 1 blocks-in-ten-years)&#34;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;StorageMarket&#34;</span><span class="p">,</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Deals&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;commPSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(== cid-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;pSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(log2 sector-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;sectorManifestSize.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* pieces comm-p-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;sectorManifestSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ sector-manifest-size.tmp1% p-size)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;maxSectorManifestHashes&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ sector-size min-piece-size)&#34;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Mining&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;provingPeriodSeconds.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* proving-period-hours 60)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;provingPeriodSeconds&#34;</span><span class="p">:</span> <span class="s2">&#34;(* proving-period-seconds.tmp1% 60)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;sealsPerSectorPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ reseal 1)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;postsPerSectorPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ year-in-seconds proving-period-seconds)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ScalingRequirements&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;storageNetworkCapacity&#34;</span><span class="p">:</span> <span class="s2">&#34;(* 10 eix)&#34;</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;ChainBandwidth&#34;</span><span class="p">,</span>
      <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;sectorsCount&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ storage-network-capacity sector-size)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allSealSizePerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(== all-seal-messages-per-year)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allSealMessagesPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(* sectors-count seals-per-sector-per-year)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allPostMessagesPerYear.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(* sectors-count posts-per-sector-per-year)&#34;</span><span class="p">,</span>
        <span class="nt">&#34;allPostMessagesPerYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ all-post-messages-per-year.tmp1% miners)&#34;</span>
      <span class="p">},</span>
      <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Chain&#34;</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Block&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;chainSizeYear&#34;</span><span class="p">:</span> <span class="s2">&#34;(* block-size blocks-in-a-year)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;chainSizeYearGib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ chain-size-year gib)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;blockSizeKib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ block-size kib)&#34;</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Block&#34;</span><span class="p">,</span>
          <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;blockSize&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ block-framing-size proofs-size-per-block)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;messages.tmp1%&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ avg-proofs-messages-per-block tx-messages-per-block)&#34;</span><span class="p">,</span>
            <span class="nt">&#34;messages&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ messages.tmp1% actors-messages-per-block)&#34;</span>
          <span class="p">},</span>
          <span class="nt">&#34;subsystems&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Proofs&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;avgProofsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ avg-seals-messages-per-block avg-posts-messages-per-block)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;avgSealsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ all-seal-messages-per-year blocks-in-a-year)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;avgPostsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ all-post-messages-per-year blocks-in-a-year)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;sealSizePerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* avg-seals-messages-per-block seal-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;postSizePerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* avg-posts-messages-per-block post-proof-size)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;proofsSizePerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(+ seal-size-per-block post-size-per-block)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;proofsSizePerBlockKib&#34;</span><span class="p">:</span> <span class="s2">&#34;(/ proofs-size-per-block kib)&#34;</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Composition&#34;</span><span class="p">,</span>
              <span class="nt">&#34;constraints&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;avgProofsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* proof-messages-fraction messages)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;txMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* tx-messages-fraction messages)&#34;</span><span class="p">,</span>
                <span class="nt">&#34;actorsMessagesPerBlock&#34;</span><span class="p">:</span> <span class="s2">&#34;(* actors-messages-fraction messages)&#34;</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span></code></pre></div>

</div>



</div>

  


</div>

  


</div>

</div>

</article>

      

      
    </div>

    
  



  </main>

  
  
</body>

</html>
